---
title : "[BOJ] 1520 내리막길 (Python3)"
toc : true
toc_sticky : true
toc_lable : "On this Page"
categories : baekjoon
---
## 문제
여행을 떠난 세준이는 지도를 하나 구하였다. 이 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 한 칸은 한 지점을 나타내는데 각 칸에는 그 지점의 높이가 쓰여 있으며, 각 지점 사이의 이동은 지도에서 상하좌우 이웃한 곳끼리만 가능하다.

![2023-02-09_11-28-02.png](attachment:e174faf0-fbb5-42fd-a2bd-a0646be5140f.png)

현재 제일 왼쪽 위 칸이 나타내는 지점에 있는 세준이는 제일 오른쪽 아래 칸이 나타내는 지점으로 가려고 한다. 그런데 가능한 힘을 적게 들이고 싶어 항상 높이가 더 낮은 지점으로만 이동하여 목표 지점까지 가고자 한다. 위와 같은 지도에서는 다음과 같은 세 가지 경로가 가능하다.

![2023-02-09_11-27-48.png](attachment:28f9fd44-aaae-4a33-a47c-bed94bf613ba.png)

지도가 주어질 때 이와 같이 제일 왼쪽 위 지점에서 출발하여 제일 오른쪽 아래 지점까지 항상 내리막길로만 이동하는 경로의 개수를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에는 지도의 세로의 크기 M과 가로의 크기 N이 빈칸을 사이에 두고 주어진다. 이어 다음 M개 줄에 걸쳐 한 줄에 N개씩 위에서부터 차례로 각 지점의 높이가 빈 칸을 사이에 두고 주어진다. M과 N은 각각 500이하의 자연수이고, 각 지점의 높이는 10000이하의 자연수이다.



## 출력
첫째 줄에 이동 가능한 경로의 수 H를 출력한다. 모든 입력에 대하여 H는 10억 이하의 음이 아닌 정수이다.

## 정답코드


```python
n, m = map(int, input().split())

graph = []

for i in range(n):
    graph.append(list(map(int, input().split())))
    
    
dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

dp = [[-1 for _ in range(m)] for _ in range(n)]

def dfs(x, y):
    
    if x == n - 1  and y == m - 1:
        return 1 
    
    if dp[x][y] == -1:
        answer = 0
    
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < m:
                if graph[x][y] > graph[nx][ny]:
                    answer += dfs(nx, ny)
            dp[x][y] = answer
                    
        return answer
    else:
        return dp[x][y]
        
print(dfs(0, 0))
```

## 문제풀이
어제 풀었던 dfs + dp 유형의 문제가 좀 어려워서 같은 유형의 문제를 풀어보고 싶어서 찾아본 문제다. 

사실 유형을 아는것도 문제를 푸는 엄청난 힌트라서 어렵지는 않았는데, 그래도 해당 유형의 문제를 숙달하는데 도움이 되었다.

dfs + dp 문제는 우선 무조건 dfs의 형태를 띄고 있다. 위의 문제는 무조건 내리막인 경로를 찾아야 하는데, bfs로도 풀이가 가능하긴 하지만 분기점마다 새로운 경우의 수로 구분하는게 복잡해서 dfs로 무조건 끝 경로까지 도달해보고 되는 경우만 체크를 해주면 된다. 하지만 위 문제의 경우 n, m의 최댓값이 500이기 때문에 단순 그래프 크기만 해도 최대 250000이라 단순 완전 탐색으로는 시간초과를 통과할 수 없다.

따라서 dp를 적용한 메모제이션으로 재귀 호출의 개수를 줄여야하는데, dfs + dp의 문제는 dfs의 매개변수만큼의 배열을 dp로 갖는다고 생각하면 편할 것 같다. 예를 들어 dfs의 매개변수가 2개라면 2차원 배열, 3개라면 3차원 배열 이런식으로 dp 배열을 갖는다. 

따라서 위 문제는 x, y를 받으므로 2차원 dp 배열을 통해 이를 메모제이션 해준다. 끝까지 도달 가능한 경우라면 1을 기록해주는 방식으로 기록한뒤, 이미 도달한 적이 있다면 dp[x][y]를 반환함으로써 재귀호출의 수를 줄여주면 된다.


```python

```
