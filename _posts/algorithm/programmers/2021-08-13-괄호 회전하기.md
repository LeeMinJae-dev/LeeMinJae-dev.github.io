---
title : "[Programmers] 괄호 회전하기 (Python3)"
categories : programmers
toc : true
toc_sticky : true
toc_label : "On this Page"
---
## 문제 설명
다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.
* (), [], {} 는 모두 올바른 괄호 문자열입니다.
* 만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다.
* 만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다.

대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x < (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.

## 제한사항
* s의 길이는 1 이상 1,000 이하입니다.

## 입출력 예
|s	|result|
|:---:|:---:|
|"[](){}"|	3|
|"}]()[{"|	2|
|"[)(]"|	0|
|"}}}"|	0|

## 입출력 예 설명
입출력 예 #1
* 다음 표는 "[](){}" 를 회전시킨 모습을 나타낸 것입니다.
|x	|s를 왼쪽으로 x칸만큼 회전	|올바른 괄호 문자열?|
|:---:|:---:|:---:|
|0	|"[](){}"|	O|
|1|	"](){}["|	X|
|2	|"(){}[]"|	O|
|3	|"){}[]("|	X|
|4	|"{}[]()"|	O|
|5	|"}[](){"|	X|

* 올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다.

입출력 예 #2
* 다음 표는 "}]()[{" 를 회전시킨 모습을 나타낸 것입니다.

|x|	s를 왼쪽으로 x칸만큼 회전	올바른 괄호 문자열?|
|0	|"}]()[{"	|X|
|1|"]()[{}"|	X|
|2	|"()[{}]"|	O|
|3	|")[{}]("|	X|
|4	|"[{}]()"|	O|
|5	|"{}]()["|	X|

* 올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다.

입출력 예 #3    
* s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.

입출력 예 #4    
* s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.

## 문제풀이
괄호문제는 스택으로 풀었던 적이 있는데 또 까먹어서 괄호별로 딕셔너리를 만들어 숫자로 괄호가 닫혔는지 안닫혔는지 확인하다가 시간이 오래걸렸다.

자꾸 풀었던 알고리즘을 까먹는 것 같아서, 내일부터는 순차적으로 돌아가며 매일 다른 유형을 풀도록 해야겠다.

괄호가 만약 오른쪽으로 열린 괄호라면 스택에 넣어주고, 왼쪽으로 열린 괄호면 스택의 -1인덱스와 같은 지 확인해준뒤 같으면 stack.pop(), 다르면 append() 해주면 된다.
모든 반복문이 끝난 후 스택이 비어있으면 올바른 괄호이므로 answer+=1을 해준다.

## 코드


```python
from collections import deque
def solution(s):
    q = deque(s)
    answer = 0
    if len(s) == 1:
        return 0
    
    left = ['[','{','(']
    asci = {']':2,'}':2, ')':1}
    for i in range(len(s)):
        stack = []
        for j in q:
            if j in left:
                stack.append(j)
            else:
                if stack and stack[-1] == chr(ord(j)-asci[j]):
                    stack.pop()
                else:
                    stack.append(j)
        q.append(q.popleft())
        if not stack:
            answer+=1
                
    return answer
```


```python
solution("[](){}")
```




    3


