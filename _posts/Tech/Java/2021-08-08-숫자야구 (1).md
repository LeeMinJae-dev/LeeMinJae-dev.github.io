---
title : "[Java] 플레이그라운드 with TDD, 클린코드 - 숫자야구 (1)"
categories : java
toc : true
toc_label : "On this Page"
toc_stciky : true
published : false
---
## 시작하면서...
자바로 간단한 프로젝트를 만들어보려 했는데, 그냥 무작정 혼자 만들다가는 나쁜 버릇이 들 것 같아서   
강의 하나를 수강하기로 했다. 특히나 자바는 객체지향이라는 개념을 사용하는 언어이고, 난 대부분 절차지향 언어만
사용해봤었기 때문에, 아직 간단한 책 한권으로는 객체지향으로 정확히 어떻게 프로그램을 구현하는지에 대한 감이 없기 때문에,
오히려 이대로 혼자 프로젝트를 진행하면, 결과물은 그런대로 작동할 수 있겠으나 코드 자체는 유지보수가 어렵고, 객체지향의 강점이
하나도 드러나지 않는 나쁜코드가 될 거라는 생각이 들었다. 개발자로써 알고리즘 자체를 짜는 것도 중요하지만 모두가 같이 일하는 환경에서는 직관적이고 유지보수가 편하게 코드를 작성하는것도 아주 중요한 덕목이라는 생각이 들었다.

그래서 이러한 관련 강의를 찾다가 아주 평이 좋은 강의를 발견해서 수강하며 블로그에 남겨두려한다.   
이 강의의 좋은 점은 내용도 좋지만, 주로 미션위주의 강의라 내가 직접 만들어보며 어떤게 잘못되었고 어떤게 올바른 코드인지 알 수 있다는 것이었고, 테스트주도형 개발도 함께 배울 수 있을 뿐만 아니라 실제 개발처럼 깃허브로 버젼을 푸쉬해가며 미션을 진행 해볼 수 있다는 것이었다. 그래서 별 고민없이 바로 결제하고 수강을 시작했다.

첫번째 미션은 숫자야구게임을 만드는것이다. 그럼 시작해보자.

## 단위테스트
자바는 대부분의 기능을 클래스로 구현해놓고, 그 클래스들을 메인메서드에서 동작시킨다.  
메인 메서드는 프로그램을 시작할 뿐만 아니라 구현한 프로그램을 테스트하는데도 사용하는데, 테스트 주도 개발을 하려면 어떻게 메인메서드에서 구현한 프로그램을 테스트 할 수 있는지 알아야 한다.

그럼 간단한 사칙연산 프로그램을 만들어 프로그램을 테스트 해보자.
```
package TDD;

public class Calculator {
    int add(int a, int b){
        return a+b;
    }
    int subtract(int a, int b){
        return a-b;
    }
    int multiply(int a, int b){
        return a*b;
    }
    int divide(int a, int b){
        return a/b;
    }
    public static void main(String[] args){
        Calculator cal= new Calculator();
        System.out.println(cal.add(3,4));
        System.out.println(cal.subtract(5,4));
        System.out.println(cal.multiply(2,6));
        System.out.println(cal.divide(8,4));
    }
}

```
위 코드를 보면 클래스 Calculator에 해당하는 프로덕션 코드 부분과, main에 해당하는 테스트 코드 부분이 있다. cal이라는 인스턴스를 만들어 준 뒤, 아래에 사칙연산을 실제로 실행시켜봄으로써 이 코드가 정상적으로 작동하는지 확인해보았는데, 이러한 메인메서드 테스트는 문제점이 존재한다.

## main method 테스트 문제점
* 프로덕션 코드와 테스트 코드가 하나에 존재한다. 이로인해 클래스 크기가 커지고 복잡도가 증가한다.
* 테스트 코드가 실제 서비스에 같이 배포된다.
* main method 하나에서 여러 개의 기능을 테스트 하기 때문에 복잡도가 증가한다.
* method 이름을 통해서 어떤 부분을 테스트 하는 것인지 알기가 힘듬
* 테스트 결과를 사람이 수동으로 확인해야한다.

이러한 main method를 사용한 테스트가 가지는 문제점을 해결하기 위해 등장한 것이 바로 JUnit 이다.

## JUnit
JUnit은 단위 테스트 Framework로, System.out으로 번거롭게 테스트 케이스를 확인하지 않도록 해주는 도구이다. 프로그램 테스트 시 걸릴 시간도 관리할 수 있게 해주며, 오픈소스 플러그인 형태로 Eclipse에 포함되어있다. 개발을 진행하면서, 어느정도의 개발이 진행되면 반드시 프로그램에 대한 단위 테스트는 필수로 진행해주어야 한다.

그럼 단위 테스트를 어떻게 진행해야 하는지 알아보자.

## String 클래스에 대한 학습 테스트
깃허브에서 내려받은 폴더에 있는 StringTest 클래스가 있다.
```
package study;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class StringTest {
    @Test
    void replace() {
        String actual = "abc".replace("b", "d");
        assertThat(actual).isEqualTo("adc");
    }
}
```

replace 함수메서드를 실행하면 테스트가 가능하다.

그럼 StringTest에 다음 요구사항을 새로운 test case로 추가해보자.

## AssertJ
여기서 요구하는 테스트를 하기 위해서는 AsserJ에 대해서 알아야한다.

AssertJ는 자바 테스트를 위해 좀 더 풍부한 문법을 제공하며, 메서드 체이닝을 통해 더 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리이다.

위의 replace를 테스트한 코드를 다시 살펴보자.

```
package study;

import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

public class StringTest {
    @Test
    void replace() {
        String actual = "abc".replace("b", "d");
        assertThat(actual).isEqualTo("adc");
    }
}
```
actual이라는 문자열 "abc".replace("b","d"), abc에서 b를 d로 바꾸는 객체를 만들고,
assertThat(actual).isEqualTo("adc") 로 실제로 replace 메서드가 우리가 원하는 값인 "adc"를 출력하는지를 확인해준다.

이처럼 AssertJ는 간편하게 테스트 코드를 작성할 수 있도록 도와주는 오픈소스이다.    
그럼 몇가지 더 유용한 사용법을 한번 알아보자. 

### Test Fail Message
JUnit5 에서는 마지막 인자값에 as()를 통해 테스트 실패 메시지를 명시해주어 테스트가 실패했을때 출력되는 메시지를 만들 수 있다.

인물에 대한 정보를 담는 Character 이라는 클래스가 있고, 그 안에 있는 getAge() 메서드를 테스트 한다고하자. 
```
public class Person {
    String name;
    int age;
    String tribe;

    public Person(String name, int age, String tribe) {
        this.age = age;
        this.name = name;
        this.tribe = tribe;
    }

    public int getAge(){
        return age;
    }
    public String getName(){
        return name;
    }

}
```
이 Character 메서드는 이름, 나이, 종족을 멤버변수로 갖고, 나이를 반환하는 getAge()와 이름을 반환하는 getName() 메서드를 갖고있다. 우리가 만약 getAge() 메서드가 테스트코드에서 실패한다면, 이 이름의 사람의 나이를 확인해보라는 메시지 창을 띄우고 싶은 경우라면, 아래와 같이 AssertJ를 이용하여 코드를 작성할 수 있다.

```
@Test
    public void Character() {
        Character frodo = new Character("Frodo", 33, "HOBBIT");
        // failing assertion, remember to call as() before the assertion, not after !

        assertThat(frodo.getAge()).as("check %s's age", frodo.getName()).isEqualTo(100);
    }
    
    
>>> [check Frodo's age] 
>>> expected: 100
>>> but was : 33
```
isEqualTo를 사용하여 우리가 원하는 기댓값과 같은 결과를 출력하는지 확인해보았고, 33이 나와야하지만 100이 나왔기 때문에 우리가 삽입해주었던 문장인 "check [이름] age" 문장이 출력되었다.

이렇게 유용한 메서드인 as()를 사용할 때 주의 해야할 점이 있는데, 바로 assertion이 수행되기 전에 사용해야한다는 것이다. 마지막에 as를 사용하면 에러를 동반하게 된다.


















만약 테스트코드가 실패하게 하면 이 사람의 나이를 다시한번 확인해보라는 문구를 넣고싶다면, 아래와 같이 하면된다.
## 요구사항 1
* "1,2"을 ,로 split 했을 때 1과 2로 잘 분리되는지 확인하는 학습 테스트를 구현한다.
* "1"을 ,로 split 했을 때 1만을 포함하는 배열이 반환되는지에 대한 학습 테스트를 구현한다.

### 힌트
* 배열로 반환하는 값의 경우 assertj의 contains()를 활용해 반환 값이 맞는지 검증한다.
* 배열로 반환하는 값의 경우 assertj의 containsExactly()를 활용해 반환 값이 맞는지 검증한다.


## 요구사항 2
* "(1,2)" 값이 주어졌을 때 String의 substring() 메소드를 활용해 ()을 제거하고 "1,2"를 반환하도록 구현한다.

## 요구사항 3
* "abc" 값이 주어졌을 때 String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져오는 학습 테스트를 구현한다.
* String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져올 때 위치 값을 벗어나면 StringIndexOutOfBoundsException이 발생하는 부분에 대한 학습 테스트를 구현한다.
* JUnit의 @DisplayName을 활용해 테스트 메소드의 의도를 드러낸다.


