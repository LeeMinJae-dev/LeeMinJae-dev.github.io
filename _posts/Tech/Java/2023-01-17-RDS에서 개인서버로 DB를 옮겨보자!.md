---
title: "RDS에서 개인서버로 DB를 옮겨보자!"
categories: java
toc: true
toc_label: "On this page"
toc_sticky: true
---
## 서론
저는 프로젝트로 제작한 웹사이트를 하나 운영하고 있습니다.

aws의 프리티어 기간을 사용하여 EC2와 RDS를 사용하고 있었는데, 프리티어 기간이 거의 끝나가는 시점이인지라 다른 서버 업ㅇ체의 저렴한 서버를 대여받아 이를 마이그레이션해보려합니다. 

사실 서버의 경우는 이미 몇달 전에 마이그레이션을 완료한 상태였고, DB도 옮길 예정이었지만 취업 일정이 여러가지 겹쳐서 계속 미루던 상태였습니다. 

하지만 이제 정말 정말 프리티어 기간이 얼마 안남았고, 제 피같은 생돈(?)을 상대적으로 비싼 aws에 낼 수는 없었기 때문에 이번에는 정말 마음을 굳게먹고 마이그레이션을 완료해보려 합니다.

## 마이그레이션 계획
현재 제 웹사이트의 구조는 다음과 같습니다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image1.PNG)

현재는 서버단은 마이그레이션을 완료해서, 국내 서버 호스팅 업체인 iwinv로 이전한 상태이며, iwinv 서버안으로 db를 옮겨보려 합니다.

간편하게 컨테이너로 mariaDB를 설치하고, 3306 포트를 통해서 서버가 DB에 접근하게 할 계획입니다. 현재 컨테이너가 이미 3개가 돌아가고 있는 상태인데, db 컨테이너까지 추가하면 서버의 사양이 별로 좋지 않아 메모리가 부족할 수 있습니다. 따라서 개발 내용을 미리 테스트 해보던 develop 컨테이너는 꺼주도록 하겠습니다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image2.PNG)

따라서 새로운 구조는 위와 같은 구조로 변경되겠네요.

## 도커로 mariaDB 설치하기
먼저 도커 허브에서 mariaDB의 이미지를 다운 받습니다.

```
docker pull mariadb 
```

설치가 완료 되었으면 해당 이미지를 컨테이너화 시켜줍시다.

```
docker run --name mariadb -d -p 3306:3306 --restart=always -e MYSQL_ROOT_PASSWORD=root mariadb
```
옵션을 조금 붙여서 컨테이너를 동작시킵니다. 옵션들의 뜻은 다음과 같습니다.

### --name
만들어서 사용할 컨테이너의 이름을 정의합니다. name을 적용해주지 않으면 명령을 내릴때 복잡한 컨테이너 id를 알아야 해서 귀찮습니다. 꼭 설정해주세요.

### -d
컨테이너를 백그라운드에서 실행합니다. 이렇게 하면 컨테이너 동작 후에도 그대로 다른 작업이 가능합니다

### -p
호스트와 컨테이너 간의 포트를 맵핑합니다. 

컨테이너 바깥인 서버의 포트와 컨테이너 내부포트를 몇번으로 연결 할지 고릅니다. 예를들어 8080:9090으로 하면, 바깥 서버에 8080으로 들어온 요청은 컨테이너의 9090 포트에 연결됩니다.

저의 경우는 밖에서 3306으로 들어오면 컨테이너 내부에서도 3306으로 포트가 연결되있도록 3306 : 3306 으로 맵핑해주겠습니다.

### --restart=always
도커가 실행되는 경우 항상 컨테이너를 실행 

이렇게 하면 도커가 실행되면 자동으로 해당 컨테이너가 실행됩니다.

### -e
기타 환경설정(Enviorment)

 MYSQL_ROOT_PASSWORD=root 
 
 mariadb의 root 사용자 초기 비밀번호를 설정하는 옵션입니다. 저의 경우는 그냥 root로 해주도록 하겠습니다.

### mariadb
저희가 방금 다운받은 mariadb를 실행하여 컨테이너화 합니다.

이렇게 하면 아주 간단하게 mariaDB 설치가 끝났습니다. 이것이 바로 도커의 무지막지한 장점입니다. 우리는 이미지를 다운받아 컨테이너화 시키기만 하면 해당 환경이 세팅된 가상 공간을 얻을 수 있습니다.

그럼 해당 공간으로 접속해 볼까요?

```
docker exec -it mariadb /bin/bash
```
여기서 mariadb는 아까 --name을 통해 설정해준 컨테이너의 이름입니다. 혹시 다른 이름을 했다면 다른이름을 적어주세요

이렇게 하면 도커 컨테이너 안으로 접속할 수 있습니다.

이 상태에서 데이터 베이스에 접속하려면

```
mysql -u root -p
```

이렇게 명령어를 입력한 뒤, 아까 설정해둔 비밀번호를 입력해주면 됩니다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image3.PNG)

이렇게 mariaDB 접속이 완료 되었습니다.

그럼 서버의 데이터베이스 연결을 하기 전에 앞서 intelij의 데이터베이스 툴을 사용해서 제 컴퓨터에서도 db에 올바르게 접속이 가능한지 확인해보도록 하겠습니다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image4.PNG)

호스트에 서버의 주소를 입력해주고, 사용자 이름과 비밀번호에는 아까 도커에서 설정했던 mariadb의 사용자이름과 비번을 입력해주면 됩니다. 저의 경우는 둘다 root로 설정해 주었으니, root를 입력하면 됩니다.

> 혹시 접속이 안된다면, 서버에서 해당 컴퓨터가 사용하는 네트워크 아이피의 3306포트가 접속가능하도록 인바운드 규칙을 설정 되어있는지 확인해보시면 됩니다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image5.PNG)

아주 연결이 잘되는 것을 확인할 수 있습니다.

## DB 연결 주소 변경하기
기존에 스프링의 resource 폴더에 있었던 properties 파일을 기존 RDS연결 에서 방금 만든 도커 컨테이너로 연결을 변경해주도록 합시다.

```
spring.datasource.url=jdbc:mariadb://{DB IP주소}:3306/{데이터베이스 이름}
spring.datasource.username={DB 사용자명} 
spring.datasource.password={비밀번호}
```

아직 스키마를 만들지는 않았지만, 만들어질 데이터 베이스이름을 설정해주고 사용자명과 root는 아까 설정해준 값으로 넣어주면 됩니다.


## DB데이터 복사하기
이제 연결된 DB의 위치도 변경했으니, 기존의 그대로 옮겨서 똑같은 상태로 만들어주어야 합니다. 그렇지 않으면 기존 DB에 있던 데이터가 모두 사라지겠죠?

이러한 마이그레이션을 위해 sqldump가 존재합니다.

sqldump를 사용하면 현재 DB를 백업하여 파일로 저장하는데, 이 기능을 이용해서 백업 파일을 다른 DB에 덮어씌울수도 있습니다.

직접 데이터 베이스를 열어서 터미널을 통해 할 수도 있지만, 복잡하기 때문에 저는 인텔리제이의 데이터베이스 툴이 지원하는 UI를 이용해서 간단하게 dump를 만들고 이를 옮겨 보도록 하겠습니다.

> 혹시 직접 데이터베이스에서 터미널을 통해 하고싶으신 분들은 아래 링크 게시물이 설명이 잘되어 있으니 참고하세요. 

> [[링크] MySQL DB 서버 간 이동시키기](https://mopipe.tistory.com/99)

먼저, 복사할 데이터베이스를 쿼리를 통해 동일한 이름으로 만들어줍니다.

```
create database jamong;
```

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image6.PNG)

위 DB가 새로운 DB, 아래가 마이그레이션할 RDS DB입니다.

RDS의 데이터베이스를 오른쪽 클릭한 뒤, 다음과 같이 mysqldump로 내보내기를 클릭해줍시다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image7.PNG)

그럼 아래와 같은 창이 뜨는데요.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image8.PNG)

mysqldump 경로는 로컬에 깔린 mysql의 bin 폴더에 있는 mysqldump 파일을 지정해주시고, 출력 경로를 설정해주면 됩니다.

> 혹시 1109 에러가 발생하시는 분들은 위의 옵션 설정 부분에 --column-statistics = 0 을 추가해주세요

그럼 해당 경로에 .sql 파일이 생성됩니다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image9.PNG)

그럼 이 파일을 그대로 새로운 DB에 덮어 씌워줍시다.

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image10.PNG)

이번에는 옮길 DB를 오른쪽 클릭하고, sql 스크립트 실행을 클릭해줍니다.

그리고 아까 출력해준 .sql 파일을 선택해주면,

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image11.PNG)

이렇게 완전하게 똑같이 DB가 덮어 씌워 진걸 볼 수 있습니다.

그럼 DB의 연결도 바꿔주었고, 내용도 복사 했으니, 새로 배포를 진행하고 잘 적용되었는지 확인해볼까요?

젠킨스에서 새로 빌드를 해보면...

![image1](/assets/images/tech/Java/2023-01-17-RDS에서/image12.PNG)

새로운 데이터베이스에서 정보를 아주 잘 불러오는걸 확인할 수 있네요.










