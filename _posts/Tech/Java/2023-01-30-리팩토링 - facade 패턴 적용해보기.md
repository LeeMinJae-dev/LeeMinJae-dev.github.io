---
title: "리팩토링 - 책임 줄이기"
categories: java
toc: true
toc_label: "On this page"
toc_sticky: true
---
## 서론

얼마전 현직자분과 멘토링을 진행할 기회가 생겨 한시간 반가량의 멘토링을 받았는데, 감사하게도 간단한 프로젝트 코드 리뷰도 진행해주셨다. 

사실 공부를 하며 항상 부족함을 느꼈던 부분이 바로 이런부분이었는데, 전문가가 되기 위한 반복작업 중 가장 중요한 마지막 작업인 피드백이 어렵다는 것이었다. 어쨌든 여러가지 좋은 조언 중 가장 와닿았던게 프로젝트 코드에 대한 내용이어서 본격적으로 리팩토링을 진행해보려한다.

특히 디자인패턴과 객체지향, 추상화에 대해서 어느정도 알고 있다고 생각했는데, 실제로 코드를 작성하는데에 있어서는 제대로 적용이 안되어 있다는 생각이 가장 크게 들었다. 

그래서 디자인 패턴도 적용해보고 클래스간의 과도한 의존성과 너무 많은 책임을 정말 세세히 분리하고 기능들을 추상화 해보며, 리팩토링을 진행해보려한다.

>[[링크] 리팩토링 할 프로젝트 주소](https://github.com/Jamong-Project/Jamong-Backend/tree/c2a2024bb01deca1dba9fea5d51b04b2a4f7a554)


## 문제 - 서비스 레이어에 너무 많은 책임이 있다
가장 먼저 지적받은 부분이기도 하고, 가장 크게 와닿기도 한 부분이다.

현재 내 서비스 레이어는 중 하나의 코드는 다음과 같은데, 

> [[링크] VolunteerService 코드](https://github.com/Jamong-Project/Jamong-Backend/blob/c2a2024bb01deca1dba9fea5d51b04b2a4f7a554/src/main/java/com/example/jamong/volunteer/service/VolunteerService.java)

보면 벌써 Repository가 다섯개씩 있고 코드가 하나의 클래스에 너무 많다. 사실 코드를 작성하면서 서비스에만 모든 코드가 다 있는데 굳이 이걸 컨트롤러 모델 서비스 구조로 하는게 의미가 있나? 싶은 생각이 들기도 했지만 거기서 생각이 멈추어서 그냥 남들이 하는대로 했었다.

이렇게 하면 레포지토리가 하나 새로 생기거나 기능이 추가될때마다 코드를 변경해야 하기 때문에 객체 지향스럽지 못하고, 이로인해 테스트코드까지 굉장히 무겁고 복잡하게 돌아간다.

실제로 내 테스트 코드는 다음과 같은데,

> [[링크] 테스트 코드](https://github.com/Jamong-Project/Jamong-Backend/blob/c2a2024bb01deca1dba9fea5d51b04b2a4f7a554/src/test/java/com/example/jamong/volunteer/service/VolunteerServiceTest.java)

코드의 양이 굉장히 많고, 유닛테스트가 아니라 통합테스트로만 작성되어있다. 

그래서 이번 게시물에서는 서비스레이어의 의존성을 줄여주고, 클래스단위로 더 나누는 방법을 찾아보며, 이를 적용해보고자 한다.

## VolunteerService 책임 분리하기
우선 이름부터 VolunteerService라는 이름으로, 모든 봉사 관련 비즈니스 로직을 여기 하나에서만 처리하게 하고있다. 이를 우선 분리하여 여러개의 클래스에 나누어 하나의 책임씩만 갖게 해야한다.

우선 VolunteerService가 가진 기능을 정리해보면 다음과 같다.

1. 모든 봉사 조회
2. id로 특정 봉사 조회
3. 봉사 저장
4. 봉사 수정
5. 봉사 삭제
6. 좋아요 누르기
7. 봉사 신청
8. 댓글 작성

이렇게 도합 8개의 기능이나 서비스 클래스 하나에서 담당하고 있었다.

이를 추상화하고 객체로 나누기 위해서 조금 더 생각해보기로 했다.

우선 봉사라고 뭉뜽그려 놓은 이름이 문제라는 생각이 들었다. 정확히는 '봉사 게시글'이고, 좋아요에 대한 내용과 댓글에 대한 내용도 다른 곳에 있어야 하지않나 싶다. 또, 같은 봉사게시글이더라도 봉사를 등록하고 수정, 삭제하는 것은 운영진의 기능이고, 봉사를 신청하고 댓글을 작성하는건 유저의 역할인데, 이 역할도 세심하게 나눠주지 않은 것 같다는 생각이 들었다.

그렇게 해주지 않은 결과로, VolunteerService 하나의 다른 도메인의 레포지토리가 5개가 모여있다. 이상적이게 객체를 분리했다면 VolunteerRepository 하나만 있어야한다.

![image1](/assets/images/tech/Java/2023-01-30-리팩토링/image2.PNG)

그래서 우선 가장 중점적으로 둘 것은 Repository가 Service당 하나만 있게하여, Repository의 의존성을 줄여보도록 할 것 이다.



#### 현재 의존성 다이어그램

![image1](/assets/images/tech/Java/2023-01-30-리팩토링/image1.PNG)


기존에 이미 VolunteerRepository만을 사용하던 메소드를 제외하고, 다른 Repository를 의존하던 함수들을 추려보면 다음과 같다.

2. id로 특정 봉사 조회
6. 좋아요 누르기
7. 봉사 신청
8. 댓글 작성

그럼 이 메소드들을 리팩토링 해보자

### VolunteerService / findById
```java
@Transactional(readOnly = true)
public VolunteerArticleResponseDto findById(Long id) {
	    Volunteer entity = volunteerRepository.findById(id).orElseThrow(NoExistVolunteerException::new);
	  // 기준으로 둘 entity 불러오기
	
	    List<Apply> applies = applyListRepository.findByVolunteer(entity);
	  
	    List<User> applicants = applies.stream()
	            .map(Apply::toDto)
	            .map(ApplyResponseDto::getUser)
	            .collect(Collectors.toList());
	   // 1번 기능
	   
	    List<Favorite> favorites = favoriteRepository.findByVolunteer(entity);
	
	    List<User> favoriteUsers = favorites.stream()
	            .map(Favorite::toDto)
	            .map(FavoriteResponseDto::getUser)
	            .collect(Collectors.toList());
	    // 2번 기능
	   
	    List<Comment> commentList = commentRepository.findByVolunteer(entity);
	     
	    List<CommentResponseDto> commentListDto = commentList.stream()
	            .map(Comment::toDto)
	            .collect(Collectors.toList());
	    // 3번 기능
	
	    return VolunteerArticleResponseDto.builder()
	            .entity(entity)
	            .pictures(entity.detailPicture())
	            .applicants(applicants)
	            .favoriteUsers(favoriteUsers)
	            .comments(commentListDto)
	            .build();
}
```

해당 메서드는 봉사 게시물을 특정 아이디로 불러오는 메서드이다. 

대략 문단 별로 1번 기능, 2번 기능, 3번 기능으로 생각해보면 기능은 다음과 같다

* 1번 기능 

해당 봉사 신청자들을 불러와 이를 Dto에 담은뒤, Apply의 필드인 user의 정보로 변환하여 리스트로 반환한다.

* 2번 기능 

해당 봉사에 좋아요를 누른 사람들을 불러와 이를 Dto에 담은뒤, Favorite의 필드인 user의 정보로 변환하여 리스트로 반환한다.

* 3번 기능
해당 봉사에 댓글 정보를 가져와 Dto에 담아 리스트로 반환한다.

이렇게 보니, 그렇게 리팩토링이 어렵지 않아보인다. 우선 ApplyListService, FavoriteService, CommentService를 나누어서 저 위의 코드를 옮겨주도록 하자.

### ApplyListService

```java
@RequiredArgsConstructor
@Service
public class ApplyListService {
    private final ApplyListRepository applyListRepository;

    public List<Apply> getApplyList(Volunteer entity) {
        List<Apply> applyList = applyListRepository.findByVolunteer(entity);

        return applyList;
    }
}
```

### FavoriteService

```java
@RequiredArgsConstructor
@Service
public class FavoriteService {
    private final FavoriteRepository favoriteRepository;

    public List<Favorite> findFavoriteByVolunteer(Volunteer entity) {
        List<Favorite> favorites = favoriteRepository.findByVolunteer(entity);

        return favorites;
    }
}
```

### CommentService
```java
@RequiredArgsConstructor
@Service
public class CommentService {
    private final CommentRepository commentRepository;

    public List<Comment> getCommentsByVolunteer(Volunteer entity) {
        List<Comment> commentList = commentRepository.findByVolunteer(entity);

        return commentList;
    }
}

```

우선 기능이 정확하게 돌아가는건 미뤄두고, 러프하게 위에서 findById가 진행하던일을 세부분으로 나눠보았다.







