<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-04-06T15:10:38+00:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Learnote-Dev</title><subtitle>대학생 예비 개발자 블로그</subtitle><author><name>이민재</name><email>lmj938@naver.com</email></author><entry><title type="html">[AWS] 환불 완료 후기</title><link href="http://localhost:4000/etc/AWS-%ED%99%98%EB%B6%88-%EC%99%84%EB%A3%8C-%ED%9B%84%EA%B8%B0/" rel="alternate" type="text/html" title="[AWS] 환불 완료 후기" /><published>2022-04-06T00:00:00+00:00</published><updated>2022-04-06T00:00:00+00:00</updated><id>http://localhost:4000/etc/%5BAWS%5D%20%ED%99%98%EB%B6%88%20%EC%99%84%EB%A3%8C%20%ED%9B%84%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/etc/AWS-%ED%99%98%EB%B6%88-%EC%99%84%EB%A3%8C-%ED%9B%84%EA%B8%B0/">&lt;h2 id=&quot;환불-완료&quot;&gt;환불 완료&lt;/h2&gt;
&lt;p&gt;오늘 AWS에서 드디어 환불이 완료되었습니다.&lt;/p&gt;

&lt;p&gt;물론 문의 글 하나만에 되지는 않았고, 살짝 몇가지 과정들을 거쳤는데요. 이를 간단하게 적어보려고 합니다.&lt;/p&gt;

&lt;h3 id=&quot;첫번째-답장&quot;&gt;첫번째 답장&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-06-[AWS]/image1.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;첫번 째 답장은 아래 네가지 질문에 답해 달라고 하셨습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;언제 요금이 부과된 사실을 알게 되었는지&lt;/li&gt;
  &lt;li&gt;요금을 멈추기 위해 어떠한 행동을 취했는지&lt;/li&gt;
  &lt;li&gt;계속 해당 계정에서 동일한 서비스를 이용할 계획이 있는지&lt;/li&gt;
  &lt;li&gt;어느 청구서에 요금 조정이 필요한지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;아마 요금이 발생한게 정말 실수인 것인지, 알아차린 즉시 요금이 발생하지 않기위한 행동을 취했는지를 확인하려고 물어보는 질문 같았습니다.&lt;/p&gt;

&lt;p&gt;그래서 저는 다음과 같이 답장을 보냈습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-06-[AWS]/image2.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;언제 요금이 부과된 사실을 알게 되었는지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;카드 결제가 되고나서야 깨달았습니다. 하지만 이제 AWS의 예산 알람기능에 대해 숙지 했기 때문에, 이런일이 다시 발생하지 않도록 약속하겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요금을 멈추기 위해 어떠한 행동을 취했는지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;즉시 제 콘솔로가서 요금이 왜 청구되었는지 확인하였고, 웹사이트를 통해서 프리티어 옵션이 하나의 인스턴스당 750시간만을 지원한다는것을 알게되었습니다. 그리고 바로 EC2와 RDS의 인스턴스를 삭제 하였습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;계속 해당 계정에서 동일한 서비스를 이용할 계획이 있는지&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;프리티어가 종료되기전까지 계속 해당 서비스를 이용할 것이나. 무료로 제공되는 기능만 사용하려고 합니다. 그래서 앞으로는 하나의 인스턴스만 사용할것입니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;어느 청구서에 요금 조정이 필요한지&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3월 청구서에 조정이 필요합니다.&lt;/p&gt;

&lt;p&gt;이렇게 답장을 보내고, 또 하루정도를 기다렸습니다.&lt;/p&gt;

&lt;h3 id=&quot;두번째-답장&quot;&gt;두번째 답장&lt;/h3&gt;
&lt;p&gt;!&lt;img src=&quot;/assets/images/tech/ETC/2022-04-06-[AWS]/image3.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두번째 답장에서는 요금조정을 위해서는 현재 요금이 발생되고있는 DB 스냅샷 삭제가 필요하다는 연락과 함께, DB스냅샷 삭제 방법이 적혀있는 링크를 받았습니다.&lt;/p&gt;

&lt;p&gt;저는 요금이 발생하는 것들을 모두 삭제했다고 생각 했는데, &lt;strong&gt;인스턴스는 생성할 때 반드시 함께 이를 복구할 수 있는 스냅샷이 함께 생성됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;인스턴스를 삭제해도 해당 스냅샷은 남아있으니, &lt;strong&gt;사용하지 않는 인스턴스라면 반드시 삭제 후에 해당 인스턴스의 스냅샷도 같이 삭제해주어야합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_DeleteSnapshot.html&quot;&gt;스냅샷 삭제 방법 링크&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 위 링크에 나와있는 방법대로, 제 RDS에 있는 DB스냅샷을 삭제한 후 다시 삭제완료 답장을 보냈습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-06-[AWS]/image4.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그리고 하루가 또 지난 후…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-06-[AWS]/image5.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-06-[AWS]/image6.jpeg&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
답변과 함께 드디어 환불이 완료되었습니다!&lt;/p&gt;

&lt;h2 id=&quot;후기&quot;&gt;후기&lt;/h2&gt;
&lt;p&gt;너무 안일하게 AWS를 사용하던 것에 후회함과 동시에, 천조국 대기업인 아마존의 넓은 아량에 감사하게되는 기회였습니다… 앞으로는 조심 또 조심하고 알람기능을 항상 활성화 시켜서, 혹시나 발생할 문제들에 대비할 수 있도록 노력해야겠습니다.&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="ETC" /><summary type="html">환불 완료 오늘 AWS에서 드디어 환불이 완료되었습니다.</summary></entry><entry><title type="html">건강관리</title><link href="http://localhost:4000/diary-univ/%EA%B1%B4%EA%B0%95%EA%B4%80%EB%A6%AC/" rel="alternate" type="text/html" title="건강관리" /><published>2022-04-05T00:00:00+00:00</published><updated>2022-04-05T00:00:00+00:00</updated><id>http://localhost:4000/diary-univ/%EA%B1%B4%EA%B0%95%EA%B4%80%EB%A6%AC</id><content type="html" xml:base="http://localhost:4000/diary-univ/%EA%B1%B4%EA%B0%95%EA%B4%80%EB%A6%AC/">&lt;h2 id=&quot;20220405&quot;&gt;2022.04.05&lt;/h2&gt;
&lt;p&gt;이틀간 코로나로 일어나면 목이 찢어질듯한 고통과 함께 코가 쓰리고 하루종일 피곤해서 뭘 할 수가 없다..&lt;/p&gt;

&lt;p&gt;그나마 토익이라도 간간히 참아가며 풀고있는중인데, 쉬어야지 하면서도 지나가는 시간들이 너무 아깝다…&lt;/p&gt;

&lt;p&gt;사람이 건강할 때는 건강이 원래 내게 주어진 무한한 재산인것 처럼 배팅하고 다니다가 항상 건강을 잃고나서야 사실은 건강이 가장 중요한것이 었다는 것을 깨닫는다.&lt;/p&gt;

&lt;p&gt;하루 20시간 일해서 일주일을 앓아눕느니, 하루 8시간씩 일주일동안 열심히 하는게 훨씬 효율적이다.&lt;/p&gt;

&lt;p&gt;물론 지금 나야 코로나 옮은거라 어쩔 수 없다지만, 앞으로도 건강관리 진짜 열심히 하면서 살아야겠다… 백억있어도 건강하지 못하면 그게 다 무슨 소용이냐.&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="diary-univ" /><category term="일기장" /><summary type="html">2022.04.05 이틀간 코로나로 일어나면 목이 찢어질듯한 고통과 함께 코가 쓰리고 하루종일 피곤해서 뭘 할 수가 없다..</summary></entry><entry><title type="html">코로나 확진되다</title><link href="http://localhost:4000/diary-univ/%EC%BD%94%EB%A1%9C%EB%82%98-%ED%99%95%EC%A7%84%EB%90%98%EB%8B%A4/" rel="alternate" type="text/html" title="코로나 확진되다" /><published>2022-04-04T00:00:00+00:00</published><updated>2022-04-04T00:00:00+00:00</updated><id>http://localhost:4000/diary-univ/%EC%BD%94%EB%A1%9C%EB%82%98%20%ED%99%95%EC%A7%84%EB%90%98%EB%8B%A4</id><content type="html" xml:base="http://localhost:4000/diary-univ/%EC%BD%94%EB%A1%9C%EB%82%98-%ED%99%95%EC%A7%84%EB%90%98%EB%8B%A4/">&lt;h2 id=&quot;20220404&quot;&gt;2022.04.04&lt;/h2&gt;
&lt;p&gt;어제부터 목이 아프다 싶어서 오늘 병원에 가서 신속항원검사를 받았는데, 아니나 다를까 코로나에 걸렸다. 사실 어제 여자친구가 목이 아프다고 자가검사 키트를 했다가 두줄이 나와서, 아 나도 코로나겠구나 하고 있었다.&lt;/p&gt;

&lt;p&gt;아니 근데 어제도 그렇고 오늘 아침에도 그렇고 나는 키트에서 계속 한줄이 나와서, 아니 아무리 봐도 코로나가 아닐수도 없는 시기에 증상인데 미심쩍다 싶어서 그냥 병원을 갔더니 바로 양성이 나왔다.&lt;/p&gt;

&lt;p&gt;증상은 사실 오늘 이틀차라 그런가 원래 경증인건가 코랑 목이 조금 아픈것 빼고는 두통이라던가 아픈건 아직 없다. 어깨 부분에 살짝 통증도 있긴 하지만 이것도 뭐 그냥 버틸만한 수준이다. 사실 내심 아 나는 백신이 잘 작동하고 있나보다~ 했는데 얄짤 없이 걸려버렸다.&lt;/p&gt;

&lt;p&gt;어차피 뭐 이제 위드코로나를 정말 정말 코앞에 두고 있는데, 어차피 이렇게 풍토병화 하려면 한번쯤은 무조건 걸리게 되어있으니  뭐, 나름 타이밍이 나쁘지 않게 걸렸다는 생각이다. 증상도 크지도 않고… 근데 귀찮은건 격리인데, 아빠 직장은 동거인 확진이면 그냥 얄짤 없이 일주일 쉰다고 해서 비확진자인 아빠랑 일주일간 불편한 동거를 하게 생겼다;; 방에서만 7일 갖혀있을 생각에 답답하기도 하면서도 별로 안아프니까 평소에 못했던 공부나 열심히 해야겠다고 생각중이다.&lt;/p&gt;

&lt;p&gt;근데 사실 생각해보니까 원래 맨날 방에서 격리 하고있었던 것 같기도하고;&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="diary-univ" /><category term="일기장" /><summary type="html">2022.04.04 어제부터 목이 아프다 싶어서 오늘 병원에 가서 신속항원검사를 받았는데, 아니나 다를까 코로나에 걸렸다. 사실 어제 여자친구가 목이 아프다고 자가검사 키트를 했다가 두줄이 나와서, 아 나도 코로나겠구나 하고 있었다.</summary></entry><entry><title type="html">[AWS] 프리티어 요금 결제되었을 때 - 청구서 부검하기</title><link href="http://localhost:4000/etc/AWS-%ED%94%84%EB%A6%AC%ED%8B%B0%EC%96%B4-%EC%9A%94%EA%B8%88-%EA%B2%B0%EC%A0%9C%EB%90%98%EC%97%88%EC%9D%84-%EB%95%8C/" rel="alternate" type="text/html" title="[AWS] 프리티어 요금 결제되었을 때 - 청구서 부검하기" /><published>2022-04-03T00:00:00+00:00</published><updated>2022-04-03T00:00:00+00:00</updated><id>http://localhost:4000/etc/%5BAWS%5D%20%ED%94%84%EB%A6%AC%ED%8B%B0%EC%96%B4%20%EC%9A%94%EA%B8%88%20%EA%B2%B0%EC%A0%9C%EB%90%98%EC%97%88%EC%9D%84%20%EB%95%8C...</id><content type="html" xml:base="http://localhost:4000/etc/AWS-%ED%94%84%EB%A6%AC%ED%8B%B0%EC%96%B4-%EC%9A%94%EA%B8%88-%EA%B2%B0%EC%A0%9C%EB%90%98%EC%97%88%EC%9D%84-%EB%95%8C/">&lt;h2 id=&quot;분명-프리티어-요금제인데-결제가&quot;&gt;분명 프리티어 요금제인데 결제가…&lt;/h2&gt;
&lt;p&gt;저는 두달 전 AWS 공부를 위해서 AWS에 가입하고 &lt;strong&gt;프리티어 요금제&lt;/strong&gt;를 가입하였습니다. 용량이 작고 성능이 제한적이긴 하지만, &lt;strong&gt;1년동안 무료로 사용할 수 있기 때문에&lt;/strong&gt; 공부를 하기에는 1년이면 뽕을 뽑고도 남았죠.&lt;/p&gt;

&lt;p&gt;근데 오늘 아침에, 제 통장에서 AWS가 돈을 출금해 갔습니다…&lt;br /&gt;
&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image1.jpeg&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;출금을 보자마자 후다닥 책상에 앉아서 AWS에 들어갔는데, 다음과 같은 청구서를 확인 할 수 있었습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image2.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;저는 간단한 웹사이트를 만들기 위해서 &lt;strong&gt;EC2&lt;/strong&gt;와 &lt;strong&gt;RDS&lt;/strong&gt;를 사용하고 있었는데 해당 항목들에서 비용이 발생 하였습니다. 전 분명히 프리티어 요금제를 사용중이라 1년간 무료일텐데, 왜 이런일이 발생했을까요?&lt;/p&gt;

&lt;p&gt;돈을 지출하게 되어 너무나도 마음이 아프지만 다시는 이런일이 없도록 다짐하고 제 마음을 위로할겸, 제 청구서를 부검해보록 하겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;프리티어-요금제는-완전한-무료가-아니다&quot;&gt;프리티어 요금제는 완전한 무료가 아니다&lt;/h2&gt;
&lt;p&gt;저는 얼마전에 기존에 책을 보고 따라만들던 웹사이트와 별개로 제가 스스로 프로젝트를 하나 해보려고 &lt;strong&gt;EC2와 RDS의 인스턴스를 하나씩 늘렸습니다.&lt;/strong&gt; EC2와 RDS 둘 다 두개의 인스턴스를  사용하고 있었던 것이죠.&lt;/p&gt;

&lt;p&gt;프리티어 요금제니까, 단순하게 1년동안은 무료인줄 알았습니다.&lt;/p&gt;

&lt;p&gt;하지만 프리티어 요금제는 &lt;strong&gt;지정된 한도내에서만&lt;/strong&gt; 무료로 서비스를 제공합니다&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/free/?all-free-tier.sort-by=item.additionalFields.SortRank&amp;amp;all-free-tier.sort-order=asc&amp;amp;awsf.Free%20Tier%20Types=*all&amp;amp;awsf.Free%20Tier%20Categories=*all&amp;amp;awsm.page-all-free-tier=1&quot;&gt;서비스 별 프리티어 요금제 무료 이용량&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;위 링크에서는 프리티어 요금제의 서비스별 사용량을 확인 할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그럼, 제 청구서를 부검해보며 저는 어떤 실수를 했길래 요금을 지불했는지 알아보겠습니다.&lt;/p&gt;

&lt;h3 id=&quot;ec2와-rds&quot;&gt;EC2와 RDS&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image11.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
EC2의 경우,  &lt;strong&gt;750시간은 free tier가 정상적으로 적용&lt;/strong&gt;되었지만, &lt;strong&gt;추가로 403시간의 비용이 청구&lt;/strong&gt; 되었습니다. EC2의 인스턴스에서 사용한 &lt;strong&gt;EBS에서는 30GB의 용량을 추가로 사용한 비용이 청구&lt;/strong&gt; 되었습니다. ElasticIP에서도 동일하게 요금이 청구 되었지만, 이는 뒤에서 따로 다루도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image12.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
RDS를 한번 볼까요? &lt;strong&gt;RDS&lt;/strong&gt;의 경우, &lt;strong&gt;750시간은 프리티어로 처리&lt;/strong&gt;되었고, &lt;strong&gt;731시간이 청구&lt;/strong&gt;되었네요. 마찬가지로 RDS에서 사용하는 &lt;strong&gt;Storage&lt;/strong&gt;에서도 기본 프리티어 사용량인 &lt;strong&gt;20기가는 프리티어로 처리&lt;/strong&gt;되었지만, &lt;strong&gt;나머지는 요금이 청구되었습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;왜 프리티어인데도 요금이 발생 했을까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image3.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진을 보면 제가 사용한 EC2와 RDS의 경우, &lt;strong&gt;월당 750시간만큼이 무료로 제공됩니다.&lt;/strong&gt; 물론 이 시간은 인스턴스 하나당 시간으로 적용되므로, 만약 저처럼 2개의 인스턴스를 사용하면 개당 375시간으로 적용되기 때문에, 보름정도의 시간이 지나고 나면, &lt;strong&gt;남은 보름에 대해서는 요금을 지불해야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로, &lt;strong&gt;EBS&lt;/strong&gt;와 &lt;strong&gt;Storage&lt;/strong&gt;도 프리티어 당 정해진 시간이 존재하고, 이 둘은 EC2나 RDS의 인스턴스를 만들면 함께 생성되기 때문에, 이 둘도 동일하게 프리티어 이상의 사용 요금을 지불해야 했죠.&lt;/p&gt;

&lt;p&gt;저의 경우는 이 사실을 모르고 인스턴스를 2개씩 만들었기 때문에, 프리티어 제공 시간을 초과한 보름 동안의 사용비용이 청구된 것 입니다.&lt;/p&gt;

&lt;h3 id=&quot;elastic-ip&quot;&gt;Elastic IP&lt;/h3&gt;

&lt;p&gt;EC2를 이용해 웹서버를 호스팅 하게 되면, EC2가 항상 같은 ip주소로 동작하게 하기 위해서 고정 아이피를 발급 받고 이를 EC2에 연결하여 사용하게 되는데요. &lt;strong&gt;이를 연결하지 않는경우, 또는 연결된 상태일지라도 EC2가 멈춰 있는 상태라면 요금이 부과됩니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image4.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진을 보면 첫번째 아이피는 EC2에 할당이 되어있지만, &lt;strong&gt;두번째 아이피는 할당이 되어있지 않습니다.&lt;/strong&gt; 이 경우에 요금이 부과됩니다. 물론 EC2에 연결되어 있는 상태더라도, EC2인스턴스가 멈춘 상태라면 요금이 부과됩니다.&lt;/p&gt;

&lt;h3 id=&quot;rds-인스턴스가-유료-옵션이-선택된-인스턴스로-만들어질-경우&quot;&gt;RDS 인스턴스가 유료 옵션이 선택된 인스턴스로 만들어질 경우&lt;/h3&gt;
&lt;p&gt;이 항목은 이번에 제가 실수하지는 않은 항목이지만, 이 경우에도 비용이 발생합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RDS 생성 시 멀티 AZ 옵션을 사용하도록 체크하면, 별도의 추가 비용이 발생합니다.&lt;/strong&gt; 이 옵션은 데이터베이스를 만들때 기본으로 YES로 설정되어 있기 때문에 이 기능이 별도로 필요하시지 않고, 온전히 무료로 프리티어로 사용하고 싶다면 해당 옵션을 꼭 꺼주셔야 합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image5.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위의 방법들만 꼼꼼히 체크한다면, &lt;strong&gt;안전하게 프리티어 요금제를 무료로 사용할 수 있습니다.&lt;/strong&gt; 하지만 더 안전한 방법은, &lt;strong&gt;내가 생각한 요금보다 큰 요금이 발생했을 때, 최대한 빠르게 알아채는 것입니다.&lt;/strong&gt; 사람은 누구나 실수를 하니까요.&lt;/p&gt;

&lt;p&gt;유료옵션을 실수로 설정했을 때는 물론이고 실수로 트래픽이 과도하게 발생하는 코드를 짰거나, 해킹을 당했을때도 &lt;strong&gt;이를 바로 알 수 있다면 즉시 인스턴스를 종료하여 요금 폭탄을 피할 수 있을 것입니다.&lt;/strong&gt; 저도 만약 알림을 설정해놓았다면, 제가 유료옵션을 실수로 선택했다는 것을 훨씬 빠르게 알아채고 대응하여 요금을 지불할 일이 없었겠죠. 그럼 이번에는 AWS의 요금 알림을 설정하는 법에 대해 알아보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;가장-좋은-것은-미리-알아-채는-것&quot;&gt;가장 좋은 것은 미리 알아 채는 것&lt;/h2&gt;
&lt;p&gt;AWS는 이러한 일들을 사용자가 겪지 않도록 하기 위해, Budget, 예산을 설정할 수 있습니다. 서비스의 예산을 정해 놓음으로써, &lt;strong&gt;해당 예산의 일정 퍼센테이지 이상 금액이 발생하면, 바로 사용자에게 알림이 가는것이죠.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;AWS 오른쪽 위에 아이디를 눌러 결제 대시보드로 이동합시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image6.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
왼쪽에 보면 여러가지 결제 관련 메뉴들이 있습니다. 여기서 Budget으로 이동해 줍시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image7.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
이 곳에서는 예산을 작성하고, 해당 예산의 일정 퍼센테이지 이상의 요금이 발생하면 메일로 알림을 받을 수 있게 됩니다.&lt;/p&gt;

&lt;p&gt;오른쪽 위에 &lt;strong&gt;예산 작성&lt;/strong&gt; 을 눌러 예산을 작성해봅시다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image8.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예산을 다양한 옵션으로 작성할 수 있습니다. 저는 프리티어 요금제를 완전히 무료로 사용하기 위해서 1달러만 비용이 발생해도 알림이 오도록 하기위해, &lt;strong&gt;비용 예산&lt;/strong&gt;을 선택하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image9.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
예산 이름은 &lt;strong&gt;FreeTier&lt;/strong&gt;로 하고, 예산 금액을 &lt;strong&gt;1달러&lt;/strong&gt;로 하겠습니다. Budget scope는 모든 AWS 서비스를 대상으로 해서, 모든 서비스의 총합 예산을 1달러로 설정합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image10.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
이제 알림을 설정하는데, &lt;strong&gt;임계값을 절대값으로 하고 0.1달러의 비용만 발생해도 알림이 오도록 해주겠습니다.&lt;/strong&gt;이메일 수신자에는 제 이메일을 입력하는데, 쉼표로 구분해주면 알림을 여러개의 이메일로 오도록 할 수도 있습니다.&lt;/p&gt;

&lt;p&gt;이제 예산을 작성을 완료했으므로, 제 AWS에서 만약 0.1달러의 요금이라도 발생하게되면 저는 이메일로 이를 알고 대응 할 수 있게 되었습니다.&lt;/p&gt;

&lt;h2 id=&quot;이미-지불한-비용은&quot;&gt;이미 지불한 비용은…?&lt;/h2&gt;
&lt;p&gt;실수로 발생한 비용이라 수업료로 생각하자는 마음이 들면서도 실수로 결제된 금액이 너무 아까워 인터넷을 찾아보니, &lt;strong&gt;AWS는 개인계정에 한해서 1회정도는 실수에 대한 요금을 환불해준다고 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;게다가 학생의 경우는 조금 더 너그럽게 실수를 처리해준다고 하는데, 인터넷 검색을 하다가 어떤 분께서는 거의 &lt;strong&gt;천만원이 넘는 비용을 무료로 처리해준 케이스도 있었습니다.&lt;/strong&gt; 정말 미국 대기업답게 시원 시원하네요…&lt;/p&gt;

&lt;p&gt;다만 기업계정의 경우 얄짤 없다고 하니, 직장에서 AWS를 사용한다면 조심 또 조심 해야 할 것 같습니다.&lt;/p&gt;

&lt;p&gt;그래서 잠시 고민에 잠겨 이번에는 수업료로 가볍게 지불하고, 혹여나 나중에 해킹을 당하거나, 코드 실수를 해서 한 천만원 이렇게 나왔을 때 환불찬스를 써야하나… 하는 생각이 잠깐 들었지만, 이번에 환불 받고 앞으로는 철저히 AWS 관리를 해서 이런 일이 발생하지 않도록 노력 하기로 했습니다.&lt;/p&gt;

&lt;p&gt;AWS 지원센터로 가서 환불요청을 하면 되는데요, &lt;strong&gt;중요한점은 문의하기전 반드시 해당 실수가 일어난 부분들을 정상으로 돌려놓은 뒤에 문의해야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-04-03-[AWS]/image13.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
저는 다음과 같이 요청했는데요, 학생임을 인증하기 위해서 학생증까지 첨부하였습니다… 부끄러운 실력으로 영어로 한자 한자 적었는데, 나중에 알고보니 한국어로 작성해도 상관없다고 합니다;&lt;/p&gt;

&lt;p&gt;문의를 할 때는 제목은 &lt;strong&gt;refund request&lt;/strong&gt;로 간결하게 적고, 카테고리는&lt;br /&gt;
&lt;strong&gt;Billing&lt;/strong&gt;, &lt;strong&gt;Charge Inquiry&lt;/strong&gt;로 설정하고 문의를 남기면 됩니다.&lt;/p&gt;

&lt;p&gt;이것으로 아마존의 넓은 아량을 믿고 제발 환불이 되기를 바라면서 제 청구서 부검을 마치고, 아직 승인이 나지 않았지만 만약 환불이 된다면 게시물에 추가하도록 하겠습니다.&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="ETC" /><summary type="html">분명 프리티어 요금제인데 결제가… 저는 두달 전 AWS 공부를 위해서 AWS에 가입하고 프리티어 요금제를 가입하였습니다. 용량이 작고 성능이 제한적이긴 하지만, 1년동안 무료로 사용할 수 있기 때문에 공부를 하기에는 1년이면 뽕을 뽑고도 남았죠.</summary></entry><entry><title type="html">지식의 가치</title><link href="http://localhost:4000/diary-univ/%EC%A7%80%EC%8B%9D%EC%9D%98-%EA%B0%80%EC%B9%98/" rel="alternate" type="text/html" title="지식의 가치" /><published>2022-03-28T00:00:00+00:00</published><updated>2022-03-28T00:00:00+00:00</updated><id>http://localhost:4000/diary-univ/%EC%A7%80%EC%8B%9D%EC%9D%98%20%EA%B0%80%EC%B9%98</id><content type="html" xml:base="http://localhost:4000/diary-univ/%EC%A7%80%EC%8B%9D%EC%9D%98-%EA%B0%80%EC%B9%98/">&lt;h2 id=&quot;20220328&quot;&gt;2022.03.28&lt;/h2&gt;
&lt;p&gt;오늘 인프런에서 강의를 거진 40만원어치를 결제 했다.&lt;/p&gt;

&lt;p&gt;아직 강의에 돈쓰는게 익숙치가 않아서 솔직히 조금 아까운 마음도 들지만, 지식을 구매하는데에는 돈을 아끼지 말아야 한다는 생각이 요즘 들어서 그냥 과감하게 결제 해버렸다.&lt;/p&gt;

&lt;p&gt;인터넷이 지금과 같이 발달하기 이전에는 어떠한 지식을 배우려면 직접 해당 지식을 가르쳐주는 학원을 등록하거나, 직접 취업을 해서 관련 기술에 대한 지식을 습득해야 했다. 하지만 이제는 대부분의 지식들이 아주 질 좋은 인터넷강의로 수강 할 수 있게 되었고, 인터넷 강의의 단점인 피드백이 부족하다는 부분도 자체 슬랙채널이나 커뮤니티를 개설해서 질문하고 대답할 수 있게 되면서 어떻게 보면 이제는 거의 오프라인 강의에 준하는 퀄리티를 갖게 되었다. (물론 아직도 오프라인의 실시간 피드백에는 크게 못미치지만, 온라인 강의의 언제든지 어디에서나 들을 수 있다는 장점이 이 부분을 크게 상쇄한다고 생각한다.)&lt;/p&gt;

&lt;p&gt;사실 이러한 몇몇 질좋은 온라인 강의들의 가성비는 말이 안되는 수준이라고 생각한다. 만약 저정도 수준의 강의들을 오프라인에서 직접 들으려면 온라인 강의에서 지불한 금액의 몇배를 지불해야할 정도일 뿐더러, 몇년전 까지만 해도 돈이 있어도 오프라인 자리가 없어 예약을 걸어놓아야 들을 수 있을 만한 수준의 강의들이 이제는 곳곳에 널려서 일정 금액만 지불하면 누구나 해당 강의를 수강할 수 있다.&lt;/p&gt;

&lt;p&gt;물론 인터넷 검색으로도 얼마든지 정보를 검색하고 찾아가며 들을 수 있겠지만, 해당 정보를 찾는 시간과 비가공된 정보들을 가공하는 과정에서 드는 노력을  하는 것 보다는 실제로 업계에서 인정받고 있는 사람이 정제하고 가공한 지식을 받아들이는게 몇배는 간편하고 빠르게 지식을 습득할 수 있을 것이다.&lt;/p&gt;

&lt;p&gt;주식이나 부동산같은 자산에  투자하는 것은 리스크와 리턴이 변동성만큼 동일하지만, 지식에 투자하는 것은 리스크가 0고 리턴은 무한하다.&lt;/p&gt;

&lt;p&gt;오늘 40만원 어치 강의를 결제했지만 이 강의가 비싼 가격인지 저렴한 가격인지는 아직 모른다. 내가 열심히 이 정보들을 내걸로 만든다면 겨우 40만원밖에 안하는 저렴한 강의가 될 것이고, 그냥 방치하고 그냥 저냥 듣는다면 무려 40만원 씩이나 하는 돈아까운 비싼 강의가 될 것이다.&lt;/p&gt;

&lt;p&gt;거창하게 썼지만… 사실 막상 40만원 나가고 보니까 아까워서 마음을 다잡으려고 한번 써봤다. ㅜ&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="diary-univ" /><category term="일기장" /><summary type="html">2022.03.28 오늘 인프런에서 강의를 거진 40만원어치를 결제 했다.</summary></entry><entry><title type="html">[Spring] JaCoCo 적용하여 테스트 커버리지 체크하기</title><link href="http://localhost:4000/java/jacoco-%EC%A0%81%EC%9A%A9%ED%95%98%EC%97%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Spring] JaCoCo 적용하여 테스트 커버리지 체크하기" /><published>2022-03-27T00:00:00+00:00</published><updated>2022-03-27T00:00:00+00:00</updated><id>http://localhost:4000/java/jacoco%20%EC%A0%81%EC%9A%A9%ED%95%98%EC%97%AC%20%ED%85%8C%EC%8A%A4%ED%8A%B8%20%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80%20%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/java/jacoco-%EC%A0%81%EC%9A%A9%ED%95%98%EC%97%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;테스트 코드는 개발 시간을 굉장히 단축시켜주는 강력한 도구입니다.&lt;/strong&gt; 물론 코드를 작성하는데 시간도 많이 들어갈 뿐더러, 눈에 보이는 성과를 주지 않는 코드이기 때문에, 괜히 작성하는 시간이 아깝고 귀찮아서 잘 작성하지 않는 경우가 대부분입니다. 저도 마찬가지였구요… 기능이 적을때는 서버를 다시 시작해서 눈으로 확인하는게 더 편하다고 생각할 수도 있겠지만, &lt;strong&gt;기능이 많아지거나, 과정이 복잡한 기능의 경우, 일일히 서버를 올린뒤 해당 기능에 에러가 날만한 값을 하나하나 넣으며 테스트하는 것은 몹시 비효율적인 행위&lt;/strong&gt;입니다.&lt;/p&gt;

&lt;p&gt;심지어 테스트 코드가 없다면 기능을 일부분 수정하거나, 기존 코드를 리팩토링 할 때도, 만약 문제가 발생한다면 &lt;strong&gt;어느 부분에서 발생한 것인지 알아채기도 어렵고, 아까 서술했던 방식대로 리팩토링을 하고나서 또 일일히 테스트를 해야할 것 입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;따라서 테스트 코드 작성을 꼼꼼히 해야하는데, 이를 강제해주는 좋은 라이브러리가 있어 한번 알아보려고 합니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;라이브러리의 이름은 &lt;strong&gt;JaCoCo&lt;/strong&gt;입니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jacoco란&quot;&gt;JaCoCo란?&lt;/h2&gt;
&lt;p&gt;JaCoCo는 자바 코드의 커버리지를 체크하는 라이브러리로, &lt;strong&gt;테스트 코드가 현재 프로덕션코드의 얼마만큼 작성되었는지 퍼센테이지로 확인하도록 해주는 라이브러리 입니다.&lt;/strong&gt; 만약 커버리지가 100퍼센트라면, 모든 프로덕션 코드에 대해서 테스트 코드가 작성되어 있는 상태라고 할 수 있을 것 입니다.&lt;/p&gt;

&lt;p&gt;심지어 JaCoCo는 이렇게 커버리지 결과를 알려줄뿐만 아니라, &lt;strong&gt;해당 커버리지가 사용자가 설정한 퍼센테이지에 미치지 못하면 build자체가 되지않게 설정하여, 테스트코드 작성을 강제합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그럼 한번 JaCoCo를 어떻게 적용하는지 알아보고, 예제를 사용해보며 JaCoCo의 사용법을 알아 보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;jacoco-추가하기&quot;&gt;JaCoCo 추가하기&lt;/h2&gt;
&lt;p&gt;먼저, build.gradle에 JaCoCo를 설정해 줍니다. &lt;strong&gt;plugins&lt;/strong&gt;부분에 아래와 같은 부분을 추가해주면, Gradle이 알아서 해당 의존성을 추가해줍니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;plugins {
	id &apos;jacoco&apos;
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이렇게 JaCoCo의 의존성을 추가하고 나면 별도의 설정이 필요한데요, 아까 말한 &lt;strong&gt;커버리지의 퍼센테이지를 설정하고, 해당 리포트를 어떤 형식으로 저장할 지를 설정해주어야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;jacocoTestReport {
  reports {
    html.enabled true
    xml.enabled false
    csv.enabled false

// 리포트의 저장 경로를 설정합니다.
html.destination file(&quot;jacoco/jacocoHtml&quot;)
xml.destination file(&quot;jacoco/jacoco.xml&quot;)
  }
}

jacocoTestCoverageVerification {
  
  violationRules { // 커버리지의 범위와 퍼센테이지를 설정합니다.
    rule {
      element = &apos;CLASS&apos;

      limit {
        counter = &apos;BRANCH&apos;
        value = &apos;COVEREDRATIO&apos;
        minimum = 0.90
      }
    }
  }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 설정 부분은 지금은 그냥 복사해서 붙여넣으시면 됩니다. 자세한 세팅은 뒤에서 다시 설명하겠습니다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 JaCoCo가 추가되는데, 오른쪽에 있는 gradle탭을 눌러 &lt;strong&gt;Tasks &amp;gt; Verification&lt;/strong&gt;에 들어가면 아래와 같은 &lt;strong&gt;jcocoTestReport&lt;/strong&gt;와 &lt;strong&gt;jacocoTestCoverageVerification&lt;/strong&gt; 명령이 생긴 것을 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image1.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 이제 JaCoCo를 사용하기에 앞서서 테스트를 위한 간단한 프로덕션 코드를 작성해보고, 이를 테스트 해보겠습니다.&lt;/p&gt;

&lt;h2 id=&quot;jacoco를-사용하여-테스트-코드-작성하기&quot;&gt;JaCoCo를 사용하여 테스트 코드 작성하기&lt;/h2&gt;
&lt;p&gt;클래스 이름은 Jacoco로 대략 붙이도록 하겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;public class Jacoco{
    public String select(String name) {
        switch (name) {
            case &quot;딸기&quot;:
                return &quot;빨간색입니다.&quot;;
            case &quot;바나나&quot;:
                return &quot;노란색입니다.&quot;;
            default:
                return &quot;잘 모르겠습니다.&quot;;
        }
    }

    public String giveMeFruit() {
        return &quot;과일주세요!&quot;;
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;간단한 함수 select()를 하나 추가 해주었는데요. 메서드에 인자로 &lt;strong&gt;딸기를 넘기면 딸기의 색깔을, 바나나를 넘기면 바나나의 색깔을 말해주는 메서드&lt;/strong&gt;입니다. 만약 &lt;strong&gt;두 과일 외의 다른 과일이 온다면, ‘잘 모르겠습니다’ 라는 문구를 출력할 것&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;p&gt;그럼 이 메서드의 테스트 코드를 한번 작성해볼까요?&lt;/p&gt;

&lt;p&gt;우선 간단하게 아래처럼 작성해보도록 하겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;class JacocoTest {
    private Jacoco jacoco = new Jacoco();

    @Test
    public void 딸기_색깔을_잘_출력하는지_테스트() {
        String actual = jacoco.select(&quot;딸기&quot;);
        String expected = &quot;빨간색입니다.&quot;;
        assertThat(actual).isEqualTo(expected);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;테스트 메서드는 알아보기 쉽게 이름을 한글로 지어보았습니다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 assertThat이 &lt;strong&gt;프로그램의 실제값(actual)&lt;/strong&gt;과 &lt;strong&gt;우리가 기대하는 값(expected)&lt;/strong&gt;가 같은 지 확인하여, 같다면 이 테스트가 pass될 것이고, 다르다면 fail될 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 이렇게 작성한 테스트 코드는 현재, &lt;strong&gt;프로덕션 코드의 몇퍼센트를 커버하고 있을까요?&lt;/strong&gt; 이를 알아보기 위해서 이제 JaCoCo를 작동시켜, 현재 테스트 코드의 커버리지를 확인해보도록 합시다.&lt;/p&gt;

&lt;p&gt;위의 Gradle 탭에서 &lt;strong&gt;test&lt;/strong&gt;,&lt;strong&gt;jcocoTestReport&lt;/strong&gt;와 &lt;strong&gt;jacocoTestCoverageVerification&lt;/strong&gt; 명령을 순서대로 작동시켜 봅시다.&lt;br /&gt;
각각의 명령은 &lt;strong&gt;테스트 코드를 실행(test)&lt;/strong&gt;하고, &lt;strong&gt;리포트를 생성(jacocoTestReport)&lt;/strong&gt;한 다음, &lt;strong&gt;커버리지를 체크(jacocoTestCoverageVerification)&lt;/strong&gt; 합니다.&lt;/p&gt;

&lt;p&gt;근데 아마 &lt;strong&gt;jacocoTestCoverageVerification&lt;/strong&gt; 명령을 실행시키면, 에러가 뜨며 해당 명령이 정상적으로 실행되지 않았다고 나올 것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image3.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;에러를 읽어보면, 우리의 테스트코드는 현재 0.33의 커버리지를 갖고있는데, 커버리지 기댓값은 0.90이라고 나와있습니다.&lt;br /&gt;
앞서 말했던대로, JaCoCo는 우리가 설정해둔 커버리지 값에 테스트 코드가 미치지 못하면 빌드 자체를 에러를 띄웁니다.&lt;/p&gt;

&lt;p&gt;그럼 아까 build.gradle 파일에서 jcocoTestReport에 설정해준 경로,&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;html.destination file(&quot;jacoco/jacocoHtml&quot;)
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;에 생성된 index.html 파일을 열어 자세한 정보를 알아보겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image2.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;index.html 파일을 원하는 브라우저로 열면, &lt;strong&gt;커버리지 퍼센트를 확인 할 수 있습니다.&lt;/strong&gt; (인텔리제이의 경우 오른쪽 위에 뜨는 팝업에서 브라우저를 누르면 바로 열 수 있습니다.)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image4.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;보면 &lt;strong&gt;Instruction은 55퍼센트의 커버리지를 달성&lt;/strong&gt;했고, 전체 &lt;strong&gt;Branches는 33퍼센트의 커버리지 밖에 달성하지 못했습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;자세히 보기 위해서 &lt;strong&gt;com.jacoco.example&lt;/strong&gt;을 눌러 세부정보들을 확인해 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image5.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진을 보면 실행파일인 JacocoApplication과 우리가 방금 만들어준 Jacoco의 커버리지가 클래스별로 나와 있는 것을 볼 수 있습니다. 우선 제쳐두고 한번 더 Jacoco를 눌러서 들어가 한번 더 세부내용을 확인해 보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image6.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;메서드 별로 커버리지가 나와있는걸 확인 할 수 있습니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;select()&lt;/strong&gt; 함수의 경우 &lt;strong&gt;Missed Branches&lt;/strong&gt; 의 커버리지가 33퍼센트인데, 여기서 &lt;strong&gt;‘브랜치’&lt;/strong&gt;는 어떤 범위를 이야기 하는 것 일 까요? index.html에서 select() 메서드를 눌러서 들어가 한번 코드를 확인해 봅시다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image8.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;초록색, 노란색, 빨간색이 있는 걸 확인 할 수 있습니다. &lt;strong&gt;빨간색&lt;/strong&gt;의 경우는 커버하지 못한 부분, &lt;strong&gt;노란색&lt;/strong&gt;의 부분은 커버되긴 했으나, 100퍼센트 커버되지 못한 부분, &lt;strong&gt;초록색&lt;/strong&gt;의 부분은 완벽하게 커버된 부분입니다.&lt;/p&gt;

&lt;p&gt;그럼, 이 메서드의 경우 &lt;strong&gt;결과값이 몇개의 분기로 이루어져 있을까요?&lt;/strong&gt; 간단하게 &lt;strong&gt;return값을 3개 갖고있는 함수이므로, 3개입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;아까 우리의 테스트 코드를 보면, &lt;strong&gt;“딸기”&lt;/strong&gt;를 입력하고 &lt;strong&gt;“빨간색입니다”&lt;/strong&gt;의 출력이 나오는 경우만 테스트 코드를 작성했기 때문에, &lt;strong&gt;바나나&lt;/strong&gt;를 입력했을 때와 &lt;strong&gt;그 외의 입력값&lt;/strong&gt;을 입력했을 때, 이 프로그램이 정상적으로 작동하는지 확신할 수 없는 상태일 것입니다. return 값을 확인해보면, &lt;strong&gt;“빨간색입니다.”의 return 값은 초록색으로 커버되었지만, 나머지 두 return값은 빨간색으로 커버되지 못한 것을 확인 할 수 있습니다.&lt;/strong&gt; 따라서 &lt;strong&gt;Branch&lt;/strong&gt;는, &lt;strong&gt;이 메서드가 가질 수 있는 출력값의 개수&lt;/strong&gt;임을 알 수 있습니다.&lt;/p&gt;

&lt;p&gt;그렇다면 Instruction은 어떤 의미로 범위를 나눈 것인 걸까요?? &lt;strong&gt;Instruction은 지나간 바이트 코드를 측정합니다.&lt;/strong&gt;  만약, 100개의 바이트 코드중에서 20개의 바이트코드를 커버했다면, Instruction은 20퍼센트인 것이지요. 무슨 말인지 모르겠다면, 간단하게 코드 글자 하나하나의 수라고 생각하면 편합니다. (정확한 설명은 아니지만, 대략 이렇게 알아두고 넘어가도 괜찮습니다.)&lt;/p&gt;

&lt;p&gt;그럼 한번 select() 함수의 커버리지를 100퍼센트 달성하는 테스트 코드를 작성해볼까요?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;class JacocoTest {
    private Jacoco jacoco = new Jacoco();

    @Test
    public void 딸기_색깔을_잘_출력하는지_테스트() {
        String actual = jacoco.select(&quot;딸기&quot;);
        String expected = &quot;빨간색입니다.&quot;;
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void 바나나_색깔을_잘_출력하는지_테스트() {
        String actual = jacoco.select(&quot;바나나&quot;);
        String expected = &quot;노란색입니다.&quot;;
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void 그_외의_값을_잘_출력하는지_테스트() {
        String actual = jacoco.select(&quot;키위&quot;);
        String expected = &quot;잘 모르겠습니다.&quot;;
        assertThat(actual).isEqualTo(expected);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;마찬가지로 간편하게 알아보기 쉽게 메서드 이름을 한글로 지었습니다.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;이로써 &lt;strong&gt;select() 메서드가 출력할 수 있는 결과인 세가지의 경우의 테스트 코드를 모두 작성하였습니다.&lt;/strong&gt; 이제 리팩토링을 하거나 다른 함수가 추가 되어도, 우리는 &lt;strong&gt;이 테스트 코드가 통과한다면 select() 메서드는 여전히 정상적으로 동작하고 있음을 알 수 있을 것 입니다.&lt;/strong&gt; 마찬가지로 다시 JaCoCo의 명령을 실행 시킨 후 select() 메서드의 테스트 코드 커버리지를 확인해볼까요?&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image7.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;select() 메서드의 커버리지가 100퍼센트가 된 것을 확인 할 수 있습니다!&lt;/p&gt;

&lt;p&gt;그럼 이제 Jacoco 클래스에 있는 또 다른 메서드인 giveMeFruit() 메서드도 테스트 코드를 작성하여, JaCoCo클래스의 커버리지를 100퍼센트로 달성해 볼까요?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;class JacocoTest {
    private Jacoco jacoco = new Jacoco();

    @Test
    public void 딸기_색깔을_잘_출력하는지_테스트() {
        String actual = jacoco.select(&quot;딸기&quot;);
        String expected = &quot;빨간색입니다.&quot;;
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void 바나나_색깔을_잘_출력하는지_테스트() {
        String actual = jacoco.select(&quot;바나나&quot;);
        String expected = &quot;노란색입니다.&quot;;
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void 그_외의_값을_잘_출력하는지_테스트() {
        String actual = jacoco.select(&quot;키위&quot;);
        String expected = &quot;잘 모르겠습니다.&quot;;
        assertThat(actual).isEqualTo(expected);
    }

    @Test
    public void giveMeFruit_테스트() {
        String actual = jacoco.giveMeFruit();
        String expected = &quot;과일주세요!&quot;;
        assertThat(actual).isEqualTo(expected);
    }
}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image9.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;다음과 같이 &lt;strong&gt;Jacoo 클래스가 100퍼센트의 커버리지를 달성 한 것을 확인 할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그런데, 아직 이 프로젝트 전체의 커버리지를 확인해보면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image10.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
 &lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image11.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 사진처럼 Branch는 100퍼센트의 커버리지를 달성했지만, &lt;strong&gt;Instruction은 100퍼센트가 달성되지 않은 것을 확인 할 수 있습니다.&lt;/strong&gt; 물론 우리의 목표는 Branch 커버리지의 90퍼센트 이상으로 설정하여 이 상태로도 빌드는 진행될 것 입니다. 그래도 만약 &lt;strong&gt;혹여 테스트가 불가능 하거나,&lt;/strong&gt; 위 JacocoApplication 파일처럼 &lt;strong&gt;테스트가 필요하지 않은 부분을 커버리지에서 제외&lt;/strong&gt;해야 할 경우가 있으니, 이를 커버리지에 포함 시키지 않는 방법도 알아보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;방법은 아주 간단합니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;import lombok.Generated;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@Generated
@SpringBootApplication
public class JacocoApplication {

	public static void main(String[] args) {
		SpringApplication.run(JacocoApplication.class, args);
	}

}
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Lombok&lt;/strong&gt; 라이브러리의 &lt;strong&gt;Generated&lt;/strong&gt; 어노테이션을 붙이면, &lt;strong&gt;해당 클래스를 커버리지에서 제외합니다.&lt;/strong&gt; 메서드 위에 붙여도 동일하게 작동합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/Java/2022-03-27-jacoco/image12.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이로써, 해당 프로젝트의 테스트 코드 커버리지 100퍼센트를 달성하였습니다.&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="Java" /><summary type="html">서론 테스트 코드는 개발 시간을 굉장히 단축시켜주는 강력한 도구입니다. 물론 코드를 작성하는데 시간도 많이 들어갈 뿐더러, 눈에 보이는 성과를 주지 않는 코드이기 때문에, 괜히 작성하는 시간이 아깝고 귀찮아서 잘 작성하지 않는 경우가 대부분입니다. 저도 마찬가지였구요… 기능이 적을때는 서버를 다시 시작해서 눈으로 확인하는게 더 편하다고 생각할 수도 있겠지만, 기능이 많아지거나, 과정이 복잡한 기능의 경우, 일일히 서버를 올린뒤 해당 기능에 에러가 날만한 값을 하나하나 넣으며 테스트하는 것은 몹시 비효율적인 행위입니다.</summary></entry><entry><title type="html">카페인…</title><link href="http://localhost:4000/diary-univ/%EC%B9%B4%ED%8E%98%EC%9D%B8/" rel="alternate" type="text/html" title="카페인…" /><published>2022-03-27T00:00:00+00:00</published><updated>2022-03-27T00:00:00+00:00</updated><id>http://localhost:4000/diary-univ/%EC%B9%B4%ED%8E%98%EC%9D%B8...</id><content type="html" xml:base="http://localhost:4000/diary-univ/%EC%B9%B4%ED%8E%98%EC%9D%B8/">&lt;h2 id=&quot;20220327&quot;&gt;2022.03.27&lt;/h2&gt;
&lt;p&gt;최근에 커피머신도 샀겠다. 맨날 아침마다 한잔씩 내려먹고, 어쩔때는 두잔 씩도 먹을 떄가 있었는데 최근에 자꾸 머리가 아파서 감기가 걸린줄 알았다. 알고보니까 카페인 두통이라고, 커피 맨날 마시면 생기는 카페인 금단 현상 같은 거였다.&lt;/p&gt;

&lt;p&gt;해결방법은 커피를 마시면 해결된다고 한다. 대신 맨날 먹어야 한다는게 문제지… 사실 카페인에 내가 민감한 건 알고 있었다. 가끔 한잔 너무 빨리 마시고 하면 가슴 너무 빨리 뛰고 그렇긴 했는데, 아주 가끔 그런거라서 별 신경 안쓰고 있었다. 무슨놈의 몸이 술도 잘 못먹고 카페인에도 약한지…&lt;/p&gt;

&lt;p&gt;자주먹고 나서는 유독 소화력이 약해진 느낌이어서 요즘 좀 안마셨었는데, 이상하게 자꾸 피곤하고 산만해졌다 싶었더니 이게 다 카페인 금단현상이었다. 어느덧 커피 맨날 아침마다 투샷씩 내려먹은게 벌써 한달이 넘어서, 카페인 중독이 좀 생긴 것 같다. 괜히 관련 글 읽고 나서부터는 세상 모든게 카페인 탓 같다.&lt;/p&gt;

&lt;p&gt;커피 취미로 한번 마셔보겠다고 쓴돈이 지금 한 이십만원이 넘는 것 같은데, 조금 현타가 온다. 진짜 졸릴때만 가끔 마셔야겠다.ㅜ&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="diary-univ" /><category term="일기장" /><summary type="html">2022.03.27 최근에 커피머신도 샀겠다. 맨날 아침마다 한잔씩 내려먹고, 어쩔때는 두잔 씩도 먹을 떄가 있었는데 최근에 자꾸 머리가 아파서 감기가 걸린줄 알았다. 알고보니까 카페인 두통이라고, 커피 맨날 마시면 생기는 카페인 금단 현상 같은 거였다.</summary></entry><entry><title type="html">하기싫은마음</title><link href="http://localhost:4000/diary-univ/%ED%95%98%EA%B8%B0%EC%8B%AB%EC%9D%80%EB%A7%88%EC%9D%8C/" rel="alternate" type="text/html" title="하기싫은마음" /><published>2022-03-24T00:00:00+00:00</published><updated>2022-03-24T00:00:00+00:00</updated><id>http://localhost:4000/diary-univ/%ED%95%98%EA%B8%B0%EC%8B%AB%EC%9D%80%EB%A7%88%EC%9D%8C</id><content type="html" xml:base="http://localhost:4000/diary-univ/%ED%95%98%EA%B8%B0%EC%8B%AB%EC%9D%80%EB%A7%88%EC%9D%8C/">&lt;h2 id=&quot;20220324&quot;&gt;2022.03.24&lt;/h2&gt;
&lt;p&gt;한 두달 전에만 해도 스프링부트를 하다가, 또 얼마전에는 창업을 하려고 플러터를 배우다가 이번에는 또 학교프로젝트에 좀 호기심이 생겨서 아두이노랑 라즈베리 파이를 해보고 있다.&lt;/p&gt;

&lt;p&gt;문득 이렇게 너무 얕게만 여러게 찍어먹기만 해도되나… 하면서도 뭔가 항상 새로운 기술을 배우다 보면, 아 거기서 그게 이거였구나! 싶은 것들이 생기는데, 그 과정이 조금 즐겁다. 여러개의 굴을 파는데 결국 그게 만나는 지점이 자주 생긴다고 해야하나?? 난 사실 깊고 좁게 파는것과 넓고 얇게 중에서 고르라면 무조건 깊고 좁게가 맞다고 생각했는데, 요즘은 넓게 파는것도 중요하다는 생각이 든다.&lt;/p&gt;

&lt;p&gt;하지만 그래도 내가 누군가에게 돈을 받고 일하려면 적어도 한구멍 정도는 어느정도 깊이 이상은 되어야 하지 않을까? 솔직히 지금 구멍의 개수는 많다고 생각하지만, 깊이가 다들 너무 얕은것 같다.&lt;/p&gt;

&lt;p&gt;그래도 나는 백엔드 관련된 스택이 다른 스택들보다는 그 깊이가 깊었으면 좋겠는데, 다른 스택들보다 깊냐고 물어보면, 또 그다지 많이 깊지도 않은 것 같다.&lt;/p&gt;

&lt;p&gt;사실 학문이나 기술이라는게, 일정 깊이 이상 파고들면 당연히 어려운 지점에 맞닿게 되는데, 이 벽을 넘지 않으면 사실 그 지식을 배운 큰 의미가 없다고 생각한다. 적어도 이 벽을 스무댓번은 넘어야 그래도 어디가서 콧방귀좀 뀔 수 있달까…&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/life/2022-03-24-하기싫은마음/image1.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;더닝크루거 효과에 따르면, 어떤 지식을 가진 초보자가 오히려 더 많은 지식을 가진 사람보다 높은 자신감을 갖는다.&lt;/p&gt;

&lt;p&gt;초보자는 오히려 처음에는 비교적 쉬운 지식만을 접하기 때문에, 우매함의 봉우리를 만나 즐거움을 느끼게 된다. 그 이후에는 다들 절망의 계곡을 마주하게 될 미래도 모른채…&lt;/p&gt;

&lt;p&gt;그래도 상심할 필요 없다. 어떤 도전에 있어 벽을 느낀다는건, 반대로 그만큼 전문가의 길에 들어섰다는거니까.&lt;/p&gt;

&lt;p&gt;요즘 나는 너무 우매함의 봉우리의만 찾아 다닌 것 같아서, 반성하는 마음을 좀 가져본다.. 절망 계곡도 좀 걸어댕기자.&lt;/p&gt;

&lt;p&gt;하기 싫고 어려워도, 열심히 스프링 부트 공부해야겠다.&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="diary-univ" /><category term="일기장" /><summary type="html">2022.03.24 한 두달 전에만 해도 스프링부트를 하다가, 또 얼마전에는 창업을 하려고 플러터를 배우다가 이번에는 또 학교프로젝트에 좀 호기심이 생겨서 아두이노랑 라즈베리 파이를 해보고 있다.</summary></entry><entry><title type="html">[Docker] 스프링부트에 도커 적용하기 + M1맥에서 AWS용 도커파일 빌드하기</title><link href="http://localhost:4000/etc/Docker-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90-%EB%8F%84%EC%BB%A4-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="[Docker] 스프링부트에 도커 적용하기 + M1맥에서 AWS용 도커파일 빌드하기" /><published>2022-03-22T00:00:00+00:00</published><updated>2022-03-22T00:00:00+00:00</updated><id>http://localhost:4000/etc/%5BDocker%5D%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90%20%EB%8F%84%EC%BB%A4%20%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0</id><content type="html" xml:base="http://localhost:4000/etc/Docker-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90-%EB%8F%84%EC%BB%A4-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/">&lt;h2 id=&quot;서론&quot;&gt;서론&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://learnote-dev.com/etc/Docker-도커로-스프링부트-띄우기/&quot;&gt;이전 게시물 : [Docker] 도커란 무엇일까?&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;저번 게시물에서는 &lt;strong&gt;도커가 무엇이고 어떻게 작동하는지에 대해 알아보았습니다. **그러면 이제 실제로 도커가 실제로 어떤방식으로 사용되는지 알아보기위해서, 제가 도커를 통해 제가 개발중인 **웹사이트의 개발환경과 서버를 이미지로 제작해서 도커허브에 올리고&lt;/strong&gt; 이를 다시 &lt;strong&gt;AWS 서버에서 내려받아 해당 컨테이너를 동작시켜보도록 하겠습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그럼 이번에는 도커허브에 있는 이미지가 아니라, &lt;strong&gt;직접 도커허브에 내 개발환경과 파일을 이미지로 만들어서 업로드 해보도록 하겠습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;dockerfile이란&quot;&gt;Dockerfile이란?&lt;/h2&gt;
&lt;p&gt;우리가 이미지를 직접 만들어 도커허브에 올리기 위해서는, &lt;strong&gt;‘도커 파일’&lt;/strong&gt;이 필요합니다. 물론 컨테이너안에서 직접 설치 하고 설정한 다음 이를 이미지 파일로 만들어 쓸 수도 있겠지만,&lt;/p&gt;

&lt;p&gt;Dockerfile을 만들어주면,  패키지, 소스코드, 명령어, 환경변수를 기록하여 빌드해주기만 하는 것으로도 바로 원하는 환경을 구성할 수 있습니다.&lt;/p&gt;

&lt;p&gt;무슨말인지 조금 어려울 수 있겠지만, 한번 해보면 왜 개발자들이 Docker를 선호하는지 알게 될 것입니다.&lt;/p&gt;

&lt;h2 id=&quot;dockerfile-만들기&quot;&gt;Dockerfile 만들기&lt;/h2&gt;
&lt;p&gt;Dockerfile은 이미지를 빌드하기 위한 파일로, 따로 확장자가 없는 텍스트 파일입니다. 기존에 도커 컨테이너 환경을 세팅하려면 베이스 이미지 다운로드 후 컨테이너에 접속해서 수동으로 환경설정을 해주던 방식과 다르게 &lt;strong&gt;자동으로 Dockerfile안에 기록한 내용대로 환경을 설정해줍니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;원하는 디렉토리에 Dockerfile을 만들어줍니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image1.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;이 때 주의할점은 Dockerfile을 빌드 할 때에는 해당 파일 ‘Dockerfile’을 포함한 디렉토리와 그 아래에 있는 서브 디렉토리를 모두 Docker로 보내 이미지화 하기 때문에 반드시 원하는 파일만 들어갈 수 있도록 디렉토리를 설정 해주셔야 합니다. 불필요한 파일이 많아지면 도커 데몬의 성능이 저하될 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;먼저, 간단하게 Dockerfile에서 사용할 문법에 대해서 알아봅시다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;FROM - 컨테이너의 Base Image를 설정합니다.&lt;/li&gt;
  &lt;li&gt;MAINTAINER - 이미지를 생성한 사람의 이름 및 정보&lt;/li&gt;
  &lt;li&gt;LABEL - 컨테이너 이미지에 컨테이너의 정보를 저장&lt;/li&gt;
  &lt;li&gt;RUN - 컨테이너 빌드를 위해 Base Image에서 실행할 명령&lt;/li&gt;
  &lt;li&gt;COPY - 컨테이너 빌드 시 호스트의 파일을 컨테이너로 복사&lt;/li&gt;
  &lt;li&gt;ADD - 컨테이너 빌드 시  호스트의 파일 (tar, url 포함) 을 컨테이너로 복사&lt;/li&gt;
  &lt;li&gt;WORKDIR - 컨테이너 빌드 시 명령어 실행될 작업 디렉터리 설정&lt;/li&gt;
  &lt;li&gt;ENV - 환경 변수 지정용&lt;/li&gt;
  &lt;li&gt;ARG - 이미지 빌드를 위해 Dockerfile 내에서 사용하기 위한 값&lt;/li&gt;
  &lt;li&gt;USER - 명령 및 컨테이너 실행 시 적용할 유저 설정&lt;/li&gt;
  &lt;li&gt;VOLUME - 파일 또는 디렉토리를 컨테이너의 디렉토리로 마운트&lt;/li&gt;
  &lt;li&gt;EXPOSE - 컨테이너 동작 시 외부에서 사용할 포트 지정&lt;/li&gt;
  &lt;li&gt;CMD - 컨테이너 동작 시 자동으로 실행할 서비스나 스크립트 지정&lt;/li&gt;
  &lt;li&gt;ENTRYPOINT - CMD와 함께 사용하면서 명령어 지정 시 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 명령어가 Dockerfile을 사용하기 위한 전부입니다. 어렵지 않죠??&lt;/p&gt;

&lt;h2 id=&quot;dockerfile-작성하기&quot;&gt;Dockerfile 작성하기&lt;/h2&gt;
&lt;p&gt;저는 현재 동아리의 웹사이트를 제작하고 있는데요, 제가 개발하는 환경을 이렇습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;자바 8버젼&lt;/li&gt;
  &lt;li&gt;스프링 부트&lt;/li&gt;
  &lt;li&gt;Gradle&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이 정도를 개발환경으로 소개할 수 있겠네요.&lt;/p&gt;

&lt;p&gt;자바의 버젼도 여러가지이고, 스프링부트도 마찬가지죠. Gradle도 버젼이 많습니다. 이들은 서로 버젼간의 호환도 생각해주어야하고, 안에 코드가 해당 버젼과 호환이 안될 수도 있을 것입니다.&lt;/p&gt;

&lt;p&gt;그렇다면 AWS에서 인스턴스에 제가 만든 웹서버를 돌린다고 가정하면 결국 &lt;strong&gt;AWS도 컴퓨터 하나를 대여하는 것 과 마찬가지인데,&lt;/strong&gt; 제가 개발한 환경과 동일하게 AWS를 설정해주어야 &lt;strong&gt;오류없이 안전하게 제가 제작한 서버를 돌릴 수 있을 것입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;만약, 제 컴퓨터에서는 이상이 없었는데 AWS에서만 에러가 발생한다면, 다시 작업환경을 날리고 일일히 버젼을 확인해가며 동일하게 세팅해주어야 할 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 저는 이러한 것을 개선하기 위해서, 제 개발환경을 통째로 사진을 찍어 (이미지화 하여) 업체에 넘기고 (도커 허브에 올리고), 이를 AWS에서 다시 내려받아 동일하게 세팅 하게 해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;제가 설정한 Dockerfile의 내용은 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;FROM openjdk:8-alpine
RUN sh -c &quot;$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.1.1/zsh-in-docker.sh)&quot;
ARG JAR_FILE=build/libs/*.jar
COPY ${JAR_FILE} app.jar
ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
EXPOSE 8080
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;생각보다 굉장히 간단하죠?&lt;/p&gt;

&lt;p&gt;그러면 한 줄 씩 해석해보겠습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;FROM openjdk:8-alpine
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 Dockerfile의 베이스 이미지는 openjdk:8-alpine 을 사용합니다. 한마디로 자바 8환경을 만드는 것이죠.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;RUN sh -c &quot;$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.1.1/zsh-in-docker.sh)&quot;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이 부분은 꼭 설정하지 않아도 됩니다. 저는 bash 보다는 zsh이 편해서, 컨테이너에서 zsh를 사용해주기 위해 해당 코드를 넣었습니다. &lt;strong&gt;RUN은 뒤의 명령어를 컨테이너에 입력합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;ARG JAR_FILE=build/libs/*.jar
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;build/libs/ 디렉터리에 있는 .jar 파일을 변수로 저장합니다. &lt;strong&gt;ARG로 선언해준 변수는 사용하면 바로 사라집니다.&lt;/strong&gt; 따라서 밑에서 이 변수를 사용하고 또 사용하기 위해서는 &lt;strong&gt;한번 더 선언하고 사용해주어야 합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;COPY ${JAR_FILE} app.jar
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;위에서 ARG로 선언해준 변수에 해당하는 파일 .jar 파일을 app.jar 라는 이름으로 &lt;strong&gt;컨테이너에 복사합니다.&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;컨테이너 실행 후 &lt;strong&gt;변경되지 않을 사항에 대해서는 ENTRYPOINT를 사용합니다.&lt;/strong&gt;&lt;br /&gt;
해당 명령은 “java -jar ./app.jar”의 명령을 컨테이너 시작과 동시에 실행합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Expose 8080
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;외부 포트에서 들어온 포트 연결을 해당 컨테이너의 포트로 연결해줍니다.&lt;/strong&gt;&lt;br /&gt;
어쩌면 이 명령어 중에 가장 헷갈리는 개념일 수 있는데, 이 부분에서는 뒤에서 설명 하도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;그럼 이제 이 Dockerfile이 이해가 되셨나요?&lt;/p&gt;

&lt;p&gt;도커는  자바8 기반으로 환경을 세팅하고, zsh을 설치 한 뒤,  빌드된 서버인 jar파일을 컨테이너로 옮겨 실행합니다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;이렇게 만들어준 파일을 그럼 빌드해서 이미지로 만들어 보겠습니다.&lt;/strong&gt; 명령어는 다음과 같습니다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;docker build -t lmj938/jamong-sever .
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;.을 빼먹지 말도록 주의 해주세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;-t 옵션을 붙이면, 뒤에있는 내용이 이미지의 이름이 됩니다.&lt;/p&gt;

&lt;p&gt;이렇게 하면 이미지 파일이 생성되는데 여기서 주의 할 점이 있습니다. 도커허브에 올리기 위해서는 &lt;strong&gt;[자신의 도커 허브 아이디] / [원하는 파일명]&lt;/strong&gt;의 형식으로 이름을 작성해주어야 합니다. 이는 사람들의 도커파일 이름이 중복 되지 않기 위함이니 꼭 주의 해주세요.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image2.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그러면 다음과 같이 이미지가 생성 된 것을 볼 수 있습니다. 이를 Run 하여서 컨테이너로 만들어 동작시켜주기만 하면, 제가 만든 웹서버를 제가 기록한 환경 설정 그대로에서 동작 시킬 수 있는 것이죠. 그럼 해당 이미지를 Run 해보도록 하겠습니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image3.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;마찬가지로 실행할 컨테이너의 이름을 설정해주는 창이 뜨는데, 아까는 이름만 정해주고 넘어갔지만, 이번에는 포트를 설정 해주어야 합니다.&lt;/p&gt;

&lt;p&gt;ContainerPort를 보시면 8080/tcp라고 써있는걸 볼 수 있습니다. &lt;strong&gt;이것이 바로 아까 EXPOSE 명령어를 통해서 사용할 컨테이너의 포트를 8080으로 설정해준 결과입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;그렇다면 &lt;strong&gt;Local Host&lt;/strong&gt;에 해당하는 포트는 무엇일까요? 바로 내가 지금 사용하는 컴퓨터의 포트 겠죠. 계속 설명했듯이, &lt;strong&gt;컨테이너를 실행시킨다는건 컴퓨터 안에서 또다른 컴퓨터를 돌리는 것과 비슷한 일입니다.&lt;/strong&gt; 그렇다면 컨테이너에게도 컴퓨터가 가진 65535개의 포트가 있을 것 입니다. 만약 이 컴퓨터에 접속 하고 싶은 사람이 있다면, 어떤 포트로 연결 해야 할까요??&lt;/p&gt;

&lt;p&gt;이전 게시물에서 사용했던 그림을 가져오겠습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image4.jpeg&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;해당 작업실들에 문이 있다고 해봅시다. 실제로는 작업실에는 각각 작업실마다 65535개의 문이 있지만 편의상 간소화 하여 그리도록 하겠습니다. &lt;strong&gt;만약 손님이 밖에 있는 집에 용무가 있어 온게 아니라, 안에 있는 작업실에 방문했다면, 우리는 어떻게 이 손님을 안에있는 작업실로 안내해줄 수 있을까요?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;간단합니다. 통로를 이어놓으면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image5.jpeg&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위와 같이 8080 문에는 첫번째 작업실의 8080문을, 8082문에는 두번째 작업실의 8080문을 연결해주면 밖의 손님이 &lt;strong&gt;안에있는 작업실의 주소를 모르더라도, 그냥 큰집의 문 번호만 알려주면 알아서 원하는 작업실로 출입할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;첫번째 작업실로 오라고 하고싶으면 8080번을 알려주면 되고, 두번째 작업실로 오라고 하고싶으면 8082 문을 열고 들어오라고 하면 되겠죠. 지금 우리가 설정해주는 것이 바로 &lt;strong&gt;바깥 포트를 안쪽 포트에 연결하여 밖에서 들어온 요청을 해당 컴퓨터로 이어주는 작업입니다.&lt;/strong&gt; 이를 &lt;strong&gt;‘포트포워딩’&lt;/strong&gt;이라 합니다.&lt;/p&gt;

&lt;p&gt;그럼 우리는 8080포트를 컨테이너의 8080포트와 연결 해주도록 할 것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image6.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;컨테이너 이름을 Server로 해주고, 8080포트를 Local Host 포트에 입력해주면, &lt;strong&gt;밖의 컴퓨터의 8080포트로 들어오는 것은 곧, 컨테이너의 8080 포트로 들어가는 것 입니다.&lt;/strong&gt;  둘은 연결되어 있으니까요.&lt;/p&gt;

&lt;p&gt;그럼 우리의 localhost:8080 포트로 접속 하면, 제가 만든 서버로 접속 할 수 있을 것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image7.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;예상대로 안에 컨테이너에서 실행한 서버에 정상적으로 접속 할 수 있는것을 확인할 수 있습니다.&lt;/p&gt;

&lt;h2 id=&quot;aws에-도커를-사용해서-서버-실행하기&quot;&gt;AWS에 도커를 사용해서 서버 실행하기&lt;/h2&gt;
&lt;p&gt;그럼 이제 이 서버를 AWS에도 동일하게 구성해볼까요?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;도커에 다루는 게시물이니 자세한 AWS까지는 설명하지 않겠습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image8.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;AWS의 제 인스턴스로 접속한 상태에서, 우선 도커를 먼저 설치해 주겠습니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;sudo yum install docker
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;그럼 AWS의 인스턴스에도 도커가 설치가 완료됩니다. AWS는 리눅스 기반이기 때문에 여기서는 도커 데스크탑과 같은 GUI를 사용할 수 없기 때문에 터미널로 docker 명령어를 사용해 주어야 합니다.&lt;/p&gt;

&lt;p&gt;그럼 이제 우리가 아까 만들었던 이미지를 불러와야합니다. 아까 만든 이미지를 도커허브에 업로드하면, 우리는 &lt;strong&gt;pull 명령어 만으로 해당 이미지를 AWS 인스턴스에 설치할 수 있을 것입니다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;방법은 아주 간단합니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image9.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
해당 이미지의 메뉴에서 push to hub를 눌러주면 끝입니다. 이름까지 이미 허브 업로드 양식에 맞추어 바꾸어 놓았으니 누르기만 하면,&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image10.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;br /&gt;
위와 같이 업로드가 완료됩니다.&lt;/p&gt;

&lt;p&gt;물론 터미널을 사용해도 되지만, GUI에서 하는게 훨씬 간편할 것입니다.&lt;/p&gt;

&lt;p&gt;그럼 다시 AWS로 돌아와서,&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;sudo docker pull lmj938/jamong-server
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;명령어를 해주면 아까 우리가 업로드 한 이미지를 다운 받습니다.&lt;/p&gt;

&lt;p&gt;혹시 여기서  아래와 같은 오류가 뜬다면&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Error response from daemon: pull access denied for lmj938/jamong-sever, repository does not exist or may require &apos;docker login&apos;: denied: requested access to the resource is denied 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;아래의 명령어를 사용해서 로그인 후 다시 진행 해주세요.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;sudo docker login 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image11.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;sudo docker images
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음 명령으로 이미지가 잘 다운로드 되었는지 확인 할 수 있습니다.&lt;br /&gt;
&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image12.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;그럼 컨테이너를 실행하려면 어떻게 해야 할까요? 아까는 GUI로 run 버튼을 누르고 나온 창에 포트를 설정 해주었지만, 터미널 환경에서는 다음과 같이 포트를 설정해 주어야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;sudo docker run -d -p 8080:8080 --name Server lmj938/jamong-server
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;docker container run [옵션] 이미지명[:태그명][인수]&lt;/strong&gt; 로 사용하면 되는데, &lt;br /&gt;
명령어 옵션은 구글링을 통해 찾아보면 여러가지 옵션을 찾아 보실 수 있습니다. 여기서는 가장 많이 다루는 세가지만 다루겠습니다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;-d   &lt;br /&gt;
&lt;strong&gt;컨테이너의 로그가 뜨지 않고 백그라운드에서 작동됩니다.&lt;/strong&gt; -d 옵션을 사용하지 않고 run하게 되면 바로 컨테이너안에 있는 로그가 나오게 됩니다. 다음 명령을 치기 위해서 저는 -d 옵션을 사용해주겠습니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-p   &lt;br /&gt;
아까 포트를 설정하던 부분입니다. &lt;strong&gt;로컬호스트 포트:컨테이너포트&lt;/strong&gt;를 입력해주면 됩니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;–name   &lt;br /&gt;
컨테이너의 이름을 정하는 옵션입니다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;이렇게 컨테이너를 작동시키고 8080 포트로 가면 접속이 완료될것 입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image14.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;m1-맥북에서-빌드하기&quot;&gt;M1 맥북에서 빌드하기&lt;/h2&gt;
&lt;p&gt;하지만 M1 프로세서를 사용하시는 분들은 AWS에서 컨테이너를 run하면 다음과 같은 오류가 뜨면서 아마 작동이 안될 것입니다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tech/ETC/2022-03-22-[Docker]스프링부트에/image13.PNG&quot; alt=&quot;image1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;이것은 M1은 arm 아키텍쳐를 사용하고 있기 때문에, 이 상태에서 &lt;strong&gt;그냥 build 하게 되면 arm용 이미지로 빌드를 하게 되기 때문입니다.&lt;/strong&gt; 따라서 빌드할때 &lt;strong&gt;amd64 버젼&lt;/strong&gt;을 따로 build한뒤 이를 push해서, AWS에서 pull 해주어야 합니다.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;sudo docker pull --platform=linux/amd64 lmj938/jamong-server 
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;다음과 같이 platform을 linux/amd64로 설정해주신 이미지를 푸쉬하고, AWS에서 내려받으면, AWS에서도 정상적으로 해당 이미지를 인식할 수 있습니다.&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="ETC" /><summary type="html">서론 이전 게시물 : [Docker] 도커란 무엇일까?</summary></entry><entry><title type="html">아두이노 라즈베리파이</title><link href="http://localhost:4000/diary-univ/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/" rel="alternate" type="text/html" title="아두이노 라즈베리파이" /><published>2022-03-21T00:00:00+00:00</published><updated>2022-03-21T00:00:00+00:00</updated><id>http://localhost:4000/diary-univ/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8%20%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4</id><content type="html" xml:base="http://localhost:4000/diary-univ/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/">&lt;h2 id=&quot;20220321&quot;&gt;2022.03.21&lt;/h2&gt;
&lt;p&gt;올해 듣는 수업이 대부분 프로젝트 수업이라서 사실 수업보다는 그냥 실험하고, 프로젝트 하나 완료하는것들이 전공수업의 전부가 되었다.&lt;/p&gt;

&lt;p&gt;전공 공부가 너무 하기싫어서 복학하기가 진짜 너무너무 싫었는데, 막상 복학하니까 이론은 3학년때가 끝이고 4학년때는 실무위주라서 조금 다행인것 같다.      &lt;br /&gt;
심지어 막상 프로젝트를 할라고 하면 회로 짜는것 보다는 코딩하는게 주가 되는 것 같아서 내가 좀 힘을 쓸 수 있는 부분이 대부분이라서 오히려 좋다고 할까??&lt;/p&gt;

&lt;p&gt;이번에 듣는 전자응용설계에서는 실제로 전자제품을 하나 설계해보고 직접 만들어내는 프로젝트가 수업의 전부인데, 아두이노나 라즈베리 파이를 사용해서 만든다.    &lt;br /&gt;
얘네 둘은 이름만 들어보고 대략 어떤건지만 알았지 이거에 대한 지식이 아예 없는 수준이라 프로젝트를 진행함에 앞서 내가 어떤 수준까지 제작이 가능한지 알아보기 위해 요 몇일 요 두개를 열심히 알아봤는데, 생각보다 너무 재밌어보이는 분야라서 나중에 지원금이 나옴에도 불구하고 그냥 사비로 두개를 모두 구매했다.&lt;/p&gt;

&lt;p&gt;전자공학이라는 내 전공이 맘에 안들었던 이유는 너무 이론적으로만 다루기도 하고, 반도체 공정이 주 수업 내용이라 내가 원래 생각했던 전자제품을 제작하는 학과의 이미지가 아니라서 실망했던건데, 4학년이 되서야 뭘 만들게 되어서 좀 재밌는 4학년이 될것 같다는 생각이 들었다. 그런데 나는 그냥 다른 분야로 가기 위해서 따로 공부를 했다지만, 다른 학생들은 전자공학 3년간의 지식으로 전자제품을 제작을 할 수가 있나? 싶은 생각이 들기는 한다. 만약 내가 3년간 배운 지식만을 사용한다고 제한하고 프로젝트를 한다고 생각하면, 아두이노로 간단한 센서 측정 기계정도 만들 수 있을 것 같다.&lt;/p&gt;

&lt;p&gt;어쨌든 아직 라즈베리파이는 아직 도착하지 않아서 못 만져봤고, 아두이노는 어제 당근마켓에 있길래 15000원에 가성비 좋은 키트를 구매했다. 근데 지금 반도체 수급이 정말 극악인 상태라 라즈베리파이 가격이 돌아버려서 사는데 좀 애를 먹었다. 신품은 구할 수도 없을 뿐더러 원래 5만원 하던 제품이 지금은 15만원 이상을 줘야 살 수 있으며, 이조차도 중고 매물도 잘 없다. 그래서 도저히 5만원 하는 제품을 10만원 넘게 구매하는건 못하겠어서, 알아보던중 라즈베리파이 400 제품을 구매하는게 더 가성비가 좋을 것같아서 라즈베리파이 400을 65000원에 구매했다. 근데 이것도 웃긴게 원래 라즈베리파이 400은 라즈베리파이 4와 키보드가 합본되어있고 안에 방열설계도 훨씬 월등하게 좋은 제품이라 원래 10만원 가까이 하는 제품인데 라즈베리파이4 가격 폭등으로 인해서 라즈베리파이 4가 라즈베리파이 400보다 비싼 가격이 되었다;&lt;/p&gt;

&lt;p&gt;물론 라즈베리 파이 400의 단점이라면 키보드 합본이라서 범용성이 조금 떨어진다는 점이 있긴하다. 센서를 직접 보드에 달지 못하고 usb형태로 꽂아줘야 한다. 근데 지금 생각해놓은건 라즈베리파이에 아두이노를 연결해서 복잡한 연결이랑 api통신은 라즈베리파이에서 하고 센서처리는 아두이노에서 할 예정이라서 크게 상관 없을 듯하다. 아두이노를 어제 구매해서 살짝 뚝딱거려봤는데, 아무래도 아두이노 요거 하나 갖고는 대학생 수준의 전자제품을 설계하는 것에는 성능에 큰 무리가 있지않을까… 싶다. 아직 프로젝트 주제는 정해지지 않았지만, 지금 내가 할 수 있는 최대의 기능을 생각해보면 웹서버를 하나 만들거나 블루투스 모듈을 제품에 연결해서 플러터로 만든 앱이랑 제품이 통신하게 하고, 아두이노의 센서값으로 뭘 처리해서 동작하게 해서 이걸 앱에서 표시하고 조작할 수 있게 하는 정도일 것 같다. 이렇게 하면 이번 프로젝트는 무난하게 A+ 받을 수 있지 않을까 생각한다. 그래도 이정도 수준이면 이 수업 듣는 사람들 중에 내가 제일 잘만들 수 있을지도?&lt;/p&gt;

&lt;p&gt;원래는 이런 IOT 제품에 대해 아무런 생각이 없었는데, 이번에 해보면서 나도 생각보다 쉽게 내가 생각해낸 걸 제품화 할 수 있다는 걸 알게되서 새로운 걸 배워볼 생각에 조금 설렌다. 미리 좀 관심 가져볼걸 뭔가 전자공학에 대한 반감때문에 의도적으로 전자관련 이야기면 좀 기피 한것도 있는 것 같기도 하고; 어쨌든 내 기술을 제품화 하는것에 공부하다보면 또 새로운 아이디어들이 생각나지 않을까 싶다.&lt;/p&gt;

&lt;p&gt;결국 내가 떠올리는 아이디어들은 내가 실현할수 있고, 알고있는 지식의 한계치내에서 나오는건데, 이 한계치가 좀 눈에 띄게 늘어나는 기회가 되지 않을까 싶다.&lt;/p&gt;</content><author><name>이민재</name><email>lmj938@naver.com</email></author><category term="diary-univ" /><category term="일기장" /><summary type="html">2022.03.21 올해 듣는 수업이 대부분 프로젝트 수업이라서 사실 수업보다는 그냥 실험하고, 프로젝트 하나 완료하는것들이 전공수업의 전부가 되었다.</summary></entry></feed>