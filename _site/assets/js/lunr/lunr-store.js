var store = [{
        "title": "일기를 쓴다는 다짐",
        "excerpt":"2021.03.28  오늘부터 일기를 쓰기로했다.  요즘 월가아재라는 분이 고등학교때부터 20년가까이 쓴일기 블로그를 읽고있는데, 인생에대한 여러가지 고찰과 그때 그 때의 감정들을 짧게 모아놓은 것을 보니 마치 한편의 문학작품을 읽는 듯하여 큰 감동을 받았다. 마치 몇년 전 본 영화 보 이후드를 봤을때의 그런느낌. 그건 영화로 각색한 내용이기라도 했지, 이 일기는 정말 한사람의 실제적인 인생의 하루하루 의 발자취를 따라가는 느낌이라 마치 그 사람의 인생을 고등학교때부터 옆에서 지켜보는 느낌이 들었다.  그래서 사실 모두의 인생은 기록되지 않아서 그렇지, 기록한다면 한명 한명의 인생이 한편의 영화이고 문학작품이라는 생 각에 나도 일기를 쓰려한다. 그저 지나가는 인생의 순간들을 영화로 만들수는 없는 노릇이니, 나의 글로나마 이 블로그에 잡아두려는 생각?  원래는 인스타에다 쓸까 생각했지만, 호들갑 같기도 하고, 또 인스타그램이라는 플랫폼 자체가 글을 쓰기에는 적합하지가 않다 보니까… 어차피 누가 보리라 생각하지도 않고, 내가 볼거니까 사실 어디에 써도 상관없지만 그래도 어느정도의 책임 감을 갖기위해 공개적인 장소였으면 했다. 얼마나 오래갈지 모르겠지만, 나름의 루틴으로 만들어놓으면 꾸준히하지않을 까??  10년뒤, 누군가가 나의 블로그를 정주행하게 될때 이 첫 일기를 보면 무슨생각을 할까… 일기에 담은 나의 인생이 블로그를 보러온 누군가에게 인사이트가 되었으면 한다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%BC%EA%B8%B0%EB%A5%BC-%EC%93%B4%EB%8B%A4%EB%8A%94-%EB%8B%A4%EC%A7%90/",
        "teaser": null
      },{
        "title": "운동",
        "excerpt":"2021.03.29  아침에 일어나서 운동 후 피부과를 다녀왔다.  요즘따라 운동은 참 가성비가 떨어지는 행위중에 하나라는 생각이 든다.  한창 운동을 시작했을때는  나름 즐겁게 시작해서 우울하고 나약했던 내 스무살에 활력이 되어주기도 하여 고마운 마음에 어느덧 집에 벤치프레스까지 사다가  갖다놓을 정도로 재미를 붙인 취미였지만,  이제는 도통 몸이 슬슬  변하지 않는다.  물론 최근에는 변할정도로  열심히 하지도 않았거니와 식단을 제대로 한것도  아니지만, 그래도 이정도로 맨날 한시간씩 꾸준히  해주는데 성과가 안나오는건 좀 아니지싶다.  식단을하고 운동강도를 늘리자니 도저히  가성비가 안맞다는 생각도 들고…  몸만드는건 뒤지게 어려운데 그 리턴이 너무  작은것 같다.  겨우 얻을수있는거라곤 옷입으면 티도 잘안나는  몸이라니. 물론 빡세게 해서  옷밖으로 나오게 만들면 되지않느냐고 하지만,  그럼 더 큰 노력을 부어주어야하고,  사실 그건 나같은 나약이에겐 버거운 수준이다.  물론 몸을 열심히 멋지게 만드는 사람들이  가성비가 나오지도 않는 일을 한다고  폄하하는게 아니다.  사람마다 추구하는 가치는 다르고 누군가는 그  보상이 충분하다고 생각하기에 그렇게 열심히  운동을 하는것이니까. 오히려 그 고난의 길을  매일 걷는 그 사람들이 존경스럽다.  식욕을 끊어내고 그 무거운 바벨을 드는게  얼마나 고통스러운지는 깔짝 운동해본 나도 잘 아니까…  게다가 운동이 가진 긍정적인 힘을 나도  경험해봤기에 아주 잘안다. 사실 운동의 진정한  순기능이 아닐까? 몸이 아주 조금이라도 변하고 중량이 조금이라도 느는곳에서 아주 큰 긍정적 에너지와 자신감. 나도 물 론 크게 경험해봤고, 느껴봤지만…!!! 그래도 힘들고 하기 싫은걸 어떡해…  요즘따라 몸이 성치가 않다.  피부과에 가서 오늘도 약을 4개나 처방받아왔는데, 환절기가 되면 비염과 알러지 두피염 등등… 온갖 피부질환이 찾아온다.  원래는 이정도는 아니었는데 꼴에 나이를 먹는다고 나이가 들수록 심해지는것 같다.  갑자기 진짜 저런 어거지 단어가 없다라고 생각했던  반오십이라는 단어가 새삼 떠오른다.  이제는 진짜 건강관리를 해야할까…?  알러지로 벗겨진 눈꺼풀과 빨간 두피염을 보며, 그래도 운동을 더 열심히 해야겠다는 다짐이 든다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "비트코인",
        "excerpt":"2021.03.30  오랫동안 갖고있었던 코인이 어제 20프로가까이 올랐다.  그래서 원래 갖고있던 다른 코인종목을 처분하고 추격매수를 했는데 8프로대로 마감 후 오늘이 되니 약하락 상태이다. 어제는 돈을 잔뜩벌어 신났는데 다시 원상태로 돌아온 허무함.  오히려 다른 종목에서의 손실을 포함하면 잃었다.  주식과 비트코인등 각종 금융투자를 하면서, 인간의 욕심이 얼마나 지독한지 깨닫는다. 거기다 인간의 이성이란건 아주 흐릿해서 조금만 요동쳐도 이성이 마비되버리는데, 내가 얼마나 나약한 존재인지 깨닫게 된다. 욕심 때문에 팔아야할때 팔지못하고, 두려움 때문에 사야할때 사지못한다. 결국 인간의 감정이 0퍼센트로 관여되지 않는 기계만이 수익을 얻을수 있는것일까.  하지만 몇몇 주식시장에서 큰 수익을 내는 사람들을 보면  그들은 오히려 인간의 그 알수없는 뭔가의 느낌에 기대서 매매를 하기도 한다.  사실 인간의 알수없는 느낌으로 매매를 해서 돈을 번다는것이 이해가 가지않는다.  증권가 은어로 ‘메사끼’가 있다고 하는데 내가 생각하기엔  확률이 만들어내는 아주 운이좋은 확률의 수혜자가 아닐까 싶다.  가위바위보를 백번연속 이길 확률에 대하여 생각해볼 떄  불가능한 확률이라고 생각하겠지만, 101명이서 토너먼트로 가위바위보를 진행한다면  100번을 연속으로 우승하는 1등은 반드시 탄생하게 된다.  금융시장도 결국 버느냐 잃느냐의 50퍼센트의 확률의 반복이 일어나는 경우의 수로 본다면,  생각보다 연속으로 백번정도 이길확률은 물론 아주 적지만, 대한민국 총인구로 미루어보았을때,  그리 작은 확률은 아니다. 게다가 주식이나 비트코인의 상승이 크거나, 시드머니가 큰 경우는 백번 이길필요도 없기 때문 에, 확률 상 운이 좋게 돈을 버는 사람들은 꽤 많이 나올수 있다는 생각이다.  물론 버느냐 잃느냐가 장전체가 상승장이냐 하락장이냐에 따라 50퍼센트는 당연히 아니겠지만,  확률상으로 우연이 만들어준 주식고수가 탄생하기 쉽다는말이다.  사실 이런 생각이 무슨 생각이 있을까.  내가 돈을 벌지도 못하는데 그저 남의 성공이 운에 기대서 이루어졌다는 생각은 그냥 열등감일 뿐.   다시 욕심을 끊어내고  차가운 이성을 머리에 챙기고  그 머리가 멍해지는 차트를 보러 다시간다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/",
        "teaser": null
      },{
        "title": "메타디움",
        "excerpt":"2021.04.01  여러분 메타디움 사세요  메타디움 사면 돈을 그냥 준다니까?? 돈이 복사가 된다고!   문득 그런생각을 했다. 인간이 경제적 자유를  누리려면 얼마의 돈이 통장에 있어야할까?  뭐 굳이 경제적 자유라는게 진짜 원하는거  명품이고 뭐고 다 사는거 말고, 그냥 돈얼마있나  통장 안보고 먹고싶은거 남 사주는것도 아니고 그냥 내거는 다 사먹을 수 있는정도… 나이가 먹으면 모르겠지만 지금은  2천만원 정도 있으면 그냥  통장안보고 살 수 있지 않을까??  20대에는 행복의 허들이 굉장히 낮다는 생각이 든다 20대때 가지고있는 중형차, 아니 준준형 차는 30대의 외제차보다 효용가치가 높다는 말이있다.  하지만 인간의 욕심이 끝이없고 벌어도 벌어도 얼마만 더 있으면 좋겠다 생각이 들겠지…  오히려 지금의 천만원이 십년뒤의 1억보다 행복할 수도 있겠다는 생각을 했다. 요즘 데이트를 언제할지 정할때마다 통장 을 먼저보고 데이트할돈걱정을 하는내 모습이 좀 그래서 그냥 한번 생각해봤다.  오늘 메타디움이 많이 올라서  40만원을 넘게 벌었다.  맛있는거 사먹어야지.  예진이도 내일 맛있는것 좀 사줘야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%A9%94%ED%83%80%EB%94%94%EC%9B%80/",
        "teaser": null
      },{
        "title": "꽁돈",
        "excerpt":"2021.04.02  여자친구를 기다리며 공부를 하려고 일찍왔다.  나름 꾸준히 매일 일기를 쓰고 있는데  이거 블로그에다 내 사생활을 얼마만큼 여기다 써도되는지가 고민이다. 원래 남들한테 다 숨기면서까지 안보여주는게 일 기장인데 이걸 블로그에다 쓰자니 참 솔직하게 쓰기가 그렇기도 하면서 어차피 아무도 안볼텐데 뭘 걱정하지? 이런생각도 들고, 뭐 사실  사생활이랄게 나한테 있나 싶다  어제 돈을 꽤 벌어서 통장에 여유가 생겼다.  돈번 기념으로 친구를 데려다 대광어를 사줬는데,  투자로 번돈 꽁돈이라고 생각하고 막쓰다가는  빈털터리 되기 쉽상인걸 알면서도 솔직히 저번에  내가 추천한 종목 물렸던걸로 맘고생 한것도 있고해서 그냥 시원하게 사줬다. 내 아까운 4만원… 참 4만원 짜리 물건 살때 는 오만가지 생각을 다하면서 먹을걸 살때는 아무런 감정이 없으니, 인간의 식욕이 물건의 소유욕보다 상위에 있는것은 확 실한듯 하다.  아침에 아빠한테 전화가 와서 잔소리를 한참 들었다.  어제 코인으로 돈을 벌어서 돈을 너가 너무 쉽게 생각하는거 같다. 일해서 벌어봐야 돈의 소중함을 안다. 이런 이야기들. 난 전혀 돈을 쉽게 생각하지않는다. 세상사 어려운거 천지지만 돈만큼 어려운게 없다. 자본주의 사회에서 돈이가지는 위상 이 어느정도 인지 뼈저리게 알고, 쉽게 벌었다고도 생각안한다. 가기다가 벌때는 쓰러질듯이 벌기 힘들면서도, 써버릴때는 얼마나 쉬운가?? 막상 돈 쓸때는 그렇게 행복하지도 않다.  트레이더들이 괜히 각종 스트레스성 질병을 달고사는게 아니라는걸 요즘 절실히 느낀다. 차트위에 그려진 파란색만큼 끔 찍한게 있을까? 아무것도 사지않았는데 내 돈이 사라지는 느낌. 게다가 버는 행복은 잃을때의 불행에 비하면 체감상 십분 의 일정도도 안되는것 같다. 따라서 나의 모든 감정을 가져가고 남는건 그동안의 불행의 십분의 일정도되는 행복과 돈. 그 돈을 위해 감정적 스트레스를 등가교환함 셈이다. 이렇게 계속하여 이 스트레스의 수치를 감소시켜놓아야 한다. 아직도 투 자의 금액이 조금만 커져도 차트를 보는 시간이 늘어나고, 정신적 스트레스가 커진다. 이러한 스트레스와 계속 부딪히면서 무뎌져야 한다. 그러한 하락을 버틴자만이 수익을 낼 수있다.  오늘도 차트를 안보겠다는 다짐을 하며 어플을 지운다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%BD%81%EB%8F%88/",
        "teaser": null
      },{
        "title": "비, 그리고 단장과 봉사",
        "excerpt":"2021.04.03  비가 내린다.  3주째 연속 주말마다 비가온다.  저저번주 봉사갈때도 왔고 저번주에 봉사갈때도 왔고 이번주도 온다.  비가 내릴때 밖에 있으면 그것만큼 짜증나는 일이 없지만,  또 집에 누워서 빗소리를 듣고있자면 또 나름의 정취에 창문을 열고 그 소리를 가만히 듣고 있게된다.  오늘은 봉사 안가길 잘했다. ᄒᄒ  뭐 잠깐 설명하자면,  이번학기부터 작년 2학기에 들어갔던 봉사동아리의 단장을 맡게되었다.  2학년때 학교 중앙동아리 회장이후로 다시는 이런 동아리같이 득도 없고 힘들기만한 단체의 장은 맡지 않기로 결심했지만, 이 감투라는게 또 중독성이 있는건지 어쩌다 보니 2학기때 세번나간 동아리의 단장이 되어버렸다. 솔직히 중앙동아리 회장때 욕도 오질나게 먹고 힘든일도 많았어서 걱정했는데,  이번 동아리 회장은 솔직히 할만하고 재미도 있다.  동아리가 다른건지, 내가 그만큼 이 작은 단체의 회장은 담을만한 그릇이 된건지는 모르겠지만  새로운 사람들도 많이 만나고 또 좋은 인맥들도 많이 쌓는 것 같아서 나름 만족하고 있는 상태다.  사실 2학년때 회장시절을 돌이켜보면, 욕먹을만도 했다.  그때는 어떻게 행동해야하는지도 잘몰랐고 솔직히 맨날 놀기만 해서 일처리도 대충대충 했던것 같다.  동아리가 또 여초였어서 나름의 힘든점도 있기도 했고, 선배들도 좀 옛날 사고방식을 가진 사람이 많기도 했지만 그래도 그때 내가 그러한 위치를 담을만한 그릇이 아니었다는건 지금이되서야 깨닫는다.  난 항상 지금 내가 가장 이성적이고 어른스럽다 생각하지만, 돌아보면 항상 그때의 나는 어리석었고 비이성적이다. 혼자서 나름의 성찰을 하는것으로 위안삼아야할까. 그렇기엔 또 지금 이 정도면 다 큰것 같단말이지…  그래서 이번엔 나름 사람들 관리하는 스킬도 늘었고 낯도 많이 두꺼워져서 단장활동에 아주 만족하고있다.  그리고 원래 같으면 휴학하고 그냥 집 공부 여자친구 집 공부 여자친구 반복이었을텐데,  단장 활동으로 또 나름 서류처리할 것도 많고 만남도 잦아서 삶에 활기가 도는 느낌이다.  어제는 얼굴도 모르는 동아리 선배님이 밤에전화하셔서, 얼굴 한번 보고싶다고  오는 택시비 가는 택시비 다줄테니까 지금 올 수있냐고 하셨다.  또 막상 찍어보니 왕복 택시비면 10만원이 넘는 거리라서  그 분도 부담스러우실 것 같아 정중하게 담에 뵙자고 했지만, 너무 감동받았다.  세상에 어떤사람이 얼굴도 모르는 사람에게 한번 보고싶다고  오는 택시비, 가는 택시비 줘가며 와달라고 하겠는가. 너무 그 마음이 고마워서  다음에 부르시면 진짜 만사 제치고 가겠노라고 약속드렸다.  단장이라는 이유로 이렇게 누가 챙겨줄때마다 그 마음씨가 고맙고 이 단체에서 오는 소속감에서  뭔지 모를 따뜻함이 느껴진다. 나도 다음에 돈 많이 벌어서 후배 회장에게 저렇게 하겠다는 다짐도 하게되고… 저번주에 봉사가서 삽질을 오지게 하고오긴 했지만, 또 하루만 지나도 추억이니까…  그래도 매주 비도오고 추웠는데 2주 동안 꼬박꼬박 다 참여한것으로  단장의 책임감은 다한걸로 치고, 하루만 쉬어보겠다.  사실 뭐 아무도 내가 안간다고 뭐라안하겠지만, 이왕 하는거 책임감 있는 사람으로 남고싶다.  요즘따라 휴학하길 잘했다는 생각이 든다.  사실 이대로 졸업했으면 진짜 방향성없는 이상한 사람이 될뻔했는데,  1년정도 나라는 사람이 어떤사람인지, 내가 뭘하고싶은지, 나의 인생의 목표는 무엇인지 여유롭게 생각을 할 수 있게되어 너무 행복하다.  그저 생각뿐 아니라 지식면으로도 더 성장할 수 있는 1년 휴학이 되기를 바라며 비가 내리는 주말에 스터디 카페에서 몇자 끄적여본다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B9%84,-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%8B%A8%EC%9E%A5%EA%B3%BC-%EB%B4%89%EC%82%AC/",
        "teaser": null
      },{
        "title": "낭만이 있던 시절",
        "excerpt":"2021.04.04  일요일은 뭔가 늘어진다. 아니 사실 토요일도…  휴학하고 사실상 날백수 상태라 주말이란 개념이 없는 수준인데도, 요상하게 주말만 되면 늘어진다. 평소같으면 아침에 일어나서 운동부터 하고 아침이면 스터디카페에 왔을텐데  여섯시반에 깨버리더니, 자고 일어나니까 여덟시반, 밥 먹는다고 뒹굴거리다가 열두시가 되서야 집밖을 겨우겨우 기어나왔다. 어제 맥주를 먹어서 그런가 몸이 굼뜬 느낌이다.  어제는 오랜만에 보민이가 청라에 와서 맥주를 한잔 마셨다.  원래는 맨날같이 질리도록 보고 연락하던 동네친구들이 이제 나이를 먹었다고 여간 바쁜게 아니다. 자취하는 놈들은 얼굴 한번보기가 몇달에 한번이고, 이사간 놈은 진짜 반년에 한번이다.  그것도 내가 날잡고 정왕을 가야 볼 수 있으니, 이 얼마나 삭막한 일인가.  물론 코로나도 한몫한다. 코로나가 집에 있게 만들어 놓으니까 그게 적응되서 그런가  다들 밖에 나오려고들을 하지않는다. 이렇게 코로나로 마스크를 쓴지도 어느덧 1년  나만 적응이 안된건지, 나는 아직도 이 생활이 너무나 불편하다.  그런 소재의 영화들이 있다. 엄청난 질병이 창궐하여, 모두가 고립되고 군대가 길거리를 통제하며, 시민들은 마스크를 쓰고 다니고 사회 시스템은 마비, 경제는 대공황… 모조리 혼돈의 카오스… 물론 영화처럼 그런 혼돈의 카오스는 일어나지않았다지만,  이런일이 내 인생에 직접 들이닥칠 줄이야. 한치 앞도 모르는게 세상일이라지만,  무슨놈의 병이 영화마냥 창궐해서 맨날 마스크를 쓰고 다녀야하고, 모든 축제와 행사는 사라졌으며 모든 식당은 10시면 닫아 버리는 이러한 사태를 내가 겪고 있다니, 얼탱이가 없다.  어제도 맥주를 먹다 10시가 되서 밖을 나와 한참을 방황하다가 엑슬루 1층에서 그냥 앉아서 마저남은 이야기를 나눴다. 그마저도 11시에 쫓겨나, 재밌는 이야기 시작도 못하고 집에 와버렸다.  개같은 코로나.  코로나가 뺏어간것들은 수도 없이 많지만,  내가 가장 짜증나는건 내 인생에 낭만이란것들을 뺏어갔다는 거다. 밤늦게 친구들과 맥주를 마시거나, 문득 혼자 영화관에가서 영화를 보고 여자친구 손을 잡고 봄꽃길을 걷는 그런것들 말이다.   코로나가 생기기전의 삶을 생각해보면, 참 낭만적이고 행복했다는 생각이 든다. 활기를 띄는 대학교, 봄꽃을 보러온 사람들, 북적북적한 번화가…  사람은 이렇게 꼭 뭔가를 뺏겨야 그 시절이 행복했다고 깨닫는다.  인생은 저때가 좋았지… 저때가 행복했지…하며  그 순간엔 그게 행복인지도 모른채 그 순간을 떠나보내는것의 반복인것 같다.  코로나가 없어지고 저 행복을 다시 돌려받게되도 한달, 아니 일주일이면 또 익숙해져서 다시 저 행복을 막 대하게 되겠지…  그래도 진짜 한번만 다시 돌려줘라 내 행복…소중하게 대해줄게 제발.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%82%AD%EB%A7%8C%EC%9D%B4-%EC%9E%88%EB%8D%98-%EC%8B%9C%EC%A0%88/",
        "teaser": null
      },{
        "title": "영어",
        "excerpt":"2021.04.05  4월의 첫 월요일이 왔다. 2021년의 4분의 1이 지나버렸다는 뜻.  1년이 참 긴것 같으면서 짧다. 작년도 사실 너무나 빨리 지나가버렸는데, 이게 코로나 때문에 더 심한 것 같다. 오늘은 아침에 일어나서 운동을 하고 와서 아침에 뉴욕타임즈 모닝 브리핑을 한번 쓱 읽고 스터디카페로 왔다. 근데 뉴스읽고 빠릿빠릿하게 왔어야 했는데 또 잠깐쉰다는게 한시간 내리 쉬어버리고 여기왔다.  왜이렇게 인간은 나약한것인가… 또 이렇게 후회할거면서 말이야  오늘부터 영어공부를 같이 시작했다.  사실 영어에 대해 크게 고민하고 있지 않았고, 내심 불안하기는 해도 나중에 몰아서 해버리면 된다는  안일한 생각때문에 영어 공부를 열심히 한적이 없다. 이렇게 피일차일 미루다 나중에 고생한다는거 알면서도 지금은 영어보다 다른 공부가 중요하다는 생각에 미뤄왔었다.  근데 공부를 해보면 할수록 영어가 얼마나 중요한지 절실히 깨닫는다.  특히나 데이터사이언스의 대부분의 정보는 영어로 되어있고, 어떠한 학문이던지 최신논문에서  트렌드를 읽어내려면 영어 독해 능력은 필수다. 심지어 변화가 빠르고 트렌드가 자주 바뀌는 이러한 업계들은. 상시 새로 쏟아져 나오는 논문들어 읽어내야 한다.  새로운 지식들과 새로운 시야를 가지려면, 새로운 언어를 익히는만큼 쉬운방법도 없다는걸 알면서  나는 왜 맨날 이 공부를 미뤄왔을까…  어릴때 집안 기둥을 뽑아서라도 외국에 살다왔어야 했다는 생각이 들었다.  어차피 그때 갔다와봤자 영어실력은 안늘고 놀다오기만 했을것 같기도하고…  그래서 어제 영어공부에 대해 고민을 저녁내내 했다.  토익을 하자니 내가 원하는 공부방향이 아니었다. 난 지금 토익 점수도 중요하지만 이번 휴학기간동안 영어 그 자체의 언어에 대한 실력을 키우고 싶었다. 실제 쓰는 회화나 표현들을 습득해야 하는데 토익은 좀 내가 원하는 방향성과 안맞을 뿐더러, 지금 그만큼의 시간을 투자할 여유가 없다.  드라마 같은거나 영화는 좀… 공부하는건지 안하는건지 모르겠다는 생각.  그래서 그냥 어제 뉴욕타임즈를 구독해버렸다.  하루에 무조건 아침에 한시간내지 두시간은 뉴욕타임즈를 독해하기로 했다.  원래는 경제지식도 좀 얻고, 나름의 어려운 용어들이 섞여있는 이코노미스트를 구독하려 했는데  너무 비싸다. 언제 쯤 되어야 저정도 돈은 자기계발을 위해 쓸수 있게되는걸까.  어쨌든 시사지식도 얻을 수 있고 영어공부도 되니 일석이조라는 생각에 구독했는데,  이게 생각만큼 안읽힌다. 그래도 어느정도 의미파악은 될줄 알았는데 전혀 읽히지가 않는다. 어느정도 친숙하고 내용을 알고있는 기사같은 경우는 문장의 모호한 부분이 예측이 되지만, 오늘 읽은 요르단 왕자 구금에 대한 기사는 배경지식이 전혀 없으니,  인물 관계가 복잡한게 이해가 도통 안되서 기사 하나를 삼십분을 넘게 해석했다.  너무 안읽혀 짜증나 죽는줄 알았지만, 뭐 나름 공부하는 기분 안들고 재밌게 읽고왔다.  이러한 공부의 가장 중요한점은 매일매일 꾸준히 하는게 거의 80퍼센트니, 하루도 안빠지고 할수 있도록 루틴으로 만들어서 자연스럽게 무조건 읽는다고 생각해야겠다.  올해의 목표는 영어로 된 온라인 강의를 완벽하게는 아니더라도  검색해보면서 들으면 들을 수 있을 정도로 영어실력을 키우는것이 1차 목표, 내년까지 꾸준히 해서 내후년에는 미국에 있는 학교의 온라인 석사 학위를 따보는게 일단 현재 시작한 영어공부의 최종목표다.  단기적으로는 무작위성이 작용하여 어떻게 될지 모르지만,  장기적으로 우상향하는 추세는 확실하게 보이게 된다. 머나면 목표일지라도 추세를 만들도록 꾸준히 노력하자.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%98%81%EC%96%B4/",
        "teaser": null
      },{
        "title": "연아퀸",
        "excerpt":"2021.04.06  아침에 오지게 뒹굴다 두시가 다되어서야 여기왔다.  뉴욕타임즈는 읽었지만 그걸 감안해도 너무 나태했다.  이따 저녁에 회의겸 술자리도 있어서 오늘 공부시간이 더 적을텐데 왜 더 뒹굴게 되는것일까…   사람들이 흔하게 저지르는 실수중에 매몰비용의 오류가 있다.  어떠한 일이 잘못되어가고 있음을 알고있는데, 그동안 투자한 비용과 시간이 아까워 쉽게 포기하지 못하는 경우들. 근데 그 반대라고 해야하나? 이것도 무슨 오류가 있는지는 모르겠지만 사람 심리가 그런게 있는것 같다.  예를들어 오늘같은 경우이다. 어차피 놀건데 오늘 그냥 하루 통으로 놀아버릴까?  하는 생각이 들어 더 시간을 낭비하게 된것 같다.  인간의 생존본능중에 어떠한 점과 직결되길래, 이런 유혹은 이렇게나 달콤한걸까…  돈을 쓸때도 마찬가지이다. 이왕 쓰는거 아끼면 좋은데, 조금만 금액이 커져도 에이 그냥 쓰는김에 쓰지 뭐~ 하면서 불필요한 지출을 해버리는건 늘상 있는일이다.  그리고 트레이딩을 할때는 또 얼마나 멍청한가? 천천히 분할 매수하고 분할 매도 하면 되는것을,  눈앞의 호가창의 흔들림을 보다보면 내 차가웠던 이성은 덩달아 흔들려 마치 내가 지금사지않으면  이 차트가 날아가버릴것 같은 망상에 빠져들고는 한다.  결국 한번에 급하게 풀매수.  사람들은 왜이렇게 똑똑한 머리를 갖고도 멍청한 짓을 반복하며 사는걸까…  이성이란게 너무나도 약하다고 느껴질때마다,  우리도 결국 본능에 충실해 사는 동물의 유전자의 노예라는 생각이 든다.  인생이란건 결국 유전자의 새겨진 짐승의 본능과 감정들을 끊어내고, 본능을 쫓는 짐승이 아닌 인간이라고 증명해내는 과정인것 같다.   김연아가 했던말이 문득 떠오른다.  ‘무슨 생각을 하면서 스트레칭하세요??’ ‘무슨 생각을 해… 그냥 하는거지…’  저래야 성공하나보다…  그냥 생각하고 재지말고 그냥 하자.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%97%B0%EC%95%84%ED%80%B8/",
        "teaser": null
      },{
        "title": "안주",
        "excerpt":"2021.04.07  오늘은 데이트라 공부를 안한다.  내일도 안한다. 그래도 셤기간이라 봉사를 안가도  되니까, 주말이 여유로워 그때 보충할 생각이다.  어제 슬슬 하던 공부가 재밌어지는걸 느꼈다.  이제 코딩 기본적인걸 다 떼서 어느정도의 데이터  가공이 가능해지니까 시간가는줄 모르고 어제 코딩을 했다. 역시 기초통계학 먼저 하기보다 프로젝트를 하나 잡고 실제적 인 결과를 내면서 이론을 병행하고자 했던 방향성이 더 나에게 맞았던것 같다.  이론으로 기초를 탄탄히 하고 시작하면 물론 그 나름의 장점이 있겠지만, 내 성격에는 동기부여도 안될뿐더러, 어디다 써 야하는지 방향성을 모르고 이론만 줄창하게 되어서 싫었다. 아직 갈길이 천리만리이지만, 남들과 경쟁하는것도 아니고 나 의 실력을 천천히 쌓는과정이라고 생각하며 하루하루 꾸준히 하는것. 그게 목표다. 한걸음씩 눈앞만 보면서 걷다보면, 뒤 를 돌아봤을때는 꽤 많은 걸음을 내딛은  이후일테니까.   내일은 유튜브 촬영을 하기로했다. 무려 조원희 선수랑 염기훈 선수랑 축구를 한다. 말이 안된다.  어떻게 이런기회가! 이래서 인맥이 중요하고 친구를 잘둬야 하나보다. 보민이가 슛포러브 여행 다녀온걸 보고 너무 부럽 고 신기했는데, 그 콩고물이라도 좀 받아먹는것 같아서 다행이다. 어제 보민이가 물어보자마자 진짜 뒤도안돌아보고 수락 했다. 살다보면 공부보다도 이러한 소중한 경험을 할 기회가 더 중요하다는 생각이 든다. 내가 살면서 저런 대단한 사람과 축구를 하고 유튜브에 나올일이 뭐가 있는가!!  벌써 너무 기대가 된다. 심지어 돈도 준다니…   이렇게 돈내고도 할 수 없는 경험을 돈받고 한다니 내일이 너무나 기대된다. 한편으로는 근데 우리같은 쩌리 다섯명이 진 짜 필요한건지 의문이다. 막상 가면 우리같은 애들 한 30명있는거 아닌지 모르겠다…   그래도 30명중에 한명이면 어떠냐.  앞으로 50년간 술자리 안주가 필요없지 싶다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%95%88%EC%A3%BC/",
        "teaser": null
      },{
        "title": "이거해조 원희형",
        "excerpt":"2021.04.09  한시가 넘어서야 비몽사몽 일어났다.  일곱시에 깼지만, 애매하게 공부하러 일어나야하는데… 더 자고싶은데… 라는 두개의 생각이 겹쳐서  제대로 잠도 못자고 공부도 못하고 운동도 못하고 죽도밥도 안됐다. 이럴거면 그냥 편하게 잠이나 잘걸.  가끔 그냥 포기해버리고 쉬어버리는 선택이 종종필요한걸까 아니면 이거마저 극복하고 책상에 앉아야 하는걸까… 아니 근데 내 체력이 줄어든건지, 오랜만에 뛰면 원래 그런건지 사실 어제 촬영가서 뛴건 30분도  안 뛴것 같은데 어제부터 해서 오늘 아침까지 진짜 죽는줄 알았다.   요즘 유산소를 안하긴 했지만 이정도로 내 몸이 약해졌을 줄이야. 아침에 유산소까지 포함해야 되나 싶다.  어제 촬영은 굉장히 재밌었다. 그런 프로축구선수가 축구하는 모습을 하는것도 신기했고  우리가 그 선수 돌파를 막아볼일이 뭐가 있겠는가. 끝나고 사진도 오지게 찍었다.   조원희 선수, 염기훈 선수 둘다 진짜 멋있고 완전 젠틀했다. 촬영 내내 자신들이 제일 힘들텐데  우리한테 힘들겠다고 걱정해주고, 분위기도 계속 띄우시려고 노력하시는 모습이 역시 프로답다는 생각이 들었다. 촬영도 한시간 연장되고, 날씨도 더웠으며, 컨텐츠 자체도 엄청 어려운 미션을 될때까지 계속 하는거라 굉장히 짜증도 나고 화도 좀 낼법한데, 진짜 끝날때까지 불평 하나도 없이 스태프들이랑 분위기 띄워가면서 진짜 될때까지 계속했다. 특히 세션부분이 진짜 한시간넘게 걸렸는데, 그 체력이 존경스러웠다. 한 스무번은 넘게 시도했는데 아마 일반인이었으면 열번도 못하고 쓰러졌을거다. 근데 더 놀라운건 그렇게 체력을 소모하고도  혼자서 우리 다섯명을 달고 다니며 날아다니셨다. 사실 1대5 자체는 우리가 너무나 유리해서  처음에는 우리가 우세했는데, 우리가 간과했던건 프로와의 체력차이였다.  초반에야 당연히 5명이니 한명이 뚫기가 어려워 실패했지만, 시도가 계속 될수록 프로선수와의 체력격차가 났다. 전력질주 몇번에 우리는 체력이 동나버렸고, 마지막 갈때쯤에는 진짜 쫓아갈 수가 없었다.  솔직히 처음에는 생각보다 쉽게 막아서 역시 프로도 다구리앞에 장사 없다 싶었지만, 일반인과 비교할 수 없는 체력이 정말 놀라웠다…   그리고 추가로 유튜브 진짜 쉽지않다는 생각이 들었다.  일단 텐션이 미쳐버렸다. 편집된 영상으로 볼때야 음악도 있고 편집도 속도감이 있어서 그냥 별생각 없이 보지만, 라이브는 굉장히 조용하고 스태프들도 많아서 그렇게 자연스럽게 하기 굉장히 민망한 분위기이다.  근데 진짜 녹화 시작하자마자 미쳐버리는 텐션의 조원희 선수를 보고 역시 프로는… 다르구나..  라는 생각이 들었다. 방송이 쉬운일이 아니구나 싶었다.  어쨌든 대기시간도 길었고 햇빛도 쨍해서 끝나고 완전히 녹초가 되었지만, 진짜 재밌는 경험이었고 앞으로 평생 못잊을 경험을 한것 같아 너무 좋았다.   추가로 유튜브는 담주 화요일날 올라올 예정이라고한다.  이틀이나 공부를 쉬었으니, 오늘부터 다시 또 열심히 해야지…  나도 누군가가 나와 함께했던 순간이 인생에 특별한 경험이 되는 사람이 되고싶다는 생각이 들었다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%B4%EA%B1%B0%ED%95%B4%EC%A1%B0-%EC%9B%90%ED%9D%AC%ED%98%95/",
        "teaser": null
      },{
        "title": "천만원",
        "excerpt":"2021.04.12  우스갯소리로 맨날 아빠한테 했던 소리가 있다.  ‘나 천만원만 줘요~~ 진짜 투자좀 시드있게 해보게~’  ‘천만원 아들 주고 맘대로 해보라고 해보는게 진짜 인생경험이라니까???’ 그럴때마다 우리 아빠는 넌 돈의 무게를 너무 가볍게안다. 직접 벌어봐야 한다. 이렇게 말씀하시고는 했다.  이상하게 나는 천만원에 대한 동경이 있었다. 이 블로그에 한번 쓴적도 있듯이 뭔가 지금 나이에는 천만원이 있으면 모든게 해결될 것 같은 그런 기분, 마치 최저시급 만원마냥 근거도 없고 논리도 없지만 왠지 그 쯤은 있어야하지않나~ 했던 생각들. 마치 천만원이 있으면 나의 경제적인 자유가 확보될듯한 꿈같은 이야기… 주식이나 비트코인 할때도 항상 입버릇 처럼 천만원은 벌어야지~ 를 달고 살았다.   근데 갑자기 덜컥 천만원이 생겨버렸다.  아빠는 어릴때부터 그랬다.   내가 뭘 말하면 그에대해 잔소리를 겁나게 하시고는,  이내 나를 믿고 항상 그대로 하게 해주셨다.  컴퓨터 사달라 했을때도 그랬고, 핸드폰 사달라 할때도 그랬고, 휴학한다고 했을때도 그랬고, 집팔리게 청소 빡세게 하면 백만원 준다고 했을때도 집팔렸는데 바로 안주고 잔소리 겁나게 하고 줬다. 맨날 어차피 줄거면서 왜 이렇게 잔소리를 하고 주는지 싶었는데,  천만원도 줄줄이야…   오랜만에 아빠의 눈물을 봤다.  살면서 아빠가 우시는 모습을 본게 손에 꼽는다.  나만이 아니라 모든 아들들이 아빠의 눈물을 볼 일은 흔치 않을테지만,  내가 기억하기로는 태어나서 두번째 눈물이다.  첫번째는 4년전 집앞 꼬치집에서 나한테 이혼을 말하시며 미안하다고 하셨을 때인데, 난 아직도 그때 그 꼬치집에서의 순간이 마음 한켠에 남아 아리게 남아있다.   아빠는 내가 어릴때부터 투자에 관심이 많으셨다.  주식부터 부동산까지 모든 투자를 항상 해오셨고, 부동산은 관련학과로 새로 공부하여 대학교까지 졸업하셨다.  항상 공무원의 대출의 유리한점을 이용해 부동산을 구매해오셨고, 주식도 꾸준히 매매하며 재산을 불렸다.  돈에 대해서 항상 잔소리하시고, 아끼고 사셔서 누가보면 구두쇠라 하는 사람도 있을 수 있겠지만  나한테는 돈을 아끼신 적이 없었다. 용돈은 항상 또래 이상의 수준이었고, 난 태어나서 내가 원한걸  못가져본적이 한번도 없다. 악기를 한달마다 때려쳐도 새로운 악기를 원하면 항상 사다주셨고, 배우고 싶은게 있으면 항상 다 시켜주셨다. 성인이 되서도 올림픽 보고 삘받아서 유도 배우고 싶다니까 유도도 시켜줬다.   가족들 하고싶은건 다 해주시고는, 자기쓸돈은 아껴서 악착같이 투자하셨다.  그렇게 모으고 레버리지를 땡겨서 투자한 돈은 경제상승의 기류를 타고 흐르고 흘러 점점 몸집이 불어났고,  중간에 이혼으로 인해 주춤하기도 했지만, 불어난 돈은 아파트를 두채나 구매하게 만들었고  마침내 얼마 전, 크게 오른 아파트를 처분하고 레버리지를 전부 청산했다.  (물론 정부의 정책으로 인해 반강제로 처분하긴 했지만.) 아파트가 팔리고,모든 빚이 없어진 날,  아빠는 내가 해준 안주와 소주 한병으로 그 날을 자축하셨다. 25년 가까이 하신 투자가 결실을 맺은 순간이었다.   어제는 할아버지가 백신을 맞으셔서 경과도 지켜보고, 이사온 집도 구경할 겸  새로 이사온집에 오셔서 주무시고 가셨다. 오랜만에 3부자가 아라뱃길 나들이를 좀하고, 점심을 어죽을 먹었다. 저녁엔 회와 소고기를 먹으며 아빠와 할아버지는 소주한잔을 하시며, 오랫동안 이야기를 나누셨다.  그리고 다음날, 할아버지는 아빠에게 천만원짜리 수표를 주셨다. 새차 사는데 보태라시면서…  아빠는 그 천만원을 보고 생각이 많아지셨는지 눈물을 보이셨고, 난 태어나서 두번째로 아빠의 눈물을 봤다.  아빠는 그 돈을 새차에 보태지 않으셨다.   내가 농담처럼 하던 말을 맘에 담아두셨던걸까. 그 수표를 나에게 건네셨다.  너가 쓰고싶은데 쓰라고, 너의 미래를 위해서 쓰라고, 그렇게 천만원이 덜컥 생겨버렸다.  막상 천만원이 생기니 경제적 자유같은건 하나도 생각이 안난다.  이 돈을 어떻게 불려야 할까. 어떻게 내 미래를 위해 사용해야할까.   난 태어나서 통장에 200위로는 모아본적이 없는데, 이렇게 덜컥 큰돈이 생겨도 될까.  사람은 돈을 담을 수 있는 그릇의 크기가 정해져있어서, 그 그릇이 커지지 않으면  아무리 큰돈이 들어와도 그 그릇이상은 탕진하게 된다고, 그래서 로또 당첨자들의 대부분은 그 그릇에 넘치는 돈을 탕진하게 된다는, 그런 이야기가 생각났다. 내 그릇은 과연 천만원을 담을만한 그릇일까?   그릇이 작으면 어거지라도 키워서 담아야지. 이게 어떤돈인데. 이 돈은 세상에서 제일 값지게 쓸거다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%B2%9C%EB%A7%8C%EC%9B%90/",
        "teaser": null
      },{
        "title": "완벽한 하루",
        "excerpt":"2021.04.13  오늘은 첫번째 기념일이다.  바람이 조금씩 불어오는 바람과 쏟아지는 햇살, 귀에는 내가 가장 좋아하는 노래들,  기분이 너무나 행복해진다.   통장엔 천만원, 자리를 잡기 시작한 내 공부, 목표가 확고해져 하루하루가 낭비없는 삶.  요즘따라 진짜 모든일이 잘풀리고 행복하다! 행복의 체감은 불행에 비하면 아주 작고, 아주 한순간이며, 삶의 대부분의 순간은 불행을 견뎌내는 것의 반복이라는걸 알기에   행복의 순간을 이렇게 글로적어서 남겨둔다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%99%84%EB%B2%BD%ED%95%9C-%ED%95%98%EB%A3%A8/",
        "teaser": null
      },{
        "title": "본능의 노예",
        "excerpt":"2021.04.15  요 몇일 너무 공부가 안된다…  갑자기 큰 돈이 생기는 바람에 머릿속에 온통 돈생각 뿐이다. 돈, 돈, 돈…   문득 그런생각이 들었다. 내 공부에 대한 미래효용가치는 얼마일까?  내가 하루에 얼마를 벌면, 그날은 공부를 안한게 더 이득인 하루인걸까??  과거의 인간은 시시때때로 찾아오는 아사의 위험이나, 거처를 당장 마련하지 않으면 얼어죽을수도 있는, 당장 눈앞에 닥친 위기를 해결하지 않으면 죽음에 이를 수 있는 상황속에서 살았다.  따라서 인간의 지금까지의 역사의 대부분은, 미래에 닥칠 위기나 이득을 계산하고 행동하는것보다는 눈앞의 위기와 이득을 계산하고 행동하는것이 생존확률을 더 높일 수 있었을것이다.  이렇게 유전자에 각인된 행동방식은 지금까지로 이어져, 인간은 멀리있는 이득과 손해보다는 당장 눈앞에 있는  이득과 손해에 집중하도록 진화하였다. 인간은 머리나 이성적으로는 당장의 절제가 미래에 훨씬 도움이 된다는것을 인식하고 있으면서도, 뇌가 주는 강렬한 자극들은 눈앞에 있는 작은 이득을 위해  멀리있는 큰 이득들을 포기해버리도록 만든다.   사람은 항상 눈앞의 편안함… 눈앞의 이득, 눈앞에 있는 달콤함을 얻기위해 자신의 미래를 끌어다 쓰곤 한다.  나도 항상 그렇다. 나중에 혹독한 다이어트로 고생할 것을 알면서, 눈앞의 맛있는 고칼로리의 음식을 먹어치우고,  나중에 땅을 치고 후회 할것을 알면서 당장 누워서 핸드폰을보고 뒹굴거린다.  삶은 어쩌면 인간에 유전자의 새겨진 본능들과 싸워 이겨내는 순간의 연속일지 모르겠다.  그래서 나는 이러한 인간행동학? 적인 요소에 관한 사실이 담긴 글들이나 영상을 보는 것을 무척이나 좋아한다. 나의 본능이 왜 그러한지를 깨달으면, 그래도 어느정도 나의 본능임을 인정하고 그것을 억지로 억누르려기보다는 우회하여 최대한 그러한 본능이 작동해버리지 않도록 나를 격리 할 수 있기 때문이다.   오늘 아침에 투자에 대한 그릇된 본능에서 나를 격리 하는 방법에 대한 글을 아주 흥미롭게 읽었다.  투자를 RPG게임처럼 하지말고, 오토배틀러 장르처럼 해야한다는 내용이었다. 무슨 말이냐면,  RPG게임처럼 장이 열린시간에 내가 하나하나직접 조종해서 투자를 하면 인간의 뇌에서 오는 뇌동매매의 본능을 끊어내는 것이 불가능한 상황에 나를 놓아두는 것이니, 내가 정비와 세팅을 해주고 게임이 시작되면 알아서 싸우는 오토배 틀러 장르처럼 투자하라는 것이다. 한마디로 장전에 세팅하고 매수한뒤, 오토배틀러 장르의 게임처럼  전투가 다 끝나고 결과를 확인하라는 뜻이다. 그리고 그 결과를 바탕으로 또 다음 전투를 정비하고, 세팅하면 된다.  이 글을 읽고 정말 반성을 많이했다. 인간의 본능은 아주 소수의 사람들만이 끊어낼수 있는 것이며, 그 사람들도 한순간의 본능에 잠식당해 나가 떨어지는 경우가 수두룩하다.   내가 그걸 건방지게 끊어낼 수 있다고 생각하고 행동하다가는,  인간의 유전자에 뿌리박힌 본능에게 된통 당할 수 밖에 없는것이다.  몇천년간 쌓여온 나의 본능을 나는 절대로 이길 수 없다는 생각을 갖고, 절대 정면승부 해서는 안된다.  아예 본능이 활동할 수 있는 상황에서 나를 격리시켜버리자.   지금부터 진짜 빡세게 공부한다. 진짜!!!! 구라아니고.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B3%B8%EB%8A%A5%EC%9D%98-%EB%85%B8%EC%98%88/",
        "teaser": null
      },{
        "title": "욕심",
        "excerpt":"2021.04.16  어제 도지코인에 넣고잔 640만원이 천만원이 되었다. 360만원을 벌은셈이다.  이러고 또 결국 본능을 이기지 못하고 단타를 치다 마지막에 50정도를 날려서 310만원의 수익을 올렸다.  50프로 가까이되는 어마어마한 수익, 총시드로 봐도 20퍼센트가 넘는 수익률을 하루에 올린것이다.  번돈으로 그동안 액정도 깨지고 배터리도 다되어서 너무 불편했던 핸드폰을 바꿨다.  내가 아이폰 프로모델 라인을 사게되는 날이 올줄이야!   그동안 대학교갈때 아빠가 사준 아이폰 6s를 4년간 쓰고, 폰굳이 좋은거 써야하나 싶어서 중고로 사서 1년좀 넘게 아이폰 X를 썼었다. 다시는 새폰 안사겠다는 생각을 했었는데, 또 돈이 생기기도 했고, 막상 중고 써보니까  배터리 효율이 너무 닳아서 뭐만하면 배터리가 다되는 바람에, 불편해서 도저히 못쓰겠더라.  태어나서 한번도 내돈으로 새 핸드폰을 사본적도 없고 해서,  아이폰12pro 그래파이트 하나를 사고, 돈도 벌었겠다 토끼같은 여자친구 뭐라도 사주고 싶은 마음에  요즘 어디가면 시끄러워서 공부가 잘안된다고 하던게 맘에 걸려서,  여자친구집으로 에어팟프로를 하나 배송시켜놨다.  물론 서프라이즈라 말은 아직안했다. ᄒᄒ  에어팟프로 케이스도 하나 사주려고 은근슬쩍 지금쓰는 에어팟  케이스 사준다고 거짓말하고 케이스고르라고 계속 했는데,  내가 에어팟프로 사주려는 것도 모르고 고르기 귀찮다고 짜증냈을다! 내일 너 에어팟 받으면 보자 진짜.   어제만 해도 한 50만원 아니 40만원이라도 벌었으면 좋겠다고 생각하고 잠들었는데, 진짜 이 인간의 욕심이  답이없다. 사실 매매자체를 욕심안부리고 잘한것 같은데, 자꾸 그대로 뒀으면 600을 벌었느니 하는 생각이  머리에 가득찬다. 310을 벌고도 마치 290만원을 잃은 사람마냥 기분이 그렇다.  310만원. 얼마나 큰돈인가. 300만원은 나의 용돈 40만원을 기준으로 8개월 가량을 한푼도 안쓰고 모아야하는 돈이며, 대부분의 30대 중반 직장인의 월급 실수령액정도되는 큰 돈이다. 이 어마어마한 돈을  벌고도 지금 불평과 아쉬움의 마음이 있다니.  얼마나 욕심이 가득하고 지독한 생각인지 모르겠다.  심지어 난 평생 300만원이 넘는돈을 통장에 가져본적이 없다.  그만큼 커다란 돈을 벌었으면, 말도안되는 상황 가정하면서  상상속의 돈을 잃었다고 하지말고, 제발 좀 감사하고 즐거워 할줄알아라.   돌이켜보면 이번매매는 사실 운좋게 맞아떨어져 큰 돈을 벌었지만, 반성해야한다.  시드머니의 절반가까이를 한 종목에 때려박았으며, 심지어 그 종목은 왜 오르는지도 알 수가 없는 그런 종목이었다. 일론머스크의 언급? 그건 인정이긴하다만, 한종목에 그 돈을 넣고 어제 잠을 잔 나도 정말 강심장이긴하다.  이제 코인은 어느정도 비중을 줄이고, 주식을 할생각이다. 좀 금액이 커지면 옵션 공부를 좀해서 풋옵션이나 콜옵션 매수 를 해보려한다. 콜옵션 같은걸 매수하면 아무래도 손절못치는 내 본능을 억지로 가둘수있지 않을까 하는 생각에, 자금이 더 커지면 옵션에 대해서도 생각을 좀 해봐야겠다.   돈이 없으면 불행하지만, 돈을 벌어도 크게 행복하진 않은가보다.  사실 지금 내가 가진 돈과 오늘 번돈은 학생기준으로 볼때 정말 어른들에게는 1,2억의 가치를 가진돈인데도, 지금 크게 행복하다거나 기분이 좋다는 생각이 들지는 않는다.  오히려 날씨좋은날 바람이 살살부는 거리를 여자친구랑 걷는다던가, 비가오는날 침대에 누워서 빗소리를 듣는것, 혹은 좋아하는 영화가 개봉해 영화관 특유의 냄새를 맡으며 영화가 시작하기전의 광고를 보는것.  이런것들이 훨씬 행복하고 좋다.   막상 내일이 되면, 도착한 최신핸드폰과 사랑하는 여자친구가 좋아하는 모습을 보고 또 다시 열렬한 자본주의의 노예가 되겠지만.   그것이 돈자체가 주는 행복따위의 보잘것 없는 것이 아니라,  내가 내돈으로 핸드폰을 처음 샀다는 성취감, 그리고 선물을 받은 여자친구의 행복한 미소에서 오는 고결한 행복임을 아는 사람이 되었으면 좋겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%95%EC%8B%AC/",
        "teaser": null
      },{
        "title": "도박",
        "excerpt":"2021.04.18  어제 하루종일 두통으로 인해 머리가 지끈 지끈 아프고  밥을 먹어도 소화가 안됐다. 감기기운이라고 둘러댔지만, 이유를 알고있었다.  그놈의 코인때문에 이틀동안 밥먹으면서도, 운동하면서도, 공부를 하면서도 차트를 켜놓고 있었기 때문이다.  사람이 극심한 스트레스로 머리가 아프다는 걸 이틀간 태어나서 처음 겪었다.  진입하자마자 물리면, 하루종일을 후회로 보내며 ‘아 왜 내가 거기서 들어갔지’, ‘진짜 한번만 오르면 본전에 팔고 다시는 코인 안한다.’의 반복… 심지어 다시 올랐을때는 다시 그득한 욕심이 기어 올라와 팔지도 않고,  결국 또 손실로 이어진다. 이렇게 어제 하루에만 150가량을 날렸다.  그동안 벌기만 했지, 이정도의 금액을 잠깐 사이에 잃어본적은 없다.  난 얼마전만 해도 하루하루가 요즘 너무 행복하다고 생각했는데, 이틀동안 이렇게 불행할수가 없었다.   머리가 아프기도 하고, 더 차트를 보고있다가는 정신병에 걸릴것 같아서  그냥 그대로 잠들기도 하고 유튜브를 보기도 하고 했다. 그 중에 슈카님의 유튜브 채널을 봤는데,  갑자기 정신이 차려졌다. 물론 비트코인에 관한 이야기가 아닌 20대 30대에 관한 이야기들이었지만  그 중에서 요즘 20대 30대가 단기에 큰수익을 올릴수 있는 코인시장에 다들 미쳐있다는 이야기.  단기간의 큰 변동성을 가진 투자는 절대 행복할 수가 없다고 했다.  나는 뭘 위해서 투자를 하는지 생각했다. 물론 돈을 벌기 위해 하는거지만, 나는 돈을 왜버는가??  돈벌어서 나의 여유로움으로 행복하고 싶어서 나는 돈을 벌고싶다.   그 관점에서 볼때, 비트코인 투자는 뭔가 잘못되었다.  돈을 벌어도 벌어도 만족스럽지도 않고, 성취감도 하나도 없다. 이건 나의 실력과 지혜로 얻어낸것이라는 생각이 전혀 안든다. 내가 이 코인을 왜 선택했으며, 왜 이 가격에 샀는지, 어떤 가격에 팔건지에 대한 아무런 기준이없다. 홀짝 도박을 할때, 홀을 고른 사람에게 왜 홀을 골랐는지에 대해 물어본다면 이렇게 말할 것이다.   ‘그냥 느낌이 좋았다’   나도 마찬가지다. 그냥 느낌이 좋았고, 뭔가 오를것 같아서 샀다. 이걸 과연 투자라고 볼 수 있을까?  옛날에 영상같은걸 틀면 앞에 광고로 나오던 그래프게임 도박이 생각났다.  비트코인과 그 불법도박이 과연 다른점이 있을까.  호재들은 모두 기술력일뿐 코인의 가격과는 직결되는 부분이 없으며,   결제수단으로 이용할수 있는건 비트코인 하나외에는 하나도 없다.  실체가 전혀 없고, 이 코인을 만든 회사나 사람이 무엇을 하는지, 정말 그걸 하긴 하는지에 대한 아무런 증거도 찾을 수 가 없다.   그래서 난 오늘부터 비트코인을 접기로 했다.  운이 좋아서 그래도 돈을 벌은 상태로 정신을 차렸다는 사실에 감사한다.  운이 나빴다면 50프로의 수익이 아니라, 50프로의 손실 후 정신을 차릴 수도 있었다. 이것은 정말 엄청난 행운이었기에, 정말 다행이라는 생각이 들었다.  하지만 가장 중요한것은 나를 믿지 않는것이다.   내 본능은 또 차트를 볼것이며, 또 그 유혹에 무조건적으로 흔들릴 것이고, 나는 또 비트코인을 매수하게 될 것이다. 그 전에 미리 나를 그러한 본능의 상황에 놓이지 않게 해야한다. 내일이 되면 케이뱅크 계좌는 바로 해지할것이고, 업비트는 탈퇴할것이다. 저 비트코인이 올라 10억이 된다해도, 그렇게 벌어들인 돈은 도박판에서 딴 돈과 같다. 도박으로 딴돈은 결국 반복되는 도박의 반복끝네 잃어야 그 악의고리가 끊긴다.  아니, 어쩌면 평생 안끊길수도 있다. 도박으로 돈을 딴 후에 정신을 차렸음에 감사한다.  그렇게 어제 모든 돈을 출금하고 앱을 삭제해버렸다. 그리고 오늘, 비트코인은 폭락했다.  운이 참 좋았다고 생각했다. 하루만 더 갖고있었더라면, 지금쯤 얼마나 괴로운 하루가 또 되었을지  상상도 하기 싫다.   코인으로 번돈으로 맥북을 한대 더 구입했다.  이로써 코인으로 번돈은 모두 사용했다. 쉽게 번돈이라 쉽게 써지는걸까.  다시 처음부터 오늘 천만원을 받았다는 생각으로 정상적인 방법으로 투자하겠다. 잃더라도 얻는게 있고, 배우는게 있겠지.  내일이 기대된다. 이번에는 꼭 행복과 돈, 두마리 토끼를 다 잡고싶다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%8F%84%EB%B0%95/",
        "teaser": null
      },{
        "title": "주식",
        "excerpt":"2021.04.19  오늘부터 주식을 좀 열심히 해볼 생각이다.  다시 공부하려니까 너무 어렵다. 그래도 공부해서 투자할수 있다는게 얼마나 큰 행운인지.  코인 도박판에서 정신 차렸으니, 열심히 다시 해서 수익률을 크게 올려볼 생각이다.  영어에 데이터 공부에 투자 공부까지… 내가 세가지를 다 잡을 수 있을까.  지금 보다 더욱 더 치열하게 살고, 부지런해져야 한다는 생각에 벌써 머리가 아프다.  요즘따라 하루가 이렇게 짧았나 싶다. 물론 이런생각 하면서도 누워서 핸드폰하고, 뒹굴고 하는시간 없애는건 왜이렇게 힘든지 모르겠다. 시간표를 아예 짜서 그대로 행동해야겠다.  그냥 재량껏 하려고 하니까 이런일이 벌어지는것 같기도 하고.   옛날에 봤던 무슨 실험프로그램에서 남편한테 일시키는 법  이런식으로 해서 나온적이 있었다. 뭐 해달라고 그냥 추상적으로 말하지말고 몇시까지 이거를 어떻게 해줘~~ 하면서 말을 하면 들어준다는 그런 실험. 놀랍게도 그냥 추상적으로 말했을때는 뒹굴거리던 남편이  시간과 행동을 정확하게 정해주자, 그 시간전에 그 일을 끝냈다.  실제로 남자들은 계약이라는 개념에 민감하게 반응하기 때문에,  시간적 제약이나 어떠한 조건에 대한 제약을 걸면  지키려는 경향이 강하다고 한다.   그래서 나도 오늘부터 나에대한 시간적 제약을 좀 걸생각이다. 내일은 오늘보다 열심히 살기를 바라면서…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%A3%BC%EC%8B%9D/",
        "teaser": null
      },{
        "title": "코딩",
        "excerpt":"2021.04.23  최근에 다시 주식을 시작하면서,  주식에 관한 데이터를 뽑아내는 프로그래밍을 하고있다.  근데 이게 도통 어떤 데이터가 연관성이 있는지 감이 잘안잡힌다.  일단 뉴스기사와 각종 지수를 크롤링해서 엑셀로 저장하는 프로그램까지는 코딩을 했는데,  더 무엇을 해야할지 잘 감이 안잡힌다. 공부가 부족해서일까…  아무튼 주식뿐만이 아니라 왠만한 단순 반복작업들을 모두 코딩으로 자동화 해보려 한다.   앞으로 한 10년만 지나도 코딩이 특별한 기술이 아니라, 현재의 엑셀처럼 누구나 보편적으로 사용하는  기술이 될거라는 생각이 들었다. 개인의 업무를 자동화 할수 있다는 건 엄청난 메리트이니까 누구나 이 이점을 알게되면 너도 나도 코딩으로 자신의 프로그램을 만들어 단순업무들을 자동화 시키는 날이 조만간 올것 같다.  오르비의 라끄리 대표의 글을 오랜만에 오르비에 찾아가서 읽었다.   이 사람이 쓴 글을 볼때마다 많은 인사이트를 받는다. 이 정도로 똑똑한 사람이 사적으로 쓴 글을 접해볼 기회가  잘없어서 그럴까? 읽을때마다 새로운 생각이 나도 덩달아 들고, 문장 한구절 한구절마다 감탄하게 된다.  머리도 똑똑한데, 어떻게든 자신의 시간을 철저히 사용하려고 폴더 하나하나 책상정리 하나하나 한번에 찾을 수 있게끔 분 류와 정리를 완벽히 해놓는다는 이야기를 보고는 정말 많은 생각이 들었다. 저 사람 보다 머리도 안좋은 내가 저렇게 노력 하지 않아서야 무슨일을 이룰 수 있겠냐는 생각을 했다. 삶에 저정도로 나는 치열한적이 있었나.  괜시리 나도 컴퓨터의 폴더를 정리해보았다.   저렇게 이악물고 시간을 아끼려는 사람 앞에서,  나는 지나가는 시간의 흐름을 그저 놓아 보내주고 있는건 아닌지 많은 생각이 들었다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%BD%94%EB%94%A9/",
        "teaser": null
      },{
        "title": "공부...",
        "excerpt":"2021.04.29  어느정도 재미를 붙이고 하던 공부가 난관에 봉착했다.  머리가 너무 아프다. 도대체 뭐 부터 해야하는지도 모르겠고 난이도는 너무 높다.  재밌는건 딱 내가 이해할수 있을때까지였고 그 위로는 재미가 하나도 없다…  하긴, 공부가 재밌을리가 없지. 사실 난이도도 난이도지만 어느 방향으로 공부해야하는지 감이 안잡혀서 어렵고 힘들고, 머리아프다. coursera 강의를 따라가려 하니 자막이없고 유튜브 강의들은 질이 너무 떨어진다. 이래서 영어를 배워야 하는건가…   영어를 못하니 질좋은 강의들을 수강 조차 할수가 없다. 사실상 인터넷이라는 도구의 기능을 영어를 못하면 한 30퍼센트밖에 활용을 못하는셈이 되는 것 같다. 영어…영어..!!  어쨌든 방향을 잃었을때 가장 좋은방법은 책을 사는 것 같아서  더럽게 비싼 4만원 짜리 책을 한권 구매하려고 한다.  다시 차근차근 책부터 떼고, 뭘 해볼 생각이다.   자기계발에 돈아끼면 안된다지만, 4만원이 너무 아깝다… 거지같은 도서정가제  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B3%B5%EB%B6%80/",
        "teaser": null
      },{
        "title": "임신",
        "excerpt":"2021.04.30  어제 밤에 월가아재님이 쓰신 블로그에서 잠겨있는 시황을 어떻게 하면 볼 수 있을까 구글 캐시를 뒤지다가, 월가아재님이 쓰신 임신 부터 출산까지의 경험을 적은 일기를 발견했다. 정작 시황은 하나도 못보고, 어제 저녁에 그 글을 읽었다. 아직 나이가 어려서, 주변에 임신에 대한 경험에 대해 들어본적도 없고, 내가 접한 출산이라고 해봤자 기껏해야 친 인척들의 출산소식정도? 였다. 근데 꽤나 상세하고 디테일하게 아기를 낳는다는 일의 무게와 찾아오는 수 많은 어려움, 그 리고 그 놀라운 출산의 기쁨에 대한 내용까지 담겨 있어,  글을 읽고 많은 생각을 하게 만들었다.   임신이 힘들다 힘들다 하지만, 저렇게 상세하게 적힌 경험들을 과연 내가 감내할수 있을까 하는 생각이 들었고, 모든 어머 니들이 저러한 고통, 누군가는 더 큰 고통을 감내하고 새로운 생명을 세상에 낳았다는게 놀라웠다. 나같은 뭣도아닌 사람 도 저렇게 무거운 짐을 견뎌 낼 수 있을까?   이러한 감상에 젖으면서도, 저 글은 감정과 경험 뿐만아니라 임신이 부부관계에 미치는 영향이나, 임신중에 어떠한 요소들 이 아이의 발달과 지능에 영향을 미치는지 월가아재님께서 여러 논문들과 통계를 읽고 정리해둔 자료와 함께있어서 감성 과 이성이 한데에 있어, 감정적으로 아기를 무조건 낳아야 겠다!! 라는 기분이 들기보다는, 생명을 만들기 위해서 내가 감 수해야할 손해와 얻어야 할 이득에 대해 다시금 생각해보게 만들었다. 아기를 낳는 다는건 인간이 경험 할 수 있는 중에 가 장 황홀하고 경이로운 경험이지만, 그 시기와 과정에 대해서는 아주 크나큰 준비와 고찰이 필요하다는 생각이 들었다.   많은사람들이 아기를 낳으면 부부가 더 돈독해지고 행복해질것 이라 말하지만, 통계적으로는 미국 등 10개 선진국에서 진 행된 연구에 따르면 결혼 만족도는 첫 출산 이후 15년간 지속 감소했고, 자식이 집을 떠나고 나서야 서서히 증가했다. 또, 양측에 합의 없이 한쪽의 요구만으로 진행한 임신 후 다툼을 가진 부부는 통계적으로 100퍼센트 이혼했다. 다들 단순히 감정적으로 돈독해지겠지~~ 라고 안일하게 생각하지만, 아이를 낳는 다는건 이토록 불행해질수 있는 거대한 리스크를 짊 어진 일인것이다. 그렇기에 출산은 정말 양쪽이 모두 준비가 된 상태에서, 합의하에 큰 계획을 갖고 만반의 준비하에 진행 하여야 리스크를 최대한 줄일 수 있는것이다.  또 글을 읽다보니, 나는 이 글을 읽으며 세상은 얼마나 불공평한가에 대해 생각을 했다.   출산까지의 과정은 사실상 아이의 평생을 좌우하는 큰 요인인데, 지적 수준이 낮거나 생활수준이 낮은 가정에서 태어난 아이는 이 세상에 나온 처음부터 남들보다 뒤쳐진대로 시작한다는 느낌이 들었다. 저 일기에 써있듯이 임신에는 통계적으 로 증명되지 않는 여러가지 낭설들과 속설들이 즐비하고, 임신상태에서는 정말 생각보다도 더욱 절대적인 안정이 필요한 데, 지적수준이 낮은가정에서는 오류에 대한 검증 없이 저러한 낭설과 속설들, 심각하게는 아이의 발달과 지능을 저하시키는 행위들을 행할것이고, 생활수준이 낮은 가정에서는 완전한 안정을 취하지 못할 것이다. 지적 수준이 낮은 가정은 대개 생활수준이 낮을 가능성이 높으므로, 이 두가지 요인들은 동시에 발생할 가능성이 매우 높다.   그렇게 여러가지 요인들에 의해 선천적으로 능력이 저하된 아이는 또 낮은 지적수준의 대물림을 받게 되는것이고, 이러한 일은 몇대를 걸쳐 반복될 확률이 매우 클것이다. 우리 사회는 항상 노력하면 누구나 성공 할 수 있다고, 마치 공평한 출발 선에서 시작한것 처럼 말하지만, 나의 노력여부에 관계없이, 이미 뱃속에서 부터 크나큰 격차를 갖고 다른 출발선에 서게 되는것이다.   세상은 항상 불편한 진실과 마주하기 싫어, 그러한 진실들을 회피하고 듣기 좋은 거짓말로 포장하려 한다. 그리고 누군가는 그러한 진실과 마주하지 않은 댓가를 치룬다. 그것도 몇대에 걸쳐서…   사람들은 부모욕에 굉장히 민감하다. 또 인종차별에 대한 것은 어떤가?? 지역이나 출신에 대한 욕만큼 화가나고  듣기 싫은건 없다. 키나 외모에 대한 욕도 동일하게 사회적으로 금기시 되는 것중에 하나이다. 이렇듯 사람들은  이제 앞으로 내가 바꿀수 있는 것에 대한 모욕보다는, 이미 정해져서 돌이킬 수 없는 것에 대한 모욕에 가장 민감하게 반응 한다. 하물며 사회에 태어날때부터 존재하는 이러한 격차에 언급하는것은 사람들에게 얼마나 불쾌할까. 아마 어떤 국회의 원이나 정치인이 이러한 문제점에 대해 이에 따른 복지 정책이 필요하다고 언급 한다 해도, 그는 이러한 불편한 진실을 말 한 댓가로 사회적인 매장을 당할 수 밖에 없을 것이다.   개선하고 보완해야할 문제점에 대해 인식하고 해결하지만 너무나 큰 불편함을 마주하는 사회가 치루는 비용이 더 클지, 이 러한 불편함을 그저 감성적인 부분들로 포장하고 모두가 불편하지 않은 상황에서 발생하는 불평등한 격차에서 사회가 치 루는 비용이 클지는, 나같은 바보는 모르겠다. 어쩌면 이미 전자보다는 후자가 비용이 적다고 분석한 결과에 따라서 지금 의 사회가 돌아가고 있을지도 모르고, 사실 둘다 정답이 아닐수도 있다.  모두가 평등을 원하지만, 사실은 모두가 평등해지고 싶지 않아 한다는 생각이 들었다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9E%84%EC%8B%A0/",
        "teaser": null
      },{
        "title": "블로그 챌린지, 빠니보틀",
        "excerpt":"2021.05.01  안그래도 요즘 일기쓰는게 살짝 귀찮아지기도 했고 쓰다보면 30분씩 쓰게 되서  자꾸 안쓰고 몇일에 한번 썼는데, 블로그 챌린지인가 뭐시기를 진행해서 2주동안 빠지지 않고 일기를 쓰면  네이버페이로 16000원을 준단다. 마침 일기 쓰고있는데 잘됐다 싶어서 하기로 했다. 여러 계정으로 해서 돈좀 두둑히 챙 겨야겠다. 요즘은 이렇게 조금만 시간을 들이면 돈이나 상품을 주는 여러 이벤트들이 다양한데, 이런것만 찾아서 잘 받아 챙겨도 쏠쏠하겠다는 생각이 든다. 얼마전에 친구가 아하토큰 출석만 해도 돈준다 했을때 하기만 했어도 지금 한 7-8만원 은 꽁으로 얻는건데, 그때 왜 안했을까. 세상에는 의외로 하기만 하면 돈을 주는데 귀찮아서 사람들이 안하는 것들이 꽤있 다. 정보가 부족하기도 하겠지만, 알면서도 안하는 것들. 예를들어 봉사동아리에서 만난 형은 나이키 운동화 래플을 여러 개를 해서 리셀을 하는데, 돈이 꽤 쏠쏠하단다. 물론 나도 래플 그동안 많이 해봤지만, 그것보다는 좀 더 귀찮게 해야된다. 온 가족 계정을 쓸어서 응모하고 운동화 하나당 사이트가 여러개라 계정 파는게 여간 귀찮은게 아닐테니. 근데 이글 쓰다 보니까 문득 해야겠다는 생각이 들기도 하고 갑자기?? 살면서 중요한게 저거 내가하면 더 잘할것 같은데? 싶으면 직접 해 봐야 하는것 같다. 근데 나는 아는 주민번호가 끽해야 내거 포함 4-5개밖에 없는데 괜찮은지 모르겠다. 일기쓰다 보니까 생각난건데 그냥 프로그램화해서 자동화 하면 되겠는데? 홈페이지 자체적으로 봇방지 해놓았으려나…   요즘은 빠니보틀 유튜브 보는거에 푹 빠졌다. 나 여행 그렇게 좋아하지도 않는데 보다보면 진짜 여행이 너무 가고싶어진 다. 물론 인도나 그런 후진국들 다니는 거 보면 유튜브로만 재밌지 절대 가고싶지는 않다. 사실 어릴 때는 월터의 상상은 현실이 된다 라는 영화에 나온 아이슬란드가 너무 예뻐서 아이슬란드 가보는게 꿈이었는데, 살다보니까 또 흐지부지 됐다. 참 여행이란게 돈도많이 들고 시간도 많이 들어서 어릴때가자니 돈이없고, 나이들고 가자니 시간이 없는것 같다. 이런 각 박한 현실에 여행다니고 유튜브 편집해서 올리면 여행비가 나온다니 얼마나 행복한 인생일까?? 물론 뭐 개꿀이라던가 이 런말이 아니라, 그냥 부러워서 하는 말이다…  빠니보틀을 보다보면 사실 진짜 별것도 없는데 영상이 너무 재밌다. 막 웃긴 얘기를 하는것도 아니고 엄청난 편집이나 스 토리가 있는 것도 아닌데, 그냥 계속 보게 된다. 여행지 그 자체가 컨텐츠여서 그렇기도 하지만, 빠니보틀 사람자체에서 나 오는 매력이 오진다. 그걸 우리나라 여행편을 보다가 깨달았다. 아 이거 여행지만 컨텐츠인줄 알았는데, 사람 자체가 컨텐 츠구나… 재밌네… 하는 생각들. 사람자체가 호감인 컨텐츠들은 진짜 무서운것 같다. 유튜브를 보다보면 금방 또 질려서 한창 맨날 보던 채널들 영상이 어느순간 10개씩 쌓이다가 안보게 되는데, 침착맨이나 빠니보틀처럼 사람 그 자체가 컨텐 츠인 영상들은 그냥 하루종일 켜놓고 본거 또보고 무편집으로 보고 설거지 하면서 보고 잘때는 들으면서 자게된다. 침착맨 님이랑 주호민님 먹방 하는 영상은 농담아니고 전체 재생목록을 한 세번씩 봤다. 침투부로도 시간이 녹아내리는데 요즘 빠 니보틀까지 합세해서 아주 아이패드를 놓지를 못하겠다.   어제 읽은 글중에 자신의 행복을 무시하지 말라는 내용의 글을 읽었다. 남들 무슨 명품두르고 여행다니는거만 행복이 아니 라 그냥 혼자 티비보면서 치킨 먹는 행복도 행복이니까 무시하지 말라는 요지의 글이었다. 사실 생각해보면 그냥 혼자 방 에서 치킨먹으면서 유튜브 보는 행복이 어디 좋은곳에 여행가고 비싼걸 살때의 행복과 큰차이 있나 싶다. 솔직히 혼자 침 대누워서 유튜브 볼때가 어마어마하게 행복할때도 많은데, 사람들은 그게 쉽다는 이유로 거기서 오는 행복을 많이 무시하 는것 같다. 나도 어제 침대에서 빠니보틀 유튜브 볼때 얼마나 행복했는데 ᄒᄒᄒᄒ  행복이란게 참 어려우면서도 별거없는것같다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%B1%8C%EB%A6%B0%EC%A7%80,-%EB%B9%A0%EB%8B%88%EB%B3%B4%ED%8B%80/",
        "teaser": null
      },{
        "title": "맥북",
        "excerpt":"2021.05.02  더 현대 서울에 데이트하러 가는중이다.  원래같으면 일기 그냥 오늘 안썼는데 블로그 챌린지 돈받아야해서 오늘도 쓴다… 돈벌기가 어디 쉽나.  최근에 산 물건중에 가장 맘에 들고 만족감이 드는 맥북에 대해 몇자 적어보려한다. 솔직히 코인으로 번돈으로 홧김에 옆 에 친구가 부추겨서 샀는데, 충동 구매한 물건이 이렇게 만족스럽고 후회가 없을수가 없다. 진짜 돈이 안아까운정도가 아 니라 이 정도면 진짜 돈 더 받아야 하는거 아니야? 이런 생각이 든다.  m1칩 진짜 아무리 봐도 외계인 갈아서 만든게 아니면 말이안된다. 애플 지하에 진짜 외계인 고문중인게 아닐까?  물론 인텔이나 다른 회사들도 기술력으로는 충분히 만들 수 있는 물건인건 알고있다. 하지만 하드웨어와 소프트웨어를 다 직접 제작하는 애플만이 할 수 있는 짓인것도 분명한 사실이다. 120만원이 안되는 돈으로 이런 성능의 노트북을 쓸 수 있다니…   나 솔직히 아이폰에 아이패드에 에어팟에 앱등이는 솔직히 맞다. 그래도 애플워치도 안쓰고 아이패드도 내 사용목적에 맞 게 그냥 7세대 쓰는 나름 ‘실용적’ 앱등이다. 아이폰쓰는거 호구라고? 솔직히 맞다. 알면서도 다 감성으로 쓴다고 생각하고 쓴 앱등이 맞다…   근데 솔직히 에어팟프로랑 맥북 m1은 인정해줘야 한다. 이정도면 가성비다. 진짜. 5월에는 아이패드에도 m1칩 넣어서 나온다는데, 진짜 진지하게 구매 고민중이다 m1 아이패드프로가 99만원밖에 안한다니… 지금 아이패드랑 펜슬 처분하면 한 30만원 좀 넘게 나올거고 아이패드 프로랑 펜슬 2세대하면 한 120 이니까 90에 산다고 생각하면 진짜 너무 싸다.   그리고 맥북 솔직히 제일 큰 장점은… 예쁘다는거다.  전자기기가 예뻐서 뭐하냐고 하겠지만 진짜 솔직히 성능 안좋아도 간지로 쓰던건데 성능까지 갖추니까 다른 노트북 회사 들이 걱정 될정도다… 맥북을 펴고 공부를 하다보면 마치 성공한 커리어맨이 되어가는 느낌이 들며, 스타벅스에서도 꿀리 지 않는 간지를 챙길 수 있다.  일기 오늘 너무 대충 헛소리 쓴것 같다. 어쨌든 이 글 보는 여러분, 무조건 맥북사세요 맥북 진짜 개좋아요 맥북 최고야 맨 날 들고다니고싶어!!!!!  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%A7%A5%EB%B6%81/",
        "teaser": null
      },{
        "title": "유혹",
        "excerpt":"2021.05.03  진짜 뒹굴거리고 혼자 침대에서 계속 누워있다가 겨우 나왔다.  그동안 생각해보니까 거의 여자친구 만나는 날 빼고는 공부 하루도 안빼먹어서  아 하루정도는 좀 뒹굴거리고 침투부랑 빠니보틀 유튜부나 24시간 연속으로 돌려버릴까? 이런 생각을 하다가 그냥 또 막상 그러고 저녁되면 현타올것 같아서 나와버렸다.  막상 오니까 오늘 날씨도 좋고 예진이가 공부하면서 먹으라고 딸기 요거트 스무디도 사줘서 나오길 잘했다는 생각이 든다. 얘두라 고마어어~~~~   요즘 자꾸 돈이 생기니까 지출에 욕심이 생긴다.  아 불릴라고 있는 돈이네 왜 자꾸 쓸려그려~ 어릴때 부터 느낀건데, 난 약간 소비욕? 소장욕 같은게 있다.  물론 누구나 다 있겠지 사실. 어쨌든 어릴때부터 뭐 하나씩 꽂혀서 그걸 줄창 사곤했는데, 아주 어릴땐 건프라였고 한때는 신발이었으며, 옷까지 갔다가 또 요즘은 옷을 안산다. 그러고서는 지금은 전자기기에 꽂힌것 같다.  물론 어릴때 부터 전자기기를 꾸준히 좋아했지만, 이게 구매력이 생기니까 너무 무섭다.  돌아보면 또 별생각 안들텐데…   한창 신발에 꽂혔을때는 진짜 거의 하루종일 신발 뭐 새로나오나 보고, 래플하고, 줄서서 신발도 사보고 했는데, 그때는 마치 평생 신발을 취미로 할것같다는 생각이 들정도로 신발에 열심이었다.  근데 지금은 시들해지고 하니까 진짜 신발 뭐나오는지 요즘 뭐있는지 하나도 모른다.  지금 전자기기도 와 이건 무조건 사야돼 진짜! 하다가도 몇달뒤면 그냥 시들해지겠지…  솔직히 아이패드 프로 새로나온거 사도 유튜브보고 필기하고 끝아닌가?  싶다가도 아니 m1칩이면 뭐라도 좀 하지 않을까,,, 하는 생각이든다. 또 나는 그 업종으로 갈거니까~~ 하면서 자꾸 지름신이 강림하는데, 이걸 막기가 힘들다.  아니 사실 막기가 싫다. 아 언제나와 진짜 나오자마자 질러버릴라…  최근에는 또 오큘러스 퀘스트2에 꽂혔다.  솔직히 vr막상 사면 얼마 하지도 않을것 같고 막 그런데,  좀 베타테스터 병이 옛날부터 있어서 자꾸 뭐 신기술 비스무리 한거 나오면 남들보다 먼저 사가지고 자랑하고 싶고 막 와 이걸 안해봤어~~ 진짜 니네 인생 손해보고 있네;;  이러면서 유세부리고 싶다.   전형적인 앱등이 테슬라충 마인드…  그래서 에어팟 프로가 출시됐을때 , 한국 정발도 안됐는데 해외 구매자 통해서  웃돈을 주고 그걸 샀다. 34만원 가량 주고샀으니 얼마나 호구인지… 그러고 나서 2주뒤엔가 바로 한국정발되었고, 지금은 24만원이면 새거를 살 수 있다.  흑우도 이런 흑우가 있나.  요즘은 쿠팡 로켓배송에 너무 꽂혔다,  오늘시키면 오늘밤 내지 내일 새벽만 되도 내가 배송한 물건이 있다니… 심지어 싼것만 되는것도 아니고 이번에 산 맥북도 지르자마자 다음날 새벽에 와있었다.   나는 어릴적, 택배가 너무나도 싫었다. 물론 그때는 지금보다 택배가 오래 걸리기도 했지만,  그걸 감안하더라도 항상 아빠가 뭐를 사준다고 약속하면  인터넷이 한참은 싼데도 항상 마트에 가서 오늘 사자고 졸랐었다.  아빠한테는 당연히 씨알도 안먹힐 소리였고, 나는 그 택배가 오기전까지 시간이 더디게 가는 것을 느끼며 한밤 한밤 세가며 오매불망 그 택배를 기다리곤했다.  그때는 돈의 가치보다 당장 내가 이걸 갖고 싶다는 소유욕이 더 컸었다.  하지만 이제는 돈의 가치를 잘 알기때문에  그 택배를 별생각없이 기다리는 나이가 되었다.  근데 쿠팡 로켓배송이 아주 성행을 하고, 좀 웃돈을 주고도 당장 오늘이나 내일 배송받기를 원하는 사람들이 많은걸 보니, 인간의 본능은 역시 끊어내기가 쉽지않나보다.  그 돈이면 그냥 더 주고 오늘받고 말지!   사람들 마음속에 숨어있던 어린아이를 자극하는 그런 사업이 돈이 되지 싶다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9C%A0%ED%98%B9/",
        "teaser": null
      },{
        "title": "사이킷런(1) 보스턴 주택가격 예측모델",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런(1) 보스턴 주택가격 예측모델  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0(1)-%EB%B3%B4%EC%8A%A4%ED%84%B4-%EC%A3%BC%ED%83%9D%EA%B0%80%EA%B2%A9-%EC%98%88%EC%B8%A1%EB%AA%A8%EB%8D%B8/",
        "teaser": null
      },{
        "title": "게으름",
        "excerpt":"2021.05.04  게으름의 늪에 빠졌다…  왜 자꾸 여섯시면 기상하던 몸이 요즘따라  아홉시는 넘어야 침대에서 일어나게 되는지 모르겠다.  뭔가의 동기부여가 심하게 떨어진것 같이 모든게 귀찮고 자꾸 쉬고 싶다. 공부가 좀 막혀서 그렇지 싶다…   더닝크루거 효과라는 현상이 있다.  어떠한 지식을 습득할때, 지식을 습득하기 시작했을때가 가장 자신이 많이 한다고 생각하고,  점점 그 지식에 대한 조예가 깊어질수록 오히려 자신이 더 모른다고 생각하게 된다는 현상.  무식한 사람이 더 자신감 있고 확신에 차있는 것도 이러한 현상에 비롯된다.  나도 얼마전까지만 해도 알아가기 시작하는 과정이 너무 즐겁고 보람찼는데,  어느수준 이상 지식을 습득하고나니, 솔직히 말해서 너무 어렵고 뭘 해야 할지 모르겠다는 생각이 자꾸 든다. 뭐 긍정적으로 생각하면 내가 어느정도 지식수준에 이르렀다는 것이겠고,  부정적으로 말하면 이제는 공부가 즐겁지 않게 될것 이라는 것이다.  처음에는 조금의 노력으로도 많은 지식을 얻을 수 있어서  노력에 대한 고통보다 무언가를 알아가는 기쁨이 더 컸는데,  이제는 하루에 한개의 개념도 이해가 될까 말까의 수준이 되어버려서  너무나 답답하고 짜증이난다. 뭐 도통 이해가 되어야 다음 스텝으로 나가는데… 계속 한부분을 붙잡고 있으면 내가 머리가 멍청한가 하는 생각이 들면서 영 책을 들여다 보기가 싫다.   그래서 차라리 여기 블로그에다 공부한 내용 써가면서 연재나 할까 싶다.  혼자 공부하니까 좀 집중도 안되고, 나름 블로그 같은데다 쓰면 누가 보지는 않아도  내가 공부한거에 대한 흔적이 남는거니까 뿌듯하기도 하고, 물론 뭔가 편집을 한다는 에너지가 더 들어가 진도가 더 느려질 수도 있겠지만, 지금도 어차피 공부가 안되서  진도가 안나가는데 더 좋으면 좋았지 나쁜점이 없지 싶다…   사실 투자 관련도 꾸준히 쓸라 했는데, 생각보다 투자는 맨날 쓸 필요가 없어서 내용 채울게 그다지 없다. 그냥 간간히 분석할때가 종목 갈아탈때나 쓰고 해야지, 내가 무슨 전업 투자자도 아니고…   괜히 무슨 맨날 할것처럼 제목을 날짜로 써붙여놓고 ‘장전시황’ 이래놨다.  어쨌든 계속 공부 방법을 바꿔가며 신선함이 느껴지도록 여러 방법을 강구해봐야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B2%8C%EC%9C%BC%EB%A6%84/",
        "teaser": null
      },{
        "title": "네이버, 비트코인",
        "excerpt":"2021.05.06  네이버 오늘일기 챌린지가 조기종료되었다.  아 나름 이거 돈도 벌고 일기도 꾸준히 쓸려고 했는데…  근데 네이버가 진행한 이벤트치고 종료된 정황이 너무 얼척없긴했다. 자기들이 시작해놓고 뭔 갑자기 돈부담된다고 조기종료를 하는지, 이정도 참여율이 나올거라고는 예상을 못한게 신기하다.   요즘 젊은 사람들은, 물론 나도 그렇지만, 돈에 완전 바짝 관심이 몰려있는것 같다.  뭐가 돈좀 된다고 하면 우르르 달려가서 모든 이득을 챙기려한다.  신발 리셀이 돈이 된다는 소리에 이제 래플은 하늘의 별따기가 되었고, 각종 사이트에서 홍보용으로  뿌리는 포인트나 돈 소식은 커뮤니티를 타고 퍼져서, 진짜 하루 이틀이면 모두 소진된다.  어제 봤었던 뉴스에는 신용카드 혜택을 최대한 이득을 보려는 사람들의 이야기가 나왔는데,  신용카드 혜택중에 천원 이하 단위는 할인해주는 카드가 있어서 그걸로 항상 990원 내지 900원으로  끝금액을 맞춰서 결제를 한단다. 7000원짜리 밥을 먹으면 100원짜리 동전을 준비해뒀다가  6900원만 결제를 한다거나, 주유소에서 한번에 기름을 넣는게 아니라 틈틈히 9900원 어치씩 기름을  넣는다 하는 식으로 신용카드 혜택을 받으려는 사람들이 요즘 늘어나고 있다고 한다.  또 얼마전에 토스에서 한 랜덤 주식 1주 증정 이벤트는 어땠었나? 물론 랜덤이라 재미요소도 있어서  참여율이 높았던 것도 있지만, 돈준다는 소식에 우르르 몰려서 다 받아갔다. 이런 요즘 흐름에서 2주동안 한줄일기만 써도 16000원을 준다는데 누가 참여를 안할까. 계정 네다섯개씩 돌려가며 받아가려고 하지.  경제수준이 올라가면서 다들 돈이나 투자에 대해 관심이 많아진건지,  아니면 정말로 어차피 집도 못사고 힘드니까 다들 돈에 미쳐사는건지는 모르겠다.  물론 나도 똑같지만 뭐…   어제 다시 비트코인을 시작했다. 그렇게 비트코인 안한다고 쑈를 하더니 왜 다시 시작했냐고?  나는 이성적으로 생각해서 비트코인을 안하겠다고 말한건데, 다시 이성적으로 생각해보니 그때는 오히려  그 심적인 고통때문에 감정적으로 안하겠다고 한것 같다. 이성적으로 생각해보니, 비중 10퍼센트 정도는 저기에 안넣을 이유가 없다. 10퍼센트 정도라면 내 감정이 요동치지 않을것이고, 일에 집중하면서 투자 할 수 있다. 다만 조심해야 할것은 내가 이미 저 상황에 노출된만큼, 본능을 못이기고 금액을 늘릴 가능성이 있는데,  어차피 시드 다 주식에 있어서 더 돈도 없다.   이더리움 클래식은 어제 돈을 넣자마자 오늘 벌써 20퍼센트가 넘는 수익률을 보이고 있다. 진짜 아무리 생각해도 얼탱이가 없네. 뭐 별생각 없이 그냥 없는돈인셈 치고 넣어두면 시드는 적어도 수익률이 괜찮을것 같다.   이걸로 벌어서 아이패드사야지.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%84%A4%EC%9D%B4%EB%B2%84,-%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/",
        "teaser": null
      },{
        "title": "변동성",
        "excerpt":"이 글은 유튜브 ‘월가아재’ 영상을 보고 공부한 내용을 기록한 글입니다.   변동성이란?  변동성이란   당연하겠지만 가격이 얼마나 ‘변동’하는지에 대한 수치이다.  어떠한 상품의 수익률의 표준편차로 계산한 값이며, 리스크의 일반적인 개념으로도 사용한다.   변동성의 종류에는 크게 두가지가 있는데,  첫번째는 실제 변동성(Actual Volatility): 실제로 가격이 얼마나 변동하는지에 대한 수치   두번째는 내재 변동성(Implied Volatility): 시장이 생각하는 변동성   실제 변동성은 실제로 가격이 변화한량을 말한다. 예를 들어 과거 실제 변동성이라고 하면   과거 특정기간(30일, 1년)간의 실제적인 변동성의 수치를 말할 것이다.  단, 현재 실제 변동성은 개념적으로는 존재하나, 현재라는것은 매번 변하고 있으므로 측정이 불가하다.   이 두가지 개념중에서 일반적으로 더 중요하게 받아들여지는건 내재변동성인데   이 내재 변동성은 시장참여자들이 생각하고 있는 변동성이다.   이 내재변동성은 말그대로 ‘내재’된 변동성이라 직접적인 측정이 불가한데   개념을 정확히 알기위해 먼저 옵션에 대해 이해해야 한다.   옵션은 어떠한 상품을 미래에 특정한 가격으로 사거나, 팔 수 있는 권리인데   사는 옵션을 콜옵션, 판매하는 옵션을 풋옵션이라 한다.   이러한 옵션은 옵션프리미엄이라는 가격을 지불하고 그 권리를 구매하게 되는데,   만약 1월 1일 만기인 행사가 100원의 콜옵션을 10의 프리미엄을 주고 구매했다고 치자.   만약 만기에 상품의 가격이 80원 이라면, 이 상품을 굳이 100원의 가격을 주고 살 필요는 없으니.   프리미엄 10을 손해보고 그 권리를 포기 하면 된다.   따라서 콜옵션은 수익은 무한대이지만, 손해는 -10으로 제한된다.      따라서 위의 그래프와 같이 아무리 상품의 가격이 하락해도 손실은 -10으로 제한된다.   ​   반대로 상품의 가격이 올라 150원이 된다면, 우리는 그 콜옵션의 권리를 행사하여, 행사가인 100원에   그 상품을 구매하게 되고, 차익 50원에서 프리미엄가격인 10원을 뺀 40원의 이익을 얻게된다.   이렇게 보면 마치 콜옵션이 손실은 제한적이고 리스크는 한정되어 있어 마냥 좋아 보이겠지만,   만약 콜옵션매수가 아닌 그냥 상품자체를 매수 했다면, 50원의 차익을 얻을것을 40원으로 줄인것이다.   따라서 하방 리스크를 제한하는 대신, 얻을수 있는 수익의 그래프를 아래로 내린 셈이 된다.   ​  반대로 풋옵션은 반대로 팔권리 이므로 가격이 떨어질수록 수익은 늘어나고,   가격이 올랐을때는 콜옵션과 동일하게 프리미엄만큼의 손실을 보고 권리를 포기하면 된다.     하지만 옵션에 있어서 가장 중요한 것은, 저 권리를 구매 할수 있는 프리미엄의 가격이다.      왼쪽의 경우는 프리미엄가격이 100, 오른쪽은 1000인데, 이러한 프리미엄의 가격차이 때문에   왼쪽은 2100만 가격이 넘어가도 수익이 나지만, 오른쪽은 3000을 넘어야 겨우 수익이 나기 시작한다.   이러한 프리미엄의 가격은 어떻게 결정될까??   ​  보통 옵션의 가격은 블랙숄즈 모델을 통해 계산되는데,   이 모델은 다섯가지의 인풋을 가진다.   ​     행사가격 : 콜옵션의 경우 행사가격이 낮을수록 옵션이 비쌈   당연히 싸게 살수 있는 권리일수록 더 많은 차익을 남길 수 있으니 옵션의 가격이 비싸다.   ​     현재 상품 가격 : 콜옵션의 경우는 현재상품 가격이 높을수록 옵션이 비싸다.   만기가 한달남았는데 이미 콜옵션의 행사가와 가까운 가격이라면, 한달만에 충분한 상승을 노릴 수 있기 때문에,   현재상품가격이 낮았을때 보다 프리미엄이 비싸다.   ​  ​- 만기까지 남은시간 : 만기까지 시간이 많이 남았을수록 옵션이 비쌈           이자율 : 이자율이 높을수록 미래 상품가격이 많이 오를것으로 기대되어 (콜)옵션이 비쌈            변동성 : 변동성이 높을수록 가격이 많이 오를 가능성이 있기 때문에, 옵션이 비싸다.       (많이 내릴 가능성도 같이 높아지는 것이지만, 그 경우에는 행사하지 않으면 되는 ‘권리’이기 때문에 상관없음)   ​  이 다섯가지 인풋중 ‘변동성’만은 시장에서 직접적으로 관찰이 불가능한 변수이다.   하지만 블랙숄즈 모델은 [행사가격, 상품가격, 만기, 이자율, 변동성] 을 입력하면 옵션가격을 출력해주기 때문에,   우리는 네가지 인풋을 넣고, 시장에서 직접 관찰 가능한 옵션가격을 공식에 대입하면,   등식이 성립되는 변동성값을 찾아낼수 있다.   ​  따라서 시장 참여자들이 결정한 옵션가격을 미루어 볼때, 그들이 기대하는 미래 변동성이   바로 ‘내재변동성’이다.   ​  이러한 내재변동성을 지수로 나타낸게 VIX지수인데 ,   이 지수가 바로 S&amp;P 500 옵션가격에서 계산되는 내재 변동성이다.   따라서 옵션 가격이 비싸면 VIX지수도 높고, 옵션 가격이 쌀때는 VIX지수가 낮다.   ​  대체로 주가지수와 변동성지수는 역상관관계인데,   주가가 폭락할때 높게 치솟으며, 이번에 코로나 사태때는 신고점을 갱신했다.   왜 변동성 지수와 주가지수는 역의 상관관계를 가질까?   ​  대략 네가지의 이유가 있는데,      공급측면: 주가는 상승할때는 천천히 상승하지만, 하락할때는 공포심리에 의해   패닉셀이 나오면서 급격하게 하락하는 성질이 있다. (변동성 지수는 Fear Indexf라고도 한다.)   즉, 하락장에서는 실제 변동성이 높아지기 때문에 옵션 매도자 입장에서는 그만큼 손실을 볼 위험이   커지는 것이므로, 더 비싼 옵션가격을 요구하게 된다.   ​     수요 측면: 하락장에서 불확실성이 높아지면, 옵션 매수를 통해 그 리스크를 헷지하려는 수요가 늘어나기 때문에 옵션의 가격이 비싸진다.   ​     매매 측면: 주가 지수 움직임에 옵션가격이 영향을 받지만, 옵션시장의 매매 때문에   주가 지수가 영향을 받기도 한다.( 다음 게시물에서 자세히 설명)   ​  4.내재 변동성구조 측면: 심화내용이므로 패스   그렇다면 우리는 이러한 변동성을 왜 알아야할까?   바로 옵션시장에서 벌어지는 일들이 주식 시장에 영향을 미치기 때문이다.   예) 소프트 뱅크 손정의 회장이 테크기업 콜옵션을 매수하는데, 왜 나스닥은 상승할까?   예) 대다수의 헤지펀드들이 보유한 옵션 포지션은 어떤 형태이고, 이는 주식 시장에 어떤 영향을 미칠까?   ​  먼저 이러한 질문들에 대한 답을 알기위해선   옵션시장의 중요한 참여자, 유동성 공급자에 대해서 알아야 한다.   유동성 공급자 (Liquidity Provider) = 마켓메이커 (Market Makre)로,   매수/매도 호가를 제시하는 사람이다.   ​  주식의 경우는 잡주가 아닌이상 항상 사고팔고 하는 사람이 많기때문에   유동성 공급자가 없더라도 충분히 서로가 서로에게 매수, 매도를 할 수 있다.   하지만 옵션의 경우는 행사가, 만기일에 따라서 수백, 수천가지의 옵션이 존재하기 때문에   특정한 옵션을 사거나 팔려고 할때 그 반대 포지션이 없을 확률이 매우크다.   따라서 유동성 공급자, 마켓메이커들이 이러한 매수 매도세에 항상 반대 포지션을 취해줌으로써   시장에 유동성을 공급한다.   ​  그렇다면 무조건 반대 포지션을 취하는 마켓메이커는 이러한 행동을 왜 하는걸까?   마켓메이커의 기본원칙은 매수호가와 매도호가의 차이 = 호가 스프레드를 끊임없이 모으는것이다.   매수호가 101 - 매도호가 103인 경우, 가격은 중간값인 102   누군가가 마켓메이커에게 101에 매도하면, 마켓메이커는 102보다 1 싸게 매수   누군가가 마켓메이커에게 103에 매수하면, 마켓메이커는 102보다 1 비싸게 매도   이런 식으로 시장의 방향과 상관없이 계속 매수 매도를 반복하며 이 1의 확률적 우위   ‘엣지’를 모아간다.   그렇다면 만약 매수포지션을 취했는데 시장이 내린다면 손해인데 이러한 상황은 어떻게 할까?   사실 매수했을때 떨어지는 경우도 있겠지만, 매수했을때 오르는 경우도 있을 것이기 때문에   장기적으로 계속 매수 매도를 반복하면 이러한 손해/이익은 상쇄된다는 가정하에 이 행위를 반복한다.   이것이 마켓메이커의 기본원칙이다.   물론 마켓메이커도 시장이 오를것같다 내릴것 같다는 뷰는 반영을한다.   이러한 원칙 때문에 마켓메이커 입장에서는 갖고있는 포지션이 적으면 적을수록 좋다.   따라서 가장 이상적인 상황은 사려는 사람과 팔려는 사람이 항상 많아서   포지션을 갖고있는 시간이 최소화되는 상황이다.   하지만 이렇게 유동성이 항상 많을 수 없기 때문에 마켓메이커에게는   무조건적으로 필수불가결하게 포지션이 쌓일수 밖에 없다.   따라서 이러한 포지션을 관리하기 위해 비슷한 만기일의 비슷한 행사가의 반대 포지션을 취하려한다.   예를 들어 애플 주식의 1/31만기 150행사가 콜옵션을 매수하게 되면,   비슷한 만기와 행사가인 1/31만기 155행사가 콜옵션을 매도할 기회가 오면 적극적으로 매도한다던지 하는식으로   최대한 비슷한 포지션을 매수 매도 하며 리스크를 최대한 중립으로 만들어,   오로지 엣지에서 오는 이득만을 취하려고 노력한다.   ​  자 다시 아까의 질문으로 돌아가서,   손정의 회장이 기술주 콜옵션을 사서 나스닥이 상승했는가? 에 대한 질문에 대해 다시 생각해보자.   이 질문은 하나처럼 보이지만 사실은,           누군가 기술주 콜옵션을 매수하면, 기술주 주식도 같이 오르는가?            손정의 회장이 매수한 콜옵션이 나스닥을 움직일 정도로 사이즈가 큰가?       이 두가지에 대한 질문으로 볼 수 있다.   손정의 회장이 콜옵션을 매수하게 되면 옵션 시장에는 어떠한 변화가 일어날까?   대규모의 콜옵션을 매수하려고 하면 그 물량은 마켓메이커들이 받아낼 것이다.   그렇게 되면 손정의 회장은 매수포지션, 마켓메이커는 매도포지션을 잡게되고,   위에서 설명했다시피 마켓메이커는 시장의 하락과 상승에 베팅하는 것이 아니므로 최대한 중립적인 포지션을 위해   리스크 헷지를 위한 기술주 현물 주식을 매수한다.   행사가와 주식가가 똑같다고 가정할때 그렇다면 마켓메이커는   콜옵션 매도와 주식의 비율을 어떻게 조정해야 가장 중립적인 포지션을 취할 수 있을까?      먼저 주식가격과 행사가격이 동일하다고 가정할 때,   콜옵션 매도 포지션과 주식매수 포지션을 1:1로 콜옵션을 100개 매도, 주식을 100개 매수했을 경우에는   오른쪽의 보라색 그래프와 같이 풋옵션 매도 포지션을 취한것과 같은 포지션이 된다.   이렇게 되면 주식이 내리면 돈을 잃게 됨으로 헷지가 아니다.      그렇다면 이번에는 콜옵션 매도 포지션과 주식매수 포지션을 2:1로 콜   옵션 매도 100개, 주식 매수 50개의 포지션을취했을 경우를 보자.   위와 동일하게 보라색 선이 이 포지션의 그래프이다.   이렇게 되면 완전히 풋이 되는것이 아니고 콜과 풋의 중간인 좌우 대칭이 된다.   따라서 크게 상승하거나 크게 하락하지만 않으면 되는 중립적인 상태가 되는데, 이처럼 헷지는   상승과 하락에 관계없도록 델타, 즉 ‘방향성’에 대한 노출을 줄이는 것이다.   따라서 콜인지 풋인지는 중요하지 않고, 변동성 자체가 중요하다.   이렇기 때문에 옵션은 방향성 매매가 아니고 변동성 매매임을 알 수 있다.   그렇다면 만약 현재 주식가격이 행사가보다 훨씬 낮다면 어떻게 될까?   위와 동일하게 옵션과 주식을 100개와 50개를 매도 매수했다고 가정했을때,   보라색 손익 그래프는 그 모양 그대로 위로 올라가게 된다.   반대로 주식 가격이 행사가 보다 높은 경우는, 보라색 손익그래프가 모양그대로 아래로 내려가게 될것이다.   근데 다시 생각해보자, 헷지를 하는 이유는 위 아래 모두 동일하게 방향성에 대한 중립상태를 만드는 것인데   만약 주식가격이 더 싼경우에는 주식을 50개 매수 할경우에,   주식이 오를때 더 이익이 많이 나게 손익그래프가 바뀌게됨으로 오르는것을 원하게되고   주식가격이 비싼경우에는 손익그래프가 주가가 내릴때 최대한의 이득이 나오게되어 주가가 내리는걸 원하게된다.   따라서 만약 주식가격이 행사가 보다 싼경우에는 주식수를 줄이고,   주식가격이 행사가 보다 비싼경우에는 주식수를 늘려서 비중을 조절하여야   주식의 방향성이 어디로 가던 중립적인 손익그래프를 얻을 수 있는것이다.   이러한 주식가격의 움직임에 대한 옵션 가격의 민감도를 ‘옵션 델타’(Delta) 라고 하는데,   델타가 0이면, 주식가격이 움직여도 옵션가격에는 아무 영향이 없다는 것이고,   델타가 1이면 주식가격이 움직이는 만큼 그대로 옵셕가격이 따라 움직인 다는것,   델타가 0.5 이면 주식가격의 50퍼센트만큼 옵션가격이 움직인다는 것이다.   예를들어 행사가 100의 콜옵션의 경우      주식가격이 10일 때, 주식가격이 9가 되던 11이 되던, 콜옵션을 행사할 가능성은 거의 없기 때문에   휴지조각과 다름없다. = 델타 0      주식가격이 500일 때, 옵션가격은 거의 주식가격과 동일하게 움직인다. = 델타 1   -주식가격이 행사가와 동일한 100일때, 행사 될확률과 안될 확률이 반반이므로, = 델타 0.5   이러한 델타는 옵션이 행사될 확률로 해석하기도 한다.(엄밀히 말하면 정확하지는 않지만, 대부분의 확률이 그러함)   따라서 상품가격이 오를수록 콜옵션의 델타가 상승한다. 따라서 헷지를 더욱 많이 해야한다.   자 다시 손정의 회장이 콜옵션을 매수 했을때의 상황을 가정해보자.   아마 아무런 대비책 없이 콜옵션을 쌩으로 매수 했을 확률은 매우 적지만,   정말 쌩으로 콜옵션을 매수했다고 가정하자. 그랬다면 행사가가 현재가격보다 높은 싼 옵션을 매수 했을 것이다.   옵션은 세가지 종류로 부를 수 있는데      내가격 옵션 (in the money) : 이미 이익구간에 들어가있는 옵션, 매수하자마자 행사해도 이익임      델타 0.5 이상       중가격 옵션 (at the money) : 주식가격과 행사가가 동일한 옵션,      델타 0.5       외가격 옵션 (out of the money) : 아직 행사가가 먼 옵션,      델타 0.5 미만    ​  내 가격은 바로 행사해도 이익이 나므로 비싸다. 따라서 손정의식 배팅의 의미를 두려면   아마도 외가격 콜옵션을 매수 했을 가능성이 크다.   델타를 0.1이라고 가정하면, 콜옵션을 매도한 마켓메이커는 이러한 포지션을 헷지해주기위해   예를들어 1조정도의 매수를 매도로 받아주었다면 천억원 정도의 주식을 매수했을것이다.   근데 이러한 상황에서 주가가 오르게 된다면, 이러한 헷지를 위해 주가가 오를때마다 주식의 비중을 늘리기 위해   더많은 주식을 매수해야만 방향성에 대한 헷지를 할 수 있다.   따라서 이러한 예가 옵션매수가 왜 현물 주식에 영향을 미치는지에 대한 이유이다.   따라서 우리가 옵션시장에서 무슨일이 일어나는지 알지 못하면,   그저 주식의 움직임이 무작위적으로만   볼 수 밖에 없는 것이다.   ​  따라서 옵션시장에 집중하여 거대 헤지펀드들이 어떠한 포지션을 취하고 있는지에 집중하면,   어느정도 확률적 우위를 선점 할 수 있다.  ","categories": ["finance"],
        "tags": ["금융","변동성","주식"],
        "url": "/finance/%EB%B3%80%EB%8F%99%EC%84%B1/",
        "teaser": null
      },{
        "title": "인플레이션",
        "excerpt":"이 글은 유튜브 ‘월가아재’ 영상을 보고 공부한 내용을 기록한 글입니다.  서론  요즘 주식시장에서 가장 사람들이 주의깊게 보고 있는것이 바로 인플레이션인데, 과연 코로나로 인한 경기침체로 인해서 여러국가들이 어마어마한 역대급 부양책을 실시하고있는 만큼, 과연 인플레이션이 올까 말까에 대한 관심이 아주 뜨겁다. 미국 재무부 장관 옐런은 얼마전 금리가 올릴것이라 발언했다가 수습했지만, 나스닥과 다우지수는 크게 하락했었다. 원자재값과 주식모두 하루가 멀다하고 상승중인 이 추세에 과연 인플레가 올것인지, 아니면 파월의 발언처럼 인플레의 기조는 일시적인 것 뿐이며, 장기적인 인플레 상승의 추세로 접어들지는 않을것인지, 앞으로 투자에 있어 중요하다고 생각되어 영상을 찾던 중 마침 월가아재 채널에 이에대한 정리가 올라와서 한번 블로그에 정리해보려 한다. 이 영상은 Man Group의 논문인 ‘The Best Strategies for Inflationary Times’를 참고하였다.   ​왜 인플레이션은 채권가격 형성에 영향을 미칠까?  인플레는 두가지 종류가 있는데, 기대 인플레(Expected Inflation)와 예상치 못한 인플레(Unexpected Infaltion)가 있다. 이 중 기대인플레이션은 이미 채권가격에 반영되어 있기 때문에, 중요한것은 예상치 못한 인플레이션인데, 인플레율의 변화율을 말한다고 생각하면 된다.   ​   인플레이션이 증가하면, 돈의가치가 빠르게 떨어지기 때문에, 채권 가격이 하락하여 채권금리가 상승한다.   채권은 고정적인 이자를 지급하기 때문에 인플레이션이 증가하면 그 고정이자에서 인플레이션분을 뺀 가격이 수익이 되는 것이기 때문에 사람들은 더 낮은 가격에 채권을 사려고 하고, 채권 가격이 내려가면 채권 금리가 상승하게된다. 또, 인플레이션이 증가한다는것은 미래에 대한 불확실성이 늘어난다는 것이기 때문에, 금리가 상승한다.   인플레이션은 주식가격에도 타격을 주는데, 첫째로는 인플레이션의 수치 변동성이 커지면 그만큼 시장에 불확실성이 증가하는것이기 때문에, 기업으로 하여금 계획, 투자, 운영을 소극적으로 만들게되고 시장점유율이 높은 기업들은 인플레로 인한 원가상승의 부담을 소비자에게 전가할수 있겠지만, 그렇지 못한 기업들이 대부분이기 때문에 기업들의 마진하락으로 이어진다. 또, 인플레이션은 미래경기에 대해 악영향이므로 미래에 대한 소득이 하락하게되고, 기업들의 경우 설비투자를 할 경우 그러한 설비들의 감가상각을 비용처리하여 절세를 할 수 있는데, 인플레가 있을경우에는 이 감가상각비용이 지나치게 낮게 인정되어 세금 손해를 보게된다. 마지막으로 이러한 인플레이션은 리스크 프리미엄을 증가시키므로, 먼 미래에 수익이 있는 기업들의 할인율을 증가시켜, 주가를 하락시킬 수 있다. 따라서 먼미래에 수익이 많은 성장주 일수록 큰타격을 입게된다.   자 그렇다면 인플레이션에 대해 이야기 하기전에,   ‘인플레이션이 왔다’라고 할 수 있게되는 인플레이션 시기(Regime)에 대해서 정의부터 하고 알아보도록 하자.  인플레를 정의하기는 매우 어려운데, 이는 인플레이션이 질적인 향상을 반영하지 않기 때문이다.  예를들어 지금의 스마트폰의 성능은 90년대에 300억하던 슈퍼컴퓨터의 성능을 뛰어넘는데, 이러한 인플레 수치는 물건자체의 질적인 향상은 반영하지 않는다.   그렇기 때문에 인플레의 정의에 있어서 가장 중요한것은 시장 컨센서스라고 할 수있는데, 다시말해 시장 참여자들이 미래 인플레이션을 어떻게 생각하고 있고, 최대한 많은 시장 참여자들이 보는 지표가 중요하다고 할 수있다.   이 논문에서는 CPI Headline Infalation을 기준으로 인플레를 정의하였고, 인플레이션 시기라 함은 연간 인플레율이 2퍼센트보다 상당히 높게 지속되는 기간으로 보통 정의하며, 이 논문에서는 5퍼센트 이상의 수치가 나온 지점부터를 인플레시기의 시작으로 보고있다.   이 논문은 지난 백여년간의 세계 경제에 있어 인플레이션 시기를 8번의 사건으로 정의했는데,           세계 2차대전 초기(1941-1942)            세계 2차대전 직후(1946-1947)            한국 전쟁 시기 (1950-1951)            브레튼우즈 체제 말기 (1966-1970)            1차 오일 쇼크(1973-1974)            이란 혁명 (1977-1980)            레이건 호황(1987-1990)            중국 수요 호황 (2007-2008)       이러한 정의를 바탕으로 주식과 채권의 인플레이션 시기 수익률을 알아보도록 하자.      왼쪽 그래프를 보면 가로축은 인플레이션 상승률, 세로축은 주가를 나타낸다.   금색선은 인플레 상승률이 중간값보다 낮은때이고, 파란색은 인플레 상승률이 중간값보다 높은 값을 가질때인데,   인플레 상슬률이 중간값보다 낮을때는 인플레가 상승하면 주가도 따라 상승하지만, 인플레 상승률이 중간값보다 낮을때는 인플레 증가에따라 주가가 하락한다. 보통 인플레가 낮다가 올라올때는 경기 상승시기, 인플레가 평균에서 높은 값으로 올라갈때는 경기 과열시기로 볼 수 있기 때문에 직관적으로도 그럴 수 있다고 느껴진다.   오른쪽 그래프도 마찬가지도 비슷한의미를 갖는 그래프인데, 인플레이션과 주가와의 상관관계를 나눈 그래프로, 인플레 상승시기의 인플레율을 하위부터 20퍼센트의 덩어리로 나누어놓은 것으로, 인플레율이 하위 20프로일때만 양의 상관관계를 갖고, 나머지는 모두 음의 상관관계를 갖는것을 알 수 있다.   ​  ​  ​ 그에 비해 국채의 경우는 그래프와 상관관계 모두 인플레 상승률에 관계없이 인플레가 상승하면 국채 가격은 하락하는것을 알 수 있다   ​  ​빨갛게 칠해진 부분이 실질 수익률, 맨 오른쪽 t stat 이 통계적 유의미성(*이 쳐져있을시 통계적으로 유의미하다는 뜻임)   또 인플레시기의 주식 섹터별 수익률을 보면 에너지 섹터만이 통계적 유의미성이 떨어지기 때문에 제외하고, 나머지 모든 섹터가 마이너스 실질수익률을 기록했다. 금융주의 경우는 금리상승이 호재로 작용하여 수익률이 높다고 생각할 수 있지만, 기업들의 파산율이 높아짐에따라 금리상승에 대한 이익보다 그로인한 손해가 더 크기 때문에 실질 수익률은 높지 않음을 알 수 있다.   이러한 수치들은 그야말로 과거의 수치들이기 때문에 현재에 그대로 적용하기에는 무리가 있다.   하지만 원자재의 경우 인플레 시기에, 인플레를 감안하더라도 아주 높은 실질 수익률을 기록했다.   ​  ​마찬 가지로 초록색부분 실질 수익률, t stat이 통계적 유의미성  ​  ​​   ​마찬가지로 상관관계에 대한그래프를 보아도, 원자재는 인플레가 상승하기만 하면   덩달아 상승하는 양의 관계를 갖는 다는 사실을 알 수 있다.   ​본 논문은 지속성이 있는 인플레가 왔다고 가정할때의 각 자산의 수익률을 분석한것으로,   ​  이러한 과거의 데이터들이 올해에 지속성이 있는 인플레가 올지 안올지는 별개의 문제이다.   게다가 이것은 100년치의 데이터를 분석했다지만 여전히 과거의 데이터일 뿐, 앞으로의 인플레이션의 경향은   또 달라질수도 있다는것에 주의하여야 한다. 과거와 현재가 인플레에 대해 다른 점을 꼽아 보자면 아래의 내용들을 꼽을 수 있는데,           과거와 달리 현재는 미국의 셰일혁명으로 인해 원유 수입의존도가 매우 낮아지고, 전기차가 상용화 되기 시작함과 동시에 과거와 달리 기술개발로 인한 원유의 사용효율이 증가해 원유에서 오는 인플레 압력이 매우 낮아졌다.            과거의 미국은 제조업 중심국가라 인플레에 민감하게 경기가 반응했지만, 현재는 GDP 11퍼센트만 제조업이며  많은 자본들이 물리적 설비 투자 보다는 무형의 자산에 집중되어 있어, 인플레에 강건한 모습을 보이고 있다.       따라서 이러한 관점에서, 우리는 인플레와 성장이라는 두가지 측면에서 시나리오를 생각해보아야한다.   인플레와 성장, 또 이것을 두가지로, 나누어 보면   일시적 인플레 vs 지속되는 인플레   강한 성장 vs 성장 둔화   따라서 저 네가지를 조합하여 나올수 있는 네가지 시나리오들에 대해 동일한 확률 25퍼센트를 배정해 놓고, 경제지표나 각종 지표들의 발표들을 주시하여 그에따라 각 시나리오에 대한 확률을 조금씩 변경하여 포트폴리오에 적용하는것이 필요하다. 이러한 확률들의 계산 결과에 따라 가장 다른시나리오들에 비해 확률적 우위가 있는 상품을 찾아 내며 대응하는것이, 승률을 높일 수 있는 가장 좋은 방법일 것이다.   나의 생각  오늘 내용을 통해 인플레이션이 왔던 과거의 데이터를 살펴봄으로써, 인플레가 왔을때 각 금융상품군들이 인플레에 어떻게 반응하는지를 알아보았다. 물론 이것들은 과거의 데이터이며, 과거와 현재의 경제 상황이 크게 달라진만큼 저위의 논문에서 나온것처럼 금융 상품들이 반응하지 않을 수도 있다는 점을 주의해야겠지만, 원자재가 인플레시기에 수익률이 좋다는 사실은 크게 변하지 않을것 같다는 생각이 든다. 결국 원자재는 현금가치하락에 따라 당연히 필연적으로 가격이 오를 수 밖에 없으니 과거와 특별히 달라진 상황이 없을것같다는 예측이 맞을 것 같다.   현재 내 포트폴리오에는 원자재인 농산물과 구리가 있고, 주식 상품군이 두개가 있다. 지금 추세는 원자재와 주식 모두가 우상향하고 있다고 느껴지는데, 그렇다는것은 저 위의 논문대로라면 인플레 상승 초입에 나타나는 현상이 라고 볼 수 있지만, 아직까지 나온 지표들로 인플레가 왔다고 판단하기에는 이르다고 생각된다. 하지만 나는 아직은 인플레상승에 대한 시장의 우려가 평균보다 높다고 생각해, 인플레 초기에 수익을 볼 수 있는 주식상품고 원자재를 모두 가지고 있는채로 대응 해보려 한다. 이후 인플레 우려가 줄어든다고 생각하면 원자재 비중을 줄이고, 인플레 우려가 오히려 증가한다고 느껴지면, 주식상품 비중을 줄임으로써 확률적 우위를 쌓아보도록 할것이다.  ","categories": ["finance"],
        "tags": ["금융","인플레이션","주식"],
        "url": "/finance/%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/",
        "teaser": null
      },{
        "title": "사이킷런 (2)  캘리포니아 주택가격 예측 모델",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런 (2) 캘리포니아 주택가격 예측 모델  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0-(2)-%EC%BA%98%EB%A6%AC%ED%8F%AC%EB%8B%88%EC%95%84-%EC%A3%BC%ED%83%9D%EA%B0%80%EA%B2%A9-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8/",
        "teaser": null
      },{
        "title": "오큘러스",
        "excerpt":"2021.05.10  몇일동안 고민했던 오큘러스 퀘스트2를 질렀다.  아마 내일 도착할것 같다. 아 그냥 미리 살걸.  고민 하던사이 64GB는 품절되서 강제로 14만원을 더주고 256GB로 샀다.   뭐 어차피 용량 많이 필요하다고는 하는데, 보니까 게임더 별로 없던것 같더만….  게임도 좀 하고 영화도 보고 운동도 그걸로 해볼까 생각중이다.  언젠가 한번쯤 제대로 된 vr을 한번 해보고 싶었는데,  오큘러스가 vr치고 말도 안되는 가격과 성능으로 나와줘서 작년 출시부터 너무 사고 싶었지만 돈이 없어서 그냥 생각도 안 하고 있었는데, 뭐 요즘 돈도 많이 생겼기도 하고 요즘같이 중고 시장이 잘되어있는 시대에 그냥 좀 사서 하다가 재미없으 면 중고로 처분해버리면 되는데 뭐 크게 고민할거 있나 싶어서 샀다.  지금 물량도 크게 많지 않아서 감가도 적은편이라, 그냥 재미없으면 싸게 렌탈했다 치고 팔아버릴 셈이다. 물론 게임이 좀 비싸서 한달은 써야게임값은 뽑으려나…   지금 보고 있는 게임은 언틸유폴, 뭐 복싱하는거랑, 비트세이버정도 생각하고 있다.  하프라이프 알릭스는 진짜 꼭해봐야 한다하는데, 집 컴퓨터 사양이 안되서 집에서는 못할것같고 날잡고 친구네 가서 하루동안 조져버릴까 생각중이다.   어릴때는 터치라는 기술이 너무 신기하고 갖고싶었는데, 어느새 터치는 거의 일상이 되었고 이제는  맨날 맨날 새로운 기술이 나온다. 심지어 가격도 낮아져서 솔직히 한 2년여전만 해도 vr기기는 기본 백오십만원은 줘야 의 미있는 체험이 가능했는데, 이제는 40만원으로도 즐길수가 있다. 기술의 발전이 가속도가 붙는다고는 하지만 요즘은 진짜 하루하루가 신기술의 연속인것같다.   이 일기를 쓰는도중 택배 출고문자가 왔다. 무슨 어제 저녁에 주문했는데 출고하나는 오지게 빠르네.  빨리 내일이 됐으면 좋겠다. 아 그냥 금요일날 살걸. 나이가 먹어도 택배 기다리는건 세상에서 제일 어렵다. 이러니 쿠팡 로켓배송이 불티나게 팔리겠지.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%98%A4%ED%81%98%EB%9F%AC%EC%8A%A4/",
        "teaser": null
      },{
        "title": "요즘",
        "excerpt":"2021.05.11  세상이 언제는 안혼란했겠냐 하지만 요즘처럼 혼란한 시대가 있나싶다.  물론 우리 아빠는 나한테 맨날 좋은 시대에 태어났음을 감사하라고 하지만 내가 진짜 좋은 시대에 태어났는지 모르겠다. 물론 아빠가 고생해서 이뤄놓은 기반을 내가 누리는 건 맞고, 애처럼 이걸 당연하다고 생각하면서 살지도 않는다. 내가 말 하는거는 이 시대와 세대에 대한 이야기인데 아무래도 아빠는 그냥 별 관심이 없으셔서 그런가 잘 모르시는 것 같다. 이런 작은 차이들이 사회에서는 크게 벌어진채로 나타나는걸까?   코로나로 인해 주변에는 취업했다 하는 사람이 거의없고, 경제는 어느정도 나아지긴 했지만 아직도 모든 경제 지표는 바닥 에 머물러있다. 백신은 나같은 20대는 언제 구경 할 수 있을지도 모를 상황이 되어버렸고 사람들은 이제 한계에 다다른것 같다. 다들 코로나 초반의 방역의지는 온데간데 없다. 집에 있기만 하니까 답답하기도 하고, 북적하던 대학가에서는 아무 소리도 없다. 하지만 이런것들은 아무래도 좋다. 이런건 다 병때문이기도 하고, 어쩔 수 없는 것들이며, 인간의 힘으로는 막을 수 없는 자연재해 같은거라고 치자.   내가 가장 요즘 힘든건 갈등과 혐오다. 인터넷만 켜면 온갖 갈등과 혐오가 만연하다. 이렇게까지 갈등이 치솟은 적이 있었 나 싶다. 지역갈등도, 좌우갈등도 이정도는 아니었다. 사람들은 누가 잘못을 저지르만은 계속 지켜보다가 사소한 잘못이라 도 하면 진짜 기다렸다는 듯이 물어뜯고 돌을 던진다. 맨날 하루하루가 지날때마다 새로운 폭로가 터지고, 사건이 터지고, 신나는건 유튜브 렉카들 밖에 없다. 코로나로 받는 스트레스들을 그렇게 풀고는 하는걸까?  그 중에서 가장 심한건 뭐니뭐니해도 남녀갈등이다. 이건 진짜 답이 없다. 도대체 누가 시작한지도 모를 이 지독한 갈등은 내가 겪어본 갈등중에 가장 심하고, 답답하며, 가장 재앙에 가깝게 느껴진다. 다른 갈등에서 발생하는 혐오들은 누가 공개 적인 자리에서 그러한 발언을 하면 당연하게 미친놈 취급을 받는다. 그리고 그 갈등은 솔직히 그들만의 것이다. 혐오를 하 고자 하는이들의 것. 일반인들은 그에대해 별생각이 없으며, 아무도 그걸 염두에 두고 살아가지 않는다.   근데 이 남녀 갈등은 수위가 선을 넘었다. 어떠한 갈등이 이렇게 노골적이고 저급하게 서로 싸우는 수준일수가 있을까? 아 무런 논리도 없고 논의도 없고 토론도 없고, 그저 원색적인 서로에 대한 욕설과 비꼬기 밖에 없다. 왜 가장 서로 사랑하고 아껴주어야 할 남녀가 이토록 갈등에 빠졌는지 도저히 모르겠다. 서로에 대한 불신이 이제는 일상생활까지 넘어와 실제로 주변의 친구들을 보면 사상에 대한 고민을 할 정도다. 내 주변에는 정상적이고 건강한 생각을 가진 사람들 밖에 없는데, 도 대체 왜 맨날 일어나는 사건사고들의 사람들은 그렇게 혐오에 가득 차있는 것일까.   내가 더 화가나는건 아무 어른들도 이걸 언급하지도 않고, 중재하려고 하지 않는다. 그동안의 좌우갈등, 지역갈등, 세대갈등등은 누군가가 항상 목소리를 냈으며 관심을 가져주었고, 중재했다. 그래선 안된다는 목소리가 항상있었고 해결방안에 대한 논의도 활발한 편이었다. 근데 도대체 왜 이 남녀갈등에 있어서는 아무도 이게 문제라고 말을 안하고 부추기기만 하 는것인지 모르겠다. 난 내가 느끼는 가장 큰 사회문제인데, 정치권에서는 자꾸 아니라고만 한다. 그런건 존재하지않는다고 못들은 척을 한다. 이미 남녀 표가 갈려서 그 중간에서 목소리를 내기엔 돌아올 수 없는 강을 건너버린 것일까? 도대체 이 긴 남녀갈등은 어디까지 가야 서로 지쳐서 그만둘까. 왜 가장 서로 사랑하고 즐거워야 할 20대의 남녀들이 이런 혐오와 갈 등속에서 서로를 의심하고 비난하고 싸워야 하는건지 모르겠다.   난 이렇게 이념과 세대, 성별갈등이 일어나는 책임이 어느정도 유튜브에 있다고 생각한다.  소위 ‘알고리즘’이라고 불리우는 이 기능. 내가 어떠한 영상에 관심이 있어서 그 영상을 켜면 계속 그와 관련되고, 비슷한 성향의 영상만 보여준다. 물론 제작 의도는 사용자로 하여금 관심이있는 영상을 더 보여주면 영상시청 시간이 늘어날 것이 고, 광고의 효과도 탁월할 것이라는 생각이었겠지만, 이게 이념이나 갈등에 대한 영상이라면 이건 진짜 재앙이 된다.   이러이러한 주장이 맞다고 말하는 영상이나 게시물을 시청하면, 알고리즘은 계속해서 그 주장이 맞다고 주장하는 영상만 계속 보여주고, 이는 편향된 의견을 머리에 주입시킨다. 편향된 의견만 듣다보면 점점 그 주장이 맞다고 생각하게 되고, 더 욱 그러한 성향의 영상만 접하다보면 한 일주일만 지나도 그 사람의 사상은 한쪽에 편향되어버릴것이다. 게다가 영상컨텐 츠는 아주 매력적이다. 진실에대해 깊이 생각할 필요도 없으며, 쉽게 머리에 주입할 수 있게 10분여내로 요약하여 아주 잘 편집되어 있고, 댓글들은 보통 이미 편향된 사람들이기 때문에 모두가 그 주장에 동조하고 있는 의견들 밖에 없다. 글은 읽 기 귀찮고 머리가 아프니 그냥 영상을 보는 경우가 많은데, 이쯤되면 뇌는 사고를 하나도 안하고 그냥 그 정보를 받아들인다.   사람들은 몇년전만 해도 글을 읽었다. 페이스북은 글이 그래도 주인 sns였고, 영상이 있긴 했지만 대부분 글과 함께 첨부 된, 글을 뒷받침 하고자 하는 영상이었다. 하지만 글을 읽는 행위보다는 영상을 보는 행위가 더 매력적이고, 자극적인 행위 라는걸 사람들은 알았다. 그래서 페이스북이 담당하던 자리는 유튜브로 점점 바뀌게 되었다. 유튜브도 그때는 이렇게 영상 시간이 짧지 않았다. 몇년 전 컨텐츠를 보면 그래도 대부분 2-30분여의 컨텐츠가 꽤 있고, 편집속도도 지금에 비하면 아주 템포가 느리다. 사람들은 긴 영상마저 보기 귀찮아 하고, 더 요약된 정보와 재미를 원했다. 유튜브의 영상 편집 템포는 점 점 짧아졌고, 영상길이는 점점 10분도 안되는 길이에 이르르기 시작했다. 근데 사람들은 이것도 길다고 느끼기 시작했다. 짧은시간에 한영상만 보기보다는 여러 영상을 보면서 새로운 자극을 계속 느끼고 싶어했다. 그래서 이제는 틱톡이 유행하 기 시작했다. 사람들은 더 짧은시간안에 많은 자극을 느낄 수 있었고 아무 생각없이 그 짧은 영상의 정보를 받아들였다. 그 래서 유튜브는 이에 질세라 유튜브 Shorts를 베타테스트 하고 있다.   영상으로 된 짧게 요약된 정보는 뇌에 아주 자극적이다. 알아듣기 아주 쉽고 생각할 필요없이 정보를 받아들일 수 있다. 거 기다 유튜브는 나의 흥미를 아주 잘 파악해 내 뇌가 즐거워할만한 영상을 쏟아주니, 난 그냥 가만히 서서 그걸 누리면 된 다. 하지만 요약된 정보일수록 왜곡은 아주 쉽고, 내가 생각할 영역은 줄어든다.  이렇게 자꾸 누워서 쏟아지는 정보를 받고 있자니 서로의 잘못된 사상은 더욱 강화되고 무조건 내 생각이 맞다고 생각 하게 되는것 같다. 대화라는건 또 얼마나 귀찮고 힘든일인지, 다들 방구석에서 키보드로만 이야기하니 갈등이 사라질리가 없 다. 몇년전만 해도 주요한 갈등 사안에 있어서는 토론프로그램에서 특집 편성을 하기도 하고, 네티즌끼리 영상 컨텐츠로 다루기도 했지만, 지금은 토론에 대한 프로그램은 거의 없고 한가지 의견만을 주장하는 영상밖에 없는 것같다.   이미 2-30대의 자발적인 의지로는 이 갈등을 해소하기 불가능한 지점에 이르렀다는 생각이든다. 제발 이제라도 정치권이던 언론이던 나서서 이 싸움이 잘못됐다는걸 좀 알려줬으며 좋겠다.  애초에 남녀갈등은 누가 더 꿀빤다 누가 더 차별받는다에 대한, 한쪽이 차별받으면 한쪽이 우세하고, 한쪽이 우세하면 한 쪽이 차별받는 영역이 아니다. 각자가 차별받는 부분에 대해 해결점을 제시해야하는 부분이다.   여성의 경력단절이 문제라고 하면 그걸 해결할 만한 방법을 찾으면 되고, 군복무에 따른 손해가 문제라고 한다면 그 역시 그에 대한 해결방안을 찾으면 된다.  애초에 하나를 해결한다고 한 성별이 차별받는, 그러한 시소에 놓여진 관계가 아니다. 제발 이 지독한 갈등이 어떤 방식에서라도 빨리 끝났으면 좋겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%94%EC%A6%98/",
        "teaser": null
      },{
        "title": "투자",
        "excerpt":"2021.05.17  저번주만 해도 빨간불이던 계좌가 파랗게 물들었다. 수익 날때 적당히 매도했어야 했는데… 얼마전에 천영록 대표가 매도타이밍에 대해 말한 영상을 시청했는데, 그 영상이 너무나 인상깊어서 매도 타이밍을 놓친 것 같기도 하다.   영상의 요지를 쉽게 축약하면, 손절은 빠르게, 익절은 최대한 늦게 해서 계좌에  파란불을 모두 지우고 빨간불만 남겨놓으라는 영상이었다. 이렇게 해야하는 이유를 몇가지 들었는데,  첫번째는 손절은 물론 괴로운 일이지만, 수익이 마이너스인 종목은 더 마이너스의 추세로 갈 확률이 높고 플로스인 종목은 더 플러스로 갈 확률이 높기때문이고, 두번째는 그러한 플러스 종목은 심리적 우위를 가져다 주어 조금 더 손절은 쉽게, 익 절은 어렵게 하게 될것이라는 이유에서다.   심지어 손절이 매우 고민되는 종목이라면 다시 팔고 바로 다시 사는 것도 추천했다. 물론 수수료와 세금이 들어가겠지만, 내 머리가 인식하는 손절액이 작아져 다시 심리적 우위를 가질 수 있을 뿐만아니라, 신기하게도 매도하는 순간 다시 사고 싶은 마음이 안들 경우에는 과감히 손절을 그대로 진행 할 수 있다는 것에서 그렇다는 것이었다.   물론 투자를 하다보면, 정말로 심리적 우위라는게 존재하기는 한다는걸 나도 안다. 나도 어떻게든 내 뇌를 속이려고 손실 이 난 계좌는 비용을 제외한채로 눈에 보이는 손실액을 더 낮춰보려고도 하고, 실제로 비트코인을 투자할때는 다시 팔고 바로 다시사거나, 평단가를 임의로 수정하기도 한다. ( 주식과 달리 코인은 내 평단가를 임의로 수정가능하다.)   하지만 아무래도 이러한 요지의 발언을 하신게 아무래도 장투로 가치투자를 하는 사람들에게  하는 말이었지 싶다. 천대표는 심지어 세자릿수 수익률만 가득찬 계좌를 만들어보라고 했는데, 단기~중기의 매매에서 세 자리 수익률을 계좌에 가득 채우는건 사실상 힘들지 싶다.   어쨌든 장기투자에 관점에서 말했던, 단기투자의 관점에서 말했던 간에, 손절은 과감히 하고 익절은 망설여야 하는건 맞는 말이기에 어느정도 적용할 부분이 있다 싶어 얼마전 수익이 날때 조금 더 욕심을 부렸던건데, 그게 독이 된것 같다. 근데 쓰다 보니까 이거 오늘 일기였는데 어째 점점 매매일지에다 올려야할 내용이 되가는것 같은데? 아무튼 이제는 머리좀 쓰고 매매한다고 생각했는데 아직도 뇌동매매 할때가 간혹 있는것 같다.   사실 매수한 종목들도 근거가 좀 부족하고, 계좌 자체를 어느정도의 전략을 갖고 기록하면서 수익권이 나오면 한번에 청산하는 습관을 들여야겠다.  요즘 드는 생각이 공부던 투자던 뭐던 기록하고 측정하여 개선할 방향이 좀 보이지 싶다.  그냥 머릿속으로만 이러이러하니까 이렇게 해야지~ 하고 계획하면 손해보는 게 좀 많은듯. 측정하는거 물론 귀찮고 시간많이 들지만, 그걸로 효율을 끌어올린다고 생각하고 아끼지 말아야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%88%AC%EC%9E%90/",
        "teaser": null
      },{
        "title": "사이킷런 (3) 손글씨 분류 모델 ",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런 (3) - 손글씨 분류 모델  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0-(3)-%EC%86%90%EA%B8%80%EC%94%A8-%EB%B6%84%EB%A5%98-%EB%AA%A8%EB%8D%B8/",
        "teaser": null
      },{
        "title": "일론머스크",
        "excerpt":"2021.05.18  요 몇일간 일론머스크 때문에 비트코인시장이 완전히 휘청했다.  나도 100만원정도 도지코인을 갖고있는데, 사실 도지코인은 그렇게 세게 안맞아서 별 타격은 없었다. 애초에 물려서 몇일에 한번 볼까 말까이기도 하고….   비트코인 자체에 가치가 있다고는 생각안하지만, 10퍼센트 정도는 포트폴리오에 추가할만하다고 생각했다. 10퍼센트정도면 괜찮겠지~ 하고 투자했는데 다시 생각 해보니까 비중이 좀 큰것 같기도 하다.  한 몇개월정도 보고 투자하기에 비트코인은 변동성은 좀 커도 나름 괜찮은 상품같다.  물론 중요한 점은 금액이 커지면 안된다는것. MDD가 너무 커서 큰 금액으로 한번 물리면, 아니 돈을 벌어도 잠을 잘 수가 없다. 실제로 비트코인에 큰 금액을 투자 하고있을 떄는 아침 여섯시도 전에 맨날 눈이 떠졌다. 이런 비트코인에 인생을 걸고 큰 금액을 투자하는 사람들은 지금 어떤 기분이 들까.  어제는 비트코인 폭락에 못견딘 사람 한명이 뛰어내리겠다고 한강 다리에 올라갔다가 다시 반등하는 비트코인을 보고 내려오는 웃지 못할 해프닝도 있었는데,  참 세상 돌아가는게 언제는 안 웃겼나 싶지만서도 요즘은 좀 오바지 싶다.   비트코인붐은 언제 끝날까. 어제 연준이 비트코인을 유동성 주머니로 사용하는게 아닐까라는 의견에 대한 영상을 봤는데, 물론 그분은 뇌피셜이라고 덧붙이며 말했지만 정황상 그게 맞다는 생각이 들었다.  나도 너무나 이상할정도로 비트코인에 대해 규제를 안하는 이 스탠스가 이상하다고 생각은 했는데,  그냥 사람들이 너무 많이사서 진짜 욕먹을까봐 규제 안하나? 이 정도 였다.  솔직히 이 엄청난 변동성에 올라탈 생각만 했지, 왜 규제를 안하는가에 대한 이유에 대한건 생각안해봤었다.  영상에 대해 간단히 설명하자면, 지금 연준에서 시행하고 있는 역사적 최대의 부양정책에서는 필연적으로 과한 유동성으로 인한 버블이 낄 수 밖에 없는데, 이러한 버블의 위험을 지금 비트코인이라는 유동성 주머니가 모두 받아 내주고 있다는 것이다. 시장에 공급되어 주식, 부 동산, 원자재로 향해야 할 이 유동성들이 전부 비트코인으로 쏠리고 있는 이 상황에서 굳이 이렇게 꿀같은 상황을 연준이 제재를 가할 필요가 없다. 심지어 이 유동성 주머니는 규제 해버리면 바로 꺼내 쓸 수 있어서, 테이퍼링이나 금리인상이 슬 슬 필요할 시기에는 바로 제재를 가해 이 곳으로 모여있는 유동성을 다시 꺼낼 수 도있는 상황, 심지어 비트코인의 폭락은 주식이나 부동산 폭락에 비해 시장이 받아들이는 충격도 아주 작으며 정부 입장에서는 책임도 없다시피한 수준이다. 따라서 연준과 미국 정부가 이 과열된 비트코인 시장을 하나의 유동성 주머니로써 사용하고 있는건 아닐까? 라는 가정 수준의 영상이었다.   물론 말한사람도 그냥 뇌피셜이고 추측이라 했지만,  솔직히 정황상 미국은 비트코인을 왜 제재하지않는가? 에대한 가장 논리적이고 타당한 이유가 아닐까 싶다.  또 코인얘기를 하자면 일론머스크를 빼놓을 수 없는데  진짜 세계 1위부자(물론 지금은 아니지만)이자 성공한 사업가가 저런식으로 행동하는게  너무 웃기긴하다. 역시 자유의 나라 미국이라 그런가, 정부가 싫어하는짓만 골라서 하는데도 의외로 하는짓에 비해 미국 정부한테 별로 안혼나는듯 하다.   사실 자율주행사업이나 항공우주사업이나 결국에는 정부의 눈치를 봐야할 수 밖에 없는 사업인데  저렇게 밉보이는 짓만 골라서 하다가 진짜 골로 가는건 아닌지, 물론 내가 세계 1위부자 걱정할 처지는 아니지만 요즘은 진짜 선을 넘는것 같아 걱정이다. 물론 저러고 뒤에서는 바이든앞에서 무릎꿇고 있을지 모르겠다.  약간 주류들, 기성세대들에게 반발하는 이미지를 가져감으로써 어떠한 사업상의 이득을 보려고 하는것같은데  갑자기 비트코인을 테슬라 결제에 사용하게 한다더니 또 돌연 취소해서 주가를 폭락시키고, 도지코인을 언급해서  가격을 오지게 띄우더니 또 무슨 도지-x 인공위성을 띄우고 결제 수단을 도지코인으로 한단다.  이번에 비트코인 결제 지원을 취소한 이유를 비트코인의 엄청난 전기사용량으로 인한 환경 문제를 들던데,  전력소모가 적은 코인으로 선택한게 도지코인일수도 있겠다 싶다는 생각이 들었다. 이미 3년여전부터 개발자들한테 지원 을 했고 계속 개발자들과 컨택했다는 사실이 밝혀졌는데, 설마 이러한 전력소모가 어마어마한 비트코인의 대체제로 코인 을 찾던 도중 도지 코인을 찾게 되었고, 이를 실제 결제수단으로 사용하기위해 계속 언급하고 띄워 도지코인의 네트워크를 형성하기 위한 초석이었다면??   물론 그냥 뇌피셜이고 개소리지만, 일론머스크라면 그럴수도 있겠다는 생각이 든다. 나보다 똑똑한 사람이니까 다 생각이 있겠지…   마침 일론머스크에 관한 내용을 쓰고있는데  아빠가 주문한 테슬라 모델3가 2분기 인도가 힘들다는 카톡이 왔다. 미안해 욕안할게 머스크 차 좀 빨리줘~~~  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%BC%EB%A1%A0%EB%A8%B8%EC%8A%A4%ED%81%AC/",
        "teaser": null
      },{
        "title": "반복",
        "excerpt":"2021.05.22  왜 사람은 같은 실수를 반복하게 되는걸까…  방금 눈앞에서 20만원이 사라졌다. 아 김연준 개패고싶네  안한다 해놓고 또하고 안한다 해놓고 또하고 중독성이 거의 뭐 도박급이다.  심지어 한번 잃으면 그거 복구하려고 눈에 불을켜고 막 도파민이 분비 되는 느낌이 들면서 돌아버리겠다.  주식으로 건강하게 잘 투자 하고있었구만 코인으로 순식간에 날려버리다니  원칙을 세웠으면 지켜야되는데 참 말을 안듣는다. 이렇게 일기를 쓰고 또 나중에 또 하겠지 그러기 위해선 아예 내가 실수할 환경자체에 놓이는 상황을 만들지 말아야한다.  나를 제발 믿지 말자.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B0%98%EB%B3%B5/",
        "teaser": null
      },{
        "title": "아이패드",
        "excerpt":"2021.05.24  아이패드를 질렀다.  m1이 들어가서 도저히 참지못하고 질러버렸다. 사실 사봤자 유튜브랑 필기밖에 안하는데 대체 왜…   wwdc때 아이패드 뭐 새로운 기능이라도… 발표해주겠지…  램도늘리고 m1칩까지 박아놓고 ipadOS만 쓰라는건 말도 안된다.   요즘 거기다가 자꾸 스마트 키보드 까지 발표하는걸보니 심상치가 않다.  팀쿡아~~   아이패드도 맥os비스무리하게 쓰게 해줘라~~ 부탁할게~~  아 맞다 오늘부터 오늘일기 챌린지 15000원짜리 시작이다. 꾸준히 써야지. 벌어서 애플펜슬 사는데 보태야겠다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%95%84%EC%9D%B4%ED%8C%A8%EB%93%9C/",
        "teaser": null
      },{
        "title": "사이킷런 (4) 중고차 가격예측",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런 (4) 중고차 가격예측  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0-(4)-%EC%A4%91%EA%B3%A0%EC%B0%A8-%EA%B0%80%EA%B2%A9%EC%98%88%EC%B8%A1/",
        "teaser": null
      },{
        "title": "블로그",
        "excerpt":"2021.05.26  어제 거의 다 써놓은 중고차 가격예측모델 공부 글을 다 날려버렸다. 개열받네.   네이버 블로그 자동저장 기능을 너무 맹신하고 맨날 글쓴채로 노트북 덮어놓다가 당했다.   진짜 거의 다써서 한 세줄만 더 쓰면 됐었는데…  물론 어차피 공부할거 다했고 블로그에 글 올리던 안올리던 큰 상관은 없지만 이거 나름 쌓이는 맛에 뿌듯한맘으로 공부하는건데 다 날리니까 화가난다.   내가 다시 써서 해놓는다 꼭 ᅳᅳ  오늘 이거 다시 써놓고   시황 분석좀 하고  다음 분석할 데이터셋 하나 찾아놓고 하루 마무리 해야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B8%94%EB%A1%9C%EA%B7%B8/",
        "teaser": null
      },{
        "title": "숏",
        "excerpt":"2021.05.28  진짜 숏 다시는 안잡는다….  물론 숏이라기보다는 변동성을 산거지만 숏이랑 다를바없는 포지션이다.   인플레를 앞두고 그래도 17-18정도에서 바닥은 지지 해줄줄 알았는데 왜 지하실까지 가냐….   숏포지션은 대부분 손실이 야금야금나고 수익이 한번에 치솟게 되는데, 이번에 수익 났을때 청산을 안해서 너무 고점에 물 려있다보니까 어느정도 확률적우위가 있다고 생각함에도 누적되는 손해가 너무 겁이난다.   오늘 밤에 발표되는 pce가 어느정도 이 포지션의 분수령이 될텐데, 아무래도 지표가 좋게나온다면 속쓰려도 여기서 잘라 야되지 싶다. 앞으로 하락배팅은 진짜 생각많이하고 신중에 신중을 기해서 매수타이밍도 뒤로 한참 미뤄서 해야겠다는 생 각이든다.   진짜 앞으로는 스프레드 딱 잡고 포지션 청산해가면서 매매 할테니까 한번만 살려주세요….  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%88%8F/",
        "teaser": null
      },{
        "title": "오늘일기",
        "excerpt":"2021.05.31  아 쓰고싶을 때 써야 재밌는건데   오늘일기 이거때문에 맨날 강제로 쓰니까 나의 행복을 하나 잃은 기분이다. 15000원에 나의 행복을 뺏어가다니  책임져라 네이버 ᅳᅳ   생각나는 글감 있을때만 쓰고싶은데 맨날 쥐어짜니까 글이 안나온다.  나중에 취업이나 뭐 지원할때 블로그가 도움이 될것같다는 생각이 들었다.   원래는 그렇게까지 생각을 해서 블로그에 공부한거 올린건 아니었는데,  공부한 내용을 깃허브나 블로그를 꾸준히 쓰면 나중에 어디 지원할때 실제로 도움이 많이 된다고한다. 공부글좀 더 열심히 써야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%98%A4%EB%8A%98%EC%9D%BC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "채권",
        "excerpt":"이 글은 유튜브 ‘월가아재’ 영상을 보고 공부한 내용을 기록한 글입니다.   채권이란?  이자를 주는 증권  발행주체 : 국가(국채), 회사 (회사채), 지자체 (지방채)  -&gt; 어떤 회사의 주식을 사면 그 회사에 대한 주주(소유자)가 되는 것이고, 어떤 회사의 채권을 사면 그회사에 대한 채권자 (빚) 가 되는 것.   채권의 방식  채권의 방식은      무이자 할인채 (zero coupon bond) : 이자없이 발행시 할인해서 발행   ex) 100달러 채권을 95달러에 팔고 만기때 100달러를 줌      이자 지급 채권: 액면가에 판매해서 이자를 주고 만기 때 액면가를 돌려줌   ex) 액면가 100달러 채권을 판매하여 6개월마다 2.5달러를 주고 만기 때 102.5달러를 상환      다양한 방식들 : 고정금리 (Fixed Rate), 변동금리(Floating Rate), 인플레 연동, 영구채, 각종 옵션이 포함된 채권 등등     채권투자 수익       은행 예금 수익 = 이자 수익   채권 투자 수익 = 이자 수익 + 자본손익   주식 투자 수익 = 배당 수익 + 자본손익   ​  이렇게 채권은 예금과 주식의 중간에 위치한 자산.   채권은 가격이 떨어져도 만기가 된다면 액면가 그대로를 돌려 받을 수 있다.   그러나 부도/자산의 경우는 액면가도 손실이 가능하다 (그럼에도 주식보다는 보통 상환순위가 우선이기 때문에, 부도시에 처분하는 자산을 주식보다 먼저 상환받을 수 있다.)   따라서 원금 손실을 피하고싶은 은퇴에 가까운 투자자들에게 필수적인 상품인데,  이러한 특성때문에 경기 침체 시기에 좋은 자산으로 분류된다.(주식과 역의 상관관계)   하지만 이러한 특성들은 지나치게 채권을 일반화한 내용인데,   이러한 채권내에서도 다양한 채권이 존재한다. 어떠한 채권은 주식보다도 위험할수도 있고, 경제가 호황일때 같이 이익을 보는 채권도 있다.   채권은 크게 우량채권과 하이일드 (High-yield)채권으로 분류되는데, 신용평가 등급 BBB이상을 우량채라 하고,   그 미만을 하이일드 채권이라 한다.   우량 채권들은 확실히 주식시장이 침체 될때에도 안정적인 수익률을 가져다준다.   그러나 하이일드 채권은 주식시장과 비슷한 움직임을 보이기도 하는데,   어떠한 채권은 수익률이 주식을 넘어서기도 한다.   채권 이자율  회사채 이자율은 무위험 이자율(국채) + 리스크 프리미엄  리스크 프리미엄 = 리스크가 높을수록 이자도 높다.      신용도   신용이 높은 주체일수록 저금리로 대출 가능, 따라서 채권이자가 가장 낮음      만기   만기가 길수록 각종 리스크에 노출되므로 이자 상승      경제 상황   경제 흐름이 안좋을수록 부도 위험이 높아 이자가 높음   이러한 금리는 시장 금리의 변동에 따라 채권가격이 그 반대로 움직이는데,  예를들면 이해가 쉽다.   ​  한 회사가 100달러 액면가에 매년 4퍼센트의 이자, 4달러를 주는 채권을 발행했는데,   만약 시중금리가 1퍼센트 상승한다면 새로 발행되는 다음 채권은 5퍼센트, 5달러의 이자를 주어야 하는데   이렇게 되면 원래의 4퍼센트 채권의 수요가 없어지기 때문에 가격이 100달러보다 낮게 거래되게 된다.   예를들어 해당 채권의 가격이 80달러로 낮아진다면, 새로 발행된 채권과 동일한   5퍼센트의 수익을 올릴 수 있게 된다.   하지만 이러한 가정은 실제와는 조금 다른데, 채권에는 만기에 받을 수 있는 금액이 있기 때문에,   실제로는 위의 예처럼 20퍼센트씩 하락하지는 않는다.   예를들어 2년만기 100달러 채권이라 할때 4퍼센트 채권은 2년 후 만기때 108달러(쉬운 이해를 위해 복리는 무시한다.)를 받게되고, 5퍼센트 채권은 2년 후 만기때 110달러를 받게되므로 4퍼센트 채권은 98달러의 가격이 되면 5퍼센트 채권과 같은 가치를 갖게 된다. 따라서 대략 금리가 1퍼센트 상승하면 채권가격은 1퍼센트 하락한다고 볼 수 있다.   이때 이 가격민감도는 채권의 만기가 많이 남아있을수록 더 높은데, 이러한 개념을 Duration이라한다.   이러한 채권의 가격을 결정하는 시중금리에 영향을 주는 요인들은 세가지가 있는데,           중앙은행이 정하는 기준 금리            인플레이션 및 인플레이션 기대심리            돈에 대한 수요(대출, 투자)와 공급 (유동성)       ​   채권이 좋은 시기는 언제일까?  보통 사람들은 저금리, 저성장 시대기 때문에 예금이자나 채권이자가 낮아 주식말고는   수익을 많이 내기가 힘들다고 생각한다. 하지만 채권과 주식의 가격은 금리 자체보다는 금리 변화에 민감하다.   작년부터 올해로 이루어진 상승은 낮은금리에서 연준이 금리를 제로금리 수준으로 낮추었기 때문에 주가의 상승폭이 컸던 것이지, 저금리 자체가 주가의 상승을 불러일으킨건 아니다.   ​  고성장 고금리 시대와 저성장 저금리 시대 두개만을 놓고보면 채권의 매력도가 높은건 사실이지만,   고성장 고금리 시대건 저성장 저금리 시대건 그 상황 자체의 사이클안에서의 경기 변화에 따른 금리 변화가 어떻게 되는지가 중요하다.     ​  위 이미지는 2018년 PIMCO 라는 투자회사에서 만든 경기 싸이클에 대한 금융상품들의 매력도를 나타낸 인포그래픽이다. 하지만 주의 할점이 있는데,   ​  왼쪽하단의 저성장 저인플레 부분을 보면 과거에는 일반적인 경제 침체시기로, 그림에는 주식은 부정적, 채권은 긍정적, 원자재는 부정적으로 되어있다. 몇년전의 경우 저성장과 저인플레가 오면 연준은 금리를 낮추고 다시 경기가 살아날때까지 기다리는 경향이 컸기 때문에 주식의 매력도가 낮아졌지만, 최근에 바뀐 연준의 스탠스 때문에 현재의 기조에서는 만약  저성장 저인플레가 온다면 성장주가 가장 매력적이게 되었다. 저성장 저인플레에서는 연준이 곧 돈을 풀것이기 때문이다.   위의 사이클대로 보자면 채권은 경기 침체 시기 또는 경기가 침체에서 회복하기 시작할때에,   즉, 인플레 압력이 낮을 때, 성장속도가 느릴때에 이렇게 두가지인데 이럴경우 연준은 금리를 내릴 가능성이 커니고, 따라서 시중금리 하락 가능성이 높을수록 유리한 채권의 매력도가 증가한다. 하지만 여기서 주의해야 할점은   지금 말하는 채권은 ‘국채’와 ‘우량채’에 한해서이다. 하이일드 채권은 주식과 비슷한 움직임을 보이기 때문에 저성장 저인플레에서는 하락한다.   ​  개별채권의 금리는 국채금리 +가산금리로 이루어지는데, 여기서 가산금리는 개별채권의 가격에서   무위험 이자율인 국채금리를 뺀 값으로, 신용도가 낮아 위험도가 큰 상품일수록 가산금리가 높다.   따라서 가산금리는 시장위험의 척도로 볼 수 있다.   실제로 2008년 금융위기때, 가산금리는 주가 폭락전 어느정도 상승하면서 선행지표로서의 의미를   나타내기도 했다.   또 이러한 지표중 하나로 CDS가 있는데 CDS는 신용리스크를 회피하기 위한 보험상품으로   CDS매수자는 CDS매도자에게 일정 금액을 정기적으로 지불하고, CDS매도자는 기초자산 상품이 부도나 파산했을때, 큰금액을 지불해준다.따라서 부도 위험이 커지거나 시장의 리스크가 커지면, CDS스프레드는 높아진다.   다시 채권으로 돌아와서 그럼 채권을 만약 매매한다고 했을 때 고려해야 할 정보들을 생각해보자.   먼저 가장 먼저 고려할것은 신용도이다. 현재 경기가 어떤 사이클에 위치해있고, 이에 따라 우량채를 매수할것인지,   하이일드 채권을 매수할것인지 선택해야 하고 두번째로는 만기를 고려해보아야 한다.   채권에서의 만기는 주식에서의 Beta 개념으로, 만기가 길수록 만기때 받을 수 있는 액면가와 이자보다는 현재 채권의 가격이 더 중요해지기 때문에 만기가 긴 채권의 변동성은 주식시장에 버금가는 변동성을 보인다.   이러한 두가지를 생각했다면, 채권이 갖는 리스크에 대해서 생각해보자.   간략하게 이 리스크를 4가지로 나눌 수 있는데,      시중 금리의 상승으로 인한 채권 가격 하락   앞서 설명 했듯이, 시중금리의 상승은 다음 채권의 이자율을 높이기 때문에 이미 발행된 채권의 가격은 하락한다.      시중 금리의 하락으로 인한 재투자 리스크   만기가 되면 약속된 이자를 받고 다음 채권을 또 매수해야 하는데, 금리가 하락하면 이전과 동일한 이자를 보장하는   상품에 투자할 수 없기 때문에 수익률이 낮아진다. 이를 재투자 리스크라 한다.      기업의 부도/파산   말그대로 해당 채권의 기업이 부도/파산으로 인해 채무를 이행할 여력이 없어지는 리스크를 말한다.      기업의 신용등급 하락   특히 BBB등급 채권의 경우, 하나만 신용등급이 하락해도 기관의 대량매도세가 나올 수 있는데   기관의 경우는 BBB등급 이상의 채권만 보유해야하는 조건등이 있는 경우가 많아, BBB등급 채권은 한등급의 신용도만 하락해도 기관의 대량매도세로 인해 가격이 크게 하락할 수 있다.   이렇듯 채권은 국제 경제에 미치는 영향이 매우 크고, 채권들의 몇몇 지표는 시장의 리스크 센티먼트를 알 수 있는 지표기 때문에 이것이 채권을 직접 매매하지 않더라도 채권의 동향을 예의주시해야할 이유이다.  ","categories": ["finance"],
        "tags": ["금융","채권","주식"],
        "url": "/finance/%EC%B1%84%EA%B6%8C/",
        "teaser": null
      },{
        "title": "차긁음",
        "excerpt":"2021.06.02  약 3년여전 제주도에서 차를 도랑에 빠뜨린이후로 오늘 또 하나의 업적을 달성했다.   아빠차 끌고나갔다가 주차장에서 옆휀더를 벽에다 긁었다. 그래도 다행이라면 항상 대물이나 대인사고는 안낸다는 점이 라고 해야하나…   핑계좀 대자면 주차장이 무슨 자동차를 엘레베이터에서 넣어가지고 층을 이동하는 진짜 듣도보도 못한 방식이어서 거기다 차 넣다가 긁었다.   근데 진짜 차사고는 날때마다 참 기분이 쇼킹하다   나이먹고는 어릴때 진짜 큰 잘못을 했을때 느끼던 그 가슴철렁하고 와 진짜 x됐다하는 감정을 느낄일이 별로 없는데, 차긁 거나 사고나면 진짜 몰컴하다 걸린 초딩마냥 가슴이 쿵쾅쿵쾅뛴다.   오늘 긁어서 9월에 아빠차 새로나오면 끌고 놀러가려고 했던 계획은 물거품이 되었다….  하긴 어차피 바꿀차라 아빠가 그냥 이눔시끼 소리하고 끝냈지 저거 새차였으면 난 뒤졌다.   그래도 9월에 차나올때쯤이면 아빠가 까먹지않을까? 몰래라도 내가 끌고나간다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%B0%A8%EA%B8%81%EC%9D%8C/",
        "teaser": null
      },{
        "title": "[BOJ] 2720 세탁소 사장 동혁 (Python3)",
        "excerpt":"문제  미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다.   동혁이는 리암에게 실망했다.   리암은 거스름돈을 주는 것을 자꾸 실수한다.   심지어 $0.5달러를 줘야하는 경우에 거스름돈으로 $5달러를 주는것이다!   어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다.   거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, $0.25)의 개수, 다임(Dime, $0.10)의 개수, 니켈(Nickel, $0.05)의 개수, 페니(Penny, $0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 $5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, $1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1&lt;=C&lt;=500)   출력  각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   3 124 25 194 예제 출력 1   4 2 0 4 1 0 0 0 7 1 1 4   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 test = int(input()) change = [] def get_change(change):     quarter = change//25     dime = change%25//10     nickel = change%25%10//5     penny = change%25%10%5//1          return [quarter,dime,nickel,penny]  result = [] for i in range(test):     change.append(int(input()))     result.append(get_change(change[i])) for i in range(test):     for j in range(4):         print(result[i][j], end=' ')     print(end = '\\n')                  1 2 3 4 5 2 124 25 4 2 0 4  1 0 0 0    #  ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%84%B8%ED%83%81%EC%86%8C-%EC%82%AC%EC%9E%A5-%EB%8F%99%ED%98%81/",
        "teaser": null
      },{
        "title": "[Programmers] 신규 아이디 추천 (Python3)",
        "excerpt":"문제  카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.  다음은 카카오 아이디의 규칙입니다.   아이디의 길이는 3자 이상 15자 이하여야 합니다.  아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.  단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.   “네오”는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.   신규 유저가 입력한 아이디가 new_id 라고 한다면,                  1단계       new_id의 모든 대문자를 대응되는 소문자로 치환합니다.                 2단계       new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.                 3단계       new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.                 4단계       new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.                 5단계       new_id가 빈 문자열이라면, new_id에 “a”를 대입합니다.                 6단계       new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.                 만약, 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.                         7단계       new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.           예를 들어, new_id 값이 “…!@BaT#*..y.abcdefghijklm” 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다.   1단계 대문자 ‘B’와 ‘T’가 소문자 ‘b’와 ‘t’로 바뀌었습니다.  “…!@BaT#..y.abcdefghijklm” → “…!@bat#..y.abcdefghijklm”     2단계 ‘!’, ‘@’, ‘#’, ‘’ 문자가 제거되었습니다.  “…!@bat#..y.abcdefghijklm” → “…bat..y.abcdefghijklm”  3단계 ‘…‘와 ‘..’ 가 ‘.’로 바뀌었습니다.  “…bat..y.abcdefghijklm” → “.bat.y.abcdefghijklm”     4단계 아이디의 처음에 위치한 ‘.’가 제거되었습니다.  “.bat.y.abcdefghijklm” → “bat.y.abcdefghijklm”     5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.  “bat.y.abcdefghijklm” → “bat.y.abcdefghijklm”     6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.  “bat.y.abcdefghijklm” → “bat.y.abcdefghi”      7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.  “bat.y.abcdefghi” → “bat.y.abcdefghi”   따라서 신규 유저가 입력한 new_id가 “…!@BaT#*..y.abcdefghijklm”일 때, 네오의 프로그램이 추천하는 새로운 아이디는 “bat.y.abcdefghi” 입니다.   신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, “네오”가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.   제한사항  new_id는 길이 1 이상 1,000 이하인 문자열입니다.  new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.  new_id에 나타날 수 있는 특수문자는 한정됩니다.   입출력 예   1 2 3 4 5 6 no\tnew_id\tresult 예1\t\"...!@BaT#*..y.abcdefghijklm\"\t\"bat.y.abcdefghi\" 예2\t\"z-+.^.\"\t\"z--\" 예3\t\"=.=\"\t\"aaa\" 예4\t\"123_.def\"\t\"123_.def\" 예5\t\"abcdefghijklmn.p\"\t\"abcdefghijklmn\"  입출력 예에 대한 설명  1 2 입출력 예 #1 문제의 예시와 같습니다.  1 2 3 4 5 6 7 8 9 입출력 예 #2 7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다. 2단계 \"z-+.^.\" → \"z-..\" 3단계 \"z-..\" → \"z-.\" 4단계 \"z-.\" → \"z-\" 5단계 변화 없습니다. 6단계 변화 없습니다. 7단계 \"z-\" → \"z--\"  1 2 3 4 5 6 7 8 9 입출력 예 #3 7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다. 2단계 \"=.=\" → \".\" 3단계 변화 없습니다. 4단계 \".\" → \"\" (new_id가 빈 문자열이 되었습니다.) 5단계 \"\" → \"a\" 6단계 변화 없습니다. 7단계 \"a\" → \"aaa\"  1 2 입출력 예 #4 1단계에서 7단계까지 거치는 동안 new_id(\"123_.def\")는 변하지 않습니다. 즉, new_id가 처음부터 카카오의 아이디 규칙에 맞습니다.  1 2 3 4 5 6 7 8 9 입출력 예 #5 1단계 변화 없습니다. 2단계 변화 없습니다. 3단계 변화 없습니다. 4단계 변화 없습니다. 5단계 변화 없습니다. 6단계 \"abcdefghijklmn.p\" → \"abcdefghijklmn.\" → \"abcdefghijklmn\" 7단계 변화 없습니다. solution.py   코드   1 new_id = \"=.=\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import re  def solution(new_id):     a = re.sub('[^a-z\\d\\-\\_\\.]','', new_id.lower())     a = re.sub('[.]+','.', a)     a = re.sub('^[.]','',a)     if(a == ''):         a = 'a'     a = a[0:15]     a = re.sub('[.]$','',a)     if(len(a)&lt;=2):         while(len(a)&lt;3):             a = a + a[-1]              return a   1 solution(new_id)   1 'aaa'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/",
        "teaser": null
      },{
        "title": "[Programmers] 크레인 인형뽑기 게임 (Python3)",
        "excerpt":"문제  게임개발자인 “죠르디”는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.  “죠르디”는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.   게임 화면은 “1 x 1” 크기의 칸들로 이루어진 “N x N” 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 “5 x 5” 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 “1 x 1” 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.   만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.   크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)  게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.   제한사항  board 배열은 2차원 배열로 크기는 “5 x 5” 이상 “30 x 30” 이하입니다.  board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.  0은 빈 칸을 나타냅니다.  1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.  moves 배열의 크기는 1 이상 1,000 이하입니다.  moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.   입출력 예  |board|\tmoves|\tresult|  |:—:|:—:|:—:|  |[[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]\t|[1,5,3,5,1,2,1,4]|\t4|   입출력 예에 대한 설명  입출력 예 #1  인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.   1 2 board = [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]\t moves = [1,5,3,5,1,2,1,4]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solution(board, moves):     a = [0]     num = 0     for i in moves:         for j in range(0,len(board[0])):             if(board[j][i-1]&gt;0):                 if(board[j][i-1] == a[-1]):                     a.pop()                     num +=2                     board[j][i-1] = 0                 else:                     a.append(board[j][i-1])                     board[j][i-1] = 0                 break             else:pass     return num   1 solution(board, moves)   1 2 3 4 5 6 7 8 [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 5, 0, 1], [0, 2, 4, 0, 2], [0, 5, 1, 3, 1]] [0, 4, 2, 3, 4]      4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%81%AC%EB%A0%88%EC%9D%B8-%EC%9D%B8%ED%98%95%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[Programmers] 키패드 누르기 (Python3)",
        "excerpt":"문제  스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.  이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.  맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.  엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.   왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.     오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.     가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.     만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.   순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.   제한사항  numbers 배열의 크기는 1 이상 1,000 이하입니다.      numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다.      hand는 “left” 또는 “right” 입니다.      “left”는 왼손잡이, “right”는 오른손잡이를 의미합니다.     왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.   입출력 예  |numbers|\thand|\tresult|  |:—:|:—:|:—:|  |[1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]\t|”right”\t|”LRLLLRLLRRL”|  |[7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]\t|”left”\t|”LRLLRRLLLRR”  |[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\t|”right”\t|”LLRLLRLLRL”|   입출력 예에 대한 설명  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 입출력 예 #1 순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다. 왼손 위치\t오른손 위치\t눌러야 할 숫자\t사용한 손\t설명 *\t#\t1\tL\t1은 왼손으로 누릅니다. 1\t#\t3\tR\t3은 오른손으로 누릅니다. 1\t3\t4\tL\t4는 왼손으로 누릅니다. 4\t3\t5\tL\t왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5\t3\t8\tL\t왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다. 8\t3\t2\tR\t왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다. 8\t2\t1\tL\t1은 왼손으로 누릅니다. 1\t2\t4\tL\t4는 왼손으로 누릅니다. 4\t2\t5\tR\t왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. 4\t5\t9\tR\t9는 오른손으로 누릅니다. 4\t9\t5\tL\t왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5\t9\t-\t-\t 따라서 \"LRLLLRLLRRL\"를 return 합니다.  1 2 입출력 예 #2 왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 \"LRLLRRLLLRR\"이 됩니다.  1 2 입출력 예 #3 오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 \"LLRLLRLLRL\"이 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import numpy as np def solution(numbers, hand):     left = [[3,0]]     right = [[3,2]]     wh = []     phone = [[1,2,3],              [4,5,6],              [7,8,9],              ['*',0,'#']]      for i in numbers:         for j in range(0,4):             if i in phone[j]:                 k = phone[j].index(i)                 if k == 0:                     left.append([j,k])                     wh.append('L')                                          break                 if k == 2:                      right.append([j,k])                     wh.append('R')                                         break                 else:                     if abs(right[-1][0]-j)+abs(right[-1][1]-k)&gt;abs(left[-1][0]-j)+abs(left[-1][1]-k):                         left.append([j,k])                         wh.append('L')                          break                     if abs(right[-1][0]-j)+abs(right[-1][1]-k)&lt;abs(left[-1][0]-j)+abs(left[-1][1]-k):                         right.append([j,k])                         wh.append('R')                                                 break                     else:                         if hand == 'right':                             right.append([j,k])                             wh.append('R')                                                      break                         else:                             left.append([j,k])                             wh.append('L')                                                     break                              else: pass                                       return \"\".join(wh)    1 2 numbers =[1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] hand = 'right'   1 solution(numbers, hand)   1 'LRLLLRLLRRL'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%82%A4%ED%8C%A8%EB%93%9C%EB%88%84%EB%A5%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 2016년 (Python3)",
        "excerpt":"문제 설명  2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT  입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요.   제한 조건  2016년은 윤년입니다.  2016년 a월 b일은 실제로 있는 날입니다.   (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)   입출력 예  |a|b|result|  |:—:|:—:|:—:|  |5|\t24|\t“TUE”|   코드   1 2 3 import datetime  datetime.date(2016,a,b).weekday()   1 3   1 2 3 4 5 import datetime def solution(a, b):     day = ['MON','TUE','WED','THU','FRI','SAT','SUN']          return day[datetime.date(2016,a,b).weekday()]   1 solution(a,b)   1 'TUE'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/2016%EB%85%84/",
        "teaser": null
      },{
        "title": "[Programmers] 3진법 뒤집기 (Python3)",
        "excerpt":"문제 설명  자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.  제한사항  n은 1 이상 100,000,000 이하인 자연수입니다.   입출력 예  |n|result|  |:—:|:—|  |45|\t7|  |125\t|229|   입출력 예 설명   입출력 예 #1  답을 도출하는 과정은 다음과 같습니다.  n (10진법)\tn (3진법)\t앞뒤 반전(3진법)\t10진법으로 표현  45\t1200\t0021\t7  따라서 7을 return 해야 합니다.   입출력 예 #2  답을 도출하는 과정은 다음과 같습니다.  n (10진법)\tn (3진법)\t앞뒤 반전(3진법)\t10진법으로 표현  125\t11122\t22111\t229  따라서 229를 return 해야 합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solution(n):     a = []     num = 0     while n&gt;0:         if n%3 == 0:             n = n/3             a.append(0)          if n%3 == 1:             n = (n-1)/3             a.append(1)          if n%3 == 2:             n = (n-2)/3             a.append(2)     for i in range(0,len(a)):         num += a[len(a)-1-i]*pow(3,i)     return num   1 2 n = 45 solution(n)   1 7   1 int('0021',3)   1 7   n 진수 만드는 코드   1 2 3 4 5 tmp = ''     while i:         tmp += str(i % n)         i = i // n    n진수는 그냥 int를 이용해서 바로 10진수로 출력 가능하다.(tmp는 str이어야함.)   1 answer = int(tmp, 3)  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 가운데 글자 가져오기 (Python3)",
        "excerpt":"문제 설명  단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요.   단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.   제한사항  s는 길이가 1 이상, 100이하인 스트링입니다.   입출력 예  |s\t|return|    |:—:|:—:|  |”abcde”\t|”c”|  |”qwer”\t|”we”|   1 2 3 4 5 6 7 8 9 10 def solution(s):           if len(s)%2 != 0:         n = len(s)//2         print(str(s[n]))     else:         n = len(s)/2         print(s[int(n)]+s[int(n-1)])                 1 2 s = \"abcdef\" solution(s)   1 dc   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%80%EC%9A%B4%EB%8D%B0-%EA%B8%80%EC%9E%90-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 두 개 뽑아서 더하기 (Python3)",
        "excerpt":"문제 설명  정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.  제한사항  numbers의 길이는 2 이상 100 이하입니다.  numbers의 모든 수는 0 이상 100 이하입니다.   입출력 예  1 2 3 numbers\t    result [2,1,3,4,1]\t[2,3,4,5,6,7] [5,0,2,7]\t[2,5,7,9,12]   입출력 예 설명  1 2 3 4 5 6 7 8 입출력 예 #1 2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.) 3 = 2 + 1 입니다. 4 = 1 + 3 입니다. 5 = 1 + 4 = 2 + 3 입니다. 6 = 2 + 4 입니다. 7 = 3 + 4 입니다. 따라서 [2,3,4,5,6,7] 을 return 해야 합니다.  1 2 3 4 5 6 7 입출력 예 #2 2 = 0 + 2 입니다. 5 = 5 + 0 입니다. 7 = 0 + 7 = 5 + 2 입니다. 9 = 2 + 7 입니다. 12 = 5 + 7 입니다. 따라서 [2,5,7,9,12] 를 return 해야 합니다.   코드   1 2 3 4 5 6 7 8 9 from itertools import combinations  def solution(numbers):     a = []     n = list(combinations(numbers,2))     for i in range(0, len(n)):         a.append(sum(n[i]))          return sorted(list(set(a)))   1 solution(numbers)   1 2 3 4 5 6 7 [(2, 1), (2, 3), (2, 4), (2, 1), (1, 3), (1, 4), (1, 1), (3, 4), (3, 1), (4, 1)]      [2, 3, 4, 5, 6, 7]   1 numbers = [2,1,3,4,1]  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%91%90-%EA%B0%9C-%EB%BD%91%EC%95%84%EC%84%9C-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 내 p와 y의 개수 (Python3)",
        "excerpt":"문제설명  대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.  예를 들어 s가 “pPoooyY”면 true를 return하고 “Pyy”라면 false를 return합니다.   제한사항  문자열 s의 길이 : 50 이하의 자연수  문자열 s는 알파벳으로만 이루어져 있습니다.   입출력 예  1 2 3 s\t        answer \"pPoooyY\"\ttrue \"Pyy\"\t    false   입출력 예 설명  입출력 예 #1      ‘p’의 개수 2개, ‘y’의 개수 2개로 같으므로 true를 return 합니다.     입출력 예 #2     ‘p’의 개수 1개, ‘y’의 개수 2개로 다르므로 false를 return 합니다.   코드   1 s=\"ytp\"   1 2 3 4 5 6 7 8 def solution(s):     s = s.lower()     if s.count('p') == s.count('y'):             return True     if len(s)== 0:         return True     else:          return False   1 solution(s)   1 True   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-p%EC%99%80-y%EC%9D%98-%EA%B0%9C%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] 비밀지도 (Python3)",
        "excerpt":"문제  비밀지도  네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.           지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.            전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 “지도 1”과 “지도 2”라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.            “지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.            암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.       secret map  네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.   입력 형식  입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.  1 ≦ n ≦ 16  arr1, arr2는 길이 n인 정수 배열로 주어진다.  정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.   출력 형식  원래의 비밀지도를 해독하여 ‘#’, 공백으로 구성된 문자열 배열로 출력하라.   입출력 예제  1 2 3 4 5 6 7 8 9 10 11 매개변수\t값 n\t      5 arr1\t [9, 20, 28, 18, 11] arr2\t [30, 1, 21, 17, 28] 출력\t    [\"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\"]  매개변수\t값 n\t      6 arr1\t [46, 33, 33 ,22, 31, 50] arr2\t [27 ,56, 19, 14, 14, 10] 출력\t    [\"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \"]  코드   1 2 3 n = 6 arr1 = [46, 33, 33 ,22, 31, 50] arr2 = [27 ,56, 19, 14, 14, 10]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def solution(n,arr1,arr2):     num = []     all_map = []     for i,j in zip(arr1, arr2):         num.append(bin(i|j)[2:n+2])          for i in num:         temp = \"\"         i = list(i)          for j in range(0, n):             if len(i) &lt; n:                 i.insert(0,'0')                  for j in range(0,n):             if i[j] == '1':                 temp+=\"#\"             else:                 temp+=\" \"         all_map.append(temp)                               return all_map   1 solution(n,arr1,arr2)   1 ['######', '###  #', '##  ##', ' #### ', ' #####', '### # ']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B9%84%EB%B0%80%EC%A7%80%EB%8F%84/",
        "teaser": null
      },{
        "title": "[Programmers] 소수 찾기 (Python3)",
        "excerpt":"문제 설명  1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.  소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.  (1은 소수가 아닙니다.)   제한 조건   n은 2이상 1000000이하의 자연수입니다.  입출력 예  1 2 3 n\tresult 10\t4 5\t3   입출력 예 설명  1 2 3 4 5 입출력 예 #1 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환  입출력 예 #2 1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환   코드   1 n = 1000   1 2 3 4 5 6 7 8 9 10 def solution(n):     num = set(range(2,n+1))          for i in range(2, n+1):         if i in num:             num-=set(range(i*i,n+1,i ))             p = range(i,n+1,i )                      return len(num)   1 solution(n)   1 168   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 같은 숫자는 싫어 (Python3)",
        "excerpt":"문제 설명  배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,  arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.  arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.  배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.   제한사항  배열 arr의 크기 : 1,000,000 이하의 자연수  배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수   입출력 예  1 2 3  arr\t            answer [1,1,3,3,0,1,1]\t   [1,3,0,1] [4,4,4,3,3]\t       [4,3]   입출력 예 설명  입출력 예 #1,2  문제의 예시와 같습니다.   코드   1 2 3 4 5 6 7 8 def solution(arr):     result = []     for i in range(0,len(arr)-1):         if arr[i] != arr[i+1]:             result.append(arr[i])     result.append(arr[-1])          return result   1 arr = [1,1,3,3,0,1,1]   1 solution(arr)   1 [1, 3, 0, 1]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/",
        "teaser": null
      },{
        "title": "[Programmers] 나누어 떨어지는 숫자 배열 (Python3)",
        "excerpt":"문제 설명  array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.  divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.   제한사항  arr은 자연수를 담은 배열입니다.  정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.  divisor는 자연수입니다.  array는 길이 1 이상인 배열입니다   입출력 예  1 2 3 4 arr\t            divisor        return [5, 9, 7, 10]\t  5\t          [5, 10] [2, 36, 1, 3]\t  1\t          [1, 2, 3, 36] [3,2,6]\t         10\t          [-1]  입출력 예 설명   입출력 예#1  1 2 arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다.  따라서 [5, 10]을 리턴합니다.  입출력 예#2  1 arr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다.   입출력 예#3  1 3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다`   코드   1 2 3 4 5 6 7 8 9 def solution(arr, divisor):     result = []     for i in range(0, len(arr)):         if arr[i]%divisor == 0:             result.append(arr[i])     if len(result) == 0:         result.append(-1)     result.sort()             return result   1 2 arr = [5,9,7,10] divisor = 5   1 solution(arr, divisor)   1 [5, 10]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/",
        "teaser": null
      },{
        "title": "[Programmers] 다트 게임 (Python3)",
        "excerpt":"문제  카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~  Game Star  카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다.   다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로,   모두가 간단히 즐길 수 있다.   갓 입사한 무지는 코딩 실력을 인정받아  게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.           다트 게임은 총 3번의 기회로 구성된다.            각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.            점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.            옵션으로 스타상() , 아차상(#)이 존재하며 스타상() 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.            스타상()은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상()의 점수만 2배가 된다. (예제 4번 참고)            스타상()의 효과는 다른 스타상()의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고)            스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)            Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.            스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.       0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.   입력 형식  “점수|보너스|[옵션]”으로 이루어진 문자열 3세트.  예) 1S2D*3T  점수는 0에서 10 사이의 정수이다.  보너스는 S, D, T 중 하나이다.  옵선은 *이나 # 중 하나이며, 없을 수도 있다.   출력 형식  3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다.     예) 37   입출력 예제  1 2 3 4 5 6 7 8 예제\tdartResult\tanswer\t설명 1\t1S2D*3T\t      37\t 11 * 2 + 22 * 2 + 33 2\t1D2S#10S\t   9\t 12 + 21 * (-1) + 101 3\t1D2S0T\t       3\t 12 + 21 + 03 4\t1S*2T*3S\t  23\t 11 * 2 * 2 + 23 * 2 + 31 5\t1D#2S*3S\t   5\t 12 * (-1) * 2 + 21 * 2 + 31 6\t1T2D3D#\t      -4\t 13 + 22 + 32 * (-1) 7\t1D2S3T*\t      59\t 12 + 21 * 2 + 33 * 2   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import re  def solution(dartResult):          bonus = {'S':1, 'D' : 1, 'T' : 3}     m = re.compile(\"[0-9]+[SDT]{1}[*#]?\")     result = m.findall(dartResult)     score = 0     for i in result:         score = i[0]**bonus(i[1])         if i[2] == '#':             score                    return score                                   1 dartResult = \"1S2D*3T\"   1 solution(dartResult)   1 'T'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8B%A4%ED%8A%B8-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[Programmers] 두 정수 사이의 합 (Python3)",
        "excerpt":"문제 설명  두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.   예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.   제한 조건  a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.  a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.  a와 b의 대소관계는 정해져있지 않습니다.   입출력 예  1 2 3 4 a\tb\treturn 3\t5\t12 3\t3\t3 5\t3\t12   코드   1 2 a = 3 b = 3   1 2 3 4 5 6 7 8 9 10 def solution(a,b):     result = 0     if a &gt; b:         temp = a         a = b         b = temp     for i in range(a,b+1):         result += i     return result            1 solution(a,b)   1 3   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%95%A9/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 내 마음대로 정렬하기 (Python3)",
        "excerpt":"문제 설명  문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다.   제한 조건  strings는 길이 1 이상, 50이하인 배열입니다.  strings의 원소는 소문자 알파벳으로 이루어져 있습니다.  strings의 원소는 길이 1 이상, 100이하인 문자열입니다.  모든 strings의 원소의 길이는 n보다 큽니다.  인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.   입출력 예  1 2 3 strings\t                n\treturn [\"sun\", \"bed\", \"car\"]\t1\t[\"car\", \"bed\", \"sun\"] [\"abce\", \"abcd\", \"cdx\"]\t2\t[\"abcd\", \"abce\", \"cdx\"]  입출력 예 설명   입출력 예 1   “sun”, “bed”, “car”의 1번째 인덱스 값은 각각 “u”, “e”, “a” 입니다. 이를 기준으로 strings를 정렬하면 [“car”, “bed”, “sun”] 입니다.   입출력 예 2   “abce”와 “abcd”, “cdx”의 2번째 인덱스 값은 “c”, “c”, “x”입니다. 따라서 정렬 후에는 “cdx”가 가장 뒤에 위치합니다. “abce”와 “abcd”는 사전순으로 정렬하면 “abcd”가 우선하므로, 답은 [“abcd”, “abce”, “cdx”] 입니다.   코드   1 2 3 def solution(strings,n):     return sorted(strings,key=lambda x:(x[n],x))        1 2 strings = [\"sun\", \"bed\", \"car\"] n = 1   1 solution(strings, n)   1 ['car', 'bed', 'sun']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-%EB%A7%88%EC%9D%8C%EB%8C%80%EB%A1%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 내림차순으로 배치하기 (Python3)",
        "excerpt":"문제 설명   문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요.  s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.   제한 사항  str은 길이 1 이상인 문자열입니다.   입출력 예  1  s\t      return \"Zbcdefg\"\t\"gfedcbZ\"   코드   1 2 def solution(s):     return \"\".join(sorted(s, reverse=True))   1 s = \"AbDcdefg\"   1 solution(s)   1 2 3 4 5 6 7 ['g', 'f', 'e', 'd', 'c', 'b', 'D', 'A']      'gfedcbAD'   1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 다루기 기본 (Python3)",
        "excerpt":"문제 설명  문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다.   제한 사항  s는 길이 1 이상, 길이 8 이하인 문자열입니다.   입출력 예  1 2 3    s\treturn \"a234\"\tfalse \"1234\"\ttrue  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import re def solution(s):     p = re.compile('[a-z]+')     m = p.search(s)     if m:         return False      else:         if (len(s) == 4 or len(s)==6):             return True                           else:             return False          1 s = \"\"   1 solution(s)   1 False   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/",
        "teaser": null
      },{
        "title": "[Programmers] N개의 최소공배수 (Python3)",
        "excerpt":"문제 설명  두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.   제한 사항  1 2 arr은 길이 1이상, 15이하인 배열입니다. arr의 원소는 100 이하인 자연수입니다.   입출력 예  1 2 3 arr\t        result [2,6,8,14]\t168 [1,2,3]\t    6  코드   1 arr = [1,2,3]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import pdb def solution(arr):     time = 1     num =0          for i in range(0,len(arr)):         time *= arr[i]         for i in range(1,time+1):         for j in arr:             if i%j == 0:                 num+=1         if num == len(arr):             return i             break         else:             num = 0                 1 get_big(15, 20)   1 5   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/N%EA%B0%9C%EC%9D%98-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] JadenCase 문자열 만들기 (Python3)",
        "excerpt":"문제 설명  JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.   제한 조건  s는 길이 1 이상인 문자열입니다.  s는 알파벳과 공백문자(“ “)로 이루어져 있습니다.  첫 문자가 영문이 아닐때에는 이어지는 영문은 소문자로 씁니다. ( 첫번째 입출력 예 참고 )   입출력 예  1 2 3 s\t                     return \"3people unFollowed me\"\t \"3people Unfollowed Me\" \"for the last week\"\t     \"For The Last Week\"  코드   1 s = \"my NAMe   4s    3injae\"   1 2 3 4 5 6 7 8 9 10 11 def solution(s):     s = s.lower().split()     result = []     for i in s:         i = list(i)         print(i)         i[0] = i[0].upper()         result.append(\"\".join(i))              return \" \".join(result)        1 solution(s)   1 'My Name   4s    3injae'   1 s.lower().split()   1 ['my', 'name', 'is', 'minjae']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-JadenCase-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 피보나치 수 (Python3)",
        "excerpt":"문제 설명  피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.  예를들어  1 2 3 4     F(2) = F(0) + F(1) = 0 + 1 = 1     F(3) = F(1) + F(2) = 1 + 1 = 2     F(4) = F(2) + F(3) = 1 + 2 = 3     F(5) = F(3) + F(4) = 2 + 3 = 5  와 같이 이어집니다.  2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.   제한 사항     n은 1이상, 100000이하인 자연수입니다.   입출력 예  1 2 3 n\treturn 3\t2 5\t5  입출력 예  피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, … 와 같이 이어집니다.  코드   1 n = 5   1 2 3 4 5 6 def solution(n):     a = 0     num = [0,1]     for i in range(0,n+1):         num.append(num[i]+num[i+1])         return num[-3]%1234567   1 solution(n)   1 5   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] 행렬의 곱셈 (Python3)",
        "excerpt":"문제 설명  2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요.   제한 조건  행렬 arr1, arr2의 행과 열의 길이는 2 이상 100 이하입니다.  행렬 arr1, arr2의 원소는 -10 이상 20 이하인 자연수입니다.  곱할 수 있는 배열만 주어집니다.   입출력 예  1 2 3 4 5 6 7 8 9 10 11 arr1\t                   \t         [[1, 4], [3, 2], [4, 1]]\t    [[2, 3, 2], [4, 2, 4], [3, 1, 4]]  arr2 [[3, 3], [3, 3]] [[5, 4, 3], [2, 4, 1], [3, 1, 1]]  return [[15, 15], [15, 15], [15, 15]] [[22, 22, 11], [36, 28, 18], [29, 20, 14]]  코드   1 2 3 4 arr1 = [[1, 4]]   arr2 = [[3],         [3]]    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solution(arr1, arr2):          result = []     for x1 in range(len(arr1)):         su2 = []         for y2 in range(len(arr2[0])):             su = []             for y1 in range(len(arr1[0])):                 su.append(arr1[x1][y1]*arr2[y1][y2])                 print(su)             su2.append(sum(su))              result.append(su2)                  return result   1 solution(arr1, arr2)   1 2 3 4 5 6 7 8 [3] [3, 12]      [[15]]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B3%B1%EC%85%88/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 압축 (Python3)",
        "excerpt":"문제 설명  데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.  간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.  예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.  다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.  압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.   제한사항  1 2 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다.   입출력 예  1 2 3 4 5 6 s\t                         result \"aabbaccc\"\t                 7 \"ababcdcdababcdcd\"\t         9 \"abcabcdede\"\t             8 \"abcabcabcabcdededededede\"\t 14 \"xababcdcdababcdcd\"\t         17  입출력 예에 대한 설명  입출력 예 #1      문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.   입출력 예 #2      문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.   입출력 예 #3      문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.   입출력 예 #4      문자열을 2개 단위로 자르면 “abcabcabcabc6de” 가 됩니다.      문자열을 3개 단위로 자르면 “4abcdededededede” 가 됩니다.      문자열을 4개 단위로 자르면 “abcabcabcabc3dede” 가 됩니다.      문자열을 6개 단위로 자를 경우 “2abcabc2dedede”가 되며,       이때의 길이가 14로 가장 짧습니다.   입출력 예 #5      문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.      따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로       자르는 것은 불가능 합니다.      이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.   코드   1 s = \"avcavcdede\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import re  def solution(s):         strlist = []     if len(s) == 1:         return 1     for i in range(1,len(s)//2+1):         result = \"\"                          temp = s[:i]         num = 1         for j in range(i,len(s),i):             if s[j:j+i] == temp:                 num += 1              else:                 if num == 1:                     num = \"\"                 result += str(num)+temp                 temp = s[j:j+i]                 num = 1          if num == 1:             num = \"\"         result += str(num)+temp         strlist.append(len(result))         temp = \"\"                                                        return min(strlist)   1 solution(s)   1 ['avcavcdede', 'avcavc2de', '2avcdede', 'avcavcdede', 'avcavcdede']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95/",
        "teaser": null
      },{
        "title": "[Programmers] 방문길이 (Python3)",
        "excerpt":"문제  게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.      U: 위쪽으로 한 칸 가기   D: 아래쪽으로 한 칸 가기   R: 오른쪽으로 한 칸 가기   L: 왼쪽으로 한 칸 가기   캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.   방문길이1_qpp9l3.png   예를 들어, “ULURRDLLU”로 명령했다면   방문길이2_lezmdo.png   1번 명령어부터 7번 명령어까지 다음과 같이 움직입니다.   방문길이3_sootjd.png   8번 명령어부터 9번 명령어까지 다음과 같이 움직입니다.   방문길이4_hlpiej.png   이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)   단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.   예를 들어, “LULLLLLLU”로 명령했다면  방문길이5_nitjwj.png      1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다.   방문길이6_nzhumd.png   이때 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다.  명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요.   제한사항  dirs는 string형으로 주어지며, ‘U’, ‘D’, ‘R’, ‘L’ 이외에 문자는 주어지지 않습니다.  dirs의 길이는 500 이하의 자연수입니다.   입출력 예   1 2 3 dirs\t      answer \"ULURRDLLU\"\t  7 \"LULLLLLLU\"\t  7   https://programmers.co.kr/learn/courses/30/lessons/49994?language=python3   1 dirs = \"LULLLLLLU\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def solution(dirs):     nx,ny,x,y = 0,0,0,0     result = set()     answer = 0     for i in dirs:         print(i)         if i == 'U':             if ny == 5:                 continue             else:                 ny+=1         if i == 'D':             if ny == -5:                 continue             else:                 ny-= 1         if i == 'R':             if nx == 5:                 continue             else:                 nx+=1         if i == 'L':             if nx == -5:                 continue             else:                 nx-=1         if (nx,ny,x,y) not in result:             result.add((nx,ny,x,y))             result.add((x,y,nx,ny))                          answer+=1                      x,y = nx, ny              return answer        1 solution(dirs)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 L (-1, 0, 0, 0) U (-1, 1, -1, 0) L (-2, 1, -1, 1) L (-3, 1, -2, 1) L (-4, 1, -3, 1) L (-5, 1, -4, 1) L L U (-5, 2, -5, 1)      7   1 a = set()   1 2 a.add((1,2)) a.add((3,4))   1 2 for i in \"dird\":     print(i)   1 2 3 4 d i r d   1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B0%A9%EB%AC%B8%EA%B8%B8%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[Programmers] 숫자의 표현 (Python3)",
        "excerpt":"문제 설명  Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.  1 2 3 4     1 + 2 + 3 + 4 + 5 = 15     4 + 5 + 6 = 15     7 + 8 = 15     15 = 15  자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.   제한사항  n은 10,000 이하의 자연수 입니다.   입출력 예  1 2 n\tresult 15\t4  입출력 예 설명  입출력 예#1  문제의 예시와 같습니다   1 2 n = 30    1 2 3 4 5 6 7 8 9 10 11 12 13 def solution(n):     answer = 0     for i in range(n+1):         result = 0         for j in range(i,n+1):             result += j             if result == n:                 answer+=1                 break             elif result &gt; n:                 break     return answer    1 solution(n)   1 4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%88%AB%EC%9E%90%EC%9D%98-%ED%91%9C%ED%98%84/",
        "teaser": null
      },{
        "title": "[Programmers] 최댓값과 최솟값 (Python3)",
        "excerpt":"문제 설명  문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 “(최소값) (최대값)”형태의 문자열을 반환하는 함수, solution을 완성하세요.  예를들어 s가 “1 2 3 4”라면 “1 4”를 리턴하고, “-1 -2 -3 -4”라면 “-4 -1”을 리턴하면 됩니다.   제한 조건  s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.   입출력 예  1 2 3 4 s                return \"1 2 3 4\"\t     \"1 4\" \"-1 -2 -3 -4\"\t \"-4 -1\" \"-1 -1\"        \t \"-1 -1\"  코드   1 s = \"1 2 3 4\"   1 2 3 4 5 6 def solution(s):     a = []     for i in s.split():         a.append(int(i))          return \" \".join([str(min(a)),str(max(a))])   1 solution(s)   1 '1 4'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%B5%9C%EB%8C%93%EA%B0%92%EA%B3%BC-%EC%B5%9C%EC%86%9F%EA%B0%92/",
        "teaser": null
      },{
        "title": "[Programmers] 최솟값 만들기 (Python3)",
        "excerpt":"문제 설명  길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다.   배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)     예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면  A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)   A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)   A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)  즉, 이 경우가 최소가 되므로 29를 return 합니다.   배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.   제한사항  1 2 배열 A, B의 크기 : 1,000 이하의 자연수 배열 A, B의 원소의 크기 : 1,000 이하의 자연수   입출력 예  1 2 3 A\t        B\t        answer [1, 4, 2]\t[5, 4, 4]\t29 [1,2]\t    [3,4]\t    10  코드   1 2 A = [1,4,2] B = [5,4,4]   1 2 3 4 5 6 7 8 def solution(A, B):     A.sort()     B.sort(reverse = True)     result = 0     for i,j in zip(A,B):         result +=(i*j)     return result            1 solution(A,B)   1 29   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%B5%9C%EC%86%9F%EA%B0%92-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] N진수 게임 (Python3)",
        "excerpt":"문제 설명  N진수 게임  튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.  숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.  10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.  이렇게 게임을 진행할 경우,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …  순으로 숫자를 말하면 된다.  한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는  0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …  순으로 숫자를 말하면 된다.  이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.   입력 형식  진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 가 주어진다.  2 ≦ n ≦ 16  0 ＜ t ≦ 1000  2 ≦ m ≦ 100  1 ≦ p ≦ m   출력 형식  튜브가 말해야 하는 숫자 t개를 공백 없이 차례대로 나타낸 문자열. 단, 10~15는 각각 대문자 A~F로 출력한다.   입출력 예제  1 2 3 4 n\tt\tm\tp\tresult 2\t4\t2\t1\t\"0111\" 16\t16\t2\t1\t\"02468ACE11111111\" 16\t16\t2\t2\t\"13579BDF01234567\"   1 2 3 4 n = 16 t = 16 m = 2 p = 2   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def getnum(a, n):     num = []          while a&gt;0:         if a%n == 0:             num.append(int(a%n))             a = a/n                                            else:             num.append(int(a%n))             a = a//n     if len(num)== 0:         return ['0']                  for i in range(len(num)):         if num[i] == 10:             num[i] = 'A'         elif num[i] == 11:             num[i] = 'B'         elif num[i] == 12:             num[i] = 'C'         elif num[i] == 13:             num[i] = 'D'         elif num[i] == 14:             num[i] = 'E'         elif num[i] == 15:             num[i] = 'F'         else:             num[i] = str(num[i])     return list(reversed(num))  def solution(n,t,m,p):     num = []     result = []          for i in range(0,m*t):         num  = num + getnum(i,n)         if len(num) &gt;m*t:             break              if m==p:          for i in range(len(num)):             if (i+1)%m == 0:                              result.append(num[i])         else:         for i in range(len(num)):             if (i+1)%m == p:                               result.append(num[i])          return \"\".join(result[:t])                      1 getnum(0,1)   1 ['0']   1 a = [10,12,13,14]   1 2 solution(n,t,m,p)            1 '13579BDF01234567'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/N%EC%A7%84%EC%88%98-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[Programmers] 다음 큰 숫자 (Python3)",
        "excerpt":"문제 설명  자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.   1 2 3 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다. 자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.   제한 사항  n은 1,000,000 이하의 자연수 입니다.   입출력 예  1 2 3 n\tresult 78\t83 15\t23   입출력 예 설명  입출력 예#1  문제 예시와 같습니다.   입출력 예#2  15(1111)의 다음 큰 숫자는 23(10111)입니다.   코드   1 n = 78   1 2 3 4 def solution(n):     for i in range(n+1,1000000):         if list(bin(n))[2:].count('1') == list(bin(i)).count('1'):             return i   1 solution(n)   1 83   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8B%A4%EC%9D%8C-%ED%81%B0-%EC%88%AB%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Programmers] 땅따먹기 (Python3)",
        "excerpt":"문제 설명  땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.  예를 들면,  1 2 3 | 1 | 2 | 3 | 5 | | 5 | 6 | 7 | 8 | | 4 | 3 | 2 | 1 |  로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.  마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.   제한사항  행의 개수 N : 100,000 이하의 자연수  열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.  점수 : 100 이하의 자연수   입출력 예  1 2 land\t                        answer [[1,2,3,5],[5,6,7,8],[4,3,2,1]]\t16   입출력 예 설명  입출력 예 #1  문제의 예시와 같습니다.   코드   1 land = [[1,2,3,5],[5,6,7,100],[4,3,2,100]]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solution(land):     locate = -1     result = 0     for i in range(len(land)-1):         for j in range(len(land[0])):             locate = land[i].index(max(land[i]))             if j == locate:                 land[i+1][j] = land[i+1][j]+sorted(land[i])[2]                                              else:                 land[i+1][j] = land[i+1][j]+max(land[i])                          return max(land[-1])   1 solution(land)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 [10, 6, 7, 100] else [10, 11, 7, 100] else [10, 11, 12, 100] else [10, 11, 12, 103] if [107, 3, 2, 100] else [107, 106, 2, 100] else [107, 106, 105, 100] else [107, 106, 105, 112] if      112   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%95%85%EB%94%B0%EB%A8%B9%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 올바른 괄호 (Python3)",
        "excerpt":"문제 설명  괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어   1 2 \"()()\" 또는 \"(())()\" 는 올바른 괄호입니다. \")()(\" 또는 \"(()(\" 는 올바르지 않은 괄호입니다.   ’(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.   제한사항  문자열 s의 길이 : 100,000 이하의 자연수  문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다.  코드   1 s = \")(\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def solution(s):     a = []     a.append(s[0])          if s[0] == ')':                 return False     for i in range(1,len(s)):         if len(a)== 0:             a.append(s[i])             if a[0] == ')':                 return False         elif a[-1] == s[i]:             a.append(s[i])         else:             a.pop()     if len(a) == 0:         return True      else:         return False            1 solution(s)   1 False   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8/",
        "teaser": null
      },{
        "title": "[Programmers] 압축 (Python3)",
        "excerpt":"문제 설명  신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.   어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.   LZW 압축은 다음 과정을 거친다.      길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.   사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다.   w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다.        입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다.            단계 2로 돌아간다.  압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.       색인 번호\t1\t2\t3\t…\t24\t25\t26    단어\t     A\t B\t C\t … X\t Y   Z       예를 들어 입력으로 KAKAO가 들어온다고 하자.     현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다.   두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인  번호 1을 출력하고, AK를 사전에 28 번째로 등록한다.   세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다.   마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다.     1 2 3 4 5   현재 입력(w)\t다음 글자(c)\t출력\t사전 추가(w+c)   K\t          A\t            11\t 27: KA   A\t          K\t            1\t 28: AK   KA\t          O\t            27\t 29: KAO   O\t\t                    15\t           이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.   입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다.  현재 입력(w)\t다음 글자(c)\t출력\t사전 추가(w+c)  T\tO\t20\t27: TO  O\tB\t15\t28: OB  B\tE\t2\t29: BE  E\tO\t5\t30: EO  O\tR\t15\t31: OR  R\tN\t18\t32: RN  N\tO\t14\t33: NO  O\tT\t15\t34: OT  T\tT\t20\t35: TT  TO\tB\t27\t36: TOB  BE\tO\t29\t37: BEO  OR\tT\t31\t38: ORT  TOB\tE\t36\t39: TOBE  EO\tR\t30\t40: EOR  RN\tO\t32\t41: RNO  OT\t\t34   입력 형식  입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다.   출력 형식  주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.   입출력 예제                  msg       answer                       KAKAO       [11, 1, 27, 15]                 TOBEORNOTTOBEORTOBEORNOT       [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]                 ABABABABABABABAB       [1, 2, 27, 29, 28, 31, 30]           코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def solution(msg):     answer = []     a = [\"a\"]     dic = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")     msg = msg+'.'     for i in range(len(msg)):         for j in reversed(range(len(msg)+1)):                              if len(a[-1])&gt;2:                 a[-1] = a[-1][:-1]                 break                             if msg[i:j] in dic:                 answer.append(dic.index(msg[i:j])+1)                 dic.append(msg[i:j+1])                 a.append(msg[i:j+1])                 break                                                 return answer   1 solution(msg)   1 [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]   1 msg = \"TOBEORNOTTOBEORTOBEORNOT\"  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%95%95%EC%B6%95/",
        "teaser": null
      },{
        "title": "[Programmers] 가장 큰 정사각형 찾기 (Python3)",
        "excerpt":"문제 설명  1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.)   1 2 3 4 5 6 7 8 9 10 11 12 13 예를 들어 1\t2\t3\t4 0\t1\t1\t1 1\t1\t1\t1 1\t1\t1\t1 0\t0\t1\t0 가 있다면 가장 큰 정사각형은 1\t2\t3\t4 0\t1\t1\t1 1\t1\t1\t1 1\t1\t1\t1 0\t0\t1\t0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다.   제한사항   1 2 3 4 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다.   입출력 예  1 2 3 board\t                                    answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]]\t9 [[0,0,1,1],[1,1,1,1]]\t                    4   입출력 예 설명  입출력 예 #1  위의 예시와 같습니다.   입출력 예 #2   1 2 | 0 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 |  로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다.   코드   1 board =[[1]]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(board):     a = []      for row in range(1,len(board)):         for column in range(1,len(board[0])):             if board[row][column] &gt;= 1:                 board[row][column] = min(board[row-1][column],board[row][column-1],board[row-1][column-1])+1                  a.append(board[row][column])             else:                 a.append(board[row][column])     if len(a) == 0:         answer = 1     else:         answer = max(a)**2          return answer   1 solution(board)   1 1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 방금 그 곡 (Python3)",
        "excerpt":"방금그곡  라디오를 자주 듣는 네오는 라디오에서 방금 나왔던 음악이 무슨 음악인지 궁금해질 때가 많다. 그럴 때 네오는 다음 포털의 ‘방금그곡’ 서비스를 이용하곤 한다. 방금그곡에서는 TV, 라디오 등에서 나온 음악에 관해 제목 등의 정보를 제공하는 서비스이다.   네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다. 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다. 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도 그 곡이 네오가 들은 곡이 아닐 수도 있다. 그렇기 때문에 네오는 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다. 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라.     방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.   네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.   각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.   음악이 00:00를 넘겨서까지 재생되는 일은 없다.   조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.   조건이 일치하는 음악이 없을 때에는 “(None)”을 반환한다.   입력 형식  입력으로 네오가 기억한 멜로디를 담은 문자열 m과 방송된 곡의 정보를 담고 있는 배열 musicinfos가 주어진다.     m은 음 1개 이상 1439개 이하로 구성되어 있다.   musicinfos는 100개 이하의 곡 정보를 담고 있는 배열로, 각각의 곡 정보는 음악이 시작한 시각, 끝난 시각, 음악 제목, 악보 정보가 ‘,’로 구분된 문자열이다.   음악의 시작 시각과 끝난 시각은 24시간 HH:MM 형식이다.   음악 제목은 ‘,’ 이외의 출력 가능한 문자로 표현된 길이 1 이상 64 이하의 문자열이다.  악보 정보는 음 1개 이상 1439개 이하로 구성되어 있다.   출력 형식  조건과 일치하는 음악 제목을 출력한다.   1 2 m = \"CC#BCC#BCC#BCC#B\" musicinfos = [\"03:00,04:27,FOO,CC#B\", \"03:00,03:30,F1,CC#B\"]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import re def solution(m, f):     result = []     m = m.replace('A#','a')     m = m.replace('B#','b')     m = m.replace('C#','c')     m = m.replace('D#','d')     m = m.replace('E#','e')     m = m.replace('F#','f')     m = m.replace('G#','g')          for i in f:         s = re.split('[,]',i)                      s[3] = s[3].replace('A#','a')         s[3] = s[3].replace('B#','b')         s[3] = s[3].replace('C#','c')         s[3] = s[3].replace('D#','d')         s[3] = s[3].replace('E#','e')         s[3] = s[3].replace('F#','f')         s[3] = s[3].replace('G#','g')                          hour = int(s[1][0:2])-int(s[0][0:2])         minu = int(s[1][3:5])-int(s[0][3:5])         time = hour*60+minu         melody = \"\"              if len(result)== 0:         return \"(None)\"      if len(result) &gt;1:         result = sorted(result,key = lambda x: -x[0])         return result [0][-1]       return result[0][1]         1 solution(m,musicinfos)   1 '(None)'   1 0%3   1 0   1 b = 'ABCD#EF#'   1 b.index('C')   1 4   1 2 b = [['b',12], ['a',12]] sorted(b,key= lambda x: x[1])   1 [['b', 12], ['a', 12]]   1 b =[\"03:00,03:30,FOO,CC#B\"]   1 int(b[0][0:2])   1 3   1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B0%A9%EA%B8%88%EA%B7%B8%EA%B3%A1/",
        "teaser": null
      },{
        "title": "[Programmers] 파일명 정렬 (Python3)",
        "excerpt":"파일명 정렬  세 차례의 코딩 테스트와 두 차례의 면접이라는 기나긴 블라인드 공채를 무사히 통과해 카카오에 입사한 무지는 파일 저장소 서버 관리를 맡게 되었다.   저장소 서버에는 프로그램의 과거 버전을 모두 담고 있어, 이름 순으로 정렬된 파일 목록은 보기가 불편했다. 파일을 이름 순으로 정렬하면 나중에 만들어진 ver-10.zip이 ver-9.zip보다 먼저 표시되기 때문이다.   버전 번호 외에도 숫자가 포함된 파일 목록은 여러 면에서 관리하기 불편했다. 예컨대 파일 목록이   [“img12.png”, “img10.png”, “img2.png”, “img1.png”]일 경우, 일반적인 정렬은 [“img1.png”, “img10.png”, “img12.png”, “img2.png”] 순이 되지만, 숫자 순으로 정렬된 [“img1.png”, “img2.png”, “img10.png”, img12.png”] 순이 훨씬 자연스럽다.   무지는 단순한 문자 코드 순이 아닌, 파일명에 포함된 숫자를 반영한 정렬 기능을 저장소 관리 프로그램에 구현하기로 했다.   소스 파일 저장소에 저장된 파일명은 100 글자 이내로, 영문 대소문자, 숫자, 공백(“ “), 마침표(“.”), 빼기 부호(“-“)만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.   파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다.     HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다.   NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다.        TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.       파일명\t             HEAD\t        NUMBER\t          TAIL    foo9.txt\t      foo            9\t               .txt    foo010bar020.zip  foo            010\t           bar020.zip    F-15\t          F-\t         15\t               (빈 문자열)       파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다.      파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. MUZI와 muzi, MuZi는 정렬 시에 같은 순서로 취급된다.   파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 &lt; 10 &lt; 0011 &lt; 012 &lt; 13 &lt; 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다.   두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. MUZI01.zip과 muzi1.png가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다.   무지를 도와 파일명 정렬 프로그램을 구현하라.   입력 형식  입력으로 배열 files가 주어진다.     files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.   각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백(“ “), 마침표(“.”), 빼기 부호(“-“)만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.   중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt, MUZI1.txt, muzi001.txt, muzi1.TXT는 함께 입력으로 주어질 수 있다.)   출력 형식  위 기준에 따라 정렬된 배열을 출력한다.   입출력 예제  1 2 3 4 입력: [\"img12.png\", \"img10.png\", \"img02.png\", \"img1.png\", \"IMG01.GIF\", \"img2.JPG\"] 출력: [\"img1.png\", \"IMG01.GIF\", \"img02.png\", \"img2.JPG\", \"img10.png\", \"img12.png\"] 입력: [\"F-5 Freedom Fighter\", \"B-50 Superfortress\", \"A-10 Thunderbolt II\", \"F-14 Tomcat\"] 출력: [\"A-10 Thunderbolt II\", \"B-50 Superfortress\", \"F-5 Freedom Fighter\", \"F-14 Tomcat\"]   코드   1 files = [\"img12.png\", \"img10.png\", \"img02.png\", \"img1.png\", \"IMG01.GIF\", \"img2.JPG\"]   1 2 3 4 5 import re def solution(files):     temp = [re.split('([0-9]+)',s) for s in files]     sort = sorted(temp, key = lambda x: (x[0].lower(),int(x[1])))         return [\"\".join(i) for i in sort]   1 solution(files)   1 ['img1.png', 'IMG01.GIF', 'img02.png', 'img2.JPG', 'img10.png', 'img12.png']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%8C%8C%EC%9D%BC%EB%AA%85-%EC%A0%95%EB%A0%AC/",
        "teaser": null
      },{
        "title": "[Programmers] 가장 큰 수 (Python3)",
        "excerpt":"문제 설명  0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.   예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.   0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.   제한 사항     numbers의 길이는 1 이상 100,000 이하입니다.   numbers의 원소는 0 이상 1,000 이하입니다.   정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.   입출력 예  numbers          \treturn  [6, 10, 2]\t        “6210”  [3, 30, 34, 5, 9]\t“9534330”   1 numbers =[0,0,0,0,0]   1 2 3 4 5 6 7 def solution(numbers):     n = []     for i in numbers:         n.append(str(i))     a = sorted(n, key = lambda x:x*3)          return str(int(\"\".join(reversed(a))))   1 solution(numbers)   1 '0'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] 스킬 트리 (Python3)",
        "excerpt":"문제 설명  선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.   예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.  위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다.   선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요.   제한 조건     스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다.   스킬 순서와 스킬트리는 문자열로 표기합니다.            예를 들어, C → B → D 라면 “CBD”로 표기합니다           선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다.   skill_trees는 길이 1 이상 20 이하인 배열입니다.   skill_trees의 원소는 스킬을 나타내는 문자열입니다.            skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.           입출력 예   1 2 skill\tskill_trees\t                      return \"CBD\"\t[\"BACDE\", \"CBADF\", \"AECB\", \"BDA\"]\t2   입출력 예 설명     BACDE”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다.   “CBADF”: 가능한 스킬트리입니다.   “AECB”: 가능한 스킬트리입니다.   “BDA”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다.   코드   1 2 skill = \"CBD\" skill_trees = [\"BACDE\", \"CBADF\", \"AECB\", \"BDA\"]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def solution(skill, skill_trees):     result = 0     for i in skill_trees:         a = []         tf = True                  for j in range(len(i)):             if i[j] in skill:                 a.append(i[j])                          for k in range(len(a)):             if a[k] != skill[k]:                 tf = False         if tf == True:             result += 1     return result                          1 solution(skill,skill_trees)   1 2   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%8A%A4%ED%82%AC%ED%8A%B8%EB%A6%AC/",
        "teaser": null
      },{
        "title": "관성",
        "excerpt":"2021.06.23  오랜만에 블로그에 일기를 쓴다.   최근에 깃허브에 재미가 들려서 이게 블로그랑 어느정도 비슷한 성격을 띄다보니까  깃허브쓰랴 블로그쓰랴 귀찮아서 최근에는 깃허브에만 코드를 업로드 했는데, 해보니까 앞으로도  블로그에 코드 올리는일은 잘 없을듯하다… 다른 공부는 모르겠지만 코딩관련 공부에 글쓰는건 깃허브가 너무 편하고 좋 아서 네이버 블로그에는 불편해서 이제 못올리겠다.   그럼에도 일기랑은 또 다른 성격이라서 블로그도 꾸준히 써야하는데 요즘 나태해져서 다시 또 정신을 차리고 꾸준히 블로 그를 쓸 다짐을 한다.   요즘 근황을 잠깐 돌아보자면, 사실 나태해졌다고 하지만 요즘처럼 공부 많이 한적이 없다.  하나에 몰두하게 되면 다른것에 소홀해지는게 당연한건지 공부량을 늘리니까 다른게 너무 귀찮아져서 운동이고 블로그고 안한지 너무 오래됐다. 육체적인 건강과 정신적인 건강을 위해서 시작한 두가지인데  조금 바빠도 두개 다 꼬박꼬박 다시 시작해야겠다는 생각을 매일 하면서도, 이게 관성이 한번 사라지니까 다시 시작하는게 너무너무너무 귀찮고 하기가 싫다… 몸에 좋은거는 왜이렇게 하기가 귀찮은지 모르겠다.   주식은 ktb 투자증권을 늦게나마 다시 진입해서 좀 벌고..  숏으로 좀 벌고… 장이 너무 혼란한것 같아서 당분간 공부에 집중도 안되고, 방향성 매매를 하기에는 서치할 여력이 없어 서 단순하게 채권금리 떨어지길래 성장주가 좋겠거니~ 하고 카카오에 장기적 느낌으로 넣었는데, 너무 잘올라서 당황스 러웠다. 저번주랑 이번주해서 거의 170가까이 벌었으니 뭐… 이정도면 아주 만족스럽다.   그래도 오늘 아침에는 운동을 하고 좀 일찍 스터디카페로 출근했으니, 다시 관성을 붙여서 더더 열심히 살아야겠다. 요즘따라 자꾸 열시 열한시까지 자고 이거 습관도 다시 아침으로 돌려서 운동하고 와서 아홉시 열시에는 스터디카페에 몸 을 붙일 수 있도록 하는게 단기적인 목표다. 오랜만에 글쓰니까 또 재밌기도 하고??   잘 모르고 있었는데 이렇게 글을 쓰다보니까 객관적으로도 요즘 인생이 참 잘풀리고 있었구나 하는 생각이 든다.  얼마전에 명상에 관해서 쓴 좋은 글을 하나 읽어서, 아침 루틴에 명상도 한번 포함시켜보려 한다. 한번에 이렇게 여러가지 계획하면 망하는 경우가 태반이던데…   그래도 관성을 붙이는김에 좀 힘들어도 여러개 한번에 루틴으로 만들어놓으면 한달뒤에 훨씬 편하다.  인생은 원래 콜드터키법이다.   힘들어?? 그거 원래그런거야. 견디면 괜찮아져~  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B4%80%EC%84%B1/",
        "teaser": null
      },{
        "title": "[Programmers] 시저 암호 (Python3)",
        "excerpt":"문제 설명  어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.   제한 조건  공백은 아무리 밀어도 공백입니다.  s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.  s의 길이는 8000이하입니다.  n은 1 이상, 25이하인 자연수입니다.   입출력 예  1 2 3 4 s\t    n\tresult \"AB\"\t1\t\"BC\" \"z\"  \t1\t\"a\" \"a B z\"\t4\t\"e F d\"   코드   1 2 s = \"a B z\" n = 1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(s,n):     alpha_lower= [\"abcdefghijklmnopqrstuvwxyz\"]     alpha_upper= [\"abcdefghijklmnopqrstuvwxyz\"]     alpha_upper = list(alpha_upper[0].upper())     alpha_lower = list(alpha_lower[0])     result = \"\"         for i in range(0, len(s)):         if s[i] == ' ':             result += ' '         else:             if s[i].islower() == True:                 result += alpha_lower[(alpha_lower.index(s[i])+n)%26]             if s[i].islower() == False:                 result += alpha_upper[(alpha_upper.index(s[i])+n)%26]     return result   1 solution(s,n)   1 'b C a'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/",
        "teaser": null
      },{
        "title": "[BOJ] 17224 APC는 왜 서브태스크 대회가 되었을까? (Python3)",
        "excerpt":"문제  현정이는 APC에 한 번이라도 나가보고 싶다는 소망이 있다. 하지만 이 소망은 여태까지 단 한 번도, 그리고 앞으로도 이루어질 리 없기 때문에 현정이가 입버릇처럼 하게 된 말이 있는데…   현정 : 아~~ 나도 APC 참가만 했으면 상금 받는 건데~~~~~  준표 : … 그건 아닌 것 같은데?  현정이의 근거 없는 자신감이 눈꼴신 준표는 출제 중에 평가한 문제 난이도를 통해 현정이의 예상 점수를 알려주고 현정이가 현실을 받아들일 수 있도록 도와주고자 한다.   현정이는 L 만큼의 역량을 가지고 있어 L보다 작거나 같은 난이도의 문제를 풀 수 있다. 또한 현정이는 코딩이 느리기 때문에 대회 시간이 부족해 K개보다 많은 문제는 해결할 수 없다. 어떤 문제에 대해 쉬운 버전을 해결한다면 100점을 얻고, 어려운 버전을 해결한다면 여기에 40점을 더 받아 140점을 얻게 된다. 어려운 버전을 해결하면 쉬운 버전도 같이 풀리게 되므로, 한 문제를 해결한 것으로 계산한다.   현정이가 APC에 참가했다면 최대 몇점을 얻을 수 있었을지 알려주자.   입력  첫 줄에 문제의 개수 N, 현정이의 역량 L, 현정이가 대회중에 풀 수 있는 문제의 최대 개수 K가 주어진다.   둘째 줄부터 N개의 줄에 걸쳐 1 ~ N번째 문제의 쉬운 버전의 난이도 sub1, 어려운 버전의 난이도 sub2 가 순서대로 주어진다.   출력  현정이가 APC에 참가했다면 얻었을 점수의 최대값을 출력한다.   제한  1 2 3 4 5 6 7 1 ≤ N ≤ 100 1 ≤ L ≤ 50 1 ≤ sub1 ≤ sub2 ≤ 50 서브태스크 1 (100점) K = N 서브태스크 2 (40점) 0 ≤ K ≤ N   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 예제 입력 1  복사 4 8 4 1 8 4 5 6 20 9 12 예제 출력 1  복사 380 1번, 2번 문제의 어려운 버전을 해결해 2×140 = 280점을, 3번 문제의 쉬운 버전을 해결해 100점을 얻어 총 380점을 얻는다.  현정이가 4문제를 풀 수 있을 정도로 대회 시간은 충분하지만, 4번 문제는 현정이에겐 너무 어려워서 풀 수 없다.  예제 입력 2  복사 8 7 5 1 3 2 5 3 5 4 8 5 8 6 9 6 7 7 10 예제 출력 2  복사 660 예제 입력 3  복사 8 9 5 1 8 3 10 4 5 5 20 7 12 8 15 9 50 14 14 예제 출력 3  복사 580 힌트 예제2, 3은 서브태스크1에서는 나오지 않는다.   전통적으로 APC는 쉬운 버전의 문제를 먼저 푸는 것이 정신건강과 안정적인 득점을 위해 좋다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 N,L,K = map(int, input().split()) ##문제의 개수 N, 현정이의 역량 L, 현정이의 최대 풀이 문제 개수 K  difficult = [] for i in range(N):     difficult.append(list(map(int, input().split()))) #difficult 리스트에 서브태스크1,2를 리스트로 묶어서 넣는다. difficult. sort() #서브태스크 1의 난이도를 기준으로 정렬 score_list = []   for problem in difficult:     if L &gt;= problem[1]:#역량보다 sub2 문제의 난이도가 적거나 같다면 스코어 +100         score_list.append(140)     else: #sub 2문제를 못풀경우         if L &gt;= problem[0]: #역량보다 sub1 문제의 난이도가 적거나 같다면 스코어 +100             score_list.append(100)         else:             pass score = 0 for i in range(K):      if len(score_list) == 0: #리스트가 비었으면 for문 종료         break     score += max(score_list) #max값을 score에 더해주고     score_list.remove(max(score_list)) #더한 max값은 리스트에서 제거           print(score)                   1 2 3 4 5 6 4 8 4 1 8 4 5 6 20 9 12 380   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/APC%EB%8A%94-%EC%99%9C-%EC%84%9C%EB%B8%8C%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%8C%80%ED%9A%8C%EA%B0%80-%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[BOJ] 2839 설탕 배달 (Python3)",
        "excerpt":"문제  상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.   상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.   상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)   출력  상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 예제 입력 1  복사 18 예제 출력 1  복사 4 예제 입력 2  복사 4 예제 출력 2  복사 -1 예제 입력 3  복사 6 예제 출력 3  복사 2 예제 입력 4  복사 9 예제 출력 4  복사 3 예제 입력 5  복사 11 예제 출력 5  복사 3  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 n = int(input()) #설탕  result = 0 #봉지수  while n&gt;=0:     if n%5 == 0: #5의 나머지가 0인경우         result += n//5         print(result) # 5로 나눈 몫이 답         break     n-= 3 # 5로 나눠지지 않으면, 나눠질때까지 3을 빼준다.     result+= 1 #빼면 봉지 하나 추가 else: #while이 거짓이 되어 종료되면     print(-1)                  1 2 18 4   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%84%A4%ED%83%95-%EB%B0%B0%EB%8B%AC/",
        "teaser": null
      },{
        "title": "[BOJ] 1946 신입사원 (Python3)",
        "excerpt":"문제  언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.   그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.   이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.   출력  각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 예제 입력 1  복사 2 5 3 2 1 4 4 1 2 3 5 5 7 3 6 7 3 4 2 1 4 5 7 2 5 6 1 예제 출력 1  복사 4 3   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import sys T = int(input()) #테스트 케이스를 입력으로 받는다.  rank = []  for i in range(T):     score = 0     N = int(input()) #지원자의 숫자를 입력으로 받는다.          for i in range(N):         new_paper, new_interview = map(int, input().split())#서류점수와 면접점수를 받음         rank.append([new_paper, new_interview])     rank.sort(key = lambda x: x[0])          result = 1       standard = rank[0][1]     for i in range(1, len(rank)):         if rank[i][1] &lt; standard:             result += 1         standard = rank[i][1]                         print(result)            1 2 3 4 5 6 7 8 9 10 1 7 3 6 7 3 4 2 1 4 5 7 2 5 6 1 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%8B%A0%EC%9E%85-%EC%82%AC%EC%9B%90/",
        "teaser": null
      },{
        "title": "휴학 반년 결산",
        "excerpt":"2021.07.04  어느덧 2021년의 6월이 지나가버리고 7월이 되었다.  1년의 절반이 훌쩍 가버렸다. 여러가지 계획한 것이 있었고, 그 계획들이 바뀌고 다시 새워지고 반복을 한 끝에  드디어 어느정도 명확한 목표가 생긴 것 같다. 휴학을 한 큰 이유중에 하나가 내가 도대체 무엇을 하고 살고 싶은지, 어떤 일을 하고싶은지에 대한 목표가 하나도 없어서, 이대로는 무슨 공부를 해도 헛걸음이 될 것같다는 생각때문이었다.   내 전공인 전자공학은 내가 목표했던 방향과 아예 달랐고, 그 상태에서는 뭐 공부를 할라고 해도 공부가 되지를 않았다. 전 역 후 불타오르던 공부욕은 금방 식어버렸고, 사실 3학년 2학기를 그냥 ‘내가 이걸 배워서 도대체 어디다 쓰지…’ 하는 생 각만 하며 보냈던것 같다. 전과를 하기에는 너무나 많이 지나 버린것 같기도 하고, 1,2학년때 망쳐놓은 학점들은 내가 뭘 도전해보고 싶던간에 내 발목을 잡았다. 그렇게 솔직히 지친마음 반, 내가 뭘하고 싶은지 생각 좀 해봐야겠다 반… 그리고 지섭이가 휴학한다길래 혼자서 학교다닐 자신이 없는 마음도 조금 포함해서 휴학을 때렸다. 솔직히 휴학을 결정하고 초반 에는 불안한 마음도 컸고, 남들은 앞으로 달려갈때, 난 이미 남들보다도 뒤쳐져있는 상태인데도 여기에 주저앉아 쉬는게 맞나 싶었다.   휴학을 하고 시간을 보내며 어떻게 살것인가에 대한 생각을 많이 했다. 첫번째는 어떻게 하면 행복하게 살수 있을까에 대한 생각. 두번째로는, 정확하게 난 무엇을 하며 살고 싶은가에 대한 생각.   난 어릴때부터 단순하게 돈이 많으면 행복할거라고 생각했고, 아마 많은 사람들도 그렇게 생각하고 있을 것이다.  일을 많이하고 돈을 많이 주는 직업과, 일은 적게 하는 대신에 돈을 적게 주는 직업이 있다면 당연히 전자를 골랐었다. 난 남들앞에서 돈쓰는것도 좋아하는 편이었고, 명품이나 자동차처럼 남들에게 보여주기 위한 제품들에 관심이 많아서, 그런 욕구가 좀 많았다. 개뿔도 없으면서…   하지만 휴학동안 많은걸 겪기도 하고, 여러 글들을 보면서 많은 생각이 바뀌었다.  우선 돈에서 오는 행복은 일정수준 이상부터는 그 행복량이 빠르게 줄어든다는 것.  돈은 생각만큼 그렇게 큰 행복을 가져다 주지않는다. 돈에서 오는 행복은 log의 그래프로 증가하는데,  내가 정말 돈이 부족해서 생활이 불편할 정도의 소득 수준이라면 그 생활의 불편함이 해소되는 과정에서는 돈에서 오는 행 복량이 클 수 있지만, 어느정도 소득 수준이상부터는 그 정도가 크게 감소하는데,  금액적으로는 약 8500만원의 연봉 이상부터는 행복도가 아주 미미하게 증가한다.   그리고 또, 4월 즈음에 비트코인으로 큰 돈을 벌어 보면서, 돈이 주는 행복이 아주 미미하다는 것, 특히 일확천금이 주는 행복은 아주 미미하다는걸 깨달았다. 많은 복권당첨자들과 도박중독자들이 왜 불행을 겪는지 몸소 체험하면서, 앞으로 내 인생에서 짧은기간안에 큰 리스크를 감당하며 돈을 버는 일은 절대로 금하기로 했다.   그래서 나는 내 인생에서 돈을 크게 우선순위로 두지 않도록 하기로 했다. 물론 꾸준한 투자는 당연히 할것이지만, 노동소 득이 자본소득보다 하위에 있다고 생각하지 않기로 했다. 집값이 천정부지로 뛰고, 옆에서는 너도 나도 코인과 주식, 부동 산으로 벼락부자가 되어가는걸 보면 항상 많은 유혹이 생기겠지만, 그게 내 인생을 잡아먹는다면 혹여나 그 운에 당첨되서 큰돈을 벌어도 더큰돈과 더 큰 운을 찾아 결국에는 불행에 다다를 것이다.   난 그래서 그냥 내가 하고싶은걸 열심히 하면서, 너무 일과 돈에 잡아먹히는 삶은 살고싶지 않게됐다.  옛날에는 워라밸거리는 사람들을 보며 배부른 소리한다고 했던적도 있었는데 내가 틀렸었다는 것을 깨달았다.  정말 상위 1프로를 지향하며 하루에 10시간이 넘게 일하며 성공을 원하는 사람들도 있겠지만, 그 인생이 행복할 확률은 크지 않다는 걸 알게 되었다.   그래서 다시 내가 뭘진짜 하고싶은지 생각해봤다.   난 어릴때부터 코딩을 너무너무 좋아했다. 근데 자꾸 클수록 단순한 프로그래머 말고 더 더 높은것, 멋진걸 하고 싶은 마음 에 허세만 잔뜩들어서 하고싶지도 않은 멋진 직업을 자꾸 꿈꿨고, 머신러닝이니 AI니 금융이니 하고 싶은지, 내가 잘할 수 있는지도 모르는 방향으로 공부를 했다. 결국 저 세가지를 공부하며 즐거웠던 이유는 코딩이었고,   나는 다시 프로그래머가 되고 싶어졌다.  이러한 반년의 휴학을 결산하여 이뤄낸 것들을 모아보자면,           명확한 목표가 생겼다.  이제 어떤 직업을 갖고 어떤 일을 하며 살고싶은지 정확하고 디테일한 목표가 생겼다.            돈에 대해서 많은 깨달음을 얻었다.  인생에 대한 방향이 돈이 아닌 행복이 되었다.            코딩실력이 늘었다.   머신러닝을 공부하고 최근에는 코딩테스트를 열심히 공부하여 코딩실력이 많이 늘었다.            공부의 습관화   휴학을 하고 공부방법에 대해서도 많이 고민하고 개선하면서, 어느정도 공부의 효율성이 많이 올라갔다.       그래서 남은 휴학기간의 목표는 아래 네가지이다.           영어 실력 향상  프로그래머로써 영어는 매우 중요하다. 인터넷에서 얻는 정보의 대부분은 영어로 되어있는데, 특히나 프로그래머로써의 원하는 정보들은 대다수가 영어이다.            프로그래머로써의 포트폴리오 채우기  내가 무엇을 공부하고, 어떤 방향성을 가졌는지 나 혼자 공부해서는 아무도 알아주지않는다. 꾸준히 블로그에 기록하고, 커밋하고 무언가를 남겨야 한다. 기억하지말고 기록해야 나의 기억을 다른 사람도 이해해준다.            투자를 통한 자산증가  단기간에 큰 수익률을 올리는 것에서 이제 손을 떼고, 연 수익률 딱 15퍼센트를 목표로 천천히 매매하는 것을 목표로 지속 가능한 투자를 하는것이 목표이다.            오프라인 개발자 모임 참여  혼자 방구석에서 공부해서는 수많은 길이 있는지도 모른채로 한길만 택해서 나아갈 뿐이다.  또, 포트폴리오로 나를 증명하는것 보다, 남이 나를 증명해주는것이 백배는 효과적이다. 내 실력을 알아줄 다른 사람들을 사귀어야 한다.       남은 6개월도 힘내서, 1년결산때는 좀더 의미있는 결과를 자신한테 보여줬으면 좋겠다.   사실 6개월 동안의 결산이라고 해봤자 그냥 마냥 하기만 할뿐 어디에도 기록하지 않아서 추상적인 결과가 전부인데, 이제 는 내 성과를 기록할 장치들을 많이 만들어 놓아서 12월이 끝나고 쓰는 결산에서는 확실한 기록들을 가져와 내가 6개월동 안 얼마나 성장했는지 수치적으로 알 수 있도록 명확하게 쓰도록 할 것 이다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%9C%B4%ED%95%99-%EB%B0%98%EB%85%84-%EA%B2%B0%EC%82%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 5585 거스름돈 (Python3)",
        "excerpt":"문제  타로는 자주 JOI잡화점에서 물건을 산다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 언제나 거스름돈 개수가 가장 적게 잔돈을 준다. 타로가 JOI잡화점에서 물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때, 받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성하시오.   입력  입력은 한줄로 이루어져있고, 타로가 지불할 돈(1 이상 1000미만의 정수) 1개가 쓰여져있다.   출력  제출할 출력 파일은 1행으로만 되어 있다. 잔돈에 포함된 매수를 출력하시오.   1 2 3 4 5 6 7 8 예제 입력 1  복사 380 예제 출력 1  복사 4 예제 입력 2  복사 1 예제 출력 2  복사 15   1 2 3 4 5 6 7 8 9 10 11 12 price = int(input())  change = 1000 - price  a = change//500 b = change%500//100 c = change%500%100//50 d = change%500%100%50//10 e = change%500%100%50%10//5 f = change%500%100%50%10%5//1  print(sum([a,b,c,d,e,f]))   1 2 380 4   1   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88/",
        "teaser": null
      },{
        "title": "[BOJ] 2217 로프 (Python3)",
        "excerpt":"문제  N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.   하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.   각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.   입력  첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.   출력  첫째 줄에 답을 출력한다.   1 2 3 4 5 6 예제 입력 1  복사 2 10 15 예제 출력 1  복사 20   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 N = int(input()) #로프의 개수 weight = [] for i in range(N):     weight.append(int(input())) #weight 리스트에 로프의 중량을 넣어준다.      weight.sort() #오름차순으로 정렬  time = N  for i in range(N):     weight.append(weight[i]*time) #리스트의 첫요소보다 큰 요소의 개수만큼 곱해     time-=1 print(max(weight))   1 2 3 4 5 6 4 20 30 40 50 90   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%A1%9C%ED%94%84/",
        "teaser": null
      },{
        "title": "[BOJ] 1449 수리공 항승 (Python3)",
        "excerpt":"문제  항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.   파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.   항승이는 길이가 L인 테이프를 무한개 가지고 있다.   항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.   물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.   입력  첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.   출력  첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.   1 2 3 4 5 예제 입력 1  복사 4 2 1 2 100 101 예제 출력 1  복사 2   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 N, L = map(int, input().split()) # N: 물이새는 곳의 개수, L: 테이프의 길이  hole = list(map(int, input().split()))  hole.sort()  hole_strt = hole[0] tape = 1  for i in range(1, N):     if hole_strt + (L-1) &gt;= hole[i]:         continue      tape += 1     hole_strt = hole[i] print(tape)   1 2 3 4 2 1 2 3 4 2   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%88%98%EB%A6%AC%EA%B3%B5-%ED%95%AD%EC%8A%B9/",
        "teaser": null
      },{
        "title": "[BOJ] 14487 욱제는 도박쟁이야!! (Python3)",
        "excerpt":"문제  욱제는 라스베이거스에서 유명한 베팅꾼이다. 어찌나 게임을 잘 하는지 ‘제2의 홍진호’라는 별명이 붙었을 정도다. 어찌나 게임을 잘 하는지 ‘제2의 홍진호’라는 별명이 붙었을 정도다.   욱제가 주로 하는 게임은 아주 단순하고, 친숙한 게임이다. 바로 동전 뒤집기 게임이다. 이 게임에 쓰이는 동전의 양면에는 절댓값이 같고 부호가 다른 정수가 한 면에 하나씩 쓰여 있다. (단, 동전끼리는 쓰인 숫자의 절댓값이 다를 수 있다) 한 플레이어 당 두 번의 라운드가 주어진다. 모든 라운드는 같은 동전으로 진행되며, 딜러는 각 라운드마다 N개의 동전을 임의로 섞고 이를 일렬로 배열한다. 이때, 동전의 앞뒤 방향도 바뀔 수 있다. 첫 번째 라운드에서는 동전에 표시된 값들의 합이 최대가 되도록 뒤집어야 하고, 두 번째 라운드에서는 동전에 표시된 값들의 합이 최소가 되도록 뒤집어야 한다. (첫 번째 라운드 동전 값의 합) - (두 번째 라운드 동전 값의 합)이 해당 플레이어가 게임에서 획득한 점수이고, 이 점수가 최대가 되는 플레이어가 바로 게임의 승자가 된다.   욱제는 엄지, 검지, 중지를 이용해서 항상 연속한 3개의 동전을 뒤집는 최고의 동전 뒤집러이다. 욱제는 연속한 3개의 동전을 뒤집지 않으면 이길 수 없다고 생각하기 때문에 실패하는 경우 없이 항상 연속한 3개의 동전만 뒤집는다. 동전 배열의 양 끝에서 벗어나서 양 끝의 동전만 뒤집거나 양 끝의 두 개 동전만 뒤집는 것도 가능하다. 동전을 뒤집는 횟수에 제한은 없다.   (!) 너, 강해 보이는군. 나와 승부를 겨루자! 띠리링띠리링디리ㅣ리리ㅣ링~ 앗! 심술쟁이 해커 임준오(동탄 주민)이 승부를 걸어왔다!   욱제는 이번 게임에서 얼마의 점수를 획득하게 될까? 욱제는 최고의 베팅꾼이기 때문에 항상 게임에서 획득할 수 있는 최고의 점수를 얻는다는 사실은 자명하다.   입력  첫째 줄에 동전의 수 N이 주어진다. (1 &lt;= N &lt;= 10,000) 둘째 줄에 욱제의 첫 번째 라운드의 N개 동전의 배열이 주어진다. 셋째 줄에 욱제의 두 번째 라운드의 N개 동전의 배열이 주어진다. 동전에 적히는 숫자는 절댓값 10,000 이하의 정수이다.   출력  욱제가 이번 게임에서 획득할 점수를 출력한다.   1 2 3 4 5 6 예제 입력 1  복사 6 5 -2 -7 -8 9 1 -9 1 8 -7 5 2 예제 출력 1  복사 64  힌트  첫 번째 라운드에서 –2, -7, -8을 뒤집으면 동전 값의 합을 최대로 만들 수 있다.   두 번째 라운드에서 1, 8, -7을 뒤집고 7, 5, 2를 뒤집으면 동전 값의 합을 최소로 만들 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 N = int(input()) round_1 = list(map(int, input().split())) round_2 = list(map(int, input().split())) result = 0 for i in range(N):     result += abs(round_1[i])     result += abs(round_2[i]) print(result)     1 2 3 4 6 5 -2 -7 -8 9 1 -9 1 8 -7 5 2 64   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%9A%B1%EC%A0%9C%EB%8A%94-%EB%8F%84%EB%B0%95%EC%9F%81%EC%9D%B4%EC%95%BC!!/",
        "teaser": null
      },{
        "title": "[BOJ] 10162 전자레인지 (Python3)",
        "excerpt":"문제  3개의 시간조절용 버튼 A B C가 달린 전자레인지가 있다. 각 버튼마다 일정한 시간이 지정되어 있어 해당 버튼을 한번 누를 때마다 그 시간이 동작시간에 더해진다. 버튼 A, B, C에 지정된 시간은 각각 5분, 1분, 10초이다.   냉동음식마다 전자레인지로 요리해야할 시간 T가 초단위로 표시되어 있다. 우리는 A, B, C 3개의 버튼을 적절히 눌러서 그 시간의 합이 정확히 T초가 되도록 해야 한다. 단 버튼 A, B, C를 누른 횟수의 합은 항상 최소가 되어야 한다. 이것을 최소버튼 조작이라고 한다.   만일 요리시간이 100초라고 하면(T=100) B를 1번, C는 4번 누르면 된다. 이와 다르게 C를 10번 눌러도 100초가 되지만 이 경우 10번은 최소 횟수가 아니기 때문이 답이 될 수 없다. 이 경우 B 1번, C 4번, 총 5번이 최소버튼 조작이다. 그리고 T=234와 같이 3개의 버튼으로 시간을 정확히 맞출 수 없는 경우도 있다.   여러분은 주어진 요리시간 T초를 맞추기 위한 최소버튼 조작 방법을 구하는 프로그램을 작성해야 한다.   입력  첫 번째 줄에는 요리시간 T(초)가 정수로 주어져 있으며 그 범위는 1 ≤ T ≤ 10,000 이다.   출력  여러분은 T초를 위한 최소버튼 조작의 A B C 횟수를 첫 줄에 차례대로 출력해야 한다. 각각의 횟수 사이에는 빈 칸을 둔다. 해당 버튼을 누르지 않는 경우에는 숫자 0을 출력해야한다. 만일 제시된 3개의 버튼으로 T초를 맞출 수 없으면 음수 -1을 첫 줄에 출력해야 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 서브태스크 번호\t배점\t제한 1\t30\t T ≤ 60 2\t30\t T ≤ 300 3\t40\t T ≤ 10,000 예제 입력 1  복사 100 예제 출력 1  복사 0 1 4 예제 입력 2  복사 189 예제 출력 2  복사 -1   1 2 3 4 5 6 7 8 9 10 11 T = int(input())  if T%10 != 0:     print(-1) else:     A = T//300     B = T%300//60     C = T%300%60//10     print(A,B,C)     1 2 100 0 1 4   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%A0%84%EC%9E%90%EB%A0%88%EC%9D%B8%EC%A7%80/",
        "teaser": null
      },{
        "title": "[BOJ] 17208 카우버거 (Python3)",
        "excerpt":"문제  윤진이는 이번에 카우버거 알바생으로 뽑히게 되었다. 그녀는 카우버거를 평소에 이용하면서 들었던 의문점 한가지가 있었다.   “카우버거에는 왜 세트 메뉴에 대한 할인이 존재하지 않는가?”  따라서 윤진이의 아이디어로 카우버거에 세트 할인을 도입하고자 한다. 세트 메뉴는 버거 1개, 사이드 메뉴 1개, 음료 1개를 선택 할 경우 각각의 제품에 대해서 10%의 세트 할인을 적용하는 방식으로 진행된다.   하지만 카우버거 점주는 POS기의 소프트웨어가 오래되어 세트 할인에 대한 내용을 추가할 수가 없었다. 따라서 소프트웨어학부에 재학 중인 윤진이는 전공을 살려 직접 프로그램을 만들어보려고 한다. 윤진이를 도와 POS기에 들어갈 세트 할인에 대한 프로그램을 작성해보자.   입력  첫째 줄에는 주문한 버거의 개수 B, 사이드 메뉴의 개수 C, 음료의 개수 D가 공백을 사이에 두고 순서대로 주어진다. (1 ≤ B, C, D ≤ 1,000)   둘째 줄에는 각 버거의 가격이 공백을 사이에 두고 주어진다.   셋째 줄에는 각 사이드 메뉴의 가격이 공백을 사이에 두고 주어진다.   넷째 줄에는 각 음료의 가격이 공백을 사이에 두고 주어진다.   각 메뉴의 가격은 100의 배수이며, 10000원을 넘지 않는다.   출력  첫째 줄에는 세트 할인이 적용되기 전 가격을 출력한다.   둘째 줄에는 세트 할인이 적용된 후의 최소 가격을 출력한다.   예제 입력 1  복사  3 3 2  2000 3000 2500  800 1300 1000  500 1000  예제 출력 1  복사  12100  11170   힌트  입력 예에 나온 메뉴들의 가격을 모두 합하면 12100원이다.   첫 번째 세트는 3000원짜리 버거, 1300원짜리 사이드메뉴, 1000원짜리 음료로 구성하면 5300 * 0.9 = 4770원이다.   두 번째 세트는 2500원짜리 버거, 1000원짜리 사이드메뉴, 500원짜리 음료로 구성하면 4000 * 0.9 = 3600원이다.   남은 2000원짜리 버거와 800원짜리 사이드메뉴는 음료가 없으므로 세트 할인을 받을 수 없다. 따라서 세트 할인이 적용된 후의 최소 가격은 4770+3600+2800 = 11170원이 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 B, C, D = map(int, input().split())  #B: 버거의 개수, C : 사이드메뉴의 개수, D : 음료의 개수  B_list = list(map(int, input().split()))  C_list = list(map(int, input().split()))  D_list = list(map(int, input().split()))  B_list.sort(reverse= True) C_list.sort(reverse= True) D_list.sort(reverse= True)  set_num = min(B,C,D)       print(sum([sum(B_list), sum(C_list), sum(D_list)])) for i in range(set_num):     B_list[i] = B_list[i]*90/100     C_list[i] = C_list[i]*90/100     D_list[i] = D_list[i]*90/100      print(int(sum([sum(B_list), sum(C_list), sum(D_list)])))    1 2 3 4 5 6 3 3 3 2500 2000 2000 3000 3000 2500 800 200 300 16300 14670   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%B9%B4%EC%9A%B0%EB%B2%84%EA%B1%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 11034 캥거루 세마리2 (Python3)",
        "excerpt":"문제  캥거루 세 마리가 사막에서 놀고 있다. 사막에는 수직선이 하나 있고, 캥거루는 서로 다른 한 좌표 위에 있다.   한 번 움직일 때, 바깥쪽의 두 캥거루 중 한 마리가 다른 두 캥거루 사이의 정수 좌표로 점프한다. 한 좌표 위에 있는 캥거루가 두 마리 이상일 수는 없다.   캥거루는 최대 몇 번 움직일 수 있을까?   입력  여러개의 테스트 케이스로 이루어져 있으며, 세 캥거루의 초기 위치 A, B, C가 주어진다. (0 &lt; A &lt; B &lt; C &lt; 100)   출력  각 테스트에 대해 캥거루가 최대 몇 번 움직일 수 있는지 출력한다.  1 2 3 4 5 6 예제 입력 1   2 3 5 3 5 9 예제 출력 1   1 3   코드   1 2 3 4 5 6 while 1:     try:         A, B, C = map(int, input().split())#캥거루의 좌표 A,B,C를 입력받는다.  ##왼쪽캥거루가 뛰는 경우, 오른쪽 캥거루가 뛰는경우         print(max(C-B, B-A)-1)     except:         break   1 2 3 2 3 5 1 1 2   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%BA%A5%EA%B1%B0%EB%A3%A8-%EC%84%B8%EB%A7%88%EB%A6%AC-2/",
        "teaser": null
      },{
        "title": "[BOJ] 2810 컵홀더 (Python3)",
        "excerpt":"문제  십년이면 강산이 변한다.   강산이네 동네에 드디어 극장이 생겼고, 강산이는 극장에 놀러갔다. 매점에서 콜라를 산 뒤, 자리에 앉은 강산이는 큰 혼란에 빠졌다. 양쪽 컵홀더를 이미 옆 사람들이 차지했기 때문에 콜라를 꽂을 컵 홀더가 없었기 때문이다. 영화를 보는 내내 콜라를 손에 들고 있던 강산이는 극장에 다시 왔을 때는 꼭 콜라를 컵 홀더에 놓겠다는 다짐을 한 후 집에 돌아갔다.   극장의 한 줄에는 자리가 N개가 있다. 서로 인접한 좌석 사이에는 컵홀더가 하나씩 있고, 양 끝 좌석에는 컵홀더가 하나씩 더 있다. 또, 이 극장에는 커플석이 있다. 커플석 사이에는 컵홀더가 없다.   극장의 한 줄의 정보가 주어진다. 이때, 이 줄에 사람들이 모두 앉았을 때, 컵홀더에 컵을 꽂을 수 있는 최대 사람의 수를 구하는 프로그램을 작성하시오. 모든 사람은 컵을 한 개만 들고 있고, 자신의 좌석의 양 옆에 있는 컵홀더에만 컵을 꽂을 수 있다.   S는 일반 좌석, L은 커플석을 의미하며, L은 항상 두개씩 쌍으로 주어진다.   어떤 좌석의 배치가 SLLLLSSLL일때, 컵홀더를 *로 표시하면 아래와 같다.   SLLLLSSLL*  위의 예에서 적어도 두 명은 컵홀더를 사용할 수 없다.   입력  첫째 줄에 좌석의 수 N이 주어진다. (1 ≤ N ≤ 50) 둘째 줄에는 좌석의 정보가 주어진다.   출력  컵을 컵홀더에 놓을 수 있는 최대 사람의 수를 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 예제 입력 1  복사 3 SSS 예제 출력 1  복사 3 예제 입력 2  복사 4 SLLS 예제 출력 2  복사 4 예제 입력 3  복사 9 SLLLLSSLL 예제 출력 3  복사 7   코드   1 2 3 4 5 6 7 8 9 N = int(input()) #좌석의 수 N을 입력으로 받는다. S = input() #좌석의 정보 S를 입력으로 받는다. people = len(S) holder = len(S.replace('LL', 'S'))+1 if people &lt; holder:     print(people) else:     print(holder)    1 2 3 9 SLLLLSSLL 6   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%BB%B5%ED%99%80%EB%8D%94/",
        "teaser": null
      },{
        "title": "[BOJ] 14659 한조 서열 정리하고옴 ㅋㅋ(Python3)",
        "excerpt":"문제  “반갑다. 내 이름은 반고흐#31555! 조선 최고의 활잡이지. 오늘도 난 금강산 위에서 적들을 노리고 있지. 내 앞에 있는 적들이라면 누구도 놓치지 않아! 좋아, 이제 곧 월식이 시작되는군. 월식이 시작되면 용이 적들을 집어삼킬 것이다. 잘 봐두어라! 마장동 활잡이 반고흐#31555님의 실력을-!”   반고흐#31555는 자기 뒤쪽 봉우리에 덩기#3958이 있음을 전혀 모르고 있었다. 덩기#3958도 반고흐#31555와 마찬가지로 월식이 시작되면 용을 불러내어 눈앞에 있는 다른 활잡이들을 모두 처치할 생각이다. 사실, 반고흐#31555와 덩기#3958 뿐만 아니라 금강 산맥의 N개 봉우리에 있는 모든 활잡이들이 같은 생각을 가지고 있다.   반고흐#31555가 있는 금강 산맥에는 총 N개의 봉우리가 있고, 모든 봉우리마다 한 명의 활잡이가 서서 월식이 시작되기만을 기다리고 있다. 다만, 애석하게도, 천계에 맥도날드가 생겨 용들이 살이 찐 탓에 용들은 자신보다 낮은 봉우리에 서있는 적들만 처치할 수 있게 되었다. 또한 용들은 처음 출발한 봉우리보다 높은 봉우리를 만나면 그대로 공격을 포기하고 금강산자락에 드러누워 낮잠을 청한다고 한다. 봉우리의 높이는 모두 다르고 모든 용들은 오른쪽으로만 나아가며, 중간에 방향을 틀거나, 봉우리가 무너지거나 솟아나는 경우는 없다.   “달에 마구니가 끼었구나.”   드디어 월식이 시작됐다! 과연 이들 활잡이 중 최고의 활잡이는 누구일까? 최고의 활잡이가 최대 몇 명의 적을 처치할 수 있는지 알아보자.   입력  첫째 줄에 봉우리의 수 겸 활잡이의 수 N이 주어진다. (1 ≤ N ≤ 30,000) 둘째 줄에 N개 봉우리의 높이가 왼쪽 봉우리부터 순서대로 주어진다. (1 ≤ 높이 ≤ 100,000) 각각 봉우리의 높이는 중복 없이 유일하다.   출력  최고의 활잡이가 처치할 수 있는 적의 최대 숫자를 출력한다.   1 2 3 4 5 6 7 예제 입력 1   7 6 4 10 2 5 7 11 예제 출력 1   3 힌트 높이 10 봉우리에 있는 활잡이가 높이 2, 5, 7 봉우리에 있는 활잡이들을 처치할 수 있다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 N = int(input()) #봉우리, 활잡이의 수 N bow = list(map(int, input().split())) #봉우리의 높이를 받아 리스트로 저장한다.  max_num = bow[0] #최댓값에 첫번째 값을 넣음  kill = 0 result = []  for i in range(1, N): #반복하며 bow의 인자가 최댓값보다 작을때만 kill을 카운트하여               if max_num &gt; bow[i]:         kill+= 1         result.append(kill)               else:         result.append(kill)         kill = 0         max_num = bow[i]  print(max(result))                                       1 2 3 4 5 6 7 7 6 4 10 2 5 7 11 [1] [1, 1, 1] [1, 1, 1, 2] [1, 1, 1, 2, 3] 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%ED%95%9C%EC%A1%B0-%EC%84%9C%EC%97%B4%EC%A0%95%EB%A6%AC%ED%95%98%EA%B3%A0%EC%98%B4-%E1%84%8F%E1%84%8F/",
        "teaser": null
      },{
        "title": "[BOJ] 1339 단어 수학 (Python3)",
        "excerpt":"문제  민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.   단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.   예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.   N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.   입력  첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.   출력  첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 예제 입력 1  복사 2 AAA AAA 예제 출력 1  복사 1998 예제 입력 2  복사 2 GCF ACDEB 예제 출력 2  복사 99437 예제 입력 3  복사 10 A B C D E F G H I J 예제 출력 3  복사 45 예제 입력 4  복사 2 AB BA 예제 출력 4  복사 187   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from collections import defaultdict N = int(input()) #단어의 개수 N  word = []  for i in range(N):     word.append(input())  word.sort(reverse= True, key = lambda x: len(x))  num = [] result = [] dic = defaultdict() n = 9  # 알파벳을 키값으로 알파벳의 자릿수에 맞는 10의 배수를 딕셔너리에 저장해준다. for alpha in word:      k = len(alpha)-1          for i in range(len(alpha)):         #딕셔너리에 이미 있으면 밸류에 자릿수를 더해준다.         if alpha[i] in dic:             dic[alpha[i]]+= pow(10, k)         else:             dic[alpha[i]]= pow(10, k)         k-=1  #딕셔너리의 밸류만을 값으로 갖는 리스트 num을 만들어준다. for value in dic.values():     num.append(value)  # 내림차순 정렬 num.sort(reverse= True)  #큰수부터 9-0을 곱해준다. t = 9 for i in range(len(num)):     num[i] = num[i]*t     t-=1           print(sum(num))         1 2 3 4 2 AAA AAA 1998   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%8B%A8%EC%96%B4-%EC%88%98%ED%95%99/",
        "teaser": null
      },{
        "title": "[BOJ] 11047 동전 0 (Python3)",
        "excerpt":"문제  준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.      동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)   둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)   출력  첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 예제 입력 1  복사 10 4200 1 5 10 50 100 500 1000 5000 10000 50000 예제 출력 1  복사 6 예제 입력 2  복사 10 4790 1 5 10 50 100 500 1000 5000 10000 50000 예제 출력 2  복사 12   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 N, K = map(int, input().split())  coin = []  for i in range(N):     coin.append(int(input()))   ans = 0 money = K i = len(coin)-1 while money:     c = coin[i]      if c &lt;= money:         ans += money//c         money = money%c         i-=1     else:         i-=1  print(ans)                  1 2 3 4 5 6 7 8 9 10 11 12 10 4790 1 5 10 50 100 500 1000 5000 10000 50000 12   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%8F%99%EC%A0%84-0/",
        "teaser": null
      },{
        "title": "[BOJ] 1052 물병 (Python3)",
        "excerpt":"문제  지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.   물은 다음과 같이 재분배 한다.   먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.  이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.   예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.   입력  첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.   출력  첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.   1 2 3 4 예제 입력 1  복사 3 1 예제 출력 1  복사 1   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 N, K = map(int, input().split()) #물병의 개수 N, 지민이가 한번에 옮길 수 있는 물병의 개수 K   def check(num): #최대로 합칠 수 있는 물병의 개수를 반환하는 함수     ans = 0     while (1):          a = num//2 #하나로 합친 물병의 수 a         b = num%2 # 합치지 못합 물병의 수 b         num = a          ans+=b         if num == 0:             break     return ans  if K &gt;= N:     print(0)      else:     i = N     while (1):         if check(i) &lt;= K:             print(i-N)             break         else:             i+=1                                        1 2 5 1 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%AC%BC%EB%B3%91/",
        "teaser": null
      },{
        "title": "[BOJ] 2473 되었을까? (Python3)",
        "excerpt":"문제  하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 한다. 이 저울의 양 팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있다.   무게가 양의 정수인 N개의 저울추가 주어질 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값을 구하는 프로그램을 작성하시오.   예를 들어, 무게가 각각 3, 1, 6, 2, 7, 30, 1인 7개의 저울추가 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21이다.   입력  첫 째 줄에는 저울추의 개수를 나타내는 양의 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 둘째 줄에는 저울추의 무게를 나타내는 N개의 양의 정수가 빈칸을 사이에 두고 주어진다. 각 추의 무게는 1이상 1,000,000 이하이다.   출력  첫째 줄에 주어진 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 출력한다.   1 2 3 4 5 예제 입력 1  복사 7 3 1 6 2 7 30 1 예제 출력 1  복사 21   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #무게추의 개수 N N = int(input())  #무게추들의 값을 공백을 기준으로 나눈 값으로 받아 리스트로 저장한다. weights = list(map(int, input().split()))  #리스트 정렬 weights.sort()  target = 1  for i in weights:     if target &lt; i:         break     target+= i print(target)      1 2 3 4 5 6 7 8 7 3 1 6 2 7 30 1 2 3 5 8 14 21   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%A0%80%EC%9A%B8/",
        "teaser": null
      },{
        "title": "카드 정렬하기",
        "excerpt":"{  \"cells\": [   {    \"cell_type\": \"markdown\",    \"id\": \"f2f2097e\",    \"metadata\": {},    \"source\": [     \"---\\n\",     \"title: \\\"[BOJ] 1715 카드 정렬하기 (Python3)\\\"\\n\",     \"\\n\",     \"categories:\\n\",     \"    baekjoon\\n\",     \"tags:\\n\",     \"    백준\\n\",     \"    파이썬\\n\",     \"    Greedy\\n\",     \"toc: true\\n\",     \"toc_label: \\\"On this page\\\"\\n\",     \"toc_sticky: true\\n\",     \"\\n\",     \"    \\n\",     \"---\\n\",     \"## 문제\\n\",     \"정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.\\n\",     \"\\n\",     \"매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.\\n\",     \"\\n\",     \"N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.\\n\",     \"\\n\",     \"## 입력\\n\",     \"첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.\\n\",     \"\\n\",     \"## 출력\\n\",     \"첫째 줄에 최소 비교 횟수를 출력한다.\\n\",     \"\\n\",     \"```\\n\",     \"예제 입력 1  \\n\",     \"3\\n\",     \"10\\n\",     \"20\\n\",     \"40\\n\",     \"예제 출력 1  \\n\",     \"100\\n\",     \"```\\n\",     \"\\n\",     \"## 코드\"    ]   },   {    \"cell_type\": \"code\",    \"execution_count\": 47,    \"id\": \"94cae64c\",    \"metadata\": {},    \"outputs\": [     {      \"name\": \"stdout\",      \"output_type\": \"stream\",      \"text\": [       \"3\\n\",       \"10\\n\",       \"20\\n\",       \"40\\n\",       \"100\\n\"      ]     }    ],    \"source\": [     \"import heapq\\n\",     \"\\n\",     \"#카드 묶음의 개수 N\\n\",     \"N = int(input()) \\n\",     \"\\n\",     \"queue = []\\n\",     \"\\n\",     \"#큐에 인풋값들을 힙 푸쉬해준다.\\n\",     \"for i in range(N):\\n\",     \"    heapq.heappush(queue, int(input()))\\n\",     \"\\n\",     \"result = 0\\n\",     \"#큐의 값들을 앞에서부터 작은순으로 더해서 다시 힙큐에 푸쉬해준다.\\n\",     \"while len(queue) > 1:\\n\",     \"    sum_value = 0\\n\",     \"    for _ in range(2):\\n\",     \"        sum_value += heapq.heappop(queue)\\n\",     \"    result+= sum_value\\n\",     \"    heapq.heappush(queue, sum_value)\\n\",     \"print(result)\\n\",     \"    \\n\",     \"    \"    ]   }  ],  \"metadata\": {   \"kernelspec\": {    \"display_name\": \"Python 3\",    \"language\": \"python\",    \"name\": \"python3\"   },   \"language_info\": {    \"codemirror_mode\": {     \"name\": \"ipython\",     \"version\": 3    },    \"file_extension\": \".py\",    \"mimetype\": \"text/x-python\",    \"name\": \"python\",    \"nbconvert_exporter\": \"python\",    \"pygments_lexer\": \"ipython3\",    \"version\": \"3.8.8\"   }  },  \"nbformat\": 4,  \"nbformat_minor\": 5 } ","categories": [],
        "tags": [],
        "url": "/%EC%B9%B4%EB%93%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 15903 카드 합체 놀이 (Python3)",
        "excerpt":"문제  석환이는 아기다. 아기 석환이는 자연수가 쓰여져있는 카드를 갖고 다양한 놀이를 하며 노는 것을 좋아한다. 오늘 아기 석환이는 무슨 놀이를 하고 있을까? 바로 카드 합체 놀이이다!   아기 석환이는 자연수가 쓰여진 카드를 n장 갖고 있다. 처음에 i번 카드엔 ai가 쓰여있다. 카드 합체 놀이는 이 카드들을 합체하며 노는 놀이이다. 카드 합체는 다음과 같은 과정으로 이루어진다.   x번 카드와 y번 카드를 골라 그 두 장에 쓰여진 수를 더한 값을 계산한다. (x ≠ y)  계산한 값을 x번 카드와 y번 카드 두 장 모두에 덮어 쓴다.  이 카드 합체를 총 m번 하면 놀이가 끝난다. m번의 합체를 모두 끝낸 뒤, n장의 카드에 쓰여있는 수를 모두 더한 값이 이 놀이의 점수가 된다. 이 점수를 가장 작게 만드는 것이 놀이의 목표이다.   아기 석환이는 수학을 좋아하긴 하지만, 아직 아기이기 때문에 점수를 얼마나 작게 만들 수 있는지를 알 수는 없었다(어른 석환이는 당연히 쉽게 알 수 있다). 그래서 문제 해결 능력이 뛰어난 여러분에게 도움을 요청했다. 만들 수 있는 가장 작은 점수를 계산하는 프로그램을 만들어보자.   입력  첫 번째 줄에 카드의 개수를 나타내는 수 n(2 ≤ n ≤ 1,000)과 카드 합체를 몇 번 하는지를 나타내는 수 m(0 ≤ m ≤ 15×n)이 주어진다.   두 번째 줄에 맨 처음 카드의 상태를 나타내는 n개의 자연수 a1, a2, …, an이 공백으로 구분되어 주어진다. (1 ≤ ai ≤ 1,000,000)   출력  첫 번째 줄에 만들 수 있는 가장 작은 점수를 출력한다.   1 2 3 4 5 6 7 8 9 10 예제 입력 1  복사 3 1 3 2 6 예제 출력 1  복사 16 예제 입력 2  복사 4 2 4 2 3 1 예제 출력 2  복사 19   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 n, m = map(int, input().split()) # n: 카드의 개수, m: 합체 수  a = list(map(int, input().split())) # 카드의 숫자를 리스트에 넣어준다.  a.sort()  for i in range(m):     a.sort()     a[0] = a[1] = a[0]+a[1] print(sum(a))       1 2 3 4 2 4 2 3 1 19   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%B9%B4%EB%93%9C-%ED%95%A9%EC%B2%B4-%EB%86%80%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[BOJ] 16173 점프왕 쩰리(small) (Python3)",
        "excerpt":"문제  ‘쩰리’는 점프하는 것을 좋아하는 젤리다. 단순히 점프하는 것에 지루함을 느낀 ‘쩰리’는 새로운 점프 게임을 해보고 싶어 한다. 새로운 점프 게임의 조건은 다음과 같다.   ‘쩰리’는 가로와 세로의 칸 수가 같은 정사각형의 구역 내부에서만 움직일 수 있다. ‘쩰리’가 정사각형 구역의 외부로 나가는 경우엔 바닥으로 떨어져 즉시 게임에서 패배하게 된다.  ‘쩰리’의 출발점은 항상 정사각형의 가장 왼쪽, 가장 위의 칸이다. 다른 출발점에서는 출발하지 않는다.  ‘쩰리’가 이동 가능한 방향은 오른쪽과 아래 뿐이다. 위쪽과 왼쪽으로는 이동할 수 없다.  ‘쩰리’가 가장 오른쪽, 가장 아래 칸에 도달하는 순간, 그 즉시 ‘쩰리’의 승리로 게임은 종료된다.  ‘쩰리’가 한 번에 이동할 수 있는 칸의 수는, 현재 밟고 있는 칸에 쓰여 있는 수 만큼이다. 칸에 쓰여 있는 수 초과나 그 미만으로 이동할 수 없다.  새로운 게임이 맘에 든 ‘쩰리’는, 계속 게임을 진행해 마침내 최종 단계에 도달했다. 하지만, 게임을 진행하는 구역이 너무 넓어져버린 나머지, 이 게임에서 이길 수 있는지 없는지 가늠할 수 없어졌다. ‘쩰리’는 유능한 프로그래머인 당신에게 주어진 구역에서 승리할 수 있는 지 알아봐 달라고 부탁했다. ‘쩰리’를 도와 주어진 게임 구역에서 끝 점(오른쪽 맨 아래 칸)까지 도달할 수 있는지를 알아보자!   입력  입력의 첫 번째 줄에는 게임 구역의 크기 N (2 ≤ N ≤ 3)이 주어진다.   입력의 두 번째 줄부터 마지막 줄까지 게임판의 구역(맵)이 주어진다.   게임판의 승리 지점(오른쪽 맨 아래 칸)에는 -1이 쓰여있고, 나머지 칸에는 0 이상 100 이하의 정수가 쓰여있다.   출력  ‘쩰리’가 끝 점에 도달할 수 있으면 “HaruHaru”(인용부호 없이), 도달할 수 없으면 “Hing” (인용부호 없이)을 한 줄에 출력합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 예제 입력 1   3 1 1 10 1 5 1 2 2 -1  예제 출력 1   HaruHaru 쩰리는 맨 왼쪽 위의 칸에서 출발해 (행, 열)로 나타낸 좌표계로,  (1, 1) -&gt; (2, 1) -&gt; (3, 1) -&gt; (3, 3)으로 이동해 게임에서 승리할 수 있다.  예제 입력 2   3 2 2 1 2 2 2 1 2 -1  예제 출력 2   Hing 쩰리는 맨 왼쪽 위의 칸에서 출발하더라도 절대 게임의 승리 지점인 (3, 3)에 도달할 수 없다.   풀이   이 문제는 dfs를 사용하여 풀이하는 문제이다.  visited를 따로 만들어주어 방문을 확인하면서 큐에 넣어가며 탐색을 하고,  맵의 좌표에 적혀있는 숫자만큼 전진하여야 되므로 따로 step이라는 변수에 좌표의 숫자를 저장하여 그 숫자만큼 이동하여 탐색하도록 해주면 간단하게 풀 수 있다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from collections import deque  n = int(input())  maps = [list(map(int, input().split())) for _ in range(n)]    dx = [-1,1,0,0] dy = [0,0,-1,1]   def bfs(sx : int, sy : int)-&gt;bool:     q = deque()     q.append([sx,sy])          visited = [[False]*3 for _ in range(n)]          while q:         x,y = q.popleft()         step = maps[x][y]                  if maps[x][y] == -1:             return True         for dir in range(4):             nx, ny = x+dx[dir]*step, y+dy[dir]*step             if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n:                 if not visited[nx][ny]:                     visited[nx][ny] = True                     q.append([nx,ny])   if bfs(0,0):     print('HaruHaru') else:     print('Hing')          1 2 3 4 5 3  1 1 10 1 5 1 2 2 -1 Hing   ","categories": ["baekjoon"],
        "tags": ["코딩테스트","백준","파이썬"],
        "url": "/baekjoon/BOJ-16173-%EC%A0%90%ED%94%84%EC%99%95-%EC%A9%B0%EB%A6%AC(small)-Python-%EB%B3%B5%EC%82%AC%EB%B3%B8/",
        "teaser": null
      },{
        "title": "[Programmers] 회문 (Python3)",
        "excerpt":"문제  회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.   여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다.   입력   입력의 첫 줄에는 주어지는 문자열의 개수를 나타내는 정수 T(1 ≤ T ≤ 30)가 주어진다. 다음 줄부터 T개의 줄에 걸쳐 한 줄에 하나의 문자열이 입력으로 주어진다. 주어지는 문자열의 길이는 3 이상 100,000 이하이고, 영문 알파벳 소문자로만 이루어져 있다.   출력   각 문자열이 회문인지, 유사 회문인지, 둘 모두 해당되지 않는지를 판단하여 회문이면 0, 유사 회문이면 1, 둘 모두 아니면 2를 순서대로 한 줄에 하나씩 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 예제 입력 1   7 abba summuus xabba xabbay comcom comwwmoc comwwtmoc 예제 출력 1   0 1 1 2 2 0 1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def inner_palindrome(word, left, right):     while left &lt; right:         if word[left] == word[right]:             left += 1             right -=1         else:             return False                  return True    def is_palindrome(word, left, right):     while left &lt; right:         if word[left] == word[right]:             left += 1             right -=1         else:             if inner_palindrome(word, left+1, right) or inner_palindrome(word, left, right-1):                 return 1             else:                 return 2                  return 0     #회문을 판별하다가 서로 다른 문자가 있으면 유사회문인지 회문이 아닌지 판별하는 함수를 재귀함수를 사용하여 정의  T = int(input()) #문자열의 개수 T  string = [] for i in range(T):     string.append(input()) # T의 개수만큼 받아 리스트로 저장  answer = [] for word in string:     left = 0     right = len(word)-1     answer.append(is_palindrome(word, left, right)) # is_palindrome 함수를 사용하여 순서대로 회문인지 판별  for i in range(len(answer)):     print(answer[i])   1 2 3 1 summuus 1   ","categories": ["programmers"],
        "tags": ["코딩테스트","Programmers","파이썬"],
        "url": "/programmers/Programmers-%ED%9A%8C%EB%AC%B8/",
        "teaser": null
      },{
        "title": " [BOJ] 1012 유기농배추 (Python3)",
        "excerpt":"문제  차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.   한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.  1 2 3 4 5 6 1\t1\t0\t0\t0\t0\t0\t0\t0\t0 0\t1\t0\t0\t0\t0\t0\t0\t0\t0 0\t0\t0\t0\t1\t0\t0\t0\t0\t0 0\t0\t0\t0\t1\t0\t0\t0\t0\t0 0\t0\t1\t1\t0\t0\t0\t1\t1\t1 0\t0\t0\t0\t1\t0\t0\t1\t1\t`   입력  입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.   출력  각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 예제 입력 1  복사 2 10 8 17 0 0 1 0 1 1 4 2 4 3 4 5 2 4 3 4 7 4 8 4 9 4 7 5 8 5 9 5 7 6 8 6 9 6 10 10 1 5 5 예제 출력 1  복사 5 1 예제 입력 2  복사 1 5 3 6 0 2 1 2 2 2 3 2 4 2 4 0 예제 출력 2  복사 2   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import sys sys.setrecursionlimit(10**6) def dfs(x: int, y: int)-&gt; bool:      if x &lt; 0 or x &gt;= M or y &lt; 0 or y &gt;= N:         return False     if graph[y][x] == 1:         graph[y][x] = 2         dfs(x-1, y)         dfs(x+1, y)         dfs(x, y+1)         dfs(x, y-1)         return True     return False #테스트 케이스의 개수 T = int(input())  answer = [] for i in range(T):     #가로길이 M, 세로길이 N, 배추의 위치의 개수 K     M, N, K = map(int, input().split())     graph = [[0]*M for i in range(N)]     result = 0     for i in range(K):         x,y = map(int, input().split())         graph[y][x] = 1     for i in range(M):         for j in range(N):             if graph[j][i] == 1:                 if dfs(i,j) == True:                     result += 1     answer.append(result)      for i in answer:     print(i)   1 2 3 4 5 6 7 8 9 1 5 3 6 0 2 1 2 2 2 3 2 4 2 4 0 2   ","categories": ["baekjoon"],
        "tags": ["코딩테스트","백준","파이썬"],
        "url": "/baekjoon/BOJ-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/",
        "teaser": null
      },{
        "title": "[BOJ] 2468 안전영역 (Python3)",
        "excerpt":"문제  재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다. 이때, 문제를 간단하게 하기 위하여, 장마철에 내리는 비의 양에 따라 일정한 높이 이하의 모든 지점은 물에 잠긴다고 가정한다.   어떤 지역의 높이 정보는 행과 열의 크기가 각각 N인 2차원 배열 형태로 주어지며 배열의 각 원소는 해당 지점의 높이를 표시하는 자연수이다. 예를 들어, 다음은 N=5인 지역의 높이 정보이다.  1 2 3 4 5 6\t8\t2\t6\t2 3\t2\t3\t4\t6 6\t7\t3\t3\t2 7\t2\t5\t3\t6 8\t9\t5\t2\t7  이제 위와 같은 지역에 많은 비가 내려서 높이가 4 이하인 모든 지점이 물에 잠겼다고 하자. 이 경우에 물에 잠기는 지점을 회색으로 표시하면 다음과 같다.  1 2 3 4 5 6\t8\t2\t6\t2 3\t2\t3\t4\t6 6\t7\t3\t3\t2 7\t2\t5\t3\t6 8\t9\t5\t2\t7  물에 잠기지 않는 안전한 영역이라 함은 물에 잠기지 않는 지점들이 위, 아래, 오른쪽 혹은 왼쪽으로 인접해 있으며 그 크기가 최대인 영역을 말한다. 위의 경우에서 물에 잠기지 않는 안전한 영역은 5개가 된다(꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다).   또한 위와 같은 지역에서 높이가 6이하인 지점을 모두 잠기게 만드는 많은 비가 내리면 물에 잠기지 않는 안전한 영역은 아래 그림에서와 같이 네 개가 됨을 확인할 수 있다.  1 2 3 4 5 6\t8\t2\t6\t2 3\t2\t3\t4\t6 6\t7\t3\t3\t2 7\t2\t5\t3\t6 8\t9\t5\t2\t7  이와 같이 장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다. 위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면 물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다.   어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.   입력  첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다. N은 2 이상 100 이하의 정수이다. 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다. 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다. 높이는 1이상 100 이하의 정수이다.   출력  첫째 줄에 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 예제 입력 1  복사 5 6 8 2 6 2 3 2 3 4 6 6 7 3 3 2 7 2 5 3 6 8 9 5 2 7 예제 출력 1  복사 5 예제 입력 2  복사 7 9 9 9 9 9 9 9 9 2 1 2 1 2 9 9 1 8 7 8 1 9 9 2 7 9 7 2 9 9 1 8 7 8 1 9 9 2 1 2 1 2 9 9 9 9 9 9 9 9 예제 출력 2  복사 6  노트  아무 지역도 물에 잠기지 않을 수도 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import sys sys.setrecursionlimit(10**6)  def dfs(x,y,water):     if x &lt; 0 or x &gt;=n or y &lt; 0 or y &gt;= n:         return False          if graph[y][x] &gt; water:         if not visited[y][x]:             visited[y][x] = True                      dfs(x+1, y, water)             dfs(x-1,y , water)             dfs(x, y+1, water)             dfs(x, y-1, water)             return True              return False      #n: 지역의 크기 N n = int(input())  #그래프 리스트 graph = [] for i in range(n):     graph.append(list(map(int, input().split())))  answer = []   max_num = max(map(max,graph))  for water in range(max_num+1):     result = 0     visited = [[False]*n for i in range(n)]     for i in range(n):         for j in range(n):             if graph[j][i]:                 if dfs(i,j,water):                     result+=1     answer.append(result)           print(max(answer))    1 2 3 4 5 3 2 2 2 2 2 2 2 2 2 1   ","categories": ["baekjoon"],
        "tags": ["코딩테스트","백준","파이썬"],
        "url": "/baekjoon/%EC%95%88%EC%A0%84%EC%98%81%EC%97%AD/",
        "teaser": null
      },{
        "title": "[BOJ] 12761 돌다리 (Pytyon3)",
        "excerpt":"문제  동규와 주미는 일직선 상의 돌 다리 위에있다. 돌의 번호는 0 부터 100,000 까지 존재하고 동규는   N번 돌 위에, 주미는 M번 돌 위에 위치하고 있다. 동규는 주미가 너무 보고싶기 때문에 최대한 빨리 주미에게 가기 위해 A,B만큼의 힘을 가진 스카이 콩콩을 가져왔다. 동규가 정한 다리를 건너는 규칙은 턴 방식인데, 한 턴에 이동할 수 있는 거리는 이러하다. 현 위치에서 +1칸, -1칸을 이동할 수 있고, 스카이 콩콩을 이용해 현 위치에서 A나 B만큼 좌우로 점프할 수 있으며, 순간적으로 힘을 모아 현 위치의 A배나 B배의 위치로 이동을 할 수 있다.   예를 들어 지금 동규가 7번 돌 위에 있고 스카이 콩콩의 힘이 8이면 그냥 점프를 해서 15번 돌에 갈 수도 있고, 순간적으로 힘을 모아 56번 돌에 갈 수도 있다는 것이다. 주어진 8가지의 방법 중 적절한 방법을 골라서 최대한 빨리 동규가 주미를 만날 수 있게 도와주자. 단, 이동 과정에서 100,000보다 크거나 0보다 작은 번호의 돌은 존재하지 않으므로 갈 수 없고, 같은 방법을 계속 사용해도 되며 항상 도달할 수 있는 케이스만 주어진다.   입력  입력의 첫 줄에 스카이 콩콩의 힘 A와 B, 그리고 동규의 현재위치 N,   주미의 현재 위치 M이 주어진다. (단, 2≤A,B≤30이고 0≤N,M≤100,000)   출력  동규가 주미에게 도달하기 위한 최소한의 이동 횟수를 출력하라.   1 2 3 4 5 6 7 8 9 10 예제 입력 1   2 3 1 20 예제 출력 1   4   예제 입력 2   3 7 2 98500 예제 출력 2   10  풀이  좌우좌표계로 연결된 노드로 생각하고 bfs를 사용하여 방문한적이 없다면 점프하기 전의 위치에서 1을 더한값을 현재위치에 저장해 주며 앞으로 끝까지 나아간다. 그 이후에 주미가 있는 곳의 숫자를 출력해주면, 그 숫자가 동규가 주미에게 도달하기위한 최소 이동 횟수가 된다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from collections import deque def bfs(x):     visited[x] = 1     q = deque()     q.append(x)     while q:         nx = q.popleft()         for i in range(8):             if i &lt; 6:                 sx = nx+dx[i]                 if 0 &lt;= sx &lt;= 100000 and visited[sx] == 0:                     q.append(sx)                     visited[sx] = 1                     stone[sx] = stone[nx]+1                              else:                 sx = nx*dx[i]                 if 0 &lt;= sx &lt;= 100000 and visited[sx] == 0:                     q.append(sx)                     visited[sx] = 1                     stone[sx] = stone[nx]+1                           A,B,N,M = map(int, input().split())  stone = [0 for i in range(100001)] visited = [0 for i in range(100001)]  dx =[1,-1,A,-A,B,-B,A,B]  bfs(N)  print(stone[M])   1 2 2 3 1 20 4   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/BOJ-12761-%EB%8F%8C%EB%8B%A4%EB%A6%AC-(Pytyon3)/",
        "teaser": null
      },{
        "title": "[BOJ] 16956 늑대와 양 (Python3)",
        "excerpt":"문제  크기가 R×C인 목장이 있고, 목장은 1×1 크기의 칸으로 나누어져 있다. 각각의 칸에는 비어있거나, 양 또는 늑대가 있다. 양은 이동하지 않고 위치를 지키고 있고, 늑대는 인접한 칸을 자유롭게 이동할 수 있다. 두 칸이 인접하다는 것은 두 칸이 변을 공유하는 경우이다.   목장에 울타리를 설치해 늑대가 양이 있는 칸으로 갈 수 없게 하려고 한다. 늑대는 울타리가 있는 칸으로는 이동할 수 없다. 울타리를 설치해보자.   입력  첫째 줄에 목장의 크기 R, C가 주어진다.   둘째 줄부터 R개의 줄에 목장의 상태가 주어진다. ‘.’는 빈 칸, ‘S’는 양, ‘W’는 늑대이다.   출력  늑대가 양이 있는 칸으로 갈 수 없게 할 수 있다면 첫째 줄에 1을 출력하고, 둘째 줄부터 R개의 줄에 목장의 상태를 출력한다. 울타리는 ‘D’로 출력한다. 울타리를 어떻게 설치해도 늑대가 양이 있는 칸으로 갈 수 있다면 첫째 줄에 0을 출력한다.   제한   1 ≤ R, C ≤ 500     예제 입력 1      6 6        ..S…      ..S.W.      .S….      ..W…      …W..      ……      예제 출력 1        1      ..SD..      ..SDW.        .SD…       .DW…       DD.W..       ……   예제 입력 2         1 2       SW       예제 출력 2         0   예제 입력 3         5 5       .S…       …S.       S….       …S.       .S…  예제 출력 3  복사       1       .S…       …S.       S.D..       …S.       .S…   노트  이 문제는 설치해야 하는 울타리의 최소 개수를 구하는 문제가 아니다.   문제풀이  이 예제에는 양과 늑대가 딱 분리될정도만 울타리를 쳐서 출력되게 되어있어서 이걸 어떻게 구현해야할지 아무리 고민해도 답이 안나와서 다른사람들은 어떻게 풀었나 하고 봤는데, 그냥 모든 평지를 울타리로 박아도 답으로 통과가 되서 허무했다.   어째 실버4 수준이라기엔 너무 복잡해서 어려웠는데, 양과 늑대를 제외하고 다 울타리로 막아버리게 되면 아주 단순한 기본적인 bfs풀이 문제이다.   모든 좌표를 방문하여,   1 2 3 4 5 * 좌표에 해당하는 문자가 W일 경우에는 bfs로 상하좌우를 확인 후, 양이 상하좌우에 있다면 반복문을 break하고 kill을 True로 바꾸고 0을 출력  * 좌표에 해당하는 문자가 S일 경우에는 continue  * 좌표에 해당하는 문자가 .일 경우에는 .을 D로 바꾸기   위 반복문이 끝나고 kill이 False라면 1과함께 리스트를 문자열로 다시 출력한다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #목장의 크기 r,c r,c = map(int,input().split()) #목장의 상태 pasture pasture = [] for i in range(r):     pasture.append(list(input())) dx = [-1,1,0,0] dy = [0,0,1,-1] kill = False for i in range(r):     for j in range(c):         if pasture[i][j] == 'W':             for k in range(4):                 nx = i+dx[k]                 ny = j+dy[k]                 if nx &lt;0 or nx&gt;=r or ny&lt;0 or ny&gt;=c:                     continue                              if pasture[nx][ny] == 'S':                     kill = True                     break         elif pasture[i][j] == 'S':             continue         elif pasture[i][j] == '.':             pasture[i][j] = 'D' if kill:     print(0) else:     print(1)     for i in range(len(pasture)):         print(\"\".join(pasture[i]))                   1 2 3 1 2 SW 0   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/BOJ-16956-%EB%8A%91%EB%8C%80%EC%99%80-%EC%96%91-(Python3)/",
        "teaser": null
      },{
        "title": "[BOJ] 17086 아기상어2 (Python3)",
        "excerpt":"문제  N×M 크기의 공간에 아기 상어 여러 마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 아기 상어가 최대 1마리 존재한다.   어떤 칸의 안전 거리는 그 칸과 가장 거리가 가까운 아기 상어와의 거리이다. 두 칸의 거리는 하나의 칸에서 다른 칸으로 가기 위해서 지나야 하는 칸의 수이고, 이동은 인접한 8방향(대각선 포함)이 가능하다.   안전 거리가 가장 큰 칸을 구해보자.   입력  첫째 줄에 공간의 크기 N과 M(2 ≤ N, M ≤ 50)이 주어진다. 둘째 줄부터 N개의 줄에 공간의 상태가 주어지며, 0은 빈 칸, 1은 아기 상어가 있는 칸이다. 빈 칸의 개수가 한 개 이상인 입력만 주어진다.   출력  첫째 줄에 안전 거리의 최댓값을 출력한다.   예제 입력 1           5 4     0 0 1 0     0 0 0 0     1 0 0 0     0 0 0 0     0 0 0 1     예제 출력 1          2   예제 입력 2       7 4     0 0 0 1     0 1 0 0     0 0 0 0     0 0 0 1     0 0 0 0     0 1 0 0     0 0 0 1     예제 출력 2      2   문제풀이  bfs 문제인데, 다른 문제들과 다르게 4방향이 아닌 대각선을 포함한 8방향으로 이동할 수 있다는게 특이한 문제이다. 다른 문제들과 마찬가지로 bfs로 풀이하면 되지만  dx와 dy를 8개의 요소를 갖는 리스트로 선언해주고 모든 좌표를 방문하다가 상어가 있는 좌표에 도달하면 bfs함수를 불러와 다름 1이 나올때까지 이동하며 그 이동거리를 누적하여 더해준 후, 가장 큰 안전거리 값을 출력한다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from collections import deque def bfs():     while q:         x,y = q.popleft()         for k in range(8):             nx,ny = x + dx[k], y + dy[k]             if nx &lt; 0 or nx&gt;=n or ny &lt;0 or ny &gt;=m:                 continue             if space[nx][ny] == 0:                 q.append([nx,ny])                 space[nx][ny] = space[x][y] + 1          #공간의 크기 n,m n,m = map(int,input().split())  q = deque()  #공간의 모습  space = [] for i in range(n):     space.append(list(map(int, input().split())))     for j in range(m):         if space[i][j] == 1:             q.append([i,j])               #대각선 이동하기 위한 dx, dy dx = [1,-1,0,0,1,-1,1,-1] dy = [0,0,1,-1,1,-1,-1,1]   bfs() dist = 0 for i in range(n):     for j in range(m):         dist = max(space[i][j], dist)          print(dist-1)   1 2 3 4 5 6 7 8 9 7 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/BOJ-17086-%EC%95%84%EA%B8%B0%EC%83%81%EC%96%B42-(Python3)/",
        "teaser": null
      },{
        "title": "[BOJ] 1326 폴짝폴짝 (Python3)",
        "excerpt":"문제  개구리가 일렬로 놓여 있는 징검다리 사이를 폴짝폴짝 뛰어다니고 있다. 징검다리에는 숫자가 각각 쓰여 있는데, 이 개구리는 매우 특이한 개구리여서 어떤 징검다리에서 점프를 할 때는 그 징검다리에 쓰여 있는 수의 배수만큼 떨어져 있는 곳으로만 갈 수 있다.   이 개구리는 a번째 징검다리에서 b번째 징검다리까지 가려고 한다. 이 개구리가 a번째 징검다리에서 시작하여 최소 몇 번 점프를 하여 b번째 징검다리까지 갈 수 있는지를 알아보는 프로그램을 작성하시오.   입력  첫째 줄에 징검다리의 개수 N(1≤N≤10,000)이 주어지고, 이어서 각 징검다리에 쓰여 있는 N개의 정수가 주어진다. 그 다음 줄에는 N보다 작거나 같은 자연수 a, b가 주어지는 데, 이는 개구리가 a번 징검다리에서 시작하여 b번 징검다리에 가고 싶다는 뜻이다. 징검다리에 쓰여있는 정수는 10,000보다 작거나 같은 자연수이다.  출력  첫째 줄에 개구리가 a번 징검다리에서 b번 징검다리로 최소 몇 번 점프하여 갈 수 있는 지를 출력하시오. a에서 b로 갈 수 없는 경우에는 -1을 출력한다.   1 2 3 4 5 6 예제 입력 1  복사 5 1 2 2 1 2 1 5  예제 출력 1  복사 1 ## 힌트 1번 징검다리에 1이 쓰여 있으므로, 1의 배수인 4만큼을 한 번에 뛰어 5번 징검다리로 갈 수 있다. ## 풀이 bfs를 이용하여 징검다리에 인덱스 + 징검다리에 적혀있는 크기의 배수들에 모두 방문하여 방문하지 않은 징검다리라면 visited에 1을 더해주는 방식으로 몇번만에 b에 도달했는지가 visited에 1보다 큰 수로 저장되도록 한다.   간단한 bfs문제이지만 푸는데 한참걸렸는데, 징검다리가 왼쪽으로도 이동할 수 있다는 사실을 생각을 안하고 계속 풀어서 아무리 반례를 찾으려 해도 찾을 수 가 없어 시간을 너무 많이 잡아먹었다. 문제를 잘읽고 프로그램을 어떤 상황까지 구현해야 하는지 확실하게 풀어야겠다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from collections import deque  def bfs(x):     q = deque()     q.append(x)     visited[x] = 1     while q:         nx = q.popleft()         dx=[]         for i in range(b+1):             if abs(bridge[nx]*-i) &gt; n:                 break             dx.append(bridge[nx]*i)         for i in range(b+1):             if abs(bridge[nx]*-i) &gt; n:                 break             dx.append(bridge[nx]*-i)         for i in range(len(dx)):             sx = nx + dx[i]             if 0 &lt;= sx &lt; n and visited[sx]==0:                 visited[sx] = visited[nx]+1                 q.append(sx)                 #print('result:', result)  n = int(input()) bridge = list(map(int,input().split())) a,b = map(int,input().split()) visited = [0]*n result = [0]*n bfs(a-1) if bridge[a-1] == 1:         print(1) elif a == b:     print(0) else:     print(visited[b-1]-1)    1 2 3 4 5 6 5 2 3 1 2 3 5 2 [0, 3, 0, -3] [0, 3, 0, -3] 1   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/BOJ-1326-%ED%8F%B4%EC%A7%9D%ED%8F%B4%EC%A7%9D-(Python3)/",
        "teaser": null
      },{
        "title": "목표",
        "excerpt":"2021.07.18  요즘 어느정도 무엇을 하고싶고 그 무엇을 하기위해 어떻게 하고싶은지에 대한 가닥이 잡혀서  목표를 뚜렷하게 정하고 시작해야겠다는 생각이 들었다.   사실 요 몇달간 열심히 하기는 했지만 더 구체적인 목표와 방향성이 있어야 내가 원하는 바를 이뤄낼 수 있겠다는 생각이 들기도 해서, 아래 구체적인 내용을 연말까지 해내는 것을 우선적인 목표로 진행해보려한다.   1일 1커밋   사실 1일 1커밋에 대한 이야기를 많이 들어서 깃허브를 처음 시작했을때 할까 고민도 했었지만, 사실 바쁜날은  1일 1커밋을 지키기 위해서 글자하나만 바꾼다던가, 의미없는 커밋을 하는게 큰의미가 있나 싶어서 의미있는 커밋을 남기는게 더 중요하다는 생각에 시도하지 않았었다. 하지만 다른사람들의 1일 1커밋 챌린지 도전에 관한 글들을 보며 느낀건, 1일 1커밋 챌린지는 그저 잔디를 예쁘게 심는것만이 목적이 아닌, 진짜로 내 삶이 개발자의 라이프 스타일이 되어서 항상 어떤것을 오늘 커밋해야할까라는 생각을 하며 살게되는 것에 큰 의미가 있다는 걸 알게 되었다. 뿐만 아니라 채워지는 잔디를 보며 내가 하루하루 해냈다는 성취감이 내일의 나를 더 나아가게 한다는 느낌이 자칫 지치고 힘들 수 있는 공부에 큰 힘이 될 것 같았다.   1일 1알고리즘 문제 풀이   사실 이 1일 1알고리즘 문제풀이는 위의 1일 1 커밋과 같은 목표라고 볼 수 있는데,  1일 1커밋을 의미없이 글자만 바꾼다거나, 의미없는 변화를 추가하여 굳이 커밋하고 싶지 않았다.  내 깃허브에 박힌 잔디들이 가진 내용은 아무리 그래도 잔디 하나당 블로그 포스트 하나 정도는 되어야 내 자존심이 상하지 않을 것 같았다. 따라서 아무리 바쁜날이 와 커밋을 할 여력이 안될지라도, 아침이나 지하철 이동 시간을 이용해서라도 하루에 한 문제를 꼭 풀어 내어 커밋하겠다는 다짐을 했다.   연말까지 한개이상의 프로젝트 완성   기본적인 이론들이나 스킬에 대한 공부도 중요하지만, 역시 가장 중요한건 직접 하나의 프로젝트를 시작해보며  거기서 오는 돌발 상황들이나 실무적인 요령을 얻는것도 몹시 중요하다. 따라서 연말내로 하나의 프로젝트를 완성 시킬 생각인데, 중요한것은 내가 현재 능숙한 언어인 파이썬으로 제작하는것이 아니라 오늘부터 새로 공부할 언어인 자바를 사용하여 제작하는 것이다. 사실 코딩테스트만 통과하자는 목적으로 파이썬으로 알고리즘 테스트만 공부할 요령이었는데, 진정한 의미로써의 내 개발자체의 실력을 올리려면 여러가지 언어를 틈틈히 공부해야 하며, 그 중 자바는 절대 빼놓을 수 없는 언어이다.   따라서 위의 세가지 목표를 중심으로 남은 6개월을 보낼 생각이다. 물론, 휴학 반년 결산에서 한 목표도 함께!  사실 6개월에 모든것을 이루기에는 너무 어려운 일일 수 있지만, 한번쯤은 적은 목표를 쉽게 이루는 것보다 많은 목표를 힘들게 못이뤄보아야 내가 어느 정도 양의 목표를 이룰 수 있을지에 대한 감이 잡힐 것같아서,   올해의 목표는 살짝 벅차게 잡아보도록 했다.   요즘따라 의욕이 넘친다. 더 나은 삶을 위해서 더 열심히 살아야겠다는 생각이 드는 요즘이다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%AA%A9%ED%91%9C/",
        "teaser": null
      },{
        "title": "[Java] 생성자",
        "excerpt":"생성자란?  다음과 같이 Person과 PersonTest 클래스를 만들어보자  1 2 3 4 5 6 7 package constructor;  public class Person {     String name;     float height;     float weight; }  위와 같은 클래스를 만들었다면 PersonTest라는 클래스를 하나 더 만들어  personLee라는 인스턴스를 선언해보자  1 2 3 4 5 6 7 package constructor;  public class PersonTest {     public static void main(String[] args){         Person personLee = new Person()     } }  여기서 new Person() 의 Person()같은 함수를 생성자라고 한다.  클래스의 멤버 변수는 메서드에 의해 값이 변경될 수도 있지만, 처음 클래스를 생성할 때 값을  정해야 하는 경우도 있다. 생성자가 하는 일은 클래스를 처음 만들 때 멤버 변수나 상수를 초기화하는 것이다.   디폴트 생성자  생성자는 오직 클래스를 생성할때만 호출한다.      생성자 이름은 클래스 이름과 동일하고, 생성자는 반환값을 갖지 않는다.  하지만 우리가 처음 Person 클래스를 만든 코드를 보면 Person() 생성자가 따로 없다.  하지만 그럼에도 new Person()을 통해 객체를 만들어 줄 수 있었는데, 이는 컴파일러가  자동으로 생성자를 만들어주기 때문이다. 이렇게 자동으로 만들어주는 생성자를 디폴트 생성자(default constructor) 라고 하는데 이는 매개변수도 없고 구현코드가 없다.   생성자 만들기  필요한 경우 디폴트 생성자가 아닌 프로그래머가 임의로 만든 생성자를 사용할 수도 있는데, 이렇게 하면  인스턴스를 생성할때 반드시 특정 멤버변수의 값을 초기화하면서 하도록 할 경우에 직접 생성자를 구현하여     사용하게된다.  1 2 3 4 5 6 7 8 9 10 11 package constructor;  public class Person {     String name;     float height;     float weight;      public Person(String pname){         name = pname;     } }  이렇게 선언하게 되면 반드시 name을 매개변수로 넣어주어야만 인스턴스의 멤버 변수값을 초기화함과 동시에  인스턴스가 만들어진다. 따라서 우리가 아까 만들었던 PersonTest 클래스는 오류를 나타내게 되는데,  이는 우리가 직접 생성자를 만들어줌으로써 컴파일러가 이제는 자동으로 디폴트 생성자를 만들게 되지 않기 때문이다. 따라서 오류가 나지 않도록 하려면 아래의 코드와 같이 name을 매개변수에 지정을 해주어야 한다.  1 2 3 4 5 6 7 package constructor;  public class PersonTest {     public static void main(String[] args){         Person personLee = new Person(\"이민재\");     } }  만약 매개변수를 받아도 되고 안받아도 되도록 하고 싶다면, 우리가 직접 디폴트 생성자도 함께 있도록 추가해주면 된다. 이렇게 하면 생성자 두개중에서 하나를 선택하여 사용 할 수 있게된다.  1 2 3 4 5 6 7 8 9 10 11 12 package constructor;  public class Person {     String name;     float height;     float weight;      public Person(String pname){         name = pname;     }     public Person(){} }  생성자 오버로드  이렇게 위처럼 생성자가 두 개 이상 제공되는 경우를 생성자 오버로드(constructor overload) 라고 한다.  필요에 따라 매개변수가 다른 생성자를 여러 개 만들 수 있으며, 경우에 따라서는 아예 디폴트 생성자를 제공하지 않을 수 도 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%83%9D%EC%84%B1%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Java] 객체 지향 프로그래밍과 클래스",
        "excerpt":"클래스란?  클래스는 객체와의 속성과 기능을 코드로 구현한 것으로, 객체를 클래스로 구현하는 것을      ‘클래스를 정의한다’라고 한다. 클래스를 정의하려면 우선 클래스 이름과 클래스가 가지는 속성,  또는 특성이 필요하다. 객체를 코드로 구현한다는 말이 모호할 수 있으니  ‘학생’이라는 객체를 클래스로 살펴보자.   학생이라는 객체가 있다면, 이 객체가 가지는 일반적인 속성들이 있을것이다.  예를들어 학번, 이름, 학년, 사는곳 정도가 될 수 있는데, 이런 클래스 속성은 특성이라고도 하고  클래스 내부에 변수로 선언한다.   이렇게 선언하는 클래스의 속성을 ‘멤버 변수’라고한다.   클래스를 정의하는 문법을 간단히 나타내면 다음과 같다.  1 2 3 4 (접근 제어자) class 클래스 이름 {     멤버 변수;     메서드; }  그럼 예를들어 학생이라는 객체의 클래스를 선언해보자.  1 2 3 4 5 6 7 8 9 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      }  위의 코드를 보면, 우리는 Student라는 클래스를 선언했다.     또, 위에서 말한 객체의 속성을 변수로써 클래스 안쪽에 선언했는데,    자바프로그램은 모든 요소가 반드시 클래스 내부에 존재하여야 한다.     클래스 외부에는 package 선언과 import 외에는 아무것도 선언하지 않는다.   클래스 기능을 구현하는 메서드  지금까지는 클래스의 속성인 멤버 변수를 선언했다면, 이번에는 클래스에 관련된 기능을 구현해볼 것이다. 예를 들어 앞서만든 학생의 클래스라면 이를 출력하는 메서드 showStudent를 만들어 보자  1 2 3 4 5 6 7 8 9 10 11 12 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     } }  위처럼 클래스 내부에 학생의 이름과 주소를 출력하는 메서드를 만든 것을 알 수 있다.  아직은 기능으로만 존재하기 때문에 이 메서드를 사용하려면 다른 방법이 추가되어야 한다.  그럼 그 전에 먼저 패키지에 대해서 알아 본 후 기능을 실제로 사용해보도록하다.   패키지란?  패키지는 간단히 말하면 클래스 파일의 묶음이라고 할 수 있다.     패키지를 말들게 되면 프로젝트 하위에 디렉토리가 하나 생기게 되는데, 이렇게 만든 패키지는  계층 구조를 가질 수 있다.  만약 학교와 관련된 프로젝트 파일이 있다면  강좌에 관련된 클래스, 학생에 관련된 패키지 등등 서로 관련이있는 클래스를 묶어주는 패키지 파일을 만들어줌으로써 계층구조를 갖도록 해주어 소스코드 관리와 유지보수를 편하게 해줄 수 있다.   패키지 선언은 맨위에 해줌으로써 이 클래스가 어떤 패키지에 소속되어있는지 알려준다.  클래스 이름이 같다고 해도 패키지 이름이 다르면 클래스 전체의 이름이 다른것이므로 다른 클래스가 된다. 다시 말해서 같은 이름의 클래스라도 다른 패키지에 속해있다면 그 두 클래스는 연관이 없다.   함수란?  함수는 하나의 기능을 수행하는 코드를 미리 만들어 놓은것으로,  예를들어 더하기 함수가 있다면 우리는 덧셈을 할때마다 덧셈에 대한 코드를 일일히 입력할 필요가   없이 더하기 함수를 불러옴으로써 간단하게 덧셈 연산을 수행할 수 있을 것이다.   함수 정의하기  더하기 함수를 실제 코드로 작성해보자.  함수의 반환형, 함수이름과 매개변수를 선언해주면, 우리는 함수를 선언할 수 있다.  1 2 3 4 5 int add(int num1, int num2){     int result;     result = num1+num2;     return result }  함수 호출하고 값 반환하기  아까 위에서 학생의 이름을 출력하는 함수를 구현만 하고 사용해보지 않았는데, 이번에는  어떻게 함수를 사용하는지에 대해 알아보도록 하자.     위에서 정의했던 add함수를 한번 구현하고 호출해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package classpart;  public class FunctionTest {     public static void main(String[] args){         int num1 = 10;         int num2 = 20;          int sum = add(num1, num2);         System.out.println(sum);      }      public static int add(int n1, int n2){          int result = n1 + n2;         return result;     } }  클래스 기능을 구현하는 메서드  자바는 함수와 별개로 클래스 내부에서 사용하는 멤버 함수를 따로 지원하는데,      이를 메서드라고 한다. 메서드는 멤버변수를 사용하여 클래스의 기능을 구현하는 것으로  함수에 객체지향이 포함된 용어로 이해하면 쉽다.   아까 만들었던 Student 클래스에 학생의 이름을 가져오는 메서드를 한번 만들어보자  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     }     public String getStudent(){         return studentName; } }  아까 만들었던 클래스에 이처럼 getStudent() 메서드를 추가해보았다.  그럼 이번에는 학생이름을 멤버 변수에 대입해주는       setStudentName()메서드를 동일하게 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     }     public String getStudent(){         return studentName; }     public void setStudentName(String name){         studentName = name; } }  그럼 이제 이 메서드를 어떻게 사용하는지에 대해 알아보자  클래스와 인스턴스  클래스를 사용하여 프로그램을 실행하려면, 먼저 main() 함수를 알아야 한다.  main() 함수는 자바의 가상머신이 프로그램을 시작하기 위해 호출하는 함수로,  클래스 내부에 만들지만, 클래스의 메서드는 아니다.   main() 함수에서 클래스를 사용하는 방법은 두가지가 있는데,     직접 만든 클래스 내부에 main()을 만드는 방법   외부에 테스트용 클래스를 만들어 사용하는 방법  두가지가 있다.   먼저 첫번째 방법으로 방금 만든 Student 클래스에 main() 함수를 작성해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     }     public String getStudent(){         return studentName;     }     public void setStudentName(String name){         studentName = name;     }      public static void main(String[] args){         Student studentLee = new Student();         studentLee.studentName = \"이민재\";          System.out.println(studentLee.studentName);         System.out.println(studentLee.getStudent());     }      }   1 2 &gt;&gt;&gt; 이민재 &gt;&gt;&gt; 이민재  이렇게 클래스안에 main() 함수를 선언하여 클래스를 테스트 해보았다.  하지만 이런 방식이라면 거의 모든 클래스에 main() 함수가 존재해야 한다.   따라서 위에서 설명한 두번째 방법인, 테스트용 클래스를 만들어 메서드를 실행시켜보도록 하겠다.   1 2 3 4 5 6 7 8 9 10 11 package classpart;  public class StudentTest {     public static void main(String[] args){         Student studentLee = new Student();         studentLee.studentName = \"이민재\";          System.out.println(studentLee.studentName);         System.out.println(studentLee.getStudent());     } }  1 2 &gt;&gt;&gt; 이민재 &gt;&gt;&gt; 이민재  실행결과가 동일한 것을 알 수 있다.   new 예약어로 클래스 생성하기  클래스를 만들고 실행하는 과정을 살펴보자.     클래스를 사용하려면 먼저 클래스를 생성해야 하는데, 자바에서 클래스를 생성할때는  new 예약어를 사용하고 이어서 생성자를 써준다.   1 클래스형 변수 이름 = new 생성자  클래스 자료형 변수를 선언하고 new 예약어로 생성자를 호출하려 대입하면 새로운 클래스가 생성된다.  클래스가 생성된다는 것은 클래스를 실제 사용할 수 있도록 메모리 공간에 올린다는 뜻으로,  이렇게 실제로 사용할 수 있도록 생성된 클래스를 ‘인스턴스’라고 한다.   우리가 앞에서 사용했던 코드를 다시 한번 보면,  1 Student studentLee = new Student();  위 코드는 Student 클래스 자료형으로 StudentLee 변수를 선언하고  new Strudent(); 로 Student 클래스를 생성하여 studentLee에 대입한다는 뜻이다.  이때 studentLee를 참조변수라고 하고, 이 변수가 생성된 인스턴스를 가르키게된다.   이렇게 인스턴스를 생성하게 되면 이 인스턴스의 멤버 변수와 메서드를 참조하여 사용 할 수 있게된다.  예를들어 우리가 만든 studentLee를 이용하여 멤버변수와 메서드를 사용해보면,  1 2 studentLee.studentName =\"이민재\" System.out.println(studentLee.getStudentName)  인스턴스와 힙 메모리  인스턴스가 생성되는 과정을 조금 더 자세히 살펴보자.     new Student()를 선언하면 Student가 하나 생성되는데, 각 Student는     studentID, studentName 등의 멤버 변수를 갖고있다. 그런데 이 변수들을 저장할 공간이 있어야 한다. 이때 사용되는 메모리를 힙 메모리라고 하는데 클래스 생성자를 하나 호출하면, 인스턴스가  힙메모리에 생성되게 되는 것이다.  1 Student studentLee = new Student();  위와 같이 생성된 클래스 (new Student())를 studentLee 변수에 대입하면,      인스턴스가 저장된 메모리를 studentLee 변수가 가르키게 된다.     studentLee는 지역변수이므로 스택 메모리에 생성되게 되고, 인스턴스는 힙메모리에 생성된다.   따라서 지역변수 studentLee에 생성된 인스턴스를 대입하는 것은 studentLee에 인스턴스가      생성된 힙 메모리의 주소를 대입한다는것과 같은 의미이다.   정리  객체 지향을 배우다 보니 새로운 용어가 많아 혼란스러울 수 있는 내용들을 정리해 표로   정리해보았다. 개념들이 이름도 살짝 모호하고 서로 엮여있다보니 헷갈릴 수가 있어  확실하게 어떤 것을 가르키는 개념인지 잘 기억해 두어야겠다.                  용어       설명                       객체       객체 지향 프로그램의 대상, 생성된 인스턴스                 클래스       객체를 프로그래밍하기 위해 코드로 만든 상태                 인스턴스       클래스가 메모리에 생성된 상태                 멤버 변수       클래스이 속성, 특성                 메서드       멤버 변수를 이용하여 클래스의 기능을 구현                 참조 변수       메모리에 생성된 인스턴스를 가리키는 변수                 참조 값       생성된 인스턴스의 메모리 주소 값           ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Java] 변수와 자료형",
        "excerpt":"변수 선언하여 사용하기  1 2 3 int level; level = 10; System.out.println(level)  변수 초기화하기  1 int level = 10;  자료형  자바는 기본자료형과 참조 자료형을 제공하는데, 기본 자료형은 자바 라이브러리에서 기본으로 제공하며, 얼마만큼의 메모리를 어떻게 사용할 것인지가 이미 정해져있다.                  바이트       정수형       문자형       실수형       논리형                       1바이트       byte       -               boolean                 2바이트       short       char       -       -                 4바이트       int       -       float       -                 8바이트       long       -       double       -           다른 자료형은 모두 다른 언어와 동일한데,  long을 사용할때의 한가지 주의 사항이 있다.   ``  int num1 = 12345678900;  1 2 3 4 5 6 7 8 9 10       |   int num1 = 12345678900;      integer number too large           long num2 = 12345678900;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16       |   long num2 = 12345678900;      integer number too large         num1의 경우는 int가 표현가능한 범위를 넘어서서 오류가 난다고 하지만,     num2의 경우는 long 사용하였는데도 왜 오류가 나는 것일까?    이는 자바가 모든 정수를 기본적으로 int를 사용하여 처리하기 때문이다.    즉 숫자 12345678900이 들어오면 우선 int로 처리하기 때문에, 숫자뒤에 L을 붙여    long형으로 이 숫자를 처리하도록 컴파일러에게 알려주어야 한다.    long num = 12345678900L;  1 2 3 4  ## 문자 자료형 선언하기    char mychar = ‘A’  1 2 3 4 5 6 7  문자를 변수에 대입하면 문자 그대로 저장되는 것이 아니라     그 문자에 해당하는 정수 값(아스키코드 값)이 저장된다.      따라서 아래와 같이 아스키코드를 대입하여도 문자를 대입한 것과 동일하게 인식한다.    char ch1 = ‘A’;  char ch2 = 65;   System.out.println(ch1);  System.out.println(ch2);  1 2 3 4 5 6 7 8      A     A   반대로 출력할때 int를 표기해주면, 씌워주면 문자에 해당하는 아스키코드값을 출력한다.    System.out.println((int)ch1)  1 2 3 4 5 6 7 8 9      65   ## 자료형 없이 변수 선언하기 var를 사용하여 변수를 선언하면 자료형을 정확히 명시하지 않고도 변수에 대입되는 값에따라 컴파일러가 자료형을 추측한다.    var num = 10;  var dNum = 10.0;  var str = “hello”  1 2 3 4 5  ## 상수와 리터럴 자바에서 상수를 선언하고 싶다면, final을 사용하여 선언한다.    final double PI = 3.14;  final int MAX_NUM = 100;  1 2 3 4 5 6 7 8 9  상수는 변하지 않기 떄문에 선언과 동시에 초기화 하는 것이 좋다.  ## 형 변환 정수와 실수는 컴퓨터 내부에서 표현되는 방식이 전혀 다르다. 따라서 정수와 실수를 더한다고 할 땐 그대로 연산을 수행 할 수 없고, 하나의 자료형으로 통일 후에 연산해야 한다. 이때 형 변환(type conversion)이 필요하다.    int n = 10;  double dnum = n;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  위 처럼 변수 n은 int형이고 dnum은 double형이다.    형 변환이란 이렇게 변수의 자료형을 같게 해주는 것을 말한다.     형 변환은 크게 **묵시적 형변환**(자동 형 변환)과 **명시적 형 변환**(강제 형 변환)  두가지가 있는데, 형 변환의 기본원칙은 다음과 같다.  *  바이트 크기가 작은 자료형에서 큰 자료형으로 형 변환은 자동으로 이루어진다 *  덜 정밀한 자료형에서 더 정밀한 자료형으로 형 변환은 자동으로 이루어진다      따라서 이 반대로 강제적 형 변환을 하게 되면, 자료 손실이 발생 할 수가 있다.  ### 묵시적 형 변환    int iNum = 20;  float fNum = iNum  1 2 3 4 5  ### 명시적 형 변환 강제로 형 변환하려면 바꾸고자 하는 타입을 괄호로 명시해주어야 한다.    int iNum = 20;  byte bNum = (byte)iNum  ```  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%B3%80%EC%88%98%EC%99%80-%EC%9E%90%EB%A3%8C%ED%98%95/",
        "teaser": null
      },{
        "title": "[Java] 기본 클래스",
        "excerpt":"java.lang  지금까지 자바로 프로그램을 구현하면서 String, Integer와 같은 클래스를 사용했다. 이러한 클래스들은 어디에 있는 걸까? 이들은 모두 java.lang 패키지에 속해 있다. String 클래스의 전체 이름은 java.lang.String이고, Integer 클래스의 전체 이름은 java.lang.Integer이다. 이처럼 java.lang 패키지에는 기본적으로 많이 사용하는 클래스들이 포함되어 있다.   자바에서는 외부 패키지에서 선언한 클래스를 사용하고자 할 때는 import문으로 클래스가 어느 패키지에 속해 있는지 선언해야한다. 근데 우리는 지금까지 String 클래스를 쓰면서 import java.lang.String을 쓴 적이 없다. 그럼에도 우리는 String 클래스를 바로바로 사용할 수 있었다. 그 이유는 컴파일을 하게 되면 자동으로 컴파일러가 import java.lang.*; 을 추가 하기 때문에 직접 써주지 않아도 우리는 java.lang의 하위 클래스를 사용 할 수 있다.   우리가 여기서 다룰 기본 클래스들은 모두 java.lang 패키지에 속한 클래스들이다.      그러면 모든 자바 클래스의 최상위 클래스인 java.lang.Object에 대해서 알아보자.   최상위 클래스, Object  Object 클래스는 모든 자바 클래스의 최상위 클래스로, 모든 클래스는 Object 클래스를 상속받는다. 이 역시 컴파일러가 자동으로 extends Object를 추가해주기 때문에, 우리가 따로 추가할 필요는 없다.   우리가 직접 만드는 클래스 뿐만 아니라, JDK에서 제공하는 클래스도 모두 Object 클래스에서 상속을 받는다.   Object 클래스에 정의된 메서드 중 주로 사용하는 메서드는 다음과 같다.                  메서드       설명                       String toString()       객체를 문자열로 표현하여 반환한다. 재정의하여 객체에 대한 설명이나 특정 멤버 변수 값을 반환한다.                 boolean equals(Object obj)       두 인스턴스가 동일한지 여부를 반환한다. 재정의하여 논리적으로 동일한 인스턴스임을 정의할 수 있다.                 int hashCode()       객체의 해시 코드 값을 반환한다.                 class getClass()       객체의 클래스를 반환한다.                 void finalize()       인스턴스가 힙 메모리에서 제거될 때 가비지 컬렉터(GC)에 의해 호출되는 메서드이다. 네트워크 연결 해제, 열려있는 파일 스트림 해제 등을 구현한다.                 void wait()       멀티스레드 프로그램에서 사용하는 메서드이다. 스레드를 ‘기다리는 상태’ (non runnable)로 만든다.                 void notify()       wait() 메서드에 의해 기다리고 있는 스레드(non runnable)를 실행가능한 상태 (runnable)로 바꾼다.           Object 메서드 중에는 재정의할 수 있는 메서드가 있고, 그렇지 않은 메서드가 있다. 여기서는 자주 재정의하여 사용하는 메서드 위주로 알아보자.   toString() 메서드  toString()은 객체 정보를 문자열로 바꾸어 준다. Object 클래스를 상속받은 모든 클래스는 toString()을 재정의할 수 있는데, String 이나 Integer등의 여러 JDK 클래스에는 toString() 클래스가 이미 재정의 되어있다.   toString의 원형은 인스턴스 클래스의 이름과 주소 값을 보여준다.     예제로 책 번호와 제목을 담고 있는 Book 클래스의 인스턴스를 생성하여 참조변수를 출력해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package objectclass;  public class ToStringEx {     public static void main(String[] args){         Book book1 = new Book(200,\"개미\");          System.out.println(book1);         System.out.println(book1.toString());     }  } class Book{     int bookNumber;     String bookTile;      Book(int bookNumber, String bookTile){         this.bookNumber = bookNumber;         this.bookTile = bookTile;     } }  &gt;&gt;&gt; objectclass.Book@3fb6a447 &gt;&gt;&gt; objectclass.Book@3fb6a447  System.out.println()에 참조 변수를 넣으면 인스턴스의 정보가 호출되는데, 이는 자동으로 toString()을 호출하는 것이다.   toString() 메서드의 원형은 다음과 같다.  1 getClass().getName()+'@'+Integer.toHexString(hashCode())  위의 정의를 살펴보면,  ‘클래스 이름@해시코드 값’을 출력하라는 뜻인걸 알 수 있다.      따라서 위처럼 objectclass.Book@해시코드값이 출력된다.   equals 메서드  equals() 의 원래 기능은 두 인스턴스의 주소값을 비교하여 boolean 값으로 반환해 주는 것이다. 주소 값이 같다면 당연히 같은 인스턴스이다. 그런데 서로 다른 주소 값을 가짐에도 같은 인스턴스라고 정의해줄 수 있는 경우가 있다. 따라서 물리적 동일성(인스턴스의 메모리 주소가 같음) 뿐 아니라 논리적 동일성(논리적으로 두 인스턴스가 같음)을 구현할 때도 equals() 메서드를 재정의하여 사용한다.   생성된 두 인스턴스가 ‘같다’는건 어떤 의미일까?   먼저 물리적 동일성의 경우, 당연히 메모리 주소값이 같은 경우 일 것이다.  1 2 Student studentLee = new Student(100, \"이민재\"); Student studentLee2 = studentLee;  예를 들어 위처럼 동일한 인스턴스를 두 변수가 가르키게 한다면, studentLee와 studentLee2의 힙메모리 주소는 같으므로 물리적으로 동일하다 할 수 있다.   하지만 이 경우를 보자.  1 2 3 Student studentLee = new Student(100, \"이민재\"); Student studentLee2 = studentLee; Student studentMin = new Student(100,\"이민재\");  이러한 경우는 studentLee와 studentMin이 다른 메모리 주소를 가르키지만, 논리적으로는 같은 학생으로 처리해주어야 할 것이다. 이 상황을 구현할 에제를 만들어 살펴보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package objectclass;  class Student{     String studentName;     int studentID;      public Student(String studentName, int studentID){         this.studentName = studentName;         this.studentID = studentID;     } } public class EqualsTest {     public static void main(String[] args){         Student studentLee = new Student(\"이민재\", 100);         Student studentLee2 = studentLee;         Student studentMin = new Student(\"이민재\",100);          if (studentLee.equals(studentLee2)){             System.out.println(\"두 주소값이 같습니다.\");         }         else{             System.out.println(\"두 주소값이 다릅니다..\");         }         if (studentLee.equals(studentMin)){             System.out.println(\"두 주소값이 같습니다.\");         }         else{             System.out.println(\"두 주소값이 다릅니다.\");         }     }   }  &gt;&gt;&gt; 두 주소값이 같습니다. &gt;&gt;&gt; 두 주소값이 다릅니다.  위는 equals()의 원래 기능으로 두 변수의 논리적 동일성이 어떻든간에, 두 인스턴스의 주소가 다르다면 false를 반환한다.  만약 논리적으로 같은 인스턴스인지 확인하고싶다면, 재정의 하여 그렇게 확인하도록 구현해주어야 한다.   따라서 앞서 말한것 처럼 String 클래스와 Integer 클래스에서는 이미 equals()가 재정의 되어있기 때문에, 주소값과 관계없이 두 인스턴스가 논리적으로 같다면 true를 반환한다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/%EA%B8%B0%EB%B3%B8-%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[BOJ] 1325 효율적인 해킹 (Python3)",
        "excerpt":"문제  해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.   이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.   이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에, N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에 신뢰하는 관계가 A B와 같은 형식으로 들어오며, “A가 B를 신뢰한다”를 의미한다. 컴퓨터는 1번부터 N번까지 번호가 하나씩 매겨져 있다.   출력  첫째 줄에, 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   5 4 3 1 3 2 4 3 5 3  예제 출력 1   1    풀이  간단한 탐색문제로 bfs로 풀 수 있는데, 컴퓨터의 신뢰관계를 노드 형식으로 리스트에 넣어주고, 노드가 많이 연결되어있는 컴퓨터순으로 출력하면 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from collections import deque #컴퓨터의 개수 n, 신뢰관계의 개수 m n,m = map(int, input().split())  #노드의 형태 graph graph = [[] for _ in range(n+1)]  #자신을 신뢰하는 컴퓨터를 자신의 리스트에 넣는다 for i in range(m):     a,b = map(int, input().split())     graph[b].append(a)  #bfs를 사용하여 1-5의 컴퓨터를 순서대로 방문하며, 자신을 신뢰하는 컴퓨터에 모두 방문한다. #방문한 횟수를 hack 변수에 넣는다. def bfs(x):     q = deque()     q.append(x)     hack = 1     visited = [0 for _ in range(n+1)]     visited[x] = 1     while q:         nx = q.popleft()         for i in graph[nx]:             if visited[i] == 0:                 q.append(i)                 hack+=1                 visited[i] = 1     return hack #자신을 신뢰하는 컴퓨터의 개수를 저장하는 리스트 answer answer = [] #bfs함수에 넣어 얻은 result를 answer 리스트에 넣어준다. for i in range(1,n+1):         answer.append(bfs(i))           #resutl 순차 출력 for i in range(len(answer)):     if max(answer)== answer[i]:         print(i+1, end = ' ')      1 2 3 4 5 6 5 4 3 1 3 2 4 3 5 3 1 2    Feedback  방문을 체크하는 visited 리스트를 만들지 않아서 계속 메모리 초과가 떴다.  예제는 서로 상호신뢰관계가 없어서 잘되길래 문제가 없다고 생각했는데, 테스트셋의 상호신뢰관계 때문에 반복이 끝나지를 않아서 메모리가 초과 된것 같다.  bfs, dfs를 풀때는 항상 방문을 잘 체크하자.   1   ","categories": ["baekjoon"],
        "tags": ["백준 알고리즘 BFS"],
        "url": "/baekjoon/BOJ-1325-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%95%B4%ED%82%B9-(Python3)/",
        "teaser": null
      },{
        "title": "[BOJ] 1325 효율적인 해킹 (Python3)",
        "excerpt":"문제  꽉꽉나라에 사는 주예와 방주는 점 S에서 만나 저녁을 먹기로 했다. 주예는 점 S에 도착했지만 길치인 방주가 약속시간이 30분이 지나도 나타나지 않자 방주에게 연락을 하여 방주가 점 E에 있다는 사실을 알아냈다. 주예는 방주에게 그 위치에 가만히 있으라고 했고, 직접 점 E로 가려고 한다.   꽉꽉나라에는 1부터 N까지의 각 점에 하나의 텔레포트 정거장이 위치해 있고 텔레포트를 통하여 연결되어 있는 다른 텔레포트의 정거장으로 이동할 수 있다. 주예는 현재 위치가 점 X라면 X+1이나 X-1로 이동하거나 X에 위치한 텔레포트와 연결된 지점으로 이동할 수 있으며 각 행동에는 1초가 소요된다. 배가 고픈 주예는 최대한 빨리 방주와 만나고 싶어 한다.   N과 텔레포트 연결 정보가 주어질 때 점 S에 있는 주예가 점 E까지 가는 최소 시간을 구해보자.   입력  첫 번째 줄에 정수 N, M이 공백으로 구분되어 주어진다. (2 ≤ N ≤ 300,000, 0 ≤ M ≤ min(N×(N-1)/2, 300,000))   두 번째 줄에 정수 S, E가 공백으로 구분되어 주어진다. (1 ≤ S, E ≤ N, S ≠ E)   그 다음 줄부터 M개의 줄에 걸쳐 텔레포트 연결 정보를 의미하는 정수 x, y가 주어진다. (1 ≤ x, y ≤ N, x ≠ y)   x y는 점 x의 텔레포트와 점 y의 텔레포트가 연결되어 있다는 뜻이다. M개의 연결정보는 중복되는 x y쌍이 없도록 주어진다.   출력  첫 번째 줄에 주예와 방주가 만날 수 있는 최소 시간을 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 예제 입력 1   5 1 1 5 1 4 예제 출력 1   2   예제 입력 2   10 3 2 5 1 6 1 3 2 8 예제 출력 2   3  풀이  단순 bfs 문제이다. 항상 이런 x좌표만 있는 문제는 단방향이 아닌 양방향으로 풀어야 한다는걸 기억하고 풀어야한다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from collections import deque n,m = map(int, input().split())  s,e = map(int, input().split())  graph = [[] for _ in range(n+1)] visited = [-1 for _ in range(n+1)]  for i in range(m):     x,y = map(int, input().split())     graph[x].append(y)     graph[y].append(x)    def bfs(x):     q = deque()     q.append(x)     visited[x] = 0     while q:         nx = q.popleft()         dx = [nx-1, nx+1]         if graph[nx]:             dx += (graph[nx])         #print('dx :', dx)         for sx in dx:             #print('nx:',nx,'sx :', sx)             if 0 &lt; sx &lt;= n and visited[sx] == -1:                 q.append(sx)                 #print('q:', q)                 visited[sx] = visited[nx]+1                 #print(visited)             if sx == e:                 return visited[sx]          print(bfs(s))   1 2 3 4 5 1 1 5 1 3 3   ","categories": ["baekjoon"],
        "tags": ["백준 알고리즘 BFS"],
        "url": "/baekjoon/BOJ-18232-%ED%85%94%EB%A0%88%ED%8F%AC%ED%8A%B8-%EC%A0%95%EA%B1%B0%EC%9E%A5/",
        "teaser": null
      },{
        "title": "[Java] static 변수",
        "excerpt":"변수를 여러 클래스에서 공통으로 사용하기  우리가 앞서만든 학생클래스에서, 만약 학번을 만들고 싶다면 어떻게 해야할까?      이 학번은 새로운 인스턴스가 생성될때마다 자동으로 생성되어 그 인스턴스에 할당되게 하고싶다.     이렇게 하려면 인스턴스마다 따로 변수가 생성되는게 아니라, 클래스 전체가 함께 사용하는 기준 변수가 하나 있어야한다. 이러한 변수가 있다면, 우리는 학번을 1씩 증가시켜가며 새로운 인스턴스가 생길때마다 할당 해주면 학번이 자동으로 정해지도록 할 수 있을 것이다.   이때, 클래스에서 사용하는 공통 변수를 static 변수로 선언한다.   static 변수의 정의와 사용 방법  static 변수는 다른 용어로 ‘정적 변수’라고도 한다. static 변수는 자바뿐만 아니라 다른 언어에서도 비슷한 개념으로 사용하는 변수로, 다른 멤버 변수와 동일하게 내부에 선언한다.     자료형앞에 static 예약어를 선언해주면 사용 할 수 있다.  1 static int seralNum;  static 변수는 클래스 내부에 선언하지만, 다른 멤버 변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아니라, 프로그램이 실행되어 메모리에 올라가면 딱 한 번 메모리 공간이 할당되고, 그 값을 모든 인스턴스가 공유하는 변수이다.   그럼 이러한 static변수를 갖고 학번을 가지는 학생 클래스를 만들어 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package staticex;  public class Student {     static int serialNum = 1000;     String studentName;     int studentID;          public Stirng getStudentName(){         return studentName     }     public void setStudentName(String name){         studentName = name;              }  }  학생 클래스는 serialNum이라는 static 변수를 갖는데, 이 값은 1000이다.  이제 테스트 코드에서 이 static 변수를 증가시키면, 이 값을 다른 인스턴스들이 공유하는지 한번 확인해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package staticex;  public class StudentTest {     public static void main(String[] args){         Student Lee = new Student();         Lee.setStudentName(\"Lee\");         System.out.println(Lee.serialNum);         Lee.serialNum++;          Student Kim = new Student();         Kim.setStudentName(\"Kim\");         System.out.println(Kim.serialNum);          System.out.println(Lee.serialNum);         System.out.println(Kim.serialNum);     } }  &gt;&gt;&gt; 1000 &gt;&gt;&gt; 1001 &gt;&gt;&gt; 1001 &gt;&gt;&gt; 1001  Lee 학생의 serialNum을 증가시켰는데, Kim학생의 serialNum도 동일하게 증가된 것을 확인 할 수 있다.     이처럼 static변수의 값은 모든 인스턴스가 공유한다는 것을 알게되었다. 그럼 이제 인스턴스가 생성되면 자동으로 증가한 학번을 할당하도록 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package staticex;  public class Student {     static int serialNum = 1000;     String studentName;     int studentID;      public Student(){         serialNum++;         studentID = serialNum;     }     public String getStudentName(){         return studentName;     }     public void setStudentName(String name){         studentName = name;       }  }  public Student를 만들어 새로운 인스턴스가 생성되면 serialNum을 1증가시키고, 그 값을 학번에다 할당하도록 했다. 그럼 다시 테스트 코드로 가서 학번이 올바르게 증가하며 할당되는지 확인 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package staticex;  public class StudentTest {     public static void main(String[] args){         Student Lee = new Student();         Lee.setStudentName(\"Lee\");         System.out.println(\"이름: \"+Lee.studentName+\" 학번: \"+Lee.serialNum);          Student Kim = new Student();         Kim.setStudentName(\"Kim\");         System.out.println(\"이름: \"+Kim.studentName+\" 학번: \"+Kim.serialNum);     } }  &gt;&gt;&gt; 이름: Lee 학번: 1001 &gt;&gt;&gt; 이름: Kim 학번: 1002  인스턴스를 생성해줄때마다 자동으로 학번이 증가하는 것을 확인 할 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-static-%EB%B3%80%EC%88%98/",
        "teaser": null
      },{
        "title": "[Java] 객체 간 협력",
        "excerpt":"객체 지향 프로그램은 객체를 정의하고 객체 간 협력으로 만들어진다.      그러면 실제로 객체간의 협력이 어떻게 이루어지는지 한번 예제를 만들어 확인해보자.   학생 클래스 구현하기  계속 예제로 들었던 학생 클래스를 또 한번 만들어보자. 학생클래스는 ‘이름’,’ 학년’, ‘가진 돈’ 이렇게 세가지 멤버 변수를 갖는다고 가정해보겠다. 그리고 메서드로는, ‘버스 타기’, ‘지하철 타기’, ‘학생의 현재 정보 보여주기’ 세가지 행동을 갖는다고 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package cooperation;  public class Student {     public String studentName;     public int grade;     public int money;      public Student(String studentName, int money){         this.studentName = studentName;         this.money = money;     }      public takeBus(Bus bus){         bus.take(1000);         this.money-= 1000;     }      public takeSubway(Subway subway){         subway.take(1500);         this.money -= 1500;     }     public void showInfo(){         System.out.println(studentName+\"님의 남은 돈은\"+money+\"입니다.\");     } }  Student 클래스는 버스를 타면 1000원을 money에서 빼주고, 지하철을 타면 1500원을 money 에서 뺀다.   그럼 위에서 Student에서 사용한 클래스들인 Bus와 Subway 클래스를 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package cooperation;  public class Bus {     int money;     int person;     int busNumber;      public Bus(int busNumber){         this.busNumber = busNumber;     }     public void take(int money){         this.money += money;         person++;     }      public void showInfo(){         System.out.println(busNumber+\"번의 승객은\"+person+\"명이고, 수입은\"+money+\"입니다\");      } }  동일하게 이름만 바꿔서 Subway를 만들어준다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package cooperation;  public class Subway {     int money;     int person;     int subwayNumber;      public Subway(int subwayNumber){         this.subwayNumber = subwayNumber;     }     public void take(int money){         this.money += money;         person++;     }      public void showInfo(){         System.out.println(subwayNumber+\"번의 승객은\"+person+\"명이고, 수입은\"+money+\"입니다\");      }  }  이렇게 Student, Bus, Subway 클래스를 만들어 주었으니 이들이 어떤 식으로 협력하여 main에서 작동하는지 TakeTrans 클래스를 만들어주어 객체간의 협력을 시켜보자.     학생은 James와 Tomas 두명으로 하고, James는 버스, Tomas는 지하철을 타도록 한뒤, 각각 탑승 후 학생의 현재 상태와 대중교통의 현재 상태가 나오도록 해주자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package cooperation;  public class TakeTrans {     public static void main(String[] args){         Student James = new Student(\"James\", 5000);         Student Tomas = new Student(\"Tomas\", 10000);          Bus bus100 = new Bus(100);         James.takeBus(bus100);         James.showInfo();         bus100.showInfo();          Subway subway9 = new Subway(9);         Tomas.takeSubway(subway9);         Tomas.showInfo();         subway9.showInfo();     } }  James와 Tomas라는 두개의 인스턴스를 만들어 준뒤, 이름과 가진돈을 추가해준다.       버스와 지하철도 동일하게 각각 하나씩 bus100과 subway9이라는 인스턴스를 추가 해준다.  James는 takeBus 메서드가 호출되어 버스를 탔고, Tomas는 takeSubway 메서드가 호출되어 지하철을 탔다.   이처럼 우리가 각각 만든 객체들을 인스턴스로 만들어 각 객체끼리 협력하도록 해줄 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EA%B0%9D%EC%B2%B4-%EA%B0%84-%ED%98%91%EB%A0%A5/",
        "teaser": null
      },{
        "title": "[Java] 싱글톤 패턴",
        "excerpt":"싱글톤 패턴이란?  프로그램을 구현하다 보면 여러 개의 인스턴스가 필요한 경우도 있고, 단 하나의 인스턴스만 필요한 경우도 있다. 객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴을 싱글톤 패턴(singleton pattern) 이라고 한다. 우리가 여기서 살펴볼 싱글톤 패턴은 static을 응용하여 프로그램 전반에서 사용하는 인스턴스를 하나만 구현하는 방식이다.   어떤 회사의 직원들을 객체지향으로 구현한다고 가정해보자. 직원은 여러명이겠지만, 회사는 하나다.  이런 경우에 직원 인스턴스는 여러 개를 생성하는 것이 당연하지만, 회사 객체는 하나여야 할 것 이다.  그럼 싱글톤 패턴으로 company 클래스를 단계적으로 만들어 보자.   싱글톤 패턴으로 회사 클래스 구현하기  단계 1 : 생성자를 private로 만들기  생성자가 하나도 없는 클래스는 컴파일러가 자동으로 디폴트 생성자를 만들어 주는데, 이 생성자는 항상 public이다. 생성자가 public이면 외부에서 접근이 가능하기 때문에 인스턴스를 여러 개 생성 할 수 있다. 따라서 싱글톤 패턴에서는 생성자를 반드시 명시적으로 만들고, 그 접근 제어자를 private로 설정해야한다.  1 2 3 4 5 6 7 package singleton;  public class Company {     private Company(){              } }  단계 2 : 클래스 내부에 static으로 유일한 인스턴스 생성하기  단계 1에서 접근제어자를 private로 함으로써 외부 인스턴스를 생성할 수 없도록 만들었다. 하지만 우리가 프로그램에서 사용할 인스턴스 하나는 필요하기 때문에, Compony 클래스 내부에서 하나의 인스턴스를 생성한다. 이 인스턴스가 프로그램 전체에서 사용가능한 유일한 인스턴스가 된다.  이 또한 private으로 선언해야만 외부에서 이 인스턴스에 접근 할 수 없어, 인스턴스 오류가 방지된다.  1 2 3 4 5 6 package singleton;  public class Company {     private static Company instance = new Company();     private Company(){ } }  단계 3 : 외부에서 참조 할 수 있는 public 메서드 만들기  이제 private으로 선언한 유일한 인스턴스인 instance를 외부에서도 사용가능 하게 설정해야한다.  이를 위해 public 메서드를 사용해 유일한 인스턴스를 반환하게 한다. 이때 인스턴스를 반환하는 메서드는 반드시 static으로 선언해주어야 인스턴스 생성과 상관없이 호출이 가능하다.  1 2 3 4 5 6 7 8 9 10 11 12 13 package singleton;  public class Company {     private static Company instance = new Company();     private Company(){ }      public static Company getInstance(){         if(instance== null){             instance = new Company();         }         return instance;     } }   단계 4 : 실제로 사용하는 코드 만들기  외부 클래스에서는 Company를 생성할 수 없으므로 getInstance() 메서드를 호출한다.     Company.getInstance(); 와 같이 호출하면 유일한 인스턴스를 받아온다.      두 인스턴스를 만들어 주소 값이 같은지 확인해보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 package singleton;  public class CompanyTest {     public static void main(String[] args){         Company myCompany1 = Company.getInstance();         Company myCompany2 = Company.getInstance();         System.out.println(myCompany1 == myCompany2);     } }  &gt;&gt;&gt; true  두개의 인스턴스를 만들었지만, 받아온 인스턴스는 동일한 주소 값을 가지는, 아까 만들었던 유일한 인스턴스를 받아왔음을 알 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/",
        "teaser": null
      },{
        "title": "[Java] 참조 자료형, 정보은닉",
        "excerpt":"참조 자료형  크기가 정해진 기본 자료형 ( int, char, float, double등)으로 선언하는 변수가 있고, 클래스 자료형으로 선언하는 참조 자료형 변수가 있다. 참조 자료형 변수의 특징에 대해 좀 더 자세히 살펴보고, 클래스를 선언하여 참조형을 이용한 프로그램을 구현해보자.   어떤 학생이 있다고 가정하자. 이 학생이 국어와 수학 과목을 수강하는데, 이 시험의 수학과 국어 점수를 저장하는 프로그램을 만든다고 생각해보면,  1 2 3 4 5 6 7 8 package reference;  public class Student1 {     int studendID;     String studentName;     int koreaScore;     int mathScore; }  이렇게 Student1이라는 클래스를 만들어보았다. 근데 만약 이 클래스에 성적뿐만 아니라 이 학생이 수강하고 있는 과목의 이름도 함께 저장하고 싶다면 어떻게 해야할까? 아주 간단한 방법으로는   String을 사용해서 클래스 안에 과목이름 변수를 추가해주는 것이다.     Student2라는 과목이름 변수도 함께있는 클래스를 만들어보자   1 2 3 4 5 6 7 8 9 package reference;  public class Student1 {     int studentID;     String studentName;     int koreaScore;     int mathScore;  }  이렇게 구현하고보니, 이 클래스는 학생에 관한 클래스인데 과목에 대한 변수가 늘어나 Student라는 이름의 클래스하나로 구현하게 되면 나중에 참조 할때 헷갈리거나 문제가 생길 수 있다.   따라서 과목에 대한 변수는 Subject라는 클래스를 따로 만들어 분리해보도록 하자.  1 2 3 4 5 6 package reference;  public class Subject {     String SubjectName;     int scorePoint; }  이렇게 Subject로 따로 클래스를 만들어 주면, 우리는 기본 자료형이 아닌 우리가 만들어준 참조 자료형으로 변수를 선언 할 수 있게된다. Subject에 과목의 이름과 과목의 점수를 저장할 수 있는 변수가 있으니, 우리는 다른 클래스에서 이 참조 자료형을 사용하여 변수를 선언 할 수가 있게 된다.   Student3 클래스를 만들어 참조자료형 선언을 해보자.  1 2 3 4 5 6 7 8 package reference;  public class Student3 {     int studentID;     String studentName;     Subject korean;     Subject math; }  이렇게 구현하게 되면 기존에는 Student2 클래스의 경우처럼 과목이름을 koreanSubjectName, mathSubjectName 이런식으로 두개의 변수를 추가 해주어야 한다. 그러나 Subject와 같이 클래스를 분리해주면 subjectName은 Subject클래스에 선언한뒤 korean.subjectName과 같이 사용해줄 수 있어 매우 편리하다.   정보 은닉  지금까지 클래스를 선언할때 public이라는 예약어를 사용하였다. 이제 이 예약어가 어떤 의미를 갖는지에 대해 알아보자.   객체 지향 프로그램에서는 예약어를 사용하여 클래스 내부의 변수나 메서드, 생성자에 대한 접근 권한을 지정한다. 이러한 예약어들을 접근 제어자(acces modifier) 라고 하는데, 우리가 사용하던 public이라고 선언했던 예약어는 외부클래스에서 접근이 가능하게 설정되었다는 뜻이다. 반대로 외부클래스에서 사용하게 하고 싶지 않은 클래스는 private으로 선언해주면 된다.  1 2 3 4 5 6 7 8 package hiding;  public class Student {     int studentID;     private String studentName;     int grade;     String address; }  위 코드는 Student라는 클래스를 만들어주어 안에 변수를 만들어주었는데, studentName 변수를 private를 사용하여 선언해주었다.  이렇게 private 예약어를 사용한 변수를 한번 다른 클래스에서 접근해보면,  1 2 3 4 5 6 7 8 9 10 package hiding;  public class StudentTest {     public static void main(String[] args){         Student studentLee = new Student();         studentLee.studentName = \"이민재\";          System.out.println(studentLee.getStudentName());     } }  위의 코드는 private로 선언한 studentName 변수에 접근했으므로, 프로그램에서 오류를 출력한다.   그렇다면 private으로 선언한 studentName에 접근하고 싶다면 어떻게 해야 할까? 이 때 사용 할 수 있는것이 바로 내부클래스에서 접근을 할수 있도록 해주는 메서드를 만들어 주는 것이다.     다시 Student 파일을 열어 메서드 두개를 추가해주도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package hiding;  public class Student {     int studentID;     private String studentName;     int grade;     String address;          public String getStudentName(){         return studentName     }          public void setStudentName(String studentName){         this.studentName = studentName;     } }  getStudentName() 클래스는 public으로 선언되어 있으며, 이 메서드는 studentName과 같은 클래스에 있으므로 접근도 가능하다. 그럼 직접 저 변수에 접근하는게 아니라 우리가 만들어준 메서드를 사용하여 우리가 private로 선언한 studentName에 접근해보자.  1 2 3 4 5 6 7 8 9 10 package hiding;  public class StudentTest {     public static void main(String[] args){         Student studentLee = new Student();         studentLee.setStudentName(\"이민재\");          System.out.println(studentLee.getStudentName());     } }  이렇게 우리가 만들어준 메서드로 접근을 할 수 있도록 코드를 작성해주니, 올바르게 프로그램에 동작하는 것을 볼 수 있다.   굳이 이렇게 직접 변수에대한 접근을 막는 private 예약어를 제공해주는 이유는 무엇일까??  만약 우리가 날짜를 받는 기능을 구현한다고 생각해보자.   각 달은 30일, 31일을 가지며, 2월의 경우에는 28일의 날짜를 갖는데, 만약 public으로 변수를 선언하고 변수를 직접 대입해주면 2월에도 30일이 들어갈 수 있는 오류가 생길 것이다.  따라서 이럴때는 변수를 private로 선언해 준뒤, set() 메서드를 만들어주어, 직접 set() 메서드가 이 월에 따른 일수가 맞는지를 판별하여 일수가 일치하는 경우에만 해당 변수에 날짜를 대입하도록 만들 수 가 있다.   이처럼 클래스 내부에서 사용할 변수는 private로 선언해주어 외부의 접근을 막아주면, 우리가 예상치 못한 오류들을 막아내는데 유용하게 사용할 수 있다.                  접근 제어자       설명                       public       외부클래스 어디에서나 접근 가능                 protected       같은 패키지 내부와 상속관계의 클래스에서만 접근가능                 아무것도 없는 경우       default이며, 같은 패키지 내부에서만 접근 가능                 private       같은 클래스 내부에서만 접근가능          ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%B0%B8%EC%A1%B0%EC%9E%90%EB%A3%8C%ED%98%95,-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89/",
        "teaser": null
      },{
        "title": "[Programmers] 쿼드 압축 후 개수 세기 (Python3)",
        "excerpt":"문제  0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.  당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.   만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.  그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.   arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.   제한사항  arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, …, 1024 중 하나입니다.   arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.  arr의 각 행에 있는 모든 값은 0 또는 1 입니다.   입출력 예  1 2 3 4 5 6 7 arr                                          result [[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]    [4,9]  [[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1], [0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1], [0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1], [0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]        [10,15]  입출력 예 설명  입출력 예 #1  다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.    최종 압축 결과에 0이 4개, 1이 9개 있으므로, [4,9]를 return 해야 합니다.   입출력 예 #2  다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.    최종 압축 결과에 0이 10개, 1이 15개 있으므로, [10,15]를 return 해야 합니다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def solution(arr):     answer = [0,0]     N = len(arr)     def quad(x,y,n):         start = arr[x][y]         for i in range(x,x+n):             for j in range(y,y+n):                 if start != arr[i][j]:                     end = n//2                     quad(x,y,end)                     quad(x+end,y, end)                     quad(x,y+end,end)                     quad(x+end,y+end,end)                     return         answer[start] += 1       quad(0,0,N)     return answer      1 2 3 4 arr = [[1,1,0,0],        [1,0,0,0],        [1,0,0,1],        [1,1,1,1]]   1 solution(arr)   1 [4, 9]   ","categories": ["programmers"],
        "tags": ["코딩테스트","Programmers","파이썬"],
        "url": "/programmers/Programmers-%EC%BF%BC%EB%93%9C-%EC%95%95%EC%B6%95-%ED%9B%84-%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 캐시 (Python3)",
        "excerpt":"문제  지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.  이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.   어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.   어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.   입력 형식  캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.  cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.  cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.  각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.   출력 형식  입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다.   조건  캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다.  cache hit일 경우 실행시간은 1이다.  cache miss일 경우 실행시간은 5이다.  입출력 예제  |캐시크기(cacheSize)|도시이름(cities)|실행시간|  |:—:|:—:|:—:|  3|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]|50  3|[“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”]\t|21  2|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]|60  5|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]|52  2|[“Jeju”, “Pangyo”, “NewYork”, “newyork”]|16  0|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]|25   문제 풀이  이 문제는 캐시메모리를 파이썬으로 간단하게 구현해보는 것인데, 카카오 문제라 그런지 한번도 풀어본 적이 없는 신유형 느낌이라 당황스러웠다. 우선 이 문제는 캐시와 LRU를 알지 못하면 아예 풀수가 없어서 이에 대해 알아야 풀 수 있다.   캐시는 메인 메모리와 CPU간의 데이터 속도 향상을 위한 중간 버퍼 역할을 하는 메모리로써, 잠시 저장해둔다는 의미를 갖고, 실제로 이 기능을 한다. 이 문제는 캐시DB를 간단하게 구현해보는 방식인데, 위 문제에서 나온 Cache Hit은 캐시에 이미 값이 저장 되어있는 값을 참조할때를 말하고, Cache Miss는 캐시메모리에 저장이 되어있지 않아서 메인 메모리로 가서 값을 캐시메모리로 저장해야 할 때를 말한다.   LRU는 캐시교체 알고리즘으로, 가장 오래전에 참조된 값을 삭제하고 새로운 데이터를 그 자리에 삽입하는 알고리즘이다. LRU를 검색하다가 캐시 교체 알고리즘에 대해 알게 되었는데, 내가 이미 큐에서 배웠던 FIFO 방식도 캐시메모리에서 비롯된 알고리즘이란걸 알게되었다.  간단하게 캐시 알고리즘을 정리 해보면 아래의 표와 같다.                  캐시 알고리즘       특징       단점                       Random       교체될 페이지를 임의 선정함       오버헤드가 적음                 FIFO(First in First Out)       캐시 내에 가장 오래있었던 페이지를 교체       자주사용되는 페이지가 교체될 우려가 있음                 LFU(Least Frequently Used)       사용 횟수가 가장 적은 페이지부터 교체       최근 적재된 페이지가 교체될 우려가 있음                 LRU(Least Recently Used)       가장 오랫동안 사용되지 않은 페이지부터 교체       time stamping에 의한 오버헤드 존재                 Optimal       향후 가장 참조되지 않을 페이지부터 교체       참조될 것을 미리 알 수 없기 떄문에 실현 불가능                 NUR(Not Used Recently)       참조 비트와 수정 비트로 미사용 페이지 교체, 최근 사용되지 않은 페이지 교체                         SCR(Second Chance Replacement)       최초 참조 비트 1로 셋팅, 1인 경우 0으로 세팅하고, 0인 경우 교체, 기회를 한번 더 준다.                   따라서 LRU 방식으로 캐시 교체를 하려면, 캐시라는 리스트를 하나 만들어주고 만약 이미 캐시 리스트 안에 있는 값이라면 참조 후 가장 최근위치로 변경해주고 실행시간 1추가, 만약 캐시 리스트 안에 없는 값이라면, 가장 앞에있는 값을 삭제 후 새로운 값을 넣어준 뒤 실행시간 5를 추가 해주면 된다.   주의할점은, 대소문자를 구분하지 않는다고 했기 때문에 반드시 .lower로 소문자로 통일해주어야 하며, 캐시사이즈가 0인 경우는 모두다 Cache Miss이기 때문에 예외처리를 해주어야한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def solution(cacheSize, cities):     #캐시리스트     cache = []     #실행시간     time = 0     #만약 캐시사이즈가 0인경우는 모두 miss처리한다.     if cacheSize == 0:         return len(cities)*5     #캐시 메모리에 리스트 요소 하나씩 추가     for city in cities:         #캐시메모리가 꽉찼을 경우에만 미스와 hit처리         if len(cache) == cacheSize:             #hit의 경우             if city.lower() in cache:                 cache.remove(city.lower())                 cache.append(city.lower())                 time += 1                 #print('hit:',cache)             #miss의 경우             else:                 cache.remove(cache[0])                 cache.append(city.lower())                 time+=5                 #print('miss:',cache)         #캐시메모리의 자리가 있다면 miss인 경우에도 삭제는 필요없음         else:             #hit의 경우             if city.lower() in cache:                 cache.remove(city.lower())                 cache.append(city.lower())                 time += 1                 #print('hit:',cache)             #miss의 경우             else:                 cache.append(city.lower())                 time+=5                 #print('miss:',cache)     return time   1 solution(3,[\"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\"])   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 firstmiss: ['jeju'] firstmiss: ['jeju', 'pangyo'] firstmiss: ['jeju', 'pangyo', 'seoul'] hit: ['pangyo', 'seoul', 'jeju'] hit: ['seoul', 'jeju', 'pangyo'] hit: ['jeju', 'pangyo', 'seoul'] hit: ['pangyo', 'seoul', 'jeju'] hit: ['seoul', 'jeju', 'pangyo'] hit: ['jeju', 'pangyo', 'seoul']      21   노트  프로그래머스에서 다른 풀이를 보니 너무 예쁘게 잘 푼 풀이가 있어서 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(cacheSize, cities):     import collections     cache = collections.deque(maxlen=cacheSize)     time = 0     for i in cities:         s = i.lower()         if s in cache:             cache.remove(s)             cache.append(s)             time += 1         else:             cache.append(s)             time += 5     return time   위 풀이는 deque의 maxlen을 이용했는데, maxlen은 deque의 크기를 제한해주는 메서드로, 그 크기를 넘어서는 값이 들어오면 알아서 가장 앞에있는 값을 삭제하고 새로운 값을 채운다. 이를 사용하면 훨씬 더 파이써닉 하게 풀 수 있을 것 같다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%EC%BA%90%EC%8B%9C/",
        "teaser": null
      },{
        "title": "[Programmers] 점프와 순간 이동 (Python3)",
        "excerpt":"문제  OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.  예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다.   아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다.   처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다.     처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다.      처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다.      위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다.   제한 사항  숫자 N: 1 이상 10억 이하의 자연수     숫자 K: 1 이상의 자연수   입출력 예  |N|result|  |:—:|:—:|  |5\t|2|  |6\t|2|  |5000\t|5|   입출력 예 설명  입출력 예 #1  위의 예시와 같습니다.   입출력 예 #2  처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동합니다. 이때 1 칸을 앞으로 점프하면 위치3으로 이동합니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 3) x 2 이동할 수 있으므로 위치 6에 도착합니다. 이 경우가 건전지 사용량이 가장 적으므로 2를 반환해주면 됩니다.   입출력 예 #3  위와 같은 방식으로 합니다.   문제풀이  대략 읽고 당연히 bfs로 풀어야하는 문제라고 생각해서 bfs로 풀다가 도저히 안풀렸는데, 생각해보니 숫자 N의 제한사항이 1이상 10억이하라 애초에 bfs로 풀 수가 없는 문제였다.굳이 bfs로 생각하지 않아도 되는 쉬운 문제였다. 배터리를 가장 적게 사용하기 위해서는 최대한 순간이동으로 이동해야 하므로, 2씩 나눠가며 나머지가 1이 나오면 한칸 점프해야 하므로 배터리사용량을 1증가시키고, 계속 순간이동 하며 가면된다.  사실 코드난이도로 보면 이게 왜 레벨2인지 잘 모르겠지만, 아마 bfs를 함정으로 낸 문제가 아닐까 싶다.   코드  1 2 3 4 5 6 7 8 9 10 def solution(n):     battery = 0     while n!=1:         if n%2 == 0:             n = n//2         else:             n= n//2             battery += 1              return battery+1   1 solution(6)   1 2   노트  문제를 풀고 다른 사람 풀이를 보니 기가막히게 푼게 있어서 첨부한다. 이런 생각을 하는사람들 보면 진짜 똑똑한것 같다… 다음에 이렇게 2로나눠서 나머지를 사용하는 문제가 있으면 이렇게도 사용할 수 있다는 것을 알고 있어야겠다.   1 2 def solution(n):     return bin(n).count('1')   2진법으로 변환할때 나머지가 있으면 1 아니면 0으로 변환하는걸 이용해서 나머지 1의 개수를 셌다.  ","categories": [],
        "tags": [],
        "url": "/%EC%A0%90%ED%94%84%EC%99%80-%EC%88%9C%EA%B0%84-%EC%9D%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "[Java] 배열과 ArrayList",
        "excerpt":"배열 선언과 초기화  배열을 사용하려면 먼저 배열을 선언해야한다.     배열도 변수와 마찬가지로 자료형을 함께 선언하는데, 배열을 선언하는 문법은 다음과 같다.  1 2 자료형[] 배열 이름 = new 자료형[개수]; 자료형 배열 이름[] = new 자료형[개수];  예를들어 학생의 학번을 만약 배열로 선언한다고 하면,  1 int[] studentIDs = new int[10];  이렇게 선언하면 studentIDs라는 이름을 가진 int형 10자리 배열이 생성된다.   만약 선언과 동시에 배열의 값을 초기화하고 싶다면,     중괄호를 사용하면 배열의 값을 초기화하면서 선언할 수 있다.  1 int[] studentIDs = new int[]{101,102,103}  이때, 알아서 초기화 되는 갯수 만큼 배열이 생성되므로, []안의 개수는 생략해야한다.  또 다음과 같이 new int[] 부분을 아예 생략할 수도 있다.  1 int[] studentIDs = {102,102,103}  배열 사용하기  선언한 배열의 요소에 접근하려면 [ ]를 사용한다.     만약 배열의 첫번째 요소에 10을 저장한다면 아래처럼 코드를 작성하면된다.  1 studentIDs[0] = 10;  배열의 순서는 항상 0부터 시작한다.   그럼 위의 코드를 하나의 프로그램으로 해서 배열을 출력해보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package array;  public class ArrayTest {     public static void main(String[] args){         int[] num = new int[] {1,2,3,4,5,6,7,8,9,10};          for (int i = 0;i&lt;num.length;i++){             System.out.println(num[i]);         }     } } &gt;&gt;&gt; 1 &gt;&gt;&gt; 2 &gt;&gt;&gt; 3 &gt;&gt;&gt; 4 &gt;&gt;&gt; 5 &gt;&gt;&gt; 6 &gt;&gt;&gt; 7 &gt;&gt;&gt; 8 &gt;&gt;&gt; 9 &gt;&gt;&gt; 10  위처럼 배열에 담긴 1부터 10까지의 수가 차례로 출력된것을 볼 수 있다.   자바의 배열은 배열길이를 가지는 legth 속성을 가지는데, 자바에서 배열길이는 처음에 선언한 배열의 전체 요소 개수를 의미한다. 전체 길이를 알고 싶은 배열 이름뒤에 도트 연산자를 붙이고 length 속성을 쓰면 배열 길이를 반환해준다. for문으로 배열의 모든 요소를 출력하고 싶다면, 조건식에 .length를 사용해줌으로써 배열의 길이만큼 출력하도록 할 수 있다.   그럼 빈 값이 들어가있는 배열에서 값이 있는 요소만 출력하고 싶다면 어떻게 해야 할까?  아래의 코드와 같이 size라는 변수를 하나 더 만들어 사용해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package array;  public class ArrayTest {     public static void main(String[] args){         int[] num = new int[5];         int size = 0;        num[0] = 10; size++;        num[1] = 20; size++;        num[2] = 30; size++;         for(int i = 0;i&lt;size;i++){            System.out.println(num[i]);        }     } }   객체 배열 사용하기  이번에는 참조 자료형으로 선언하는 객체 배열에 대해 알아보자.     동일한 기본 자료형 변수 여러개를 사용할 수 있듯이 참조자료형 변수도 여러 개를 배열로 사용 가능하다. 책과 책 저자를 저장하는 클래스 Book을 만들어 객체 배열을 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package array;  public class Book {     private  String bookName;     private String author;      public Book(){}          public Book(String bookName, String author){         this.bookName = bookName;         this.author = author;     }     public String getBookName(){         return bookName;     }     public void setBookName(String bookName){         this.bookName = bookName;     }     public String getAuthor(){         return author;     }     public void setAuthor(String author){         this.author =author;     }     public  void showBookInfo(){         System.out.println(bookName+\",\"+author);     } }  Book 클래스를 만들어 책이름과 저자를 저장하는 변수 bookName, author를 만들어주고, 각각을 받아오는 get 함수와 각각을 저장하는 set함수를 만들고, 마지막으로 책이름과 저자를 출력하는 showBookInfo 함수를 만들어주었다.   이제 도서관에 책이 5권있다고 가정하고 Book클래스를 사용하여 책 5권을 객체 배열로 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package array;  public class BookArray {     public static void main(String[] args){         Book[] library = new Book[5];          for(int i = 0; i&lt;library.length;i++){             System.out.println(library[i]);         }     } }  &gt;&gt;&gt; null &gt;&gt;&gt; null &gt;&gt;&gt; null &gt;&gt;&gt; null  library = new Book[5]; 를 보면 마치 5개의 인스턴스가 생성된 것처럼 보이지만, 실제로는 인스턴스를 가리키는 주소값을  담을 공간 5개를 생성하는 문장이다. 따라서 이 코드를 실행하게 되면 Book의 주소를 담을 공간 5개가 만들어지고 자동으로 공간이 null로 초기화 된다.   그럼 이제 만들어준 빈공간에 인스턴스를 만들어 저장해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package array;  public class BookArray2 {     public static void main(String[] args){         Book[] library = new Book[5];                  library[0] = new Book(\"태백산맥\", \"조정래\");         library[1] = new Book(\"데미안\", \"헤르만 헤세\");         library[2] = new Book(\"1q84\", \"무라카미 하루키\");         library[3] = new Book(\"토지\", \"박경리\");         library[4] = new Book(\"어린왕자\", \"생택쥐페리\");              for(int i = 0;i&lt;library.length;i++){             library[i].showBookInfo();         }              } }  &gt;&gt;&gt; 태백산맥,조정래 &gt;&gt;&gt; 데미안,헤르만 헤세 &gt;&gt;&gt; 1q84,무라카미 하루키 &gt;&gt;&gt; 토지,박경리 &gt;&gt;&gt; 어린왕자,생택쥐페리  출력값을 보면 각 인스턴스가 모두 잘 생성되었음을 알 수 있다.   배열 복사하기  기존 배열과 자료형 및 크기가 똑같은 배열을 새로 만들거나 배열의 모든 요소에 자료가 꽉 차서 더 큰 배열을 만들어   기존 배열에 저장된 자료를 가져오려고 할 때, 배열을 복사한다.     배열을 복사하는 방법은 두 가지가 있는데, 첫 번째는 기존 배열과 배열 길이가 같거나 더 긴 배열을 만들고 for문을 사용하여 각 요소 값을 반복해서 복사하는 법이고, 두 번째는 System.arraycopy() 메서드를 사용하는 방법이다.   Sysyem.arraycopy(src,srcPos,dest,destPos,length)   각 매개변수의 의미는 다음과 같다.                  매개변수       설명                       src       복사할 배열 이름                 srcPos       복사할 배열의 첫 번째 위치                 dest       복사해서 붙여 넣을 대상 배열 이름                 destPos       복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치                 length       src에서 dest로 자료를 복사할 요소 개수           그럼 예제를 통해 실제로 배열을 한번 복사해보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 package array;  public class ArrayCopy {     public static void main(String[] args){         int[] array1 = {10,20,30,40,50};         int[] array2 = {1,2,3,4,5};          System.arraycopy(array1,0,array2,1,4);         for(int i = 0;i&lt;array2.length;i++){             System.out.println(array2[i]);         }     } }  src = array1, dest = array2 이므로 array1에 있는 값을 array2에 복사한다.     srcPos = 0, destPos = 1 이므로, array1의 값은 0부터 array2의 1부터의 공간에 length인 4만큼의 길이로 복사된다.  이때, 복사할 대상 배열의 길이가 복사할 요소 개수보다 작다면 오류가 난다.   이번에는 객체 배열을 복사해보자.     객체 배열도 마찬가지로 동일한 방식으로 복사해서 사용 할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package array;  public class ObjectCopy1 {     public static void main(String[] args){         Book[] library1 = new Book[3];         Book[] library2 = new Book[3];           library1[0] = new Book(\"태백산맥\", \"조정래\");         library1[1] = new Book(\"데미안\", \"헤르만 헤세\");         library1[2] = new Book(\"1q84\", \"무라카미 하루키\");          System.arraycopy(library1,0,library2,0,3);          for(int i=0;i&lt; library2.length;i++){             library2[i].showBookInfo();         }     } } &gt;&gt;&gt; 태백산맥,조정래 &gt;&gt;&gt; 데미안,헤르만 헤세 &gt;&gt;&gt; 1q84,무라카미 하루키   다음과 같이 library1의 인스턴스가 library2로 복사된 것을 확인 할 수 있다.     이 상태에서 만약 library1의 값을 변경하게 되면 어떻게 될까??     예제를 통해 확인해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package array;  public class ObjectCopy2 {         public static void main(String[] args){             Book[] library1 = new Book[3];             Book[] library2 = new Book[3];               library1[0] = new Book(\"태백산맥\", \"조정래\");             library1[1] = new Book(\"데미안\", \"헤르만 헤세\");             library1[2] = new Book(\"1q84\", \"무라카미 하루키\");              System.arraycopy(library1,0,library2,0,3);              library1[0].setBookName(\"나목\");             library1[0].setAuthor(\"박완서\");                          for(int i=0;i&lt; library2.length;i++){                 library2[i].showBookInfo();                      }     }  }  &gt;&gt;&gt; 나목,박완서 &gt;&gt;&gt; 데미안,헤르만 헤세 &gt;&gt;&gt; 1q84,무라카미 하루키  library1[0]의 값을 변경해주었는데, library2[0]의 값도 변경되었다.     이는 객체 배열의 요소에 저장된 값은 인스턴스 자체가 아니고, 인스턴스의 주소 값이기 때문이다. 따라서 객체 배열을 복사하게되면 인스턴스를 따로 생성하는게 아닌, 기존 인스턴스의 주소값만을 복사하게된다. 결국 두 배열의 서로 다른 요소가 같은 인스턴스를 가리키고 있으므로, 복사되는 배열의 인스턴스 값이 변경되면 두 배열 모두 영향을 받게되는 것이다. 이런 복사를 얕은 복사(shallow copy) 라고 한다.   그렇다면 실제로 두 배열의 요소가 각각 다른 주소값의 인스턴스를 가르키도록 복사하려면 어떻게 해야할까?   이렇게 하고 싶다면, 직접 인스턴스를 만들어 요소 값을 복사해야 한다.      아래의 코드를 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package array;  public class ObjectCopy3 {     public static void main(String[] args){         Book[] library1 = new Book[3];         Book[] library2 = new Book[3];          library1[0] = new Book(\"태백산맥\",\"조정래\");         library1[1] = new Book(\"데미안\", \"헤르만 헤세\");         library1[2] = new Book(\"1q84\", \"무라카미 하루키\");          library2[0] = new Book();         library2[1] = new Book();         library2[2] = new Book();                  for(int i = 0;i&lt; library2.length;i++){             library2[i].setBookName(library1[i].getBookName());             library2[i].setAuthor(library1[i].getAuthor());         }          library1[0].setBookName(\"나목\");         library1[0].setAuthor(\"박완서\");          for(int i =0;i&lt; library2.length;i++){             library2[i].showBookInfo();         }      } }  위의 코드는 library2의 인스턴스를 직접 만들어 준뒤, setBookName과 setAuthor를 사용하여 하나 하나의 값에 요소값을 복사 해주었다.     이렇게 하면 복사한 배열 요소는 기존 배열 요소와 서로 다른 인스턴스를 가르키므로 기존 배열의 요소값이 변경되어도 영향을 받지 않는다는 것을 알 수 있다.   향상된 for문과 배열  자바 5부터 제공되는 향상된 for문(enhanced for loop) 은 배열의 처음에서 끝까지 모든 요소를 참조할 때 사용하면 편리한 반복문으로, 향상된 for문은 배열 요소 값을 하나씩 가져와 변수에 대입한다. 따로 초기화와 종료조건을 명시하지 않아도 알아서 모든 배열의 시작요소부터 끝 요소까지를 실행해준다.  1 2 3 4 5 6 7 8 9 10 11 package array;  public class EnhancedFor {     public static void main(String[] args){         String[] srtArray = {\"Java\", \"Android\", \"C\", \"JavaScript\", \"Python\"};          for(String lang : srtArray){             System.out.println(lang);         }     } }  이처럼 for문의 매개변수에 (String 변수 : 배열 )을 넣어주면 배열의 첫 요소부터 끝까지를 참조해준다.   ArrayList  우리가 앞서 배운 배열은 기본 프로그램에서 사용하기 위해서는 항상 배열의 길이를 정하고 시작해야 한다.     하지만 만약 예를 들어 100명의 학생을 위한 프로그램을 개발했는데, 어느 순간 학생 수가 100명이 넘은 경우를 생각해보자. 배열을 사용하는 중에는 배열의 길이를 변경 할 수 없기 때문에 코드를 수정해야한다.  또, 만약 한명이 중간에 전학을 가게되었다면 배열은 중간의 요소를 비워 둘 수 없으므로 배열 요소의 위치를 변경해야한다. 이 두 경우 모두 배열을 하나 하나 수정하려 한다면 매우 힘들고 복잡할 것이다.   그래서 자바는 객체 배열을 더 쉽게 사용 할 수 있도록 객체 배열클래스 ArrayList를 제공한다.      ArrayList 클래스는 객체 배열을 관리하는 멤버변수와 메서드를 따로 제공하기 때문에, 사용방법만 알아 둔다면 편리하게 사용가능하다.   ArrayList 클래스는 이미 만들어져 있는 메서드가 있는데, 가장 주로 사용하는 메서드를 정리해보자면 다음과 같다.                  메서드       설명                       boolean add(E e)       요소 하나를 배열에 추가한다. E는 요소의 자료형을 의미한다.                 int size()       배열에 추가된 요소 전체 개수를 반환한다.                 E get(int index)       배열의 index 위치에 있는 요소 값을 반환한다.                 E remove(int index)       배열의 index 위치에 있는 요소 값을 제거하고 그 값을 반환한다.                 boolean isEmpty()       배열이 비어있는지 확인한다.           add( ) 메서드를 사용하면 배열 길이와 상관없이 객체를 추가 할 수 있다. 만약 배열 요소 개수가 부족하다면  배열 크기를 더 키울 수 있도록 구현되어 있으며, 또 배열 중간의 어떤 요소가 제거되면 그 다음 요소 값을 하나씩 앞으로 이동하는 코드도 이미 구현되어 있기때문에, 훨씬 편리하게 프로그래밍 할 수 있다.   ArrayList 활용하기  ArrayList를 사용하는 방법은 다음과 같다.  1 ArrayList&lt;E&gt; 배열 이름 = new ArrayList&lt;E&gt;();  선언하는 부분 &lt;&gt;안에 사용할 객체의 자료형을 쓰면 된다.     예를들어 앞에서 살펴본 Book 클래스형을 자료형으로 사용해서 ArrayList 배열을 생성한다면 다음과 같다.  1 ArrayList&lt;Book&gt; library = new ArrayList&lt;Book&gt;();  ArrayList는 java.util 패키지에 구현되어 있는 클래스로, 현재 만든 프로그램에는 이 패키지가 포함되어 있지 않기 때문에 컴파일러에게 ArrayList를 사용하기 위해서는 컴파일러에게 ArrayList가 어디에 구현되어 있다고 알려주기 위해 코드 맨 위에 선언하는 것을 임포트(import) 한다고 한다. 즉 ArrayList를 사용하려면 ArrayList를 import해주어야 사용할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package array; import java.util.ArrayList;  public class ArrayListTest {     public static void main(String[] args){         ArrayList&lt;Book&gt; library = new ArrayList&lt;Book&gt;();          library.add(new Book(\"태백산맥\", \"조정래\"));         library.add(new Book(\"데미안\", \"헤르만 헤세\"));         library.add(new Book(\"1q84\", \"무라카미 하루키\"));         library.add(new Book(\"토지\", \"방경리\"));         library.add(new Book(\"어린왕자\", \"생택쥐페리\"));          for(int i = 0; i&lt;library.size();i++){             Book book = library.get(i);             book.showBookInfo();         }         System.out.println();          System.out.println(\"=== 향상된 for문 사용 ===\");         for(Book book : library){             book.showBookInfo();         }      } }  기본 배열에서는 [ ] 안에 배열 전체 길이를 미리 지정해야 했습니다. 하지만 ArrayList를 생성할 때는 미리 지정할 필요 없이 add( ) 메서드를 사용해 생성자만 호출하면 된다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%B0%B0%EC%97%B4%EA%B3%BC-ArrayList/",
        "teaser": null
      },{
        "title": "[Programmers] 이진 변환 반복하기 (Python3)",
        "excerpt":"문제  0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.  x의 모든 0을 제거합니다.  x의 길이를 c라고 하면, x를 “c를 2진법으로 표현한 문자열”로 바꿉니다.  예를 들어, x = “0111010”이라면, x에 이진 변환을 가하면 x = “0111010” -&gt; “1111” -&gt; “100” 이 됩니다.  0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 “1”이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.   제한사항  s의 길이는 1 이상 150,000 이하입니다.  s에는 ‘1’이 최소 하나 이상 포함되어 있습니다.   입출력 예  |s\t|result|  |:—:|:—:|  |”110010101001”\t|[3,8]|  |”01110”\t|[3,3]|  |”1111111”|\t[4,1]|   입출력 예 설명  입출력 예 #1  “110010101001”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.                  회차       이진 변환 이전       제거할 0의 개수       0 제거 후 길이       이진 변환 결과                       1       “110010101001”       6       6       “110”                 2       “110”       1       2       “10”                 3       “10”       1       1       “1”           3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, [3,8]을 return 해야 합니다.   입출력 예 #2  “01110”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.                  회차       이진 변환 이전       제거할 0의 개수       0 제거 후 길이       이진 변환 결과                       1       “01110”       2       3       “11”                 2       “11”       0       2       “10”                 3       “10”       1       1       “1”           3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다.   입출력 예 #3  “1111111”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.                  회차       이진 변환 이전       제거할 0의 개수       0 제거 후 길이       이진 변환 결과                       1       “1111111”       0       7       “111”                 2       “111”       0       3       “11”                 3       “11”       0       2       “10”                 4       “10”       1       1       “1”           4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, [4,1]을 return 해야 합니다.   문제풀이  간단한 문제였다. 그냥 문제가 시키는대로 천천히 코드를 짜주면 풀 수 있다.  중간에 0을 제거한 숫자의 길이를 이진변환 하는것을 문제를 제대로 안읽어서 자꾸 숫자자체를 이진변환하려다가 자꾸 무한루프가 떠서 좀 걸렸는데, 제대로 풀고나서도 테스트 케이스에서 하나 시간초과가 떠서 중간에 변환과정을 줄였다.  앞으로는 문제를 잘 읽자…   코드   1 2 3 4 5 6 7 8 9 10 11 def solution(string):     string = list(string)     change = 0     zero = 0     while len(string) != 1:         zero+=string.count('0')         string = ['1']*string.count('1')         change+=1         string = list(bin(len(string))[2:])         #print(string)     return [change,zero]   1 solution(\"110010101001\")   1 [3, 8]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%9D%B4%EC%A7%84-%EB%B3%80%ED%99%98-%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 오픈채팅방 (Python3)",
        "excerpt":"문제  카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데,       본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.      신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.   “[닉네임]님이 들어왔습니다.”   채팅방에서 누군가 나가면 다음 메시지가 출력된다.   “[닉네임]님이 나갔습니다.”   채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.     채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.   채팅방에서 닉네임을 변경한다.  닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.     예를 들어, 채팅방에 “Muzi”와 “Prodo”라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.   “Muzi님이 들어왔습니다.”      “Prodo님이 들어왔습니다.”   채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.   “Muzi님이 들어왔습니다.”      “Prodo님이 들어왔습니다.”     “Muzi님이 나갔습니다.”   Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.   “Prodo님이 들어왔습니다.”      “Prodo님이 들어왔습니다.”      “Prodo님이 나갔습니다.”      “Prodo님이 들어왔습니다.”   채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.   “Prodo님이 들어왔습니다.”      “Ryan님이 들어왔습니다.”      “Prodo님이 나갔습니다.”       “Prodo님이 들어왔습니다.”   채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.   제한사항  record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다.     다음은 record에 담긴 문자열에 대한 설명이다.     모든 유저는 [유저 아이디]로 구분한다.   [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - “Enter [유저 아이디] [닉네임]” (ex. “Enter uid1234 Muzi”)   [유저 아이디] 사용자가 채팅방에서 퇴장 - “Leave [유저 아이디]” (ex. “Leave uid1234”)   [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - “Change [유저 아이디] [닉네임]” (ex. “Change uid1234 Muzi”)  첫 단어는 Enter, Leave, Change 중 하나이다.  각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다.   유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다.   유저 아이디와 닉네임의 길이는 1 이상 10 이하이다.   채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.     입출력 예      |record\t|result|  |:—:|:—:|  |[“Enter uid1234 Muzi”, “Enter uid4567 Prodo”,”Leave uid1234”,”Enter uid1234 Prodo”,”Change uid4567 Ryan”]|\t[“Prodo님이 들어왔습니다.”, “Ryan님이 들어왔습니다.”, “Prodo님이 나갔습니다.”, “Prodo님이 들어왔습니다.”]|       문제풀이  이 문제는 유저아이디와 닉네임이 있으므로 딕셔너리에 유저아이디를 키로 넣고 닉네임을 밸류값으로 넣어서 호출하면 풀 수 있는 문제이다.   다만 닉네임 변경이라는 부분이 까다로워서 생각을 좀 더 하게 만들었는데, 레코드를 나눠 바로 닉네임값만 받아 메세지를 결과리스트에 추가하면 나중에 딕셔너리에서 바뀐값을 또 결과리스트에서 참조하기가 불가능해, 닉네임 변경이 어려웠다.   그래서 따로 process라는 리스트를 하나만들어준 뒤, Enter인경우는 앞에 ‘i’를 유저아이디 앞에 붙여서 저장하고, Leave인경우에는 ‘o’를 유저아이디 앞에 붙여 저장하도록 했으며, Change인 경우에는 딕셔너리에 있는 유저아이디 키값에 해당하는 밸류를 바꾸도록 했다.      그렇게 모든 레코드를 받아 process에 저장한 뒤에 process의 요소를 하나씩 받아 맨앞 글자로 Enter와 Leave를 판단한 뒤, 그 뒤에 붙어있는 유저아이디를 딕셔너리에서 호출해서 텍스트를 결과리스트에 저장하도록 했다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def solution(record):     process = []     msgdic  = dict()     result = []     for user in record:         msg = user.split()         if msg[0] == \"Enter\":             msgdic[msg[1]] = msg[2]             process.append('i'+msg[1])         if msg[0] == \"Leave\":             process.append('o'+msg[1])         else:             msgdic[msg[1]] = msg[2]     for i in process:         if i[0] == 'i':             result.append(msgdic[i[1:]]+\"님이 들어왔습니다.\")         if i[0] == 'o':              result.append(msgdic[i[1:]]+\"님이 나갔습니다.\")              return result   1 solution([\"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\",\"Leave uid1234\",\"Enter uid1234 Prodo\",\"Change uid4567 Ryan\"])   1 ['Prodo님이 들어왔습니다.', 'Ryan님이 들어왔습니다.', 'Prodo님이 나갔습니다.', 'Prodo님이 들어왔습니다.']   노트  풀고나니 역시 나보다 똑똑한 사람이 푼 훨씬 깔끔한 코드가 있어 첨부한다.     이 사람은 printer라는 딕셔너리를 하나 더 만들어주어 닉네임 뒤에 붙는 메시지도 호출 할 수 있게해서 훨씬 깔끔하다. 나도 따로 process를 만들지 않고 record를 두번 참조하는 편이 메모리도 아끼고 훨씬 간단했을텐데 왜 이 생각을 못했는지 아쉽다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(record):     answer = []     namespace = {}     printer = {'Enter':'님이 들어왔습니다.', 'Leave':'님이 나갔습니다.'}     for r in record:         rr = r.split(' ')         if rr[0] in ['Enter', 'Change']:             namespace[rr[1]] = rr[2]      for r in record:         if r.split(' ')[0] != 'Change':             answer.append(namespace[r.split(' ')[1]] + printer[r.split(' ')[0]])      return answer  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9/",
        "teaser": null
      },{
        "title": "[Java] 배열 응용 프로그램",
        "excerpt":"예제 시나리오  1001학번 Lee와 1002 학번 Kim, 두 학생이 있다. Lee 학생은  2과목을 수강한다. 국어 점수가 100점, 수학 점수는 50점이다.  Kim 학생은 3과목을 수강한다. 국어 점수가 70점, 수학 점수가 85점, 영어 점수가 100점이다. Student 클래스와 Subject 클래스를 생성한 후 두 학생의 과목 성적과 총점을 각각 출력해 보자.   먼저 Student 클래스를 구현해보자.     Student 클래스는 이름과 학번, 그리고 수강과목을 멤버변수로 갖는데, 이중 수강과목은 ArrayList로 선언하여 구현한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package arraylist; import java.util.ArrayList;  public class Student {     String name;     int studentId;     ArrayList&lt;Subject&gt; subjectList;      public Student(int studentId, String name){         this.studentId = studentId;         this.name = name;         subjectList = new ArrayList&lt;Subject&gt;();     }     //생성자     public void addSubject(String name, int score){         Subject subject = new Subject();         subject.setScore(score);         subject.setName(name);         subjectList.add(subject);     }     public void showInfo(){         int total = 0;         for(Subject s: subjectList){             total += s.getScore();             System.out.println(\"학생\" + name + \"의\" + s.getName()+\"과목 성적은\"+s.getScore()+\"입니다.\");         }         System.out.println(\"총점은\"+total);     } }  Student 클래스는 과목을 추가하는 addSubject와 정보를 출력하는 showInfo 메서드를 갖는다.  여기서 ArrayList의 자료형으로 Subject 클래스를  선언했으므로 Subject 클래스를 만들어주자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package arraylist;  public class Subject {     private String name;     private int score;      public Subject(){         this.name = name;         this.score = score;     }     public void setName(String name){         this.name = name;     }     public String getName(){         return name;     }     public void setScore(int score) {         this.score =  score;     }     public int getScore() {         return score;     }  }  Student 인스턴스의 addSubject 메서드안에 있는 Subject의 메서드를 만들어주어야 하므로, 점수와 이름을 private 멤버변수로 선언해주고, 각각의 변수에 값을 할당하는 함수 setName과 setScore를 만들어준다.   이제 ArrayListTest 클래스를 만들어 main함수로써 우리가 위에 만들었던 클래스들이 동작하도록, Lee와 Kim의 인스턴스를 선언해 주고 과목과 점수를 입력후, 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package arraylist;  public class ArrayListTest {     public static void main(String[] args){         Student Lee = new Student(1001, \"Lee\");         Lee.addSubject(\"국어\",100);         Lee.addSubject(\"수학\",50);          Student Kim = new Student(1002, \"Kim\");         Kim.addSubject(\"국어\", 70);         Kim.addSubject(\"수학\", 85);         Kim.addSubject(\"영어\", 100);          Lee.showInfo();         System.out.println(\"---------------------------\");         Kim.showInfo();     }  }  &gt;&gt;&gt; 학생Lee의국어과목 성적은100입니다. &gt;&gt;&gt; 학생Lee의수학과목 성적은50입니다. &gt;&gt;&gt; 총점은150 &gt;&gt;&gt; --------------------------- &gt;&gt;&gt; 학생Kim의국어과목 성적은70입니다. &gt;&gt;&gt; 학생Kim의수학과목 성적은85입니다. &gt;&gt;&gt; 학생Kim의영어과목 성적은100입니다. &gt;&gt;&gt; 총점은255  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%B0%B0%EC%97%B4-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/",
        "teaser": null
      },{
        "title": "[Programmers] 배달 (Python3)",
        "excerpt":"문제  N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다.     위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.   마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.   제한사항     마을의 개수 N은 1 이상 50 이하의 자연수입니다.   road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.   road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.   road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.   a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.   두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.   한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.   K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.   임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.   1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.     입출력 예      |N\t|road\t|K\t|result|  |:—:|:—:|:—:|:—:|  |5\t|[[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]]\t|3\t|4|  |6\t|[[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]]|4|\t4       입출력 예 설명  입출력 예 #1      문제의 예시와 같습니다.   입출력 예 #2      주어진 마을과 도로의 모양은 아래 그림과 같습니다.         1번 마을에서 배달에 4시간 이하가 걸리는 마을은 [1, 2, 3, 5] 4개이므로 4를 return 합니다.   문제풀이  맨 처음에는 bfs나 dfs로 풀려고 했는데, 아무리 풀어봐도 거리를 저장하는게 어려워서 해답을 찾아봤다. 이 문제는 다익스트라 알고리즘(dijkstra algorithm) 으로 푸는 문제로, 다익스트라 알고리즘은 최단거리를 구할 때 사용하는 알고리즘이다. 보통 노드와 노드, 그리고 노드 사이의 거리 or 시간의 세가지가 주어질 때 사용하는 알고리즘으로, 힙큐와 bfs를 일정 부분 섞어서 사용하는 알고리즘이다.   다익스트라 알고리즘은 그리디 알고리즘의 한 종류로, 매 상황에서 가장 비용이 적은 노드를 선택해 과정을 반복함으로써 얻은 최단 경로가 실제로 가장 비용이 적은 노드가 해답이라는 가정하에 사용한다.   알고리즘의 동작 과정은 다음과 같다.     출발 노드를 설정한다.   최단 거리 테이블을 초기화한다.   방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.   해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.   3번과 4번을 반복한다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import heapq import sys INF = sys.maxsize  def solution(N, road, K):     distance = [INF]*(N+1)     graph = [[] for _ in range(N+1)]     for i in road:         graph[i[0]].append((i[1],i[2]))         graph[i[1]].append((i[0],i[2]))          def dijkstra(start):         q = []         heapq.heappush(q,(0,start))         distance[start] = 0         while q:             dist, now = heapq.heappop(q)             if distance[now] &lt; dist:                 continue             for i in graph[now]:                 cost = dist+i[1]                 if cost &lt; distance[i[0]]:                     distance[i[0]] = cost                     heapq.heappush(q,(cost,i[0]))     dijkstra(1)     result = 0     for i in range(1, N+1):         if distance[i] &lt;= K:             result += 1              return result   1 solution(5,[[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]],3)   1 2 3 4 5 6 7 [[], [(2, 1), (4, 2)], [(1, 1), (3, 3), (5, 2)], [(2, 3), (5, 1)], [(1, 2), (5, 2)], [(2, 2), (3, 1), (4, 2)]]      4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B0%B0%EB%8B%AC/",
        "teaser": null
      },{
        "title": "[Programmers] 주식가격 (Python3)",
        "excerpt":"문제  초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.   제한사항  prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.      prices의 길이는 2 이상 100,000 이하입니다.   입출력 예  |prices|\treturn|  |:—:|:—:|  |[1, 2, 3, 2, 3]|\t[4, 3, 1, 1, 0]|   입출력 예 설명  1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.     2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.     3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.     4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.     5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.     ※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다.   문제 풀이  이 문제는 브루트포스로 풀어도 통과가 뜨긴 하지만, 그래도 더 빠른 동작을 위해서는 스택을 사용해서 풀어야 한다. 결국 가격이 떨어지지 않은 기간은 가격이 떨어지게되는 가격의 인덱스에서 해당 인덱스를 뺀 값이기 때문에, 가격을 스택에 쌓아주다가 다음 가격이 더 크면 스택에 쌓고, 다음 가격이 더 작으면 pop해준다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(prices):     answer = [0]*len(prices)     stack = []     for i,price in enumerate(prices):         while stack and price &lt; prices[stack[-1]]:             j = stack.pop()             answer[j] = i - j             #print(stack)         stack.append(i)         #print(stack)     while stack:         j = stack.pop()         answer[j] = len(prices)-1-j                       return answer   1 solution([1, 2, 3, 2, 3])   1 2 3 4 5 6 7 8 9 10 11 12 [0] [0, 1] [0, 1, 2] [0, 1] [0, 1, 3] [0, 1, 3, 4]      [4, 3, 1, 1, 0]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%A3%BC%EC%8B%9D%EA%B0%80%EA%B2%A9/",
        "teaser": null
      },{
        "title": "[Java] 상속",
        "excerpt":"상속이란?  객체 지향 프로그래밍의 중요한 특징 중 하나가 바로 상속(inheritance) 이다. 상속은 우리가 아는 의미인 무엇인가를 물려받는다는 의미 동일하게 사용되며, 부모가 자식에게 상속을 해주면 자녀가 그 재산을 사용할 수 있듯이, 객체 지향 프로그램에서도 마찬가지로 B클래스가 A클래스를 상속받으면 B클래스는 A클래스의 멤버 변수와 메서드를 사용할 수 있게 된다. 객체 지향 프로그램은 유지 보수하기가 간편하고 프로그램을 수정하거나 새로운 내용을 추가하는 것이 유연한데, 그 기반이 되는 기술이 바로 상속이다.   클래스의 상속  우리가 일반적으로 생각할 때는 상속을 하는 클래스에서 받는 클래스로 화살표가 갈 것 같지만, 클래스 간 상속을 표현할 때는 상속받는 클래스에서 상속 해주는 클래스로 화살표가 간다.   클래스를 상속하려면 extends 예약어를 사용한다. extends는 연장, 확장한다는 의미로, A가 갖고있는 속성이나 기능을 추가로 확장하여 B클래스를 구현한다는 뜻이다. 아래와 같이 선언해주면, B클래스는 A클래스를 상속한다.  1 class B extends A{}  예를들어, 포유류와 사람의 관계를 생각해보자. 포유류는 사람보다 일반적인 개념으로써, 사람은 포유류의 특징과 기능을 기본으로 더 많거나 다른 특징과 기능을 가지고 있다. 따라서 포유류 클래스를 사람클래스에 상속해주면, 우리는 포유류의 특징과 기능은 그대로 사용하고, 이를 간단하게 변형하거나 추가하여 사용할 수 있는 것이다.   상속을 사용하여 고객 관리 프로그램 구현하기  회사에서 고객 정보를 갖고 맞춤 서비스를 제공하기 위해 고객관리 프로그램을 구현하려고 한다고 가정해보자.     그렇다면 먼저, 고객 클래스를 만들어주어야 할 것 이다. 앞서 배웠듯이 고객 클래스의 속성을 멤버 변수로 선언 해주면 된다.      이 예제에서는 고객 아이디, 이름, 고객 등급, 보너스 포인트, 보너스 포인트 적립 비율을 속성으로 선언한다고 해보겠다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package inheritance;  public class Customer {     private int customerID;     private String customerName;     private String customerGrade;     int bonusPoint;     double bonusRatio;      public Customer(){         customerGrade = \"SILVER\";         bonusRatio = 0.01;     }     public int calcPrice(int price) {         bonusPoint += price * bonusRatio;         return price;     }     public String getCustomerInfo(){         return customerName+\" 님의 등급은 \"+ customerGrade+\"이며, 보너스 포인트는\"+bonusPoint+\"입니다.\";     } }  위의 클래스는 인스턴스가 생성될 경우 기본적으로 customerGrade가 SILVER 등급으로 설정되고, bonusRatio가 0.01로 설정된다.  또, 보너스 포인트를 적립하고 지불 가격을 계산하는 calcPrice() 메서드와 고객 정보를 가져오는 getCustomerInfo() 메서드를 갖고있다.   그럼 이제 이러한 상황에서 새로운 고객등급이 필요한 경우를 생각해보자.      만약 고객이 점점 늘어나고 판매가 늘어나 단골 고객이 생긴 경우에는, 단골 고객은 회사 매출에 많은 기여를 하는 우수 고객이기 때문에, 이들에게 더 우수한 혜택을 주어야 할 것이다. 우수 고객 등급은 VIP 등급이며, 다음과 같은 혜택을 제공한다고 가정해보자.      제품을 살때는 항상 10% 할인   보너스 포인트를 5% 적립   담당 전문 상담원 배정   이러한 혜택을 추가하고 싶다면 어떻게 해야 할까? 가장 간단하게 생각한다면, Customer 클래스에 VIP고객 등급에 필요한 변수와 메서드를 추가하여 구현하는 것이다. 하지만 그렇게 하면 Customer 클래스의 코드가 복잡해 진다. 게다가 일반 고객의 인스턴스를 생성할 때에는 VIP 고객과 관련된 기능은 필요가 없는데, VIP 고객의 내용이 계속 생성되기 때문에 메모리 낭비가 발생할 수 있다.  따라서 이러한 경우에 상속을 사용하여 VIPCustomer 클래스를 따로 만들어주는 것이 좋다.   VIP 클래스의 경우는 Customer의 속성과 메서드를 모두 포함한 상태로 추가적인 혜택이 제공 되는 것이기 때문에, Customer를 상속하여 만들어주면 추가적인 멤버변수와 메서드만 작성해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package inheritance;  public class VIPCustomer extends Customer {     private  int agentID;     double saleRatio;          public VIPCustomer(){         customerGrade = \"VIP\";//오류 발생         bonusRatio = 0.05;         saleRatio = 0.1;              }     public  int getAgentID(){         return agentID;     } }  이렇게 위 처럼 Customer를 상속한 VIPCustomer 클래스를 만들어 보았다.     하지만, 상속을 해주었음에도 customerGrade의 변수를 사용하려고 하니, 오류가 발생한다.      우리는 아까 Customer 변수를 선언할 때 private으로 customerGrade를 선언해주었기 때문에, 이 변수를 외부 클래스에서 사용할 수 없어 오류가 발생한 것이다. 이럴 때 사용하는 것이 protected 예약어이다.   protected는 private와 동일하게 다른 외부클래스에서 접근하지 못하도록 해주지만, 하위클래스에서는 사용할 수 있도록 해준다.     따라서 상속받은 클래스에서는 public과 동일하게 작동하게 되는것이기 때문에, 외부클래스에서의 접근은 막고싶지만, 상속받은 클래스에서는 사용할 수 있도록 해주려면, protected 예약어를 사용해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package inheritance;  public class Customer {     protected int customerID;     protected String customerName;     protected String customerGrade;     int bonusPoint;     double bonusRatio;      public Customer(){         customerGrade = \"SILVER\";         bonusRatio = 0.01;     }     public int calcPrice(int price) {         bonusPoint += price * bonusRatio;         return price;     }     public String getCustomerInfo(){         return customerName+\" 님의 등급은 \"+ customerGrade+\"이며, 보너스 포인트는\"+bonusPoint+\"입니다.\";     }     public void setCustomerID(int customerID){         this.customerID = customerID;     }     public void setCustomerName(String customerName){         this.customerName = customerName;     } }   다시 Customer 클래스의 private를 protected로 변경 해줌으로써, VIPCustomer에서도 멤버 변수를 사용 할 수 있게 되었다.      추가로, 외부 클래스에서 접근 할 수 있도록, set() 메서드를 추가해주었다.   그러면 간단하게 테스트 프로그램을 만들어 다음의 예제를 구현해보자.   일반 고객 1명과 VIP 고객 1명이 있다. 일반 고객의 이름은 이순신, 아이디는 100010이고, 이 고객은 현재 보너스 포인트를 1000점 갖고있다. VIP 고객의 이름은 김유신, 아이디는 10020이며, 이 고객은 보너스 포인트를 10000점 가지고 있다고 가정해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package inheritance;  public class Test {     public static void main(String[] args){         Customer customerLee = new Customer();         customerLee.setCustomerID(10010);         customerLee.bonusPoint = 1000;         customerLee.setCustomerName(\"이순신\");         System.out.println(customerLee.getCustomerInfo());          VIPCustomer customerKim = new VIPCustomer();         customerKim.setCustomerID(10020);         customerKim.bonusPoint = 10000;         customerKim.setCustomerName(\"김유신\");         System.out.println(customerKim.getCustomerInfo());     } }  위처럼 고객들의 인스턴스를 생성하여 메서드를 사용해 이름과 고객번호, 보너스포인트를 저장해 준 뒤, 고객의 정보를 출력해보았다.   상속에서 클래스 생성과 형 변환  하위 클래스가 생성될 때는 상위 클래스의 생성자가 먼저 호출된다. 상속관계에서 클래스의 생성 과정을 살펴보면 하위 클래스가 상위 클래스의 변수와 메서드를 사용할 수 있는 이유와 하위클래스가 상위클래스의 자료형으로 형 변환이 가능한 이유를 이해하기 쉽다.   ## 하위 클래스가 생성되는 과정   상속을 받은 하위 클래스는 상위 클래스의 변수와 메서드를 사용할 수 있다고 했었다. 즉 Test 예제를 보면, VIPCustomer 클래스로 선언한 customerKim 인스턴스는 상속받은 상위 클래스의 변수를 자기 것처럼 사용할 수 있다. 변수를 사용할 수 있다는 것은 그 변수를 저장하고 있는 메모리가 존재한다는 뜻이다. 그런데 VIPCousomer 클래스 코드에는 해당 변수가 존재하지 않는다. Custmer 클래스를 상속받았을 뿐이다. 여기서 우리는 상속된 하위 클래스가 생성되는 과정을 생각해볼 필요가 있다.   테스트 해보기 위해 Customer  클래스와 VIPCustomer 클래스 생성자에 출력문을 추가해 보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package inheritance;   public class Customer {      protected int customerID;      protected String customerName;      protected String customerGrade;      int bonusPoint;      double bonusRatio;       public Customer(){          customerGrade = \"SILVER\";          bonusRatio = 0.01;          System.out.println(\"Customer() 생성자 호출\");      }      public int calcPrice(int price) {          bonusPoint += price * bonusRatio;          return price;      }      public String getCustomerInfo(){          return customerName+\" 님의 등급은 \"+ customerGrade+\"이며, 보너스 포인트는\"+bonusPoint+\"입니다.\";      }      public void setCustomerID(int customerID){          this.customerID = customerID;      }      public void setCustomerName(String customerName){          this.customerName = customerName;      }  }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package inheritance;  public class VIPCustomer extends Customer {     private  int agentID;     double saleRatio;          public VIPCustomer(){         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         System.out.println(\"VIPCustomer() 생성자 호출\");      }     public  int getAgentID(){         return agentID;     } }  두 클래스 모두 생성자 안에 “(생성자이름) 생성자 호출” 이라는 문자열을 출력하도록 했다.      따라서 생성자가 호출되면 위 문자열이 출력될 것이므로, 한번 생성자가 호출될때 어떻게 되는지 확인해 보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package inheritance;  public class Test2 {     public static void main(String[] args){         VIPCustomer customerKim = new VIPCustomer();         customerKim.setCustomerID(10020);         customerKim.setCustomerName(\"김유신\");         customerKim.bonusPoint = 10000;         System.out.println(customerKim.getCustomerInfo());     } }  &gt;&gt;&gt; Customer() 생성자 호출 &gt;&gt;&gt; VIPCustomer() 생성자 호출 &gt;&gt;&gt; 김유신 님의 등급은 VIP이며, 보너스 포인트는10000입니다.  Test2 클래스를 만들어 VIPCustomer의 인스턴스인 customerKim을 만들어 생성자가 어떻게 호출되는지 확인해 보았다.     출력 내용을 보면, 먼저 Customer() 생성자가 호출된 뒤, 그 다음에 VIPCustomer()가 호출되는 것을 알 수 있다.   정리해보면, 상위클래스를 상속받은 하위 클래스가 생성될 때는 반드시 상위클래스의 생성자가 먼저 호출된다.     그 이후 상위 클래스 생성자가 호출될 때 상위 클래스의 멤버 변수가 메모리에 생성되는 것이다.   따라서 상위클래스의 변수가 메모리에 먼저 생성되기 때문에 하위 클래스에서도 이 값들을 모두 사용할 수 있는 것이다.   부모를 부르는 예약어, super  super 예약어는 하위 클래스에서 상위 클래스로 접근할 때 사용한다. 하위 클래스는 상위 클래스의 주소, 즉 참조 값을 알고 있다.  이 참조 값을 갖고 있는 예약어가 바로 super로, this가 자기 자신의 참조 값을 가지고 있는 것과 같다고 생각하면 된다. 또한 supers는 상위 클래스의 생성자를 호출할 때도 사용된다.      이러한 super()는 상속된 하위 클래스를 호출하면 하위 클래스 생성자가 자동으로 호출한다.  1 2 3 4 5 6 public VIPCustomer(){     super();     customerGrade = \"VIP\";     bonusRatio = 0.05;     saleRatio = 0.1; }  위와 같이 디폴트 코드로 변환되기전에 super();를 자동으로 호출한다.   이런 경우를 생각해 보자. Customer 클래스를 생성할 때 고객 ID와 이름을 반드시 지정하도록 할때를 생각해보자. 이런 경우에 set() 메서드로 값을 지정하는게 아니고, 새로운 생성자를 만들어 매개변수로 값을 전달 받아야 할 것 이다. 즉 자동으로 생성되는 디폴트 생성자가 아닌 매개변수가 있는 생성자를 직접 구현해야 한다.  1 2 3 4 5 6 7 8 public Customer(){        this.customerID = customerID;        this.customerName = customerName;        customerGrade = \"SILVER\";        bonusRatio = 0.01;        System.out.println(\"Customer() 생성자 호출\");            }  위의 Customer 클래스의 생성자는 반드시 customerID와 customerName을 지정해야하는 생성자이다. 이렇게 디폴트 생성자가 아닌 새로운 생성자를 작성하면, Customer를 상속받은 VIPCustomer 클래스에서 오류가 발생한다.  Customer 클래스를 새로 생성할 때 반드시 멤버변수를 지정하도록 했으므로, VIPCustomer 클래스를 생성할 때도 당연히 이 멤버변수를 지정해주어야 할 것 이다. 따라서 super()를 사용하여 상위클래스의 생성자를 호출해 주어야 한다.   1 2 3 4 5 6 7 8 9 ublic VIPCustomer(int customerID, String customerName, int agentID){         super(customerID, customerName);         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         System.out.println(\"VIPCustomer() 생성자 호출\");         this.agentID = agentID;      }  위처럼 상위 생성자를 super()로 호출후 매개변수를 지정 해주어야 정상적으로 코드가 작동하는 것을 볼 수 있다.   상위 클래스로 묵시적 클래스 형 변환  상속을 공부하면서 우리가 이해해야 하는 중요한 관계가 클래스 간의 형 변환이다. 일단 Customer와 VIPCustomer의 관계를 생각해보자. 개념 면에서 보면 상위클래스인 Customer가 VIPCustomer보다 일반적 개념이지만, 기능 면에서 보면 VIPCustomer가 Customer보다 상위에 있다.   따라서 VIPCustomer는 VIPCustomer형이면서 동시에 Customer형이기도 하다. 즉 VIPCustomer 클래스로 인스턴스를 생성할 때 이 인스턴스의 자료형을 Customer형으로 클래스 형 변환하여 선언할 수 있다.   형 변환을 선언하는 방법은 다음과 같다.  1 Cutomer vc = new VIPCustomers();  이렇게 선언하면 VIPCustomer의 생성자가 호출되지만, 그 클래스의 자료형이 Customer로 한정된다. 따라서 선언해준 vc는 Customer 클래스의 멤버 변수와 메서드만 사용가능하게 된다.   메서드 오버라이딩  위에서 새로운 등급을 만들면서 VIP 고객에게 제공하는 할인율과 세일 가격을 어떻게 적용 할지는 구현하지 않았다. 이번에는 그 기능을 구현해보도록 하자.   상위클래스 Customer에는 제품 가격을 계산하는 calcPrice() 메서드가 이미 정의 되어있는데, 이 메서드는 포인트를 적립 후 정가를 그대로 지불한다. 그런데 VIP 고객은 정가에서 10%의 할인을 받을 수 있어야 하므로, 상위클래스인 Customer의 메서드를 그대로 사용해서는 할인이 적용되지 않는다.   이렇게 상위클래스에서 정의한 메서드가 하위 클래스에서 구현할 내용과 맞지 않는 경우에는 이 메서드를 재정의 할 수 있는데, 이를 메서드 오버라이딩(method overiding) 이라고 한다.   오버라이딩을 하려면 반환형, 메서드 이름, 매개변수 개수, 매개변수 자료형이 반드시 같아야한다. 그렇지 않으면 자바 컴파일러는 재정의한 메서드를 기존 메서드와 다른 메서드로 인식한다.   한번 VIPCustomer 에서 calPrice() 메서드를 오버라이딩 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package inheritance;  public class VIPCustomer extends Customer {     private  int agentID;     double saleRatio;          public VIPCustomer(int customerID, String customerName){         super(customerID, customerName);         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         System.out.println(\"VIPCustomer() 생성자 호출\");       }     public int getAgentID(){         return agentID;     }     public int calcPrice(int price){         bonusPoint +=price * bonusRatio;         return price - (int)(price * saleRatio);     } }  위와 같이 calcPrice를 매개변수의 자료형 및 개수가 같고, 반환형도 int형으로 같다.      이렇게 하면 자바 컴파일러는 이 메서드를 오버라이딩한다. 이런 오버라이딩은 이클립스의 기능을 사용해서 오버라이딩 할 수도 있다.   이렇게 메서드를 오버라이딩한 결과를 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package inheritance;  public class Test {     public static void main(String[] args){         Customer customerLee = new Customer(10010, \"이순신\");         customerLee.bonusPoint = 1000;          VIPCustomer customerKim = new VIPCustomer(10020,\"김유신\");         customerKim.bonusPoint = 10000;         int price = 10000;         System.out.println(customerLee.getCustomerInfo()+\"님이 지불해야 하는 금액은\"+customerLee.calcPrice(price)+\"원입니다.\");         System.out.println(customerKim.getCustomerInfo()+\"님이 지불해야 하는 금액은\"+customerKim.calcPrice(price)+\"원입니다.\");     } }  &gt;&gt;&gt; 이순신 님의 등급은 SILVER이며, 보너스 포인트는1000입니다.님이 지불해야 하는 금액은10000원입니다. &gt;&gt;&gt; 김유신 님의 등급은 VIP이며, 보너스 포인트는10000입니다.님이 지불해야 하는 금액은9000원입니다.  VIP회원인 김유신은 올바르게 지불 금액이 할인된것을 볼 수 있다.   묵시적 클래스 형 변환과 메서드 재정의  다음과 같은 경우에는 어떻게 실행될지 생각해 보자.  1 2 Customer vc = new VIPCustomer(\"10030\", \"나몰라, 2000); vc.calcPrice(10000);  VIPCustomer 가 Customer형으로 변환되었다.  calcPrice()는 Customer 클래스와 VIPCustomer 클래스에 모두 존재한다. 그렇다면, vc.calcPrice(10000)은 어떤 클래스의 메서드를 호출할까??   고객이 지불해야 하는 금액은 얼마일지 다음 코드로 테스트해 보겠습니다.  1 2 3 4 5 6 7 8 9 10 11 12 package inheritance;  public class OveridngTest {     public static void main(String[] args){         Customer vc = new VIPCustomer(10030,\"나몰라\", 2000);         vc.bonusPoint = 1000;          System.out.println(vc.getCustomerName()+\"님이 지불해야 하는 금액은\"+vc.calcPrice(10000)+\" 원 입니다.\");     } }  &gt;&gt;&gt; 나몰라님이 지불해야 하는 금액은9000원 입니다.  호출한 결과 분명 묵시적 형변환으로 Customer() 클래스로 형변환을 해주었음에도 VIPCustomer 클래스의 calcPrice() 메서드가 호출된것을 볼 수 있다. 왜일까?   상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할 때 호출되는 메서드는 인스턴스에 따라 결정된다. 다시 말해 선언한 클래스형이 아니라 생성된 인스턴스의 메서드를 호출하는 것이다. 이렇게 인스턴스의 메서드가 호출되는 것을 가상 메서드(virtual mehod) 라고 한다. 가상메서드가 실행되는 원리를 이해하면 왜 위의 예제가 Customer() 클래스의 메서드가 아닌 VIPCustomer의 메서드를 호출하는지 이해할 수 있다.   가상 메서드  자바의 클래스는 멤버 변수와 메서드로 이루어져 있다. 클래스를 생성하여 인스턴스가 생성되면 멤버 변수는 힙 메모리에 위치한다. 그렇다면 메서드는 어디에 위치할까? 변수가 사용하는 메모리와 메서드가 사용하는 메모리는 다르다. 변수는 인스턴스가 생성될 때마다 새로 생성되지만, 메서드는 실행해야 할 명령 집합이기 때문에 인스턴스가 달라도 같은 로직을 수행하게 된다. 즉 같은 객체의 인스턴스를 여러 개 생성해도 메서드는 여러 개 생성되지 않는다.   따라서 인스턴스가 달라도 동일한 메서드가 실행된다.   calcPrice() 메서드는 두 클래스에서 서로 다른 메서드 주소를 가지고 있다. 이렇게 재정의된 메서드는 실제 인스턴스에 해당하는 메서드가 호출되는데, getCustomInfo()와 같이 재정의되지 않은 메서드인 경우는 메서드 주소가 같으며, 상위클래스의 메서드가 호출된다.   이렇게 변수를 선언할 때 사용한 자료형의 메서드가 호출되는 것이 아니라 생성된 인스턴스의 메서드가 호출되는것을 가상 메서드라한다. 자바의 모든 메서드는 가상 메서드이다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%83%81%EC%86%8D/",
        "teaser": null
      },{
        "title": "[BOJ] 녹색 옷 입은 애가 젤다지? (Python3)",
        "excerpt":"문제  젤다의 전설 게임에서 화폐의 단위는 루피(rupee)다. 그런데 간혹 ‘도둑루피’라 불리는 검정색 루피도 존재하는데, 이걸 획득하면 오히려 소지한 루피가 감소하게 된다!   젤다의 전설 시리즈의 주인공, 링크는 지금 도둑루피만 가득한 N x N 크기의 동굴의 제일 왼쪽 위에 있다. [0][0]번 칸이기도 하다. 왜 이런 곳에 들어왔냐고 묻는다면 밖에서 사람들이 자꾸 “젤다의 전설에 나오는 녹색 애가 젤다지?”라고 물어봤기 때문이다. 링크가 녹색 옷을 입은 주인공이고 젤다는 그냥 잡혀있는 공주인데, 게임 타이틀에 젤다가 나와있다고 자꾸 사람들이 이렇게 착각하니까 정신병에 걸릴 위기에 놓인 것이다.   하여튼 젤다…아니 링크는 이 동굴의 반대편 출구, 제일 오른쪽 아래 칸인 [N-1][N-1]까지 이동해야 한다. 동굴의 각 칸마다 도둑루피가 있는데, 이 칸을 지나면 해당 도둑루피의 크기만큼 소지금을 잃게 된다. 링크는 잃는 금액을 최소로 하여 동굴 건너편까지 이동해야 하며, 한 번에 상하좌우 인접한 곳으로 1칸씩 이동할 수 있다.   링크가 잃을 수밖에 없는 최소 금액은 얼마일까?   입력  입력은 여러 개의 테스트 케이스로 이루어져 있다.   각 테스트 케이스의 첫째 줄에는 동굴의 크기를 나타내는 정수 N이 주어진다. (2 ≤ N ≤ 125) N = 0인 입력이 주어지면 전체 입력이 종료된다.   이어서 N개의 줄에 걸쳐 동굴의 각 칸에 있는 도둑루피의 크기가 공백으로 구분되어 차례대로 주어진다. 도둑루피의 크기가 k면 이 칸을 지나면 k루피를 잃는다는 뜻이다. 여기서 주어지는 모든 정수는 0 이상 9 이하인 한 자리 수다.   출력  각 테스트 케이스마다 한 줄에 걸쳐 정답을 형식에 맞춰서 출력한다. 형식은 예제 출력을 참고하시오.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 예제 입력 1   3 5 5 4 3 9 1 3 2 7 5 3 7 2 0 1 2 8 0 9 1 1 2 1 8 1 9 8 9 2 0 3 6 5 1 5 7 9 0 5 1 1 5 3 4 1 2 1 6 5 3 0 7 6 1 6 8 5 1 1 7 8 3 2 3 9 4 0 7 6 4 1 5 8 3 2 4 8 3 7 4 8 4 8 3 4 0  예제 출력 1   Problem 1: 20 Problem 2: 19 Problem 3: 36  문제 풀이  좌표 형식인 맵을 받아서 좌표에 적힌 도둑루피의 값을 노드 형식으로 바꿔서 다익스트라 알고리즘을 적용해서 풀었다. 좌표를 각각 왼쪽에서 오른쪽으로 1,2,3,4…로 값을 매긴 뒤  각 숫자에 있는 값들을 소모값으로 해서 (노드번호,소모값)의 형태로 해서 다익스트라 알고리즘을 적용해 주었다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import sys import heapq #input = sys.stdin.readline INF = sys.maxsize  n = 1 result = [] while n:     dx = [-1,1,0,0]     dy = [0,0,-1,1]     #동굴의 지도 graph     graph = []     #동굴의 크기를 n으로 받는다.     n = int(input())     #동구의 지도를 받아 graph에 이차원 배열로 넣는다.     if n == 0:         break     for i in range(n):         graph.append(list(map(int, input().split())))     #노드를 담을 리스트 node     node = [[] for _ in range(n*n+1)]     #지도를 노드화 시켜준다. 노드는 좌에서 우로 순서대로 1,2,3... 순이다.     # x+n+1+y를 하면 노드화가 가능하다.     for i in range(n):         for j in range(n):             for k in range(4):                 nx = i +dx[k]                 ny = j+ dy[k]                 num = i*n+1+j                 if nx &gt;= 0 and ny &gt;= 0 and nx &lt; n and ny &lt; n:                     index = nx*n+1+ny                     node[num].append((index,graph[nx][ny]))     #print(node)           distance = [ INF for _ in range(n*n+1)]          def djikstra(start):         q = []         heapq.heappush(q,(start,0))         distance[start]          while q:             now, dist = heapq.heappop(q)             if dist &gt; distance[now]:                 continue             for i in node[now]:                 cost = dist+i[1]                 if distance[i[0]] &gt; cost:                     distance[i[0]] = cost                     heapq.heappush(q,(i[0], cost))     djikstra(1)     result.append(distance[-1]+graph[0][0]) problem = 1 for i in result:     print(\"Problem\",str(problem)+\":\",i)     problem+=1   1 2 3 4 5 6 7 8 9 10 11 12 13 3 5 5 4 3 9 1 3 2 7 5 3 7 2 0 1 2 8 0 9 1 1 2 1 8 1 9 8 9 2 0 3 6 5 1 5 0 Problem 1: 20 Problem 2: 19   노트  풀고나니까 굳이 노드화 하지않고도 이차원 배열형식을 바로 다익스트라 알고리즘으로 풀 수가 있었다… 생각해보니까 이차원 배열형식 자체가 전후좌우로 연결된 노드기 때문에 당연한건데, 너무 복잡하게 문제를 생각했던것 같다. 바로 다익스트라를 적용한 코드를 아래 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import heapq  # direction arr dx = [-1, 1, 0, 0] dy = [0, 0, -1, 1]  # while input != 0 n, problem = int(input()), 1 while n != 0:   # input   data = list(list(map(int, input().split())) for _ in range(n))    # init distance array   distance = [[int(1e9) for i in range(n)] for j in range(n)]   distance[0][0] = data[0][0]   # dijkstra   heap = []   heapq.heappush(heap, [distance[0][0], 0, 0])   while heap:     dist, x, y = heapq.heappop(heap)     if dist &gt; distance[x][y]:       continue     for i in range(4):       nx, ny = x + dx[i], y + dy[i]       if not(0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n):         continue       cost = dist + data[nx][ny]       if cost &lt; distance[nx][ny]:         distance[nx][ny] = cost         heapq.heappush(heap, [cost, nx, ny])    # print ans   print('Problem ' + str(problem) + ': ' + str(distance[n-1][n-1]))   # next input   n = int(input())   problem += 1   1 2 3 4 5 6 3 5 5 4 3 9 1 3 2 7 Problem 1: 20 0   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EB%85%B9%EC%83%89-%EC%98%B7-%EC%9E%85%EC%9D%80-%EC%95%A0%EA%B0%80-%EC%A0%A4%EB%8B%A4%EC%A7%80/",
        "teaser": null
      },{
        "title": "[BOJ] 최소비용 구하기 (Python3)",
        "excerpt":"문제  N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.   입력  첫째 줄에 도시의 개수 N(1 ≤ N ≤ 1,000)이 주어지고 둘째 줄에는 버스의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 M+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.   그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다. 출발점에서 도착점을 갈 수 있는 경우만 입력으로 주어진다.   출력  첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 예제 입력 1   5 8 1 2 2 1 3 3 1 4 1 1 5 10 2 4 2 3 4 1 3 5 1 4 5 3 1 5 예제 출력 1   4   문제풀이  다익스트라 알고리즘을 사용하면 간단하게 풀 수 있다.     양방향으로 노드를 그려서 자꾸 다른 값이 나와서 오래걸려버렸다…      그래도 오류를 찾는다고 다익스트라 알고리즘을 처음부터 끝까지 하나하나 단계를 그려봐서 조금 더 다익스트라 알고리즘에 동작방식에 대한 이해가 늘었으니 만족한다.     이런 경로 문제를 풀때는 항상 단방향인지 양방향인지 잘 살펴보고 문제를 풀자.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import sys import heapq INF = sys.maxsize #input = sys.stdin.readline #도시의 개수 n = int(input()) #버스의 개수 m = int(input()) #도시의 노드 graph graph = [[]for _ in range (n+1)] #거리 테이블 dist distance = [INF]*(n+1)  visited = [False]*(n+1) #입력을 받아 graph를 채워준다. for i in range(m):     g = list(map(int,input().split()))     graph[g[0]].append((g[1],g[2])) #출발 도시와 도착도시의 번호 start,end = list(map(int,input().split()))  #다익스트라 알고리즘 def dijkstra(start):     q = []     heapq.heappush(q,(0, start))      while q:         dist, now = heapq.heappop(q)            if distance[now] &lt; dist:             continue                 for i in graph[now]:             cost = dist + i[1]             if cost &lt; distance[i[0]]:                 distance[i[0]] = cost                                  heapq.heappush(q,(cost,i[0]))  dijkstra(start) print(distance[end])    1 2 3 4 5 6 7 8 9 10 11 12 5 8 1 2 2 1 3 3 1 4 1 1 5 10 2 4 2 3 4 1 3 5 1 4 5 3 1 5 4   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "여름",
        "excerpt":"2021.07.30  요즘 날씨가 진짜 너무 덥다….      지구온난화 솔직히 어느정도 과장했다고 생각하고 있었는데, 과장이 아닐지도…?       에어컨을 하루종일 틀어도 잘 시원해지지가 않을정도로 덥다. 이렇게 더운 여름이 있었나 싶을정도로 요즘 더운 것 같다.      밖에 그냥 나가기가 싫을 정도로 너무 더운데, 괜히 더우니까 사람까지 늘어지고 나태해지는 기분이라고 해야하나…       아홉시에는 스터디카페 출근하기로 약속했는데, 최근에 아홉시에 출근한적이 없다. 물론 저번주, 이번주 월화 생동성을 다녀와서  좀 일정이 꼬인것도 있는데, 그래도 너무 늘어진다 이건…   운동도 좀 하고 해야하는데, 진짜 운동 운동 운동!!!!!       에너지가 잘 없으니까 운동할 의욕이 생기지가 않는다. 뭐던간에 한번 어느정도 해놔야 그걸 잃기 싫어서 계속 열심히 하는법인데,  쌓아놨던 운동의 경험을 한번에 싹 날려버리니 이제 될대로 되라… 하기 싫다 식이다…   나는 좀 기록을 만들고 뭔가 남겨야 더 열심히 하는 스타일인데, 운동이라는게 어디다 뭐를 남길만한 그게 좀없다.  엑셀 파일이라도 하나 만들어서 기록이라도 할까….   어쨌든 나태해진 나를 또, 몇번째 반성하는지 모르겠는데, 반성하며 다시 공부하러 가야겠다…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%97%AC%EB%A6%84/",
        "teaser": null
      },{
        "title": "[Java] 다형성",
        "excerpt":"다형성이란?  지금까지 설명한 묵시적 클래스 형 변환과 가상 메서드를 바탕으로 객체 지향의 중요한 특성인 다형성(polymorphism) 을 알아보자. 다형성이란, 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 말한다. 쉽게 말해 같은 코드에서 여러 실행결과가 나오는 것으로, 예제를 통해 살펴보자.   만약 Animal 클래스가 있고 이를 상속받아 Human, Tiger, Eagle 클래스를 만들어본다고 가정해보자.       Animal 클래스에 메서드를 하나 정의하고 이를 상속받은 클래스에서 재정의 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package polymorphism;  class Animal{     public void move(){         System.out.println(\"동물이 움직입니다.\");     } } class Human extends Animal{     public void move(){         System.out.println(\"사람이 두 발로 걷습니다.\");     } }  class Eagle extends Animal{     public void move(){         System.out.println(\"독수리가 하늘을 납니다.\");     }  } class Tiger extends Animal{     public void move(){         System.out.println(\"호랑이가 네발로 뜁니다.\");     }  } public class AnimalTest{     public static void main(String[] args){         AnimalTest aTest = new AnimalTest();         aTest.moveAnimal(new Human());         aTest.moveAnimal(new Eagle());         aTest.moveAnimal(new Tiger());      }     public void moveAnimal(Animal animal){         animal.move();     } }  위 코드는 Animal 클래스를 하나 만들고, 이를 상속하는 클래스 Human, Tiger, Eagle 을 만들어준 뒤 Animal의 메서드인 move를 오버라이딩하여 이를 main 함수에서 moveAnimal 메서드를 통해 사용되도록 했다.   여기서 moveAnimal 메서드는 어떤 인스턴스가 매개변수로 넘어와도 모두 Animal 형으로 변환한다. 예를 들어 매개변수 부분에 Human 인스턴스가 전달되었다면, 다음코드처럼 형 변환된다.  1 Animal ani = new Human();  Animal에서 상속받은 클래스가 매개변수로 넘어오면 모두 Animal형으로 변환되므로 animal.move() 메서드를 호출할 수 있다. 가상 메서드 원리에 따라 animal.move() 메서드가 호출하는 메서드는 Animal의 move가 아닌 매개변수로 넘어온 실제 인스턴스의 메서드이다. 따라서 animal.move() 메서드는 변함이 없지만 어떤 메서드가 넘어왔느냐에 따라 출력문이 달라지는데,  이를 다향성이라 한다.   다향성의 장점  다른 동물이 새로 추가되는 경우를 생각해보자. 새로운 동물도 Animal 클래스를 상속받아서 구현하면 모든 클래스를 Animal 자료형 하나로 쉽게 관리할 수 있을것이다. 이것이 바로 다형성을 활용한 프로그램의 확장성이다. 각 자료형에 따라 코드를 다르게 구현하면 코드는 훨씬 복잡해지고 내용도 길어지겠지만, 상위클래스에서 공통 부분의 메서드를 제공하고, 하위 클래스에서는 그에 기반한 추가요소만 덧붙여 구현하면 코드 양도 줄어들며, 유지보수도 편리하다.   그럼 다형성을 이용해서 상속에서 다뤘던 VIP 클래스를 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package polymorphism;  public class Customer {     protected int customerID;     protected String customerName;     protected String customerGrade;     int bonusPoint;     double bonusRatio;      public Customer(){         initCustomer();     }     public Customer(int customerID, String customerName){         this.customerID = customerID;         this.customerName = customerName;         initCustomer();     }     private void initCustomer(){         customerGrade = \"SILVER\";         bonusRatio = 0.01;     }      public int calcPrice(int price){         bonusPoint += price * bonusRatio;         return price;     }     public String showCustomerInfo(){         return customerName+\"님 의 등급은 \" + customerGrade+\"이며, 보너스 포인트는 \"+bonusPoint+\"입니다.\";     } }  먼저 Customer 클래스를 만들어 주었는데, 등급과 보너스 비율을 기본으로 설정하는 메서드를 생성자 두곳에서 모두 사용할 수 있도록 initCustomer() 메서드로 만들어주었다. 그럼 이를 상속하여 VIPCustomer 클래스를 만들어보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package polymorphism;  public class VIPCustomer extends Customer {     private int agentID;     double saleRatio;          public VIPCustomer(int customerID, String customerName, int agentID){         super(customerID, customerName);         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         this.agentID = agentID;     }     public int calcPrice(int price){         bonusPoint += price * bonusRatio;         return price - (int)(price * saleRatio);     }     public String showCustomerInfo(){         return super.showCustomerInfo()+ \"담당 상담원 번호는\" + agentID+\"입니다.\";     }     public int getAgentID(){         return agentID;     }      }  Customer 클래스를 상속하여 VIPCustomer 클래스를 만들어 주었다. VIPCustomer 클래스만의 멤버변수를 선언해 준뒤, calcPrice()와 showCustomerInfo() 메서드도 오버라이딩 해주었다.   이제 이렇게 생성해준 Customer 클래스와 VIPCustomer 클래스를 사용해서 각각의 인스턴스를 선언해 돈을 지불하고 계산해보면서 다형성에 대해 알아보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package polymorphism;  public class CustomerTest {     public static void main(String[] args){         Customer customerLee = new Customer(10010, \"이순신\");         customerLee.bonusPoint = 1000;          System.out.println(customerLee.showCustomerInfo());          Customer customerKim = new VIPCustomer(10020,\"김유신\",12345);         customerKim.bonusPoint = 1000;          System.out.println(customerKim.showCustomerInfo());         System.out.println(\"====================\");          int price = 10000;         int leePrice = customerLee.calcPrice(price);         int kimPrice = customerKim.calcPrice(price);          System.out.println(customerLee.customerName + \"님이\" + leePrice+\"원 을 지불했습니다.\");         System.out.println(customerLee.showCustomerInfo());         System.out.println(customerKim.customerName+ \"님이\" + kimPrice+\"원을 지불 하셨습니다.\");         System.out.println(customerKim.showCustomerInfo());     } }  &gt;&gt;&gt; 이순신님 의 등급은 SILVER이며, 보너스 포인트는 1000입니다. &gt;&gt;&gt; 김유신님 의 등급은 VIP이며, 보너스 포인트는 1000입니다.담당 상담원 번호는12345입니다. &gt;&gt;&gt; ==================== &gt;&gt;&gt; 이순신님이10000원 을 지불했습니다. &gt;&gt;&gt; 이순신님 의 등급은 SILVER이며, 보너스 포인트는 1100입니다. &gt;&gt;&gt; 김유신님이9000원을 지불 하셨습니다. 김유신님 의 등급은 VIP이며, 보너스 포인트는 1500입니다.담당 상담원 번호는12345입니다.   위에는 인스턴스로 customerLee와 customerKim 두개를 생성해주었는데, customerKim 은 형변환을 하여 Customer형으로 선언해주었다. 고객의 자료형은 Customer형으로 동일하지만, 할인율과 보너스 포인트는 각 인스턴스에 맞게 계산된 것을 알 수 있다.   이처럼 상속관계에 있는 상위 클래스와 하위 클래스는 같은 상위 클래스 자료형으로 선언되어 생성 할 수 있지만, 재정의된 메서드는 각각 호출될뿐만 아니라 이름만 같을 뿐, 서로 다른 역할을 구현하고 있음을 알 수 있다.   다형성 활용하기  앞에서 배운 상속과 다형성을 이용하여 어떻게 이 둘을 활용하여 프로그램을 간편하게 만들 수 있는지 알아보자.  다음과 같은 요구 사항이 발생했다고 하자.   고객이 늘어 VIP 고객만큼 물건을 많이 구매하지는 않지만, 그래도 단골인 분들에게 혜택을 주고싶다. 그래서 고객등급에 GOLD 고객등급을 하나 추가 하려한다. GOLD 회원의 혜택은 다음과같다.     제품을 살 때는 항상 10% 할인해준다.   보너스 포인트를 2% 적립해준다.   담당 전문 상담원은 없다.   이것을 기반으로 Customer 클래스를 상속받아 GOLDCustomer 클래스를 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package polymorphism;  public class GOLDCustomer extends Customer{     double saleRatio;      public GOLDCustomer(int customerID, String customerName){         super(customerID, customerName);         customerGrade = \"GOLD\";         bonusRatio = 0.02;         saleRatio = 0.1;     }     @Override     public int calcPrice(int price){         bonusPoint += price * bonusRatio;         return price - (int)(price * saleRatio);     } }  그럼 다시 CustomerTest 클래스에  main 함수를 구현하여 고객관리 프로그램을 구현해보자.   다음과 같은 상황을 구현해보도록 할 것 이다.   이 회사의 고객은 현재 5명이다. 5명 중 VIP 1명, GOLD 2명, SILVER 2명이다. 이 고객들이 각각 10000원 짜리 상품을 구매했을 때의 결과를 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package polymorphism; import java.util.ArrayList; import java.util.concurrent.atomic.AtomicReferenceArray;  public class CustomerTest {     public static void main(String[] args){         ArrayList&lt;Customer&gt; customerList = new ArrayList&lt;Customer&gt;();          Customer customerLee = new Customer(10010, \"이순신\");         Customer customerShin = new Customer(10020, \"신사임당\");         Customer customerHong= new GOLDCustomer(10030, \"홍길동\");         Customer customerYoul = new GOLDCustomer(10040, \"이율곡\");         Customer customerKim = new VIPCustomer(10050, \"김유신\",12345);          customerList.add(customerLee);         customerList.add(customerShin);         customerList.add(customerHong);         customerList.add(customerYoul);         customerList.add(customerKim);          System.out.println(\"==== 고객 정보 출력 ====\");         for(Customer c : customerList){             System.out.println(c.showCustomerInfo());         }          System.out.println(\"==== 할인율과 보너스 포인트 계산 ====\");         int price = 10000;         for (Customer c : customerList){             int cost = c.calcPrice(price);             System.out.println(c.customerName+ \"남이 \"+cost+\"원 지불하셨습니다.\");             System.out.println(\"현재 남아있는 포인트는\"+c.bonusPoint+ \"입니다.\");         }     } }  &gt;&gt;&gt; 이순신님 의 등급은 SILVER이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 신사임당님 의 등급은 SILVER이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 홍길동님 의 등급은 GOLD이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 이율곡님 의 등급은 GOLD이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 김유신님 의 등급은 VIP이며, 보너스 포인트는 0입니다.담당 상담원 번호는12345입니다. &gt;&gt;&gt; ==== 할인율과 보너스 포인트 계산 ==== &gt;&gt;&gt; 이순신님이 10000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는100입니다. &gt;&gt;&gt; 신사임당님이 10000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는100입니다. &gt;&gt;&gt; 홍길동남이 9000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는200입니다. &gt;&gt;&gt; 이율곡님이 9000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는200입니다. &gt;&gt;&gt; 김유신님이 9000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는500입니다.  5명의 고객의 정보를 담기 위해 객체 배열 ArrayList를 선언해주었다. 그리고 Customer 클래스로 5개의 인스턴스를 선언했는데, 이순신, 신사임당은 SILVERCustomer 객체로, 홍길동, 이율곡은 GOLDCustomer, 김유신은 VIPCustomer 객체로 선언하였다. 그리고 for 문을 사용하여 ArrayList에 있는 요소를 하나씩 가져와 c변수에 넣게되어 메서드를 실행하게된다. 그리고 각 인스턴스가 메서드를 호출하면 현재 이 변수의 실제 인스턴스가 무엇이냐에 따라 재정의한 메서드를 각각 호출하여 계산한다. 이것이 다형성이다.   만약 재정의한 메서드가 가상 메서드 방식에 의해 자동으로 호출되지 않는다면 if-else if문을 사용하여 각 자료형에 적합한 코드를 따로 구현해야 할 것이다. 게다가 새로운 등급의 고객이 필요할 때 마다 또 다른 조건을 구현해야 하므로 코드의 유지보수가 어려워진다. 이련경우에 상속과 다형성을 활용하면 복잡한 코드를 간결하게 하고 확장성있는 프로그램을 구현할 수 있게된다.   상속의 사용 조건  이렇게 상속에 대해 알아봤는데, 상속은 코드의 재사용 개념이 아니라는 것을 알아야한다.     예를 들어 과목을 나타내는 Subject 클래스가 있다고 하자. 과목 아이디, 이름을 멤버변수로 가지고 get(), set() 메서드도 제공한다. 이제 Student 클래스를 만들고자 하는데, 모든 학생은 전공 과목을 가지고 있기 때문에, Subject 클래스에서 제공하는 여러 메서드를 활용할 수 있도록 상속 해주면 좋을 것 같다는 생각이 든다.   하지만 이런 경우에는 상속을 사용하지 않는게 좋다. Subject가 Student를 포괄하는 개념의 클래스가 아니기 때문이다. 또한 Student 클래스를 상속받는 다른 클래스가 있을 수도 있기 때문에 상속을 사용하지 않는 것이 좋다. 이런경우를 HAS-A 관계(has a relationship; association) 라고 한다.   이 관계는 한 클래스가 다른 클래스를 소유한 관계로 상속이 아닌 멤버변수로 사용하는 것이 좋다.  1 2 3 class Student(){     Subject majorSubject; }  그렇다면 어떤 경우에 상속을 사용해주어야 좋을까?   바로 두 개념이 상위와 하위에 위치한, 일반적인 개념과 구체적인 개념의 관계를 갖고있는 상황에서 사용해주어야 한다. 즉 ‘사람은 포유류이다’ 와 같은 관계이다. 이러한 관계를 IS-A 관계(is a relationship; inheritance) 라고 한다.  상속은 이러한 관계를 갖고있는 개념에서 사용해주어야 올바르고 효율적인 코드를 작성할 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%8B%A4%ED%98%95%EC%84%B1/",
        "teaser": null
      },{
        "title": "[Programmers] 메뉴 리뉴얼 (Python3)",
        "excerpt":"문제  레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.       기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 “스카피”는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.        단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다.        예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,      (각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.)                  손님 번호       주문한 단품메뉴 조합                       1번 손님       A, B, C, F, G                 2번 손님       A, C                 3번 손님       C, D, E                 4번 손님       A, C, D, E                 5번 손님       B, C, F, G                 6번 손님       A, C, D, E, H           가장 많이 함께 주문된 단품메뉴 조합에 따라 “스카피”가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다.                  코스 종류       메뉴 구성       설명                       요리 2개 코스       A, C       1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다.                 요리 3개 코스       C, D, E       3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다.                 요리 4개 코스       B, C, F, G       1번, 5번 손님으로부터 총 2번 주문됐습니다.                 요리 4개 코스       A, C, D, E       4번, 6번 손님으로부터 총 2번 주문됐습니다.           각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, “스카피”가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, “스카피”가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.   제한사항     orders 배열의 크기는 2 이상 20 이하입니다.   orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다.   각 문자열은 알파벳 대문자로만 이루어져 있습니다.   각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다.   course 배열의 크기는 1 이상 10 이하입니다.   course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다.   course 배열에는 같은 값이 중복해서 들어있지 않습니다.   정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요.   배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다.   만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다.   orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다.   입출력 예  |orders|\tcourse|\tresult|  |:—:|:—:|:—:|  |[“ABCFG”, “AC”, “CDE”, “ACDE”, “BCFG”, “ACDEH”]\t|[2,3,4]\t|[“AC”, “ACDE”, “BCFG”, “CDE”]|  |[“ABCDE”, “AB”, “CD”, “ADE”, “XYZ”, “XYZ”, “ACD”]|\t[2,3,5]\t|[“ACD”, “AD”, “ADE”, “CD”, “XYZ”]|  |[“XYZ”, “XWY”, “WXA”]|\t[2,3,4]\t|[“WX”, “XY”]|   입출력 예에 대한 설명  입출력 예 #1  문제의 예시와 같습니다.   입출력 예 #2  AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.  요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다.   입출력 예 #3  WX가 두 번, XY가 두 번 주문됐습니다.  3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.  또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다.   문제풀이  카카오 문제들은 다 다른 문제들에서 풀어보지못한 유형으로 문제가 출제되는 것 같다. 문제를 정말 열심히 만드시는 듯 하다… 근데 이 문제는 솔직히 이해하기 너무 어렵게 써놔서 문제를 세번씩 풀었다. 내가 이해력이 떨어지는건가??   이 문제는 메뉴 자체들을 주문한 수를 세는게 아니라 각각의 손님들이 주문한 음식들을 하나의 코스를 시킨것으로 간주하고 거기서 조합을 모두 출력하여 각 course변수에 있는 숫자들의 조합별로 최대로 많이 나온 조합자체를 코스로 세야한다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import defaultdict import operator from itertools import combinations  def solution(orders, course):     result = []     menudic = defaultdict()     for num in course:         for order in orders:             menus = list(order)             combis = combinations(menus, num)                          for combi in combis:                 combi = sorted(list(combi))                 if \"\".join(combi) in menudic:                     menudic[\"\".join(combi)]+=1                 else:                     menudic[\"\".join(combi)]=1     menu_candidate = []     print(menudic)     for num in course:         count = []         for i in menudic.items():             if len(i[0]) == num and i[1]&gt;=2:                 count.append(i)          for i in count:             if i[1] == max(count, key = lambda x: x[1])[1]:                 result.append(i[0])                                                    return sorted(result)   1 solution([\"XYZ\", \"XWY\", \"WXA\"], [2, 3, 4])   1 2 3 4 5 6 7 defaultdict(None, {'XY': 2, 'XZ': 1, 'YZ': 1, 'WX': 2, 'WY': 1, 'AW': 1, 'AX': 1, 'XYZ': 1, 'WXY': 1, 'AWX': 1})      ['WX', 'XY']   노트  역시나 나보다 훨씬 간단하게 푼 코드가 있어서 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import collections import itertools  def solution(orders, course):     result = []      for course_size in course:         order_combinations = []         for order in orders:             order_combinations += itertools.combinations(sorted(order), course_size)          most_ordered = collections.Counter(order_combinations).most_common()         result += [ k for k, v in most_ordered if v &gt; 1 and v == most_ordered[0][1] ]      return [ ''.join(v) for v in sorted(result) ]   1 solution([\"XYZ\", \"XWY\", \"WXA\"], [2, 3, 4])   1 ['WX', 'XY']   이 코드는 Counter()와 most_common() 메서드를 통해서 더 간단하게 풀었다.  두 메서드다 사용해본 적이 있는 메서드인데, 까먹어서 사용을 못했다. 파이썬 딕셔너리 사용하는 문제를 좀 더 많이 풀어봐야겠다.   Counter() 메서드는 리스트 요소의 개수를 세어 딕셔너리로 반환해주는 메서드이고, Counter().most_common()은 이렇게 반환한 딕셔너리를 개수가 많은 요소순으로 정렬하여 튜플리스트 값으로 반환해주는 메서드이다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC/",
        "teaser": null
      },{
        "title": "[Programmers] 후보키 (Python3)",
        "excerpt":"문제  프렌즈대학교 컴퓨터공학과 조교인 제이지는 네오 학과장님의 지시로, 학생들의 인적사항을 정리하는 업무를 담당하게 되었다.       그의 학부 시절 프로그래밍 경험을 되살려, 모든 인적사항을 데이터베이스에 넣기로 하였고, 이를 위해 정리를 하던 중에 후보키(Candidate Key)에 대한 고민이 필요하게 되었다.  후보키에 대한 내용이 잘 기억나지 않던 제이지는, 정확한 내용을 파악하기 위해 데이터베이스 관련 서적을 확인하여 아래와 같은 내용을 확인하였다.      관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.   유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.   최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.     제이지를 위해, 아래와 같은 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.                  학번       이름       전공       학년                       100       ryan       music       2                 200       apeach       math       2                 300       tube       computer       3                 400       con       computer       1                 500       muzi       music       3                 600       apeach       music       2           위의 예를 설명하면, 학생의 인적사항 릴레이션에서 모든 학생은 각자 유일한 “학번”을 가지고 있다. 따라서 “학번”은 릴레이션의 후보 키가 될 수 있다.       그다음 “이름”에 대해서는 같은 이름(“apeach”)을 사용하는 학생이 있기 때문에, “이름”은 후보 키가 될 수 없다. 그러나, 만약 [“이름”, “전공”]을 함께 사용한다면 릴레이션의 모든 튜플을 유일하게 식별 가능하므로 후보 키가 될 수 있게 된다.     물론 [“이름”, “전공”, “학년”]을 함께 사용해도 릴레이션의 모든 튜플을 유일하게 식별할 수 있지만, 최소성을 만족하지 못하기 때문에 후보 키가 될 수 없다.     따라서, 위의 학생 인적사항의 후보키는 “학번”, [“이름”, “전공”] 두 개가 된다.  릴레이션을 나타내는 문자열 배열 relation이 매개변수로 주어질 때, 이 릴레이션에서 후보 키의 개수를 return 하도록 solution 함수를 완성하라.  제한사항     relation은 2차원 문자열 배열이다.   relation의 컬럼(column)의 길이는 1 이상 8 이하이며, 각각의 컬럼은 릴레이션의 속성을 나타낸다.   relation의 로우(row)의 길이는 1 이상 20 이하이며, 각각의 로우는 릴레이션의 튜플을 나타낸다.   relation의 모든 문자열의 길이는 1 이상 8 이하이며, 알파벳 소문자와 숫자로만 이루어져 있다.   relation의 모든 튜플은 유일하게 식별 가능하다.(즉, 중복되는 튜플은 없다.)   입출력 예  |relation|\tresult|  |:—:|:—:|  |[[“100”,”ryan”,”music”,”2”],[“200”,”apeach”,”math”,”2”],[“300”,”tube”,”computer”,”3”],[“400”,”con”,”computer”,”4”],[“500”,”muzi”,”music”,”3”],[“600”,”apeach”,”music”,”2”]]|\t2|   입출력 예 설명  입출력 예 #1  문제에 주어진 릴레이션과 같으며, 후보 키는 2개이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from collections import defaultdict from itertools import combinations  def solution(relation):     N = len(relation[0])     key_idx = list(range(N))     candidate_key = []          for i in range(1,N+1):         for comb in combinations(key_idx,i):             hist = []             for rel in relation:                 current_key = [rel[c] for c in comb]                 if current_key in hist:                     break                 else:                     hist.append(current_key)             else:                 for ck in candidate_key:                     if set(ck).issubset(set(comb)):                         break                 else:                     candidate_key.append(comb)             return len(candidate_key)    1 solution([[\"100\",\"ryan\",\"music\",\"2\"],[\"200\",\"apeach\",\"math\",\"2\"],[\"300\",\"tube\",\"computer\",\"3\"],[\"400\",\"con\",\"computer\",\"4\"],[\"500\",\"muzi\",\"music\",\"3\"],[\"600\",\"apeach\",\"music\",\"2\"]])   1 2   노트  이 문제는 집합형 자료형 set에 대해 알아야 효율적으로 풀이가 가능한 문제다. 사실 중복을 처리할때 뺴고는 set 자료형의 교집합이나 합집합 기능을 사용할일 이 적은데, 미리 알아두면 다른 문제를 풀때도 응용이 가능할 것 같아 정리해두려 한다.   set 자료형  set 자료형은 집합에 관련된 것을 처리 하기 위해 만들어진 자료형으로 set 키워드를 사용하거나 중괄호를 이용하여 표현 할 수 있다. 선언 방식은 아래와 같다.   1 2 3 s1 = set({1,2,3}) s2 = set([1,2,3]) s3 = {1,2,3}   세 방법 모두 같은 집합을 만들며 빈 집합을 선언하기 위해서는 아래와 같이 사용한다.   1 s4 = set()   집합의 특징은 다음과 같다.     set() 키워드 혹은 중괄호를 이용한다.   순서가 없다   고유한 값을 가진다.   mutable(=값이 변하는) 객체이다.   순서가 없기 때문에 리스트나 튜플에서 사용했던 인덱싱은 불가능하다.   교집합   1 2 3 4 5 6 7 8 s1 = set([1,2,3,4,5]) s2 = set([4,5,6,7,8])  #교집합 메서드 print(s1.intersection(s2))  #교집합 연산자 print(s1 &amp; s2)   1 2 {4, 5} {4, 5}   위의 두 메서드와 연산자 모두 교집합을 구할 수 있도록 한다.   합집합   1 2 3 4 5 6 7 8 s1 = set([1,2,3,4,5]) s2 = set([4,5,6,7,8])  #합집합 메서드 union print(s1.union(s2))  #합집합 연산자 | print(s1 | s2)   1 2 {1, 2, 3, 4, 5, 6, 7, 8} {1, 2, 3, 4, 5, 6, 7, 8}                  합집합은 union 메서드나       연산자를 이용하여 구할 수 있다.           차집합   1 2 3 4 5 6 7 8 9 10 11 s1 = set([1,2,3,4,5]) s2 = set([4,5,6,7,8])  #차집합 메서드 difference print(s1.difference(s2)) print(s2.difference(s1))  #차집합 연산자 - print(s1 - s2) print(s2 - s1)    1 2 3 4 {1, 2, 3} {8, 6, 7} {1, 2, 3} {8, 6, 7}   순서가 상관이 없는 교집합, 합집합과는 다르게 차집합은 순서가 상관이 있다.     차집합을 구할떄는 difference 메서드를 이용하거나 - 연산자를 이용하여 구할 수 있다.   집합이 아예 다른지를 확인하는 경우   1 2 3 4 5 6 s1 = {1,2,3,4} s2 = {5,6,7,8} s3 = (1,5,6,7)  print(s1.isdisjoint(s2)) print(s1.isdisjoint(s3))   1 2 True False   isdisjoint 메서드는 두 집합의 요소가 한개도 동일하지 않은지를 확인하는 메서드이다. 만약 요소가 한개라도 같다면 False를 출력하고, 요소가 모두 다를 경우 True를 출력한다.   집합이 부분집합인지를 확인하는 경우   1 2 3 4 5 6 s1 = {1,2,3,4} s2 = {1,2}  print(s1.issubset(s2)) print(s2.issubset(s1))    1 2 False True   해당 집합이 메서드 배개변수의 집합의 부분집합인지를 판별하여 bool 자료형으로 출력해준다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%ED%9B%84%EB%B3%B4%ED%82%A4-(Python3)/",
        "teaser": null
      },{
        "title": "[Java] 다운 캐스팅과 instanceof",
        "excerpt":"하위 클래스로 형 변환, 다운캐스팅  앞에서 상위 클래스로 형 변환이 묵시적으로 이루어지는 과정을 알아보왔다. 여기서는 다시 하위 클래스로 형 변환이 되는 과정을 살펴보자.   Animal 이라는 클래스가 있고, 하위 클래스로  Human, Tiger, Eagle 세가지 클래스가 있다면     우리는 상위클래스를 자료형으로 선언하는 Animal ani = new Human(); 코드를 사용할 수 있다.  이때 생성된 인스턴스 Human은 Ainimal 형이다. 이렇게 Animal형으로 형 변환이 이루어진 경우에는 Animal 클래스에서 선언한 메서드와 멤버변수만 사용할 수 있다. 따라서 Human 클래스에 더 많은 메서드가 구현되어 있고 다양한 멤버 변수가 있다고 하더라도 자료형이 Animal 이라면 사용할 수가 없을 것 이다. 따라서 다시 원래의 인스턴스 자료형으로 되돌아가야 하는 경우가 있다. 이렇게 상위클래스로 형 변환된 하위 클래스를 원래 자료형으로 형 변환하는 것을 다운캐스팅(down casting) 이라고 한다.   instanceof  상속관계를 생각해보면 모든 인간은 동물이지만, 모든 동물이 인간은 아니다. 따라서 다운캐스팅을 하기 전에 상위 클래스로 형 변환된 인스턴스의 원래 자료형을 확인해야 변환할 때 오류를 막을 수 있다. 이를 확인하는 예약어가 바로 instanceof 인데, instanceof의 사용 방법은 다음과 같다.  1 2 3 4 Animal hAnimal = new Human(); if(hAnimal instanceof Human){     Human human = (Human)hAnimal }  위에서 사용한 hAnimal은 원래 Human형으로 생성되었는데, Animal형으로 형 변환된다. instanceof 예약어는 왼쪽에 있는 변수의 원래 인스턴스형이 오른쪽 클래스 자료형인가를 확인한다. 코드를 보면 hAnimal이 Animal 형으로 되어있지만, 원래는 Human형으로 생성된 인스턴스인지 확인하는 것이다. instanceof의 반환값이 true이면 다운 캐스팅을 하는데, 이때는 Human human = (Human)hAnimal; 문장과 같이 명시적으로 자료형을 써주어야 한다.  상위 클래스 형변환은 묵시적으로 가능하지만, 하위클래스로 형변환은 명시적으로 해야하기 때문이다.   다음처럼 원래 자료형이 Human이 아닌 경우를 보자.  1 2 Animal ani = new Tiger(); Human h = (Human)ani;  위와 같이 코딩해도 컴파일 오류는 나지 않는다. 왜일까? 일단 Tiger 인스턴스는 상위클래스로의 형 변환이기 때문에 자동으로 형 변환이 된다. 변수 h의 자료형 Human과 강제 형 변환되는 ani(Human)의 자료형이 동일하므로 컴파일 오류는 일어나지 않는다. 그 대신 이 코드를 실행하면 오류가 발생한다.   따라서 참조 변수의 원래 인스턴스형을 정확히 확인하고 다운 캐스팅을 해야 안전하며, 이때 instanceof를 사용하는 것이다. 그럼 원래 인스턴스 형으로 가운 캐스팅하는 예를 살펴보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package downcasting; import java.util.ArrayList;  class Animal {     public void move(){         System.out.println(\"동물이 움직입니다.\");     }  }  class Human extends Animal{     @Override     public void move() {     System.out.println(\"사람이 걷습니다.\");     }     public void readBook(){         System.out.println(\"사람이 책을 읽습니다.\");     } }  class Tiger extends Animal{     @Override     public void move(){         System.out.println(\"호랑이가 네발로 깁니다.\");     }     public void hunting(){         System.out.println(\"호랑이가 사냥을 합니다.\");     } }  class Eagle extends Animal{     @Override     public void move(){         System.out.println(\"독수리가 날아갑니다..\");     }     public void flying(){         System.out.println(\"독수리가 멀리 납니다.\");     } }  public class AnimalTest {     ArrayList&lt;Animal&gt; aniList = new ArrayList&lt;Animal&gt;();      public static void main(String[] args){         AnimalTest aTest = new AnimalTest();         aTest.addAnimal();         System.out.println(\"===다운 캐스팅===\");         aTest.testCasting();     }     public void addAnimal(){         aniList.add(new Human());         aniList.add(new Tiger());         aniList.add(new Eagle());          for(Animal ani : aniList){             ani.move();         }     }     public void testCasting(){         for(int i = 0; i &lt; aniList.size();i++){             Animal ani = aniList.get(i);             if(ani instanceof Human){                 Human h = (Human)ani;                 h.readBook();              }             else if(ani instanceof Tiger){                 Tiger t = (Tiger) ani;                 t.hunting();             }             else if(ani instanceof Eagle){                 Eagle e = (Eagle) ani;                 e.flying();             }             else{                 System.out.println(\"지원되지 않는 자료형입니다.\");             }         }      } }   &gt;&gt;&gt; 사람이 걷습니다. &gt;&gt;&gt; 호랑이가 네발로 깁니다. &gt;&gt;&gt; 독수리가 날아갑니다.. &gt;&gt;&gt; ===다운 캐스팅=== &gt;&gt;&gt; 사람이 책을 읽습니다. &gt;&gt;&gt; 호랑이가 사냥을 합니다. &gt;&gt;&gt; 독수리가 멀리 납니다.   위의 코드를 보면 각 동물 클래스를 인스턴스로 생성하여 Animal 형으로 선언한 배열에 추가한다. 이렇게 되면 배열에 추가되는 요소의 자료형은 모두 Animal 형으로 변환되는데, 이때 호출할 수 있는 메서드는 Animal 클래스에 선언된 메서드 뿐이다. 이렇게 선언된 배열에서 요소를 하나씩 꺼내 move() 메서드를 호출 하면 제정의한 메서드가 호출된다.  하지만 배열요소가 Animal 형이므로, 각각에 있는 메서드인 readBook(), hunting(), flying() 메서드는 사용할 수 없기 때문에, for 문을 사용하여 각각을 if문으로 다운캐스팅 해주어야만 각각의 메서드를 실행 시킬 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85%EA%B3%BC-instanceof/",
        "teaser": null
      },{
        "title": "[Java] 추상 클래스",
        "excerpt":"추상클래스란?  ‘추상적이다’라는 말의 뜻을 생각해 보자. 추상적이라는 것은 구체적이지 않고 막연한 것을 뜻한다.  그렇다면 어떤 클래스가 추상적이다 라는 말은 무슨 뜻일까? 앞의 용어풀이를 대입해 보면 ‘구체적이지 않은 클래스’ 라는 뜻일 것이다. 추상 클래스를 영어로 하면 abstract class이고, 추상 클래스가 아닌 클래스는 concrete class 라고 한다. 우리가 지금까지 만든 클래스는 모두 concrete class이다. 추상 클래스 활용방법을 살펴보기 전에 추상 클래스 문법부터 배워보자.   추상 클래스는 항상 추상메서드 를 포함한다. 추상메서드는 구현코드가 없다. 함수의 구현 코드가 없다는 것은 함수 몸체가 없다는 뜻이다.  1 2 3 int add(int x, int y){     return x + y; }  중괄호 {}로 감싼 부분을 함수의 구현부(implementation)라고 하며, 이 부분이 없는 함수는 추상 함수(abstract function)이고 자바에서는 추상 메서드(abstract method) 라고 한다. 추상메서드는 다음과 같이 선언만 하며 abstract 예약어를 사용한다. 또한 {}대신 ;를 사용한다.  1 abstract int add(int x int y)  참고로 아래와 같은 메서드는 추상 메서드가 아니다.  중괄호를 사용한 것 만으로 메서드를 구현한 셈이기 때문이다.  1 int add(int x, int y){}  정리하자면, 자바에서 추상 메서드는 abstract 예약어를 사용하여 선언만 하는 메서드이다.   이러한 추상 클래스를 이해하려면 먼저 메서드 선언의 의미에 대해서 생각해보아야한다.     아래의 코드를 보자.  1 int add(int num1, int num2);  위 코드처럼 선언한 메서드를 보면 두 개의 정수를 입력받은 후 더해서 그 결과 값을 반환한다는 것을 유추할 수 있다. 즉 이 메서드의 선언부(declaration)만 봐도 어떤일을 하는 메서드인지 알수 있는 것이다. 함수의 선언부 즉 반환 값, 함수 이름, 매개변수를 정의 한다는것은 곧 함수의 역할이 무엇인지, 어떻게 구현해야 하는지를 정의한다는 뜻이다. 우리가 자바에서 사용하는 메서드 역시 마찬가지이다. 메서드를 선언한다는 것은 해야 할 일을 명시해 두는 것이다.   추상클래스 구현하기  아래의 코드를 보고, 추상클래스에 대해 알아보자  1 2 3 4 5 6 7 8 9 10 11 12 package abstractex;  public class Computer {     public void display();     public void typing();     public void turnOn(){         System.out.println(\"전원을 켭니다\");     }     public void turnOff(){         System.out.println(\"전원을 끕니다.\");     } }  컴퓨터라는 클래스를 만들어주고 display와 typing, turnOn,turnOff 메서드를 선언해주었는데, 함수구현부를 써주지않은 display와 typing에서는 오류가 발생하고 있다. 이 부분이 오류가 나지 않으려면 몸체 부분을 작성하거나, 이 메서드를 추상 메서드로 선언해주어야 한다. 그럼 display와 typing 앞에 abstract 예약어를 사용해보자.  1 2 3 4 5 6 7 8 9 10 11 12 package abstractex;  public class Computer {     public abstract void display();     public abstract void typing();     public void turnOn(){         System.out.println(\"전원을 켭니다\");     }     public void turnOff(){         System.out.println(\"전원을 끕니다.\");     } }  그러면 이제 오류가 없어졌지만, 이제는 class Computer에 오류가 뜬다. 왜냐하면 추상 메서드가 속한 클래스를 추상 클래스로 선언하지 않았기 때문이다. 그러니 이번에는 Computer 클래스를 추상 클래스로 바꿔서 선언해보자.  1 2 3 4 5 6 7 8 9 10 11 12 package abstractex;  public abstract class Computer {     public abstract void display();     public abstract void typing();     public void turnOn(){         System.out.println(\"전원을 켭니다\");     }     public void turnOff(){         System.out.println(\"전원을 끕니다.\");     } }  이제 모든 오류가 제거되었다. Computer 클래스에 이렇게 구현한 이유는   Computer를 상속받는 클래스를 이와 같이 구현한것은 ‘Computer를 상속받는 클래스 중 turnOn과 turnOff( ) 구현 코드는 공통이다. 하지만 display()와 typing()은 하위 클래스에 따라 구현이 달라질 수 있다. 그래서 Computer에서는 구현하지 않고, 이 두 메서드 구현에 대한 책임을 상속받는 클래스에 위임한다’ 라는 의미이다.   따라서 Computer 클래스의 추상 메서드는 추상 클래스를 상속받은 DeskTop과 NoteBook에서 실제로 구현하게 된다. 이 클래스의 상위 클래스에서는 하위 클래스도 공통으로 사용할 메서드를 구현하고, 하위 클래스마다 다르게 구현할 메서드는 추상 메서드로 선언해 두는 것이다.   그러면 DeskTop 클래스를 만들어보자. 다음과 같이 DeskTop 클래스를 선언하고 Computer 클래스를 상속받는다.  1 2 3 4 package abstractex;  public class DeskTop extends Computer{ }  이렇게 Computer를 상속한 DeskTop을 만들어주면 오류가 발생한다.   추상 클래스를 상속했으므로, 위에서 추상메서드로 선언했던 display() 와 typing() 메서드의 몸체 부분을 상속받은 클래스에서 구현해주던가, 상속한 DeskTop도 추상 클래스로 선언해주던가 둘중에 하나를 해주어야 오류가 발생하지 않는다. display()와 typing() 메서드의 몸체 부분을 작성해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 package abstractex;  public class DeskTop extends Computer{      @Override     public void display() {         System.out.println(\"DeskTop display()\");     }      @Override     public void typing() {         System.out.println(\"Desktop typing()\");     } }  마찬가지로 NoteBook 클래스도 구현한다.  1 2 3 4 5 6 7 8 9 10 11 package abstractex;  public abstract class NoteBook extends Computer {       @Override     public void display() {         System.out.println(\"Notebook display\");     }  }  NoteBook 클래스는 추상 클래스로 선언해주기 위해 abstract 예약어를 사용했다.  그럼 NoteBook 클래스를 또 상속하는 MyNoteBook 클래스를 만들어보자.  1 2 3 4 5 6 7 8 package abstractex;  public class MyNoteBook extends NoteBook{     @Override     public void typing(){         System.out.println(\"MyNoteBook typing()\");     } }  이렇게 하면, 가장 상위클래스이자 추상클래스인 Computer에서 추상 메서드인 display와 typing이 선언되고, 그 아래의 DeskTop 클래스는 두가지 메서드를 모두 재정의 하여 추상클래스가 아닌 클래스가 되었고, NoteBook은 display 하나만 재정의 함으로써 추상클래스로 선언된걸 확인 할 수 있다. 마지막으로 MyNoteBook은 NoteBook을 상속받은 뒤, NoteBook에서 선언하지 않은 typing을 재정의 해줌으로써 구체적 클래스가 된다.   추상 클래스를 만드는 이유  추상 클래스를 어떻게 정의하고 구현하는지를 이야기 했다. 그렇다면 이런 추상 클래스는 어디에 사용하기 위해 사용하는 것일까? 앞서 만든 추상클래스를 사용하여 알아보자.  1 2 3 4 5 6 7 8 9 10 package abstractex;  public class ComputerTest {     public static void main(String[] args){         Computer c1 = new Computer();         Computer c2 = new DeskTop();         Computer c3 = new NoteBook();         Computer c4 = new MyNoteBook();     } }  ComputerTest 클래스를 만들어 메인함수를 통해 인스턴스를 각각의 자료형으로 4개 선언해주었다.      추상 클래스인 Computer 와 NoteBook이 오류가 나는것을 확인 할 수 있다.   이러한 오류가 발생하는 이유는 바로 추상클래스는 인스턴스로 생성 할 수 없기 떄문이다.   추상 클래스는 상속을 하기 위해 만든 클래스로, 하위클래스에서 각각 다르게 구현해야 할 메서드가 있다면, 구현 내용 제목만 상위클래스에 남겨두고 이러한 내용을 하위클래스에서 재정의하여 사용하도록 한 것이 바로 추상 클래스이다.   추상클래스는 이러한 특징때문에 많은 프레임워크에서 사용되고 있는 구현방식인데, 앱마다 어떻게 만드는지에 따라 다르게 구현해야할 클래스인 경우, 이런식으로 추상클래스로 선언하여 사용하게되는 것이다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Programmers] 거리두기 확인하기 (Python3)",
        "excerpt":"문제  개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다.  코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데,   개발 직군 면접인 만큼      아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다.          대기실은 5개이며, 각 대기실은 5x5 크기입니다.     거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요.     단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.      응시자가 앉아있는 자리(P)를 의미합니다.\t빈 테이블(O)을 의미합니다.\t파티션(X)을 의미합니다.   예를들어,   PXP     위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다.   PX     XP     위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다.   PX     OP     위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다.   5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.   제한사항     places의 행 길이(대기실 개수) = 5   places의 각 행은 하나의 대기실 구조를 나타냅니다.   places의 열 길이(대기실 세로 길이) = 5   places의 원소는 P,O,X로 이루어진 문자열입니다.   places 원소의 길이(대기실 가로 길이) = 5   P는 응시자가 앉아있는 자리를 의미합니다.   O는 빈 테이블을 의미합니다.   X는 파티션을 의미합니다.   입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다.   return 값 형식   1차원 정수 배열에 5개의 원소를 담아서 return 합니다.   places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다.   각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다.   입출력 예  |places|\tresult|  |:—:|:—:|  |[[“POOOP”, “OXXOX”, “OPXPX”, “OOXOX”, “POXXP”], [“POOPX”, “OXPXP”, “PXXXO”, “OXXXO”, “OOOPP”], [“PXOPX”, “OXOXP”, “OXPOX”, “OXXOP”, “PXPOX”], [“OOOXX”, “XOOOX”, “OOOXX”, “OXOOX”, “OOOOO”], [“PXPXP”, “XPXPX”, “PXPXP”, “XPXPX”, “PXPXP”]]|\t[1, 0, 1, 1, 1]|   문제풀이  이 문제는 bfs를 이용해서 푸는 문제인데, 뭔가 너무 복잡하게 생각해서 오래 걸린 문제였다. 거리두기 문제가 아닌 바이러스를 퍼뜨리는 문제라고 생각하니, 쉽게 풀수 있었는데, p가 바이러스를 놓는위치라고 생각하고 거리가 2보다 커지거나, 파티션을 만나면 바이러스가 더 이상 못퍼진다고 생각하면 동일한 결과로 문제를 풀 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from collections import deque  def solution(places):     def bfs(x,y):         dx = [-1,1,0,0]         dy = [0,0,-1,1]         q = deque()             q.append([x,y])         while q:             nx,ny = q.popleft()             if visited[nx][ny] == 0:                 visited[nx][ny] +=1             for i in range(4):                 sx = nx+dx[i]                 sy = ny+dy[i]                 if 0 &lt;= sx &lt; 5 and 0 &lt;= sy &lt; 5 and visited[sx][sy] ==0:                     if room[sx][sy] ==  'X':                         continue                     if room[sx][sy] == 'P':                         visited[sx][sy] = 1                         distance.append(visited[nx][ny])                         q.append([sx,sy])                     else:                         visited[sx][sy] = visited[nx][ny] + 1                         q.append([sx,sy])         return visited     answer = []     for place in places:                  room = []         for pl in place:             room.append(list(pl))              distance = []                            visited = [[0 for i in range(5)]for i in range(5)]         for i in range(5):             for j in range(5):                 if room[i][j] == \"P\":                     bfs(i,j)         #print(visited)                  if 1 in distance or 2 in distance:             answer.append(0)         else:             answer.append(1)                                                    return answer   1 solution([[\"POOOP\", \"OXXOX\", \"OPXPX\", \"OOXOX\", \"POXXP\"], [\"POOPX\", \"OXPXP\", \"PXXXO\", \"OXXXO\", \"OOOPP\"], [\"PXOPX\", \"OXOXP\", \"OXPOX\", \"OXXOP\", \"PXPOX\"], [\"OOOXX\", \"XOOOX\", \"OOOXX\", \"OXOOX\", \"OOOOO\"], [\"PXPXP\", \"XPXPX\", \"PXPXP\", \"XPXPX\", \"PXPXP\"]])   1 [1, 0, 1, 1, 1]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Java] 인터페이스",
        "excerpt":"인터페이스란?  **인터페이스(Interface)는 클래스 혹은 프로그램이 제공하는 기능을 명시적으로 선언하는 역할을 한다. 인터페이스는 추상 메서드와 상수로만 이루어져 있다. 구현된 코드가 없기 때문에 당연히 인터페이스로는 인스턴스도 생성 할 수 없다. 그렇다면 구현코드도 없는 인터페이스는 어떻게 사용하는 걸까? 인터페이스를 직접 만들어 보면서 살펴보자.   인터페이스를 사용해 간단한 계산기 프로그램을 만들어보자.  내가 사용하고 있는 책에서는 이클립스를 사용하고 있는데, 패키지에서 오른쪽 버튼 클릭 후 New -&gt; Interface를 클릭하면된다. 나는 IntelliJ를 사용하고 있기 때문에 방법이 다른데, 클래스를 추가하면 클래스 이름을 설정하라고 나올때, 형식을 클래스가 아닌 Interface로 설정하면 된다.  1 2 3 4 package interfaceex;  public interface Calc { }  이렇게 하면 인터페이스를 사용할 준비가 끝났다.   그럼 인터페이스의 구현부를 추상 클래스와 상수로 채워보자.  1 2 3 4 5 6 7 8 9 10 11 package interfaceex;  public interface Calc {     double PI = 3.14;     int ERROR = -99999999;          int add(int num1,int num2);     int substract(int num1, int num2);     int times(int num1, int num2);     int divide(int num1,int num2); }  인터페이스의 메서드와 멤버변수는 추상메서드와 상수로만 이루어져야 한다고 했다. 근데 위 인터페이스는 파이와 에러가 변수로 선언되어있으며 메서드도 추상메서드로 선언하는 예약어인 abstract로 선언하지 않았다.   인터페이스의 메서드와 변수는 예약어를 명시하지않아도 컴파일 과정에서 자동으로 추상메서드로 변환되고, 변수는 상수가 된다. 따라서 public abstract나 public static final 예약어를 선언하지 않아도 된다.   클래스에서 인터페이스 구현하기  그럼 이제 선언한 인터페이스를 클래스에서 사용해보자. 상속을 할때는 기능을 확장한다는 의미로 extends를 썼었다. 인터페이스에서는 인터페이스에서 선언한 기능을 클래스가 구현한다는 의미로 implements 예약어를 사용한다. calc 인터페이스를 Calculator에서 구현하는 방법은 다음과 같다.  1 2 3 4 package interfaceex;  public class Calculator implements Calc{ }  이렇게 implements로 선언해주면 추상 메서드 4개를 포함하는 Calculator 클래스가 선언된다. 이 추상메서드 4개를 구현하지 않으면, Calcultor 클래스도 추상클래스가 된다. 그럼 추상메서드의 개념까지 한번 더 생각해 볼겸, add()와 substract() 메서드만 구현한 추상메서드로 한번 더 추상클래스를 선언해보고, CompleteCalc에서 모든 기능을 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 package interfaceex;  public abstract class Calculator implements Calc{     @Override     public int add(int num1, int num2) {         return num1 + num2;     }      @Override     public int substract(int num1, int num2) {         return num1 - num2;     } }  2개의 메서드만 구현했으므로 이 클래스 또한 추상 클래스이다. 따라서 abstract 예약어를 사용해서 선언한다.   그럼 이제 모든 메서드를 구현한 클래스를 만들어보자. 위에서 만든 추상클래스 Calculator를 상속받아 CompleteCalc에 아직 구현되지 않은 times()와 divide() 추상 메서드를 이 클래스에 구현해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package interfaceex;  public class CompleteCalc extends Calculator{       @Override     public int times(int num1, int num2) {         return num1 * num2;     }      @Override     public int divide(int num1, int num2) {         if(num2 != 0)             return num1 / num2;         else             return Calc.ERROR;     }        public void showInfo(){         System.out.println(\"Calc 인터페이스 구현 완료\");     } }   이제 이렇게 만든 클래스를 Test 파일에서 메인함수를 만들어 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package interfaceex;  public class Test {     public static void main(String[] args){         int num1 = 10;         int num2 = 5;                  CompleteCalc cal = new CompleteCalc();         System.out.println(cal.add(num1,num2));         System.out.println(cal.substract(num1,num2));         System.out.println(cal.divide(num1,num2));         System.out.println(cal.times(num1,num2));         cal.showInfo();     } }   &gt;&gt;&gt; 15 &gt;&gt;&gt; 5 &gt;&gt;&gt; 2 &gt;&gt;&gt; 50 &gt;&gt;&gt; Calc 인터페이스 구현 완료  덧셈, 뺄셈, 나눗셈, 곱셈 연산을 실행하고 그 값을 출력해보았다. 이처럼 인터페이스는 선언부를 모아놓았기 때문에, 해당 메서드의 구현부를 재정의하여 사용 할 수 있게 해준다.   인터페이스 구현과 형 변환  Calculator 클래스는 인터페이스에서 선언한 추상 메서드 중 일부 메서드만 구현했으므로 추상 클래스이다.  그리고 이를 상속받은 CompleteCalc 클래스는 Calc에서 구현하지 않은 나머지 추상 메서드를 모두 구현하고 showInfo() 메서드를 추가로 구현했다. 이러한 관계에서 하위 클래스의 형 변환은 어떻게 이루어지는지 알아보자.   상속관계에서는 하위클래스는 상위클래스로 묵시적 형변환이 언제든 가능하다고 했다. 인터페이스도 마찬가지로 CompleteCalc 클래스는 상위클래스인 Calculator 형이면서 Calc형이다. 따라서 다음과 같은 코드 선언이 가능하다.  1 Calc calc = new CompleteCalc();  이렇게 하면 calc 변수에 대입한 newCalc는 인터페이스에서 선언한 메서드만 사용할 수 있고, CompleteCalc 에서 구현한 showInfo() 메서드는 사용할 수 없다. 이것이 바로 인터페이스의 중요한 역할이다.   인터페이스의 역할  지금까지 인터페이스를 정의하고 클래스에서 구현해보았는데, 그러면 이러한 인스턴스는 어디에 쓰는 코드일까?   인터페이스는 클라이언트 프로그램에 어떤 메서드를 제공하는지 미리 알려주는 명제 또는 약속의 역할로, 만약 Abc 클래스를 구현한 A클래스가 있다고 가정하자. 이 클래스를 사용하는 Z라는 프로그램이 있다면, Abc인터페이스에는 구현해야할 추상메서드가 모두 선언되어있고, 어떤 매개변수가 사용되는지, 어떤 자료형 값이 반환되는지 선언되어 있을 것이다. 즉 Z프로그램에서는 A클래스의 구현부를 살펴보지 않고 Abc 인터페이스의 선언 부분만 보고도 A클래스의 사용방법을 알게되는 것이다.   만약 Z프로그램에서 Abc 인터페이스를 구현한 다른 클래스 B를 사용하고 싶다면, 인터페이스 명을 B클래스로 교체하여 사용가능하다.  1 2 3 4 Abc abc; abc = new A(); abc = new B(); abc = new C();  이렇게 Z프로그램에서 각 클래스를 사용하려고 할 떄, 클래스에서 구현한 내용을 몰라도 Abc 인터페이스에서 선언한 메서드의 매개변수 자료형과 반환값을 알면 인터페이스를 구현한 어떤 클래스든 사용가능하다.   인터페이스와 다형성  인터페이스를 사용하면 다형성을 구현하여 확장성 있는 프로그램을 만들 수 있다.     즉, 클라이언트 프로그램을 많이 수정하지 않고 기능을 추가하고 다른 기능을 사용할 수 있게된다.   다음 예제를 보자.   고객센터에는 전화 상담을 하는 상담원이 있다. 고객센터로 전화가 오면 대기열에 저장되고, 상담원이 지정되기 전까지 대기 상태가 된다. 전화를 상담원에게 분배하는 방법은 세가지가 있는데,      순서대로 배분하기: 모든 상담원에게 순서대로 전화를 준다.   짧은 대디열 찾아 헤메기 : 가장 적은 대기명을 보유하지않은 상담원에게 전화를 준다.   우선순위에 따라 배분하기 : 고객 등급에 따라 등급이 높을 수록 업무능력이 높은 상담원에게 우선 배분한다.   이 전화를 배분하기 위해 Scheduler 인터페이스를 만들어보자.  1 2 3 4 5 6 package interfaceex;  public interface Scheduler {     public void getNextCall();     public void sendCallToAgent(); }  그럼 순서대로 배분하는 경우 부터 인터페이스의 구현부를 채워보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 package interfaceex;  public class RoundRobin implements Scheduler {     @Override     public void getNextCall(){         System.out.println(\"전화를 순서대로 대기열에서 가져온다.\");     }      @Override     public void sendCall() {         System.out.println(\"다음 순서 상담원에게 배분\");     }  }  먼저 순서대로 배정하는 경우 (RoundRobin)를 구현해보았다.  마찬가지로implements를 사용하여 Scheduler 인터페이스를 기반으로 클래스를 선언헀다.   다음은 짧은 대기열 먼저 분배하는 LeastJob 클래스, 우선순위에 따라 배분하는 PriorityAllocation 클래스를 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package interfaceex;  public class LeastJob implements Scheduler{      @Override     public void getNextCall() {         System.out.println(\"상담 전화를 순서대로 대기열에서 가져옵니다.\");     }      @Override     public void sendCall() {         System.out.println(\"대기가 적은 순으로 상담원에게 할당합니다.\");      } }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package interfaceex;  public class PriorityAllocation implements Scheduler{      @Override     public void getNextCall() {         System.out.println(\"고객등급이 높은 순서대로 대기열에서 가져온다.\");     }      @Override     public void sendCall() {         System.out.println(\"업무 역량이 높은 상담원 우선 배정한다.\");      } }  이제 해당 클래스들을 main 함수에서 구동해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package interfaceex;  import java.io.IOException;  public class SchedulerTest {     public static void main(String[] args)throws IOException {         System.out.println(\"전화 상담 할당 방식을 선택하세요\");         System.out.println(\"R : 한명씩 차례로 할당\");         System.out.println(\"L : 대기가 적은 상담원에게 할당\");         System.out.println(\"P : 우선순위가 높은 고객 먼저 할당\");          int ch = System.in.read();         Scheduler scheduler = null;          if(ch == 'R' || ch == 'r'){             scheduler = new RoundRobin();         }         else if(ch == 'L' || ch == 'l'){             scheduler = new LeastJob();         }         else if(ch == 'P' || ch == 'p'){             scheduler = new PriorityAllocation();         }         else{             System.out.println(\"지원하지 않는 기능입니다.\");             return;         }         scheduler.getNextCall();         scheduler.sendCall();     } }   위 함수를 실행하면, 입력받은 전화 할당 방식에 따라서 각 기능에 따른 메서드가 실행된다.   만약 새로운 정책을 추가해야 한다면, 앞에서와 마찬가지로 Scheduler 인터페이스를 구현하는 새 클래스로 만들면된다. 어떤 클래스를 구현하던간에 클라이언트가 인터페이스를 구현한 클래스를 사용하는 방식은 다음과 같다.  1 2 scheduler.getNextCall() scheduler.sendCall();  이렇게 클라이언트 프로그램은 각 클래스의 구현 방법을 몰라도 인터페이스에서 선언된 매개변수, 반환값을 보고 클래스를 사용할 수 있다.   인터페이스 상수  인터페이스는 추상 메서드로 이루어지므로 인스를 생성할 수 없으며 멤버 변수도 사용할 수 없다.  1 2 3 4 public interface Calc{     double PI = 3.14;     int ERROR = -9999999999; }  그런데, 위의 코드와 같이 변수를 선언해도 오류가 발생하지 않는다. 그 이유는 인터페이스에서 선언한 변수를 컴파일하면 상수로 변환 되기 떄문이다.   디폴트 메서드와 정적 메서드  원래 자바는 인터페이스를 구현한 여러 클래스에서 사용할 메서드가 클래스마다 같은 기능을 제공하는 경우에도 인터페이스에 메서드를 구현할 수 없기 때문에 클래스마다 똑같이 그 기능을 반복해 구현해야 했다. 하지만 자바 8부터는 인터페이스 활용성을 높이기 위해 디폴트 메서드와 정적 메서드를 지원한다.   정적 메서드는 인스턴스 생성과 관계없이 사용할 수 있는 메서드이다. 하지만 디폴트 메서드나 정적 메서드를 추가 했다고 해서 인터페이스가 인스턴스를 생성할 수 있는건 아니다. 그럼 인터페이스에 구현하는 디폴트 메서드와 정적 메서드가 무엇인지 살펴보자.   디폴트 메서드  디폹트 메서드란 말 그대로 기본으로 제공되는 메서드로, 인터페이스에서 구현하지만 이후 인터페이스를 구현한 클래스가 생성되면 그 클래스에서 사용할 기본 기능이다. 디폴트 메서드는 default를 사용해 선언한다.  1 2 3 4 5 6 7 public interface Calc {     ...          default void description(){         System.out.println(\"정수 계산기를 구한다.\");     } }  디폴트는 일반 메서드와 동일하게 구현하고 자료형 앞에 default만 붙여주면 된다.  그럼 디폴트 메서드를 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package interfaceex;  public class Test {     public static void main(String[] args){         int num1 = 10;         int num2 = 5;          CompleteCalc cal = new CompleteCalc();         System.out.println(cal.add(num1,num2));         System.out.println(cal.substract(num1,num2));         System.out.println(cal.divide(num1,num2));         System.out.println(cal.times(num1,num2));         cal.showInfo();         cal.description();     } }   다음과 같이 인스턴스 cal을 생성하면 디폴트 메서드를 호출 할 수 있다.      이러한 디폴트 메서드도 마찬가지로 하위클래스에서 기능을 다르게 구현하고 싶다면, 재정의가 가능하다.   정적 메서드  정적 메서드는 static 예약어를 사용하여 선언하며 클래스 생성과 무관하게 사용할 수 있다.     정적 메서드를 사용할 때는 인터페이스 이름으로 직접 참조하여 사용한다. 그러면 Calc 인터페이스에 매개변수로 전달된 배열의 모든 요소 값을 더하는 정적 메서드 total()을 추가해 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package interfaceex;  public interface Calc {     double PI = 3.14;     int ERROR = -9999999;       int add(int num1,int num2);     int substract(int num1, int num2);     int times(int num1, int num2);     int divide(int num1,int num2);      default void description(){         System.out.println(\"정수 계산기를 구한다.\");     }          static int total(int[] arr){         int total = 0;                  for(int i : arr){             total+=i;         }         return total     } }   위 처럼 static을 사용하여 정적 메서드인 total을 선언해보았다.      마찬가지로 main함수에서 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package interfaceex;  public class Test {     public static void main(String[] args){         int num1 = 10;         int num2 = 5;          CompleteCalc cal = new CompleteCalc();         System.out.println(cal.add(num1,num2));         System.out.println(cal.substract(num1,num2));         System.out.println(cal.divide(num1,num2));         System.out.println(cal.times(num1,num2));         cal.showInfo();         cal.description();          int[] arr = {1,2,3,4,5}         System.out.println(\"총합 :\"+ Calc.total(arr));     } }  마지막줄에 정적메서드인 total을 호출하였다. 특이한점은 인스턴스로 참조한게 아니라 직접 인터페이스 이름으로 정적메서드를 호출하였다.   private 메서드  자바 9부터는 인터페이스에 private 메서드를 구현할 수 있다. private 메서드는 인터페이스를 구현한 클래스에서 사용하거나 재정의할 수 없다. 따라서 기존에 구현된 코드를 변경하지 않고 인터페이스를 구현한 클래스에서 공통으로 사용하는 경우에 private 메서드로 구현하면 코드 재사용성을 높일 수 있다.   private 메서드는 코드를 모두 구현해야 하므로 추상 메서드에 private을 사용할 순 없지만, static은 함께 사용할 수 있다. 그럼 Calc인터페이스에 private와 private static을 구현하고 이를 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package interfaceex;  public interface Calc {     double PI = 3.14;     int ERROR = -9999999;       int add(int num1,int num2);     int substract(int num1, int num2);     int times(int num1, int num2);     int divide(int num1,int num2);      default void description(){         System.out.println(\"정수 계산기를 구한다.\");         myMethod();     }      static int total(int[] arr){         int total = 0;          for(int i : arr){             total+=i;         }         myStaticMethod();         return total;     }      private void myMethod() {         System.out.println(\"private 메서드입니다.\");     }     private static void myStaticMethod(){         System.out.println(\"private static 메서드 입니다.\");     } }   private와 static private로 선언한 메서드를 각각 디폴트 메서드와 정적메서드에서 호출시켜주면 올바르게 호출 된 것을 확인 할 수 있다.   인터페이스 활용하기  한 클래스가 여러 클래스를 상속받으면 메서드 호출이 모호해지는 문제가 발생하곤 한다. 하지만 인터페이스는 한 클래스가 여러 인터페이스를 구현할 수 있다. 만약 Customer 클래스가 추상 메서드 buy()와 sell() 두 인터페이스를 구현하고 있다고 하자.  1 2 3 public interface Buy{     void buy(); }  1 2 3 public interfce Sell{     void sell(); }  이렇게 선언해준 추상메서드 두개를 구현해보면,  1 2 3 4 5 6 7 8 9 public class Customer implemeent Buy,Sell{     @override     public void buy(){     System.out.println(\"구매하기)     }     public void sell(){     System.out.println(\"구매하기)     }    }  인터페이스는 구현 코드나 멤버 변수를 갖지 않기 떄문에 여러 개를 동시에 구현 가능하다. 두 인터페이스에 이름이 같은 메서드가 선언되어도 구현은 클래스에서 이루어지므로, 어떤 메서드를 호출해야 하는지 모호하지 않은것이다.   이제, 테스트 프로그램에서 두가지 인터페이스를 구현가능한 Customer를 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package interfaceex;  public class Test2 {     public static void main(String[] args){         Customer customer = new Customer();         Buy buyer = customer;         buyer.buy();          Sell seller = customer;         seller.sell();          if(seller instanceof Customer){             Customer customer2 = (Customer) seller;             customer2.buy();             customer2.sell();         }      } }  Customer 클래스형인 customer를 Buy 인터페이스 형인 buyer에 대입하여 형 변환한 뒤 buy()를 호출해주고, 다음은 customer를 Sell 인터페이스형은 seller에 대입하여 sell() 메서드를 호출 해보았다. 이처럼 우리가 구현한 Customer 클래스는 두가지를 다중 상속받은 것처럼 Buy와 Sell로 형변환이 가능한 것을 알 수 있다. 상속과 마찬가지로 instanceof로 하위클래스로의 형변환도 당연히 가능하다.   두 인터페이스의 디폴트 메서드가 중복되는 경우  정적 메서드는 인스턴스 생성과 상관없이 사용이 가능하다. 만약 Customer 클래스가 Buy,Sell 두 인터페이스를 구현하고   두 인터페이스에 pay()라는 정적메서드가 있다고 생각해보자. 이 경우 Buy.pay()와 Sell.pay()로 특정하여 호출할 수 있기 떄문에 문제가 되지 않는다. 그런데 디폴트 메서드는 어떻게 될까? 디폴트 메서드는 인스턴스를 생성해야 호출 가능한 메서드이기 때문에, 다음처럼 이름이같은 디폴트 메서드가 두 인터페이스에 있으면 문제가 된다.   다음 코드를 보자.  1 2 3 4 5 6 7 public interface Buy{     void buy();          default void order(){         System.out.println(\"구매 주문\");         } }  1 2 3 4 5 6 7 public interface Sell{     void buy();          default void order(){         System.out.println(\"판매 주문\");         } }  이렇게 정의 하고 두 인터페이스를 모두 구현하면 Customer 클래스에서는 오류가 발생한다.  두 디폴트 메서드가 중복되었으므로, Customer 클래스에서 재정의 해주어야 동일한 이름이어도 오류가 발생하지 않는다.  1 2 3 4 5 6 7 8 9 public class Customer implements Buy, Sell{          ...          @Overide     public void order(){         System.out.println(\"고객 판매 주문\") } }  위 와같이 재정의 해주면 오류가 발생하지않고, 재정의된 메서드가 호출된다.   인터페이스 상속  인터페이스 간에도 상속이 가능합니다. 인터페이스 간 상속을 구현 코드를 통해 기능을 상속하는 것이 아니므로 형 상속(type inheritance) 라고 부른다. 클래스의 경우에는 하나의 클래스만 상속받을 수 있지만, 인터페이스는 여러 개를 동시에 상속 받을 수 있다. 한 인터페이스가 여러 인터페이스를 상속받으면, 상속받은 인터페이스는 상위 인터페이스에 선언한 추상 메서드를 모두 가지게 된다.   만약 X와 Y라는 인터페이스를 선언해주고 이를 상속받는 인터페이스 MyInterface를 선언해준다면 이 인터페이스는 3개의 추상 메서드를 가진 인터페이스가 되는것이다. 따라서 MyInterface를 구현하려면 3개의 메서드를 구현해주어야 한다.   인터페이스 구현과 클래스 상속 함께 쓰기  한 클래스에서 클래스 상속과 인터페이스 구현을 모두 할 수도 있다. 다음은 Queue 인터페이스를 구현하고 Shelf 클래스를 상속받는 BookShelf 클래스를 나타낸 그림입니다.   BookShelf 클래스는 책을 넣은 순서대로 꺼내어 볼 수 있도록 만들려고 한다. BookShelf 클래스를 구현하기 전에 더 큰 개념인 Shelf 클래스를 먼저 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package bookshelf;  import java.util.ArrayList;  public class Shelf {     protected ArrayList&lt;String&gt; shelf;          public Shelf(){         shelf = new ArrayList&lt;String&gt;();     }          public ArrayList&lt;String&gt; getShelf(){         return shelf;     }     public int getCount(){         return shelf.size();     } }   Shelf 클래스에는 자료를 순서대로 저장할 배열 객체를 선언했다. 이름을 저장 할 수 있도록 자료형은 String을 사용한다. getShelf() 메서드는 저장되어있는 배열 shelf를 반환하고, getCount() 메서드는 배열 shelf에 저장된 요소 개수를 반환한다.   그럼 Queue 인터페이스를 정의해보자. Queue 인터페이스는 먼저 들어온 자료를 먼저 꺼내는 기능을 정의한다.  1 2 3 4 5 6 7 package bookshelf;  public interface Queue {     void enQueue(String title); //배열의 맨 마지막에 추가     String deQueue(); //배열의 맨 처음 항목 반환     int getSize(); //현재 Queue에 있는 개수 반환 }   이제 Shelf 클래스와 Queue 인터페이스를 사용하여 BookShelf 클래스를 다음과 같이 구현 할 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package bookshelf;  public class BookShelf extends Shelf implements Queue{      @Override     public void enQueue(String title) {         shelf.add(title);     }      @Override     public String deQueue() {         return shelf.remove(0)     }      @Override     public int getSize() {         return getCount();     } }  위의 코드를 보면 Shelf를 상속받고 Queue도 구현하는 BookShelf의 코드이다.     상속받은 shelf 멤버 변수를 사용해서 Queue 인터페이스에서 선언한 메서드를 구현한 것을 볼 수있다.   이제 책의 이름을 배열에 추가해주고, 순서대로 앞에서부터 출력해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package bookshelf;  public class BookShelfTest {     public static void main(String[] args){         Queue shelfQueue = new BookShelf();          shelfQueue.enQueue(\"태백산맥 1\");         shelfQueue.enQueue(\"태백산맥 2\");         shelfQueue.enQueue(\"태백산맥 3\");          System.out.println(shelfQueue.deQueue());         System.out.println(shelfQueue.deQueue());         System.out.println(shelfQueue.deQueue());     } }  &gt;&gt;&gt; 태백산맥 1 &gt;&gt;&gt; 태백산맥 2 &gt;&gt;&gt; 태백산맥 3  올바르게 배열의 앞에서부터 반환되어 큐의 역할을 잘 수행하는 것을 볼 수 있다.   실무에서 인터페이스를 사용하는 경우  인터페이스는 클래스가 제공할 기능을 선언하고 설계하는 것이다. 만약 여러 클래스가 같은 메서드를 서로 다르게 구현한다면 어떻게 해야할까? 우선 인터페이스에 메서드를 선언한 다음 인터페이스를 구현한 각 클래스에서 같은 메서드에 대해 다양한 기능을 구현하면 된다. 이것이 바로 인터페이스를 이용한 다형성의 구현이다.   이런 경우를 생각해보자. 어느회사에서 자료를 저장하기 위해 데이터베이스를 사용한다고 하면, 처음에는 MySQL 데이터 베이스를 사용했는데, 이 시스템을 다른 회사에 가서 설치하려고 하니 오라클 데이터 베이스를 사용하여 해달라고 하고, 또 다른 회사는 MS-SQL을 사용한다고 한다. 프로그램은 하나인데 사용하는 데이터 베이스가 제각각 인 것이다. 하지만 이프로그램의 웹페이지나 모바일 페이지는 데이터베이스의 종류와 관계없이 동일하게 수행된다.   데이터베이스와 연관되는 코드는 프로그램의 특정 부분인 것이지,나머지는 동일한것이다.     이런경우에 데이터베이스 기능을 인터페이스로 정의해주면 된다. 그리고 인터페이스 정의에 맞게 여러 데이터베이스 관련 모듈을 개발하면 되는것이다.   인터페이스를 잘 정의하는 것이 확장성 있는 프로그램을 만드는 시작이라고 할 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Programmers] 프렌즈4블록 (Python3)",
        "excerpt":"문제  프렌즈4블록  블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 “프렌즈4블록”.  같은 모양의 카카오프렌즈 블록이 2\u0014×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.      만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.      블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.      만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다.      위 초기 배치를 문자로 표시하면 아래와 같다.  TTTANT     RRFACC     RRRFCC     TRRRAA     TTMMMF     TMMTTJ     각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다  입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.   입력 형식  입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다.  2 ≦ n, m ≦ 30  board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.   출력 형식  입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라.   입출력 예제  |m\t|n\t|board|\tanswer|  |:—:|:—:|:—:|:—:|  |4\t|5\t|[“CCBDE”, “AAADE”, “AAABF”, “CCBBF”]|\t14|  |6\t|6\t|[“TTTANT”, “RRFACC”, “RRRFCC”, “TRRRAA”, “TTMMMF”, “TMMTTJ”]|\t15|   문제풀이  카카오 문제들은 풀 때마다 까다로운 것 같다. 이 문제도 푸는데 너무 오랜시간이 걸렸다.  근데 논리 구조가 조금 까다로워서 그렇지, 사실 어려운 발상을 하거나 특정 알고리즘을 적용할 필요는 없는 문제였는데 자꾸 브루트포스말고 신박한 풀이를 생각해내려다 더욱 오래 걸렸다. 항상 시간복잡도를 생각해보고, 시간복잡도 신경 안써도 되겠다 싶은 문제면 그냥 브루트포스로 풀어버리는게 결국 더 문제를 빨리 푸는 방법인것 같다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def solution(m, n, boards):     #board를 이차원 배열로 받는 리스트 board     board_list = []          #board를 이차원 배열로 받는다.     for board in boards:         board_list.append(list(board))                    #오른쪽, 아래, 오른쪽 아래 대각을 확인할 dx,dy     dx = [1,0,1]     dy = [1,1,0]          count = 0               while 1:         #삭제여부를 0과 1로 나타낼 리스트 remove         remove = [[0 for i in range(n)]for i in range(m)]                  for i in range(m):             for j in range(n):                 if board_list[i][j] == '-':                     continue                 for k in range(3):                     nx = i+dx[k]                     ny = j+dy[k]                     if 0&lt;= nx &lt; m and 0&lt;= ny &lt; n:                         if board_list[i][j] != board_list[nx][ny]:                             break                     else:                         break                 else:                     remove[i][j] = 1                     for k in range(3):                         nx = i+dx[k]                         ny = j+dy[k]                         remove[nx][ny] = 1                              if max(map(max,remove))== 0:             break                      for i in range(m):             for j in range(n):                 if remove[i][j] == 1:                     board_list[i][j] = '-'                     count+=1         while 1:                   check = []             for i in range(m):                 for j in range(n):                     if board_list[i][j] == '-':                         if i-1 &gt;= 0 and board_list[i-1][j] != '-' :                             board_list[i][j] = board_list[i-1][j]                             board_list[i-1][j] = '-'                             check.append(1)             if len(check) == 0:                 break                  return count   1 2 3 4 5 6 7 8 solution(8, 5, ['HGNHU',                  'CRSHV',                  'UKHVL',                  'MJHQB',                  'GSHOT',                  'MQMJJ',                  'AGJKK',                  'QULKK'])   1 8   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D/",
        "teaser": null
      },{
        "title": "[Programmers] 2개 이하로 다른 비트 (Python3)",
        "excerpt":"문제  양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.     x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수  예를 들어,   f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.                  수       비트       다른 비트의 개수                       2       000…0010                         3       000…0011       1              f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.                  수       비트       다른 비트의 개수                       7       000…0111                         8       000…1000       4                 9       000…1001       3                 10       000…1010       3                 11       000…1011       2           정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.   제한사항     1 ≤ numbers의 길이 ≤ 100,000   0 ≤ numbers의 모든 수 ≤ 1015   입출력 예  |numbers|\tresult|  |:—|:—|  |[2,7]|\t[3,11]|   입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.   문제 풀이  처음 문제를 보자마자 당연히 xor 비트연산자로 푸는 문제라고 생각해 풀었는데 테스트케이스 10,11에서 시간초과가 떴다. 테스트 케이스의 값의 크기들이 커서 시간초과가 중요한 문제 인줄은 알았지만, 비트 연산자가 내 생각보다 시간복잡도를 많이 잡아 먹는다는걸 알게되었다.   어쨌든 그래서 문제를 풀기위해 숫자를 하나하나 증가시켜가면서 어떻게 해야 비트가 2개이하인 가장 작은수를 찾을 수 있는지 노트에 써보았는데,  이렇게 구현방식을 정확하게 했음에도 풀리지 않는 문제는, 특이한 패턴이 있어 그 패턴을 찾아 구현하면 통과 된다는 것을 깨달았다.   이 문제는 비트가 2개 이하로 다르면서 가장 작은 수를 구하는 패턴을 찾아야 하는데, 짝수일 경우는 끝이 0이기 때문에 1하나만 바꿔주면 바로 다음 작은수가 된다. 따라서 짝수일때는 해당 숫자 +1을 답으로 저장해주면되고, 혹수일 경우는 오른쪽에서부터 0을 찾아서 그 값을 1로 바꾼뒤 그 다음인덱스를 0으로 바꿔주면 답이나온다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 def solution(numbers):     answer = []     for number in numbers:         if number%2 == 0:             answer.append(number+1)         else:             bin_num = list('0' + bin(number)[2:])             idx = ''.join(bin_num).rfind('0')             bin_num[idx] = '1'             bin_num[idx+1] = '0'             answer.append(int(''.join(bin_num),2))              return answer   1 solution([2,7])   1 [3, 11]   노트  역시 풀이를 보니까 너무나 간단한 풀이가 있었는데, 이번거는 좀 놀랐다…  너무 간단하게 풀었기 때문인데, 사실 저 패턴을 짧은시간에 직관적으로 찾아내는건 말이 안되는 것 같다.   아래에 코드 첨부한다.   1 2 3 4 5 6 7 def solution(numbers):     answer = []     for idx, val in enumerate(numbers):         answer.append(((val ^ (val+1)) &gt;&gt; 2) +val +1)      return answer   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/2%EA%B0%9C-%EC%9D%B4%ED%95%98%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EB%B9%84%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[Programmers] Weekly Challenge 1주차 (Python3)",
        "excerpt":"문제 설명  새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.   놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.   단, 금액이 부족하지 않으면 0을 return 하세요.   제한사항  놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수      처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수   놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수   입출력 예  |price|\tmoney|\tcount|\tresult|  |:—:|:—:|:—:|:—:|  |3\t|20|\t4|\t10|   입출력 예 설명  입출력 예 #1   이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.   참고 사항  미션 언어는 Java, JavaScript, Python3, C++ 만 해당 됩니다.  같은 코드를 제출한 사람이 여럿이라면 코드를 가장 먼저 제출한 분께 상품을 드립니다.  좋아요 수가 동일할 경우 코드를 가장 먼저 제출한 분께 상품을 드립니다.   문제 풀이  문제자체는 난이도 하중에 하인데, 중요한건 문제를 푸는것 보다 어떻게 하면 코드를 간결화하거나 신박하게 풀 수 있는지에 의의를 두고 진행하는 챌린지다 보니까 이 쉬운 문제를 보고 생각을 많이 했다. 파이썬인 만큼 한줄로 풀고 싶어서 lambda를 사용하여 나름 파이써닉 하게 풀이를 냈다. 근데 자꾸 테스트 케이스 하나가 오류가 떠서 극단적인 케이스 값을 넣으면서 시간을 더 썼는데, 다시보니까 금액이 안부족하면 0을 return 하라고 되어있었다… 너무 쉽다고 무시해서 문제를 제대로 안 읽었나…   코드   1 2 def solution(price, money, count):     return max(0,sum(list(map(lambda x: x*price,range(1,count+1))))-money)   1 solution(3,20,4)   1 10   노트  나름 한줄로 간결하게 풀었다고 생각했는데 역시나 더 간결하게 푼사람이 있었다.  역시 이런거 보면 알고리즘은 수학이 중요한지도…     1부터 n까지의 총합은 어차피 시작이 무조건 1이고 n이 더해야할 숫자의 개수이므로 n*(n+1)/2라고 할 수 있다. 그러면 이 총합에다가 price를 곱해서 money를 빼주면 바로 이 문제를 풀이할 수 있다. 아마 이 사람이 상품 타갈 것 같긴한데, 다음주에 빠르게 문제 풀면 상품 받기 크게 어렵지 않을지도…?   1 2 3 def solution(price, money, count):     return max(0,price*(count+1)*count//2-money)   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Java] Swing (1)",
        "excerpt":"Swing  자바에서 GUI를 개발하기 위해서는 AWT, SwIng등이 있는데, 이번 프로젝트는 Swing을 이용하여 만들어 보도록 할 것이다. 둘이 사용할 때의 차이는 예로 버튼 Button을 만든다면 AWT는 Button, Swing은 JButton을 사용한다. 앞의 J로 이 프로그램이 어떤 GUI 라이브러리로 만들어졌는지 알 수 있다.   컨테이너  GUI의 각각의 요소를 컴포넌트라고 한다. 버튼이나 텍스트등의 GUI의 요소들을 말하는데, 이러한 컴포넌트들이 자리를 잡을 화면, 창이 필요할 것이다. 이러한 창은 컨테이너 라고 한다. 컨테이너 조차도 하나의 컴포넌트라고 할 수 있는데, 이러한 컨테이너는 JFrame을 상속하여 만들어준다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package swing;   import javax.swing.*;  public class MyFrame{     public static void main(String[] args){         JFrame frame = new JFrame;                  frame.setSize(300,400);         frame.setTitle(\"첫 번째 프레임\");         frame.setResizable(false);         frame.setLocationRelativeTo(null);         frame.setVisible(true);     } }  JFrame을 상속한 MyFrame() 클래스를 만들어 주었다.      setTitle()은 창의 제목을 설정한다.   setSize()는 창의 크기를 설정한다.   setVisible은 창을 보이게 설정할 것인지, 안보이게 할 것인지를 정한다.   setResizeable은 창의 크기조절을 가능하게 할것인지를 정한다.   setLocationReativeTo는 매개변수를 null값으로 넣으면 창을 화면 정 가운데에 띄운다.   이제 main을 만들어 MyFrame의 생성자를 불러오면,      위와 같이 컨테이너를 생성했음을 알 수 있다.   이 창을 x를 눌러 닫으면 창은 닫혔지만, 다시 프로그램을 실행시키려 하면 이미 프로그램이 실행중이라고 종료 후 실행하겠다는 창이 뜬다. 따라서 창만 닫히고 프로그램은 종료되지 않고 있는 것이다. 따라서 창을 닫으면 프로그램이 종료 되는 기능을 추가해주어야 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package swing;   import javax.swing.*;  public class MyFrame{     public static void main(String[] args){         JFrame frame = new JFrame;                  frame.setSize(300,400);         frame.setTitle(\"첫 번째 프레임\");         frame.setResizable(false);         frame.setLocationRelativeTo(null);         frame.setVisible(true);         frame.serDefaultCloseOperation();     }  MyFrame생성자 안에 setDefaultCloseOperation() 메서드를 추가해주었다. 매개변수로 JFram.EXIT_ON_CLOSE를 넣어주면 시스템의 exit 메소드를 사용해서 프로그램을 같이 종료해준다.   여기까지는 GUI를 적용한 프로그램을 만들 때 반드시 추가해주어야 하는 부분이라고 할 수 있다.   버튼  그럼 이제 만들어준 컨테이너에 버튼을 한번 추가해보자.  1 2 3 4 5 6 7 MyFrame(){         setTitle(\"첫번째 프레임\");         setSize(300,400);         setVisible(true);         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         Container c = getContentPane();     }  먼저 컨탠트팬을 만들어준다. 창 자체위에 버튼들이 올라올 수 있는 공간으로 보통 우리가 보는 창에서 위의 상태창을 제외한 공간을 말한다.  getContentPane(); 을 추가하여 만들어주었다.   다음은 JButton 클래스를 사용해서 버튼의 인스턴스를 만들어 준 뒤, 컨테이너 자료형으로 선언한 c의 add() 메소드를 사용해서 버튼을 추가해주자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package swing;   import javax.swing.*; import java.awt.*;  public class MyFrame extends JFrame {     MyFrame(){         setTitle(\"첫번째 프레임\");         setSize(300,400);         setVisible(true);         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         Container c = getContentPane();         c.setLayout(new FlowLayout());          JButton j = new JButton(\"확인\");         JButton j2 = new JButton(\"취소\");          c.add(j);         c.add(j2);         setVisible(true);     }     public static void main(String[] args){         new MyFrame();     } }          setLayout : 컨테이너의 배치를 결정하는 배치관리자 메서드 이다. 매개변수로 배치관리자를 넣어 주면 되는데, 컨테이너마다 하나의 배치관리자가 존재하며, 컨테이너에 부착되는 컴포넌트의 위치와 크기를 결정해준다. 배치관리자의 대표유형은 4가지인데, 아래와 같다.              FlowLayout - 컴포넌트가 삽입되는 순서대로 왼쪽에서 오른쪽으로 배치, 배치할 공간이 없으면 아래로 내려와서 반복한다.       BorderLayout - 컨테이너의 공간을 동,서,남,북,중앙의 5개영역으로 나누어 응용 프로그램에서 지정한 영역에 컴포넌트를 배치한다.       GridLayout - 컨테이너를 프로그램에서 설정한 동일한 크기의 2차원 격자로 나눈다. 컴포넌트는 삽입 순서대로 좌에서우, 위에서 아래로 배치된다.       CardLayout - 컨테이너의 공간에 카드를 쌓아놓은 듯이 컴포넌트를 포개어 배치           우리는 FlowLayout을 사용하여 버튼을 추가했다.      JButton 자료형의 버튼 인스턴스를 만들어 준뒤, 매개변수로는 버튼에 사용하고 싶은 텍스트를 써준다. 그리고 해당 인스턴스에 있는 메서드인 add()를 사용하면 간단하게 버튼을 만들 수 있다.      또, JLabel을 자료형으로 만든 변수를 add를 통해 추가하면 그냥 텍스트가 출력이 된다.      또, 리스트를 통해서 버튼을 추가할 수도 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package swing;  import javax.swing.*; import java.awt.*;  public class MyFrameEx extends JFrame {     Container c;     JButton buttonList[] = new JButton[4];     String strList[] ={\"확인\", \"취소\", \"뒤로가기\",\"앞으로가기\"};     MyFrameEx(){         setVisible(true);         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         setSize(300,400);         setTitle(\"나의 두 번째 창\");          c = getContentPane();         c.setLayout(new FlowLayout());          for(int i=0;i&lt;buttonList.length;i++){             buttonList[i] = new JButton(strList[i]);             c.add(buttonList[i]);         }         setVisible(true);      }     public static void main(String[] args){         new MyFrameEx();     } }  버튼과 버튼에 들어갈 문자열을 각각 리스트로 선언하여 버튼을 일일히 선언하지않고 한번에 처리하였다.      패널  패널은 프레임을 세부적으로 나누어주는 컴포넌트로, 패널을 나누어 놓으면 패널마다의 각각의 컴포넌트를 추가해놓고 패널단위로 가리거나 패널 단위로 편집할 수 있게 되어 유지보수에 편리하다. 패널은 패널안에도 추가할 수 있다.   패널은 JPanel로 선언하여, 배경색을 지정하고 안에 버튼을 넣어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package swing;  import javax.swing.*; import java.awt.*;    class MyFrame2 extends JFrame {     Container c;     JPanel jPanel = new JPanel();     JButton btn = new JButton();     JButton buttonList[] = new JButton[4];     String strList[] = {\"확인\", \"취소\", \"뒤로가기\",\"앞으로 가기\"};      MyFrame2(){         setTitle(\"나의 두번째 창\");         setSize(300,400);         setDefaultCloseOperation(EXIT_ON_CLOSE);         setButton();         setVisible(true);     }     void setButton(){         c = getContentPane();         jPanel.setBackground(Color.magenta);         jPanel.setLayout(new FlowLayout());          for(int i = 0; i&lt;4; i++){             buttonList[i] = new JButton(strList[i]);             jPanel.add(buttonList[i]);         }         c.add(jPanel);      }  }  public class MyFrame3 {      public static void main(String[] args){         new MyFrame2();     } }  깔끔하게 패널의 부분은 setButton() 메서드로 따로 정리 해주었다.     setBackground() : 패널의 배경색을 설정하도록 해준다.   setLayout() : 마찬가지로 패널을 어떻게 프레임에 넣을지 정해준다.   이렇게 실행한 창의 결과는 다음과 같다.     ","categories": ["java"],
        "tags": [],
        "url": "/java/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%EC%82%B0%EA%B8%B0-(1)/",
        "teaser": null
      },{
        "title": "[Programmers] 구명 보트(Python3)",
        "excerpt":"문제  무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.   예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.   구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.   사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.   제한사항     무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.   각 사람의 몸무게는 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.   입출력 예                  people       limit       return                       [70, 50, 80, 50]       100       3                 [70, 80, 50]       100       3           문제풀이  아무리 봐도 어려운 문제도 아니고 알고리즘이 이렇게 복잡할리가 없다 싶다 했더니… 2명이 최대라는 걸 안보고 자꾸 3명 4명타는 케이스를 생각하고 풀려고 하니까 문제가 풀리지를 않았다. 앞으로 문제를 밑줄쳐가면서 읽는 습관을 들여야겠다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def solution(peoples, limit):     boat = 0     peoples.sort()     left = 0     right = len(peoples)-1     while left &lt;= right:                 if peoples[left]+peoples[right] &gt; limit:             right-=1             boat+=1         else:             left+=1             right-=1             boat+=1                       return boat   1 solution([20,30,40,50,80,90], 100)   1 2 3 4 5 6 7 8 9 10 5 0 4 0 3 1 2 2      4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[Programmers] 영어 끝말잇기 (Python3)",
        "excerpt":"문제  1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.     1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.   마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.   앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.   이전에 등장했던 단어는 사용할 수 없습니다.   한 글자인 단어는 인정되지 않습니다.   다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.   tank → kick → know → wheel → land → dream → mother → robot → tank   위 끝말잇기는 다음과 같이 진행됩니다.      1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.   2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.   3번 사람이 자신의 첫 번째 차례에 know를 말합니다.   1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.   (계속 진행)   끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는   단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.   사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.   제한 사항     끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.   words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.   단어의 길이는 2 이상 50 이하입니다.   모든 단어는 알파벳 소문자로만 이루어져 있습니다.   끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.   정답은 [ 번호, 차례 ] 형태로 return 해주세요.   만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.   입출력 예  |n|\twords|\tresult|  |:—:|:—:|:—:|  |3|\t[“tank”, “kick”, “know”, “wheel”, “land”, “dream”, “mother”, “robot”, “tank”]|\t[3,3]|  |5\t|[“hello”, “observe”, “effect”, “take”, “either”, “recognize”, “encourage”, “ensure”, “establish”, “hang”, “gather”, “refer”, “reference”, “estimate”, “executive”]\t|[0,0]|  |2\t|[“hello”, “one”, “even”, “never”, “now”, “world”, “draw”]\t|[1,3]|   입출력 예 설명  입출력 예 #1  3명의 사람이 끝말잇기에 참여하고 있습니다.      1번 사람 : tank, wheel, mother   2번 사람 : kick, land, robot   3번 사람 : know, dream, tank   와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.   입출력 예 #2  5명의 사람이 끝말잇기에 참여하고 있습니다.      1번 사람 : hello, recognize, gather   2번 사람 : observe, encourage, refer   3번 사람 : effect, ensure, reference   4번 사람 : take, establish, estimate   5번 사람 : either, hang, executive   와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.   입출력 예 #3  2명의 사람이 끝말잇기에 참여하고 있습니다.      1번 사람 : hello, even, now, draw   2번 사람 : one, never, world   와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 ‘r’로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.   문제풀이  난이도가 2단계중에서 낮은 수준에 속하는 문제였다. 단순하게 이전 문자의 마지막과 다음문자의 첫 문자가 일치하는지 확인해주고, used리스트를 만들어서 이전에 사용된적 있는 단어인지 확인해주면 된다.   코드   1 2 3 4 5 6 7 8 9 10 def solution(n, words):     used = []     last = words[0][0]     for i,word in enumerate(words):         if last != word[0] or word in used:             return [(i%n)+1,(i//n)+1]         used.append(word)            last = word[-1]     return [0,0]        1 solution(5,[\"hello\", \"observe\", \"effect\", \"take\", \"either\", \"recognize\", \"encourage\", \"ensure\", \"establish\", \"hang\", \"gather\", \"refer\", \"reference\", \"estimate\", \"executive\"])   1 [0, 0]   노트  좋은 풀이가있어서 하나 더 첨부한다.      나는 따로 used 리스트와 last라는 변수를 만들어서 사용된 문자를 담고, 문자의 끝문자를 저장했는데, 그렇게 하지않고 words[:p]로 지금 순서 이전의 리스트를 used로 사용하고, 이전문자의 끝말도 따로 변수에 저장하지 않고 words[p-1][-1]로 인덱싱을 사용하여 메모리 공간을 내가 푼 풀이보다 훨씬 아낀 좋은 풀이인 것 같다. 나도 어떻게 하면 더 코드와 메모리를 줄일 수 있을지 더 신중하게 생각하며 문제를 풀어야겠다.   1 2 3 4 5 def solution(n, words):     for p in range(1, len(words)):         if words[p][0] != words[p-1][-1] or words[p] in words[:p]: return [(p%n)+1, (p//n)+1]     else:         return [0,0]  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%98%81%EC%96%B4-%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0/",
        "teaser": null
      },{
        "title": "모가디슈",
        "excerpt":"2021.08.06  원래는 좀 글쓰고 싶은거 있을때만 종종 좀 글빨있게(?) 쓰려고 했었다가,      얼마전에 여자친구가 블로그 시작해서 맨날 그냥 일상을 올리는 걸 보니 그게 너무 보기 좋아서.     나도 뭐 하루에 한개씩 되도록 그냥 일상글이라도 끄적여보려고 한다.   어제는 오랜만에 친구랑 영화관가서 영화를 봤다.      오랜만이라기엔 최근에도 종종 여자친구랑 가서 보긴했는데,     그냥 동네에서 친구랑 본게 오랜만이었다. 원래는 밑에서 버거킹 할인하는거 하나 사서.     먹으면서 보는게 국룰인데, 코로나 때문에 영화관내에서 음료 말고는 취식이 안되기도 하고…     무엇보다 영화가 재밌는게 안나왔었다. 그래도 이제 좀 코로나가 어쩔 수 없다는 걸 아는 건지 괜찮은게 하나씩     개봉하는 것 같은데, 오랜만에 재밌는 한국영화가 나온 것 같아서 영화관에 가서 봤다.   아니 근데 우선 영화관 욕좀 하고 시작해야겠다. 얘네는 코로나 때문에 잘안되면 영화비 내려서 관객 모을 생각을 해야지     왜이렇게 가격을 올리는지 모르겠다. 아니 한번 보는데 13000원은 좀 선넘지… 물론 어떻게 할인 받아서 9500원에 보긴했지만  진짜 가격좀 그만올렸으면 좋겠다. 그리고 skt는 언제 멤버십에서 영화 무료를 롯데시네마 빼고 없애 버렸는지 다음에 핸드폰 바꾸면 진짜 통신사 무조건 kt나 lg로 바꾼다 진짜. 솔직히 멤버십 쓰는거 영화관 밖에 없는데 그걸 없애?   어쨌든 영화 자체는 뭐 기대보다는 재미가 덜했지만 그럭저럭 재밌었다.     류승완 감독 영화는 군함도 빼고 다 본 것 같은데 이번에도 류승완 냄새나게 액션나름 찰지게 섞어서     실화 각색것 치고 재밌게 뽑은 것 같다. 우선 소말리아 저 위험한 나라 한가운데 서있는것 자체가 서스펜스라서,  보는 내내 긴장되고 재밌긴 했다. 마지막에 차에다가 책이랑 모래주머니 휘감고 달리는 장면도 멋졌고…      아니 근데 총을 저렇게 쏘는데 한명만 죽는건 조금 오바가 아닌가…   어쨌든 신파도 하나도 안섞고 나름 남한과 북한이 서로를 이해하고 잠깐의 목표를 위해서 화합하는건 인상깊긴했다.     그렇게 점점 두 단체가 쟤들도 우리랑 다를거 없는 그냥 사람이구나… 싶어지고 관객들이 더 이상 저 사람들을 북한사람과 남한 사람이   아닌 모두 살았으면 좋겠다는 마음을 갖게 될 때 즈음에 딱 우리는 남한이고 저들은 북한인걸 뼈저리게 인식시켜주므로써      아 맞다 쟤네들 북한이었지… 하며 체제의 다름에서 오는 섞일 수 없는 벽을 체감하게 해준다.   사실 극찬하는 리뷰를 보고 가서 너무 기대를 했는데, 영화자체는 오랜만에 나름 재밌게 봤고,     조인성 연기 잘해서 놀랐다. 특히 그 경찰서에서 총 이마에 들이밀고 소리지르는 장면은 카리스마 있고 멋지게 잘 담아낸것 같아서  영화 끝나고도 그 장면이 생각났다.   다음은 수어사이드 스쿼드가 보고싶은데… 이건 또 누구랑 봐야할지…     다음주까지 꼭 볼 생각이다. 영화보는걸 이렇게 좋아했었는데 코로나가 다 뺏어간게 애석하다.     그래도 이제 재밌는게 슬슬 나오는것 같으니 종종 가서 봐야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%AA%A8%EA%B0%80%EB%94%94%EC%8A%88/",
        "teaser": null
      },{
        "title": "[Java] Class 클래스",
        "excerpt":"Class 클래스란?  지금까지 변수를 선언할 때 자료형을 미리 파악하고 그 자료형에 따라 변수를 선언했다.     그리고 클래스를 사용할 때도 이미 그 클래스 정보(변수, 메서드)를 알고 있는 상황에서 프로그램을 만들었다. 하지만 어떤 경우에는 여러 클래스 중에 상황에 따라 다른 클래스를 사용해야 할 때도 있고, 반환받는 클래스가 정확히 어떤 자료형인지 모를 때도 있다. 이렇게 모르는 클래스의 정보를 사용할 경우에는 우리가 클래스 정보를 직접 찾아야한다. 이때 Class 클래스를 사용한다.   Class 클래스를 선언하고 클래스 정보를 가져오는 방법은 다음과 같다.      Object 클래스의 getClass() 메서드 사용하기     1 2 String s = new String(); Class c = s.getClass           클래스 파일 이름을 Class 변수에 직접 대입하기     1 Class c = String.Class;           Class.forName(“클래스 이름”) 메서드 사용하기     1 Class c = Class.forName(\"java.lang.String\")           1번의 경우는 모든 클래스가 사용할 수 있는 메서드이다. 이 메서드를 사용하려면 이미 생성된 인스턴스가 있어야한다. 2,3번의 경우는 컴파일된 클래스 파일이 있으면 클래스 이름만으로도 Class 클래스를 반화놘다.   다음 예제로 Class 클래스를 반환받아 사용해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package objectclass;  public class Person {     private String name;     private int age;      public Person(){}      public Person(String name){         this.name = name;     }      public Person(String name, int age){         this.name = name;         this.age = age;     }      public String getName(){         return name;     }      public void setName(String name){         this.name = name;     }      public int getAge(){         return age;     }      public void setAge(int age){         this.age = age     } }  이 예제 클래스는 사람의 이름과 나이를 변수로 갖고, 생성자 매개변수가 없는경우, 이름만 있는경우, 이름과 나이가 있는경우를 만들었고, get 과 set 함수를 만들어 이름과 나이를 불러오고, 접근할 수 있도록 만들었다.   이제 Person의 Class 클래스를 가져와보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package objectclass;  public class PersonTest {     public static void main(String[] args) throws ClassNotFoundException{         Person person = new Person();         Class pClass1 = person.getClass();         System.out.println(pClass1.getName());          Class pClass2 = Person.class;         System.out.println(pClass2.getName());          Class pClass3 = Class.forName(\"objectclass.Person\");         System.out.println(pClass3.getName());     } }  &gt;&gt;&gt; objectclass.Person &gt;&gt;&gt; objectclass.Person &gt;&gt;&gt; objectclass.Person  Person의 클래스를 가져온것을 확인할 수 있다.   Class를 활용해 클래스 정보 알아보기  프로그래밍을 하다 보면 내가 사용할 클래스의 자료형을 모르는 경우가 왕왕 생기곤한다. 예를 들어 내 컴퓨터에 저장되어 있지 않은 객체를 메모리에 로드하고 생성하는 경우에는 그 객체의 정보를 알기가 쉽지 않을 것 이다. 이때 Class 클래스를 가져올 수 있다면 해당 클래스의 생성자, 메서드, 멤버변수 정보를 찾을 수 있다. 이렇게 사용하려는 클래스의 자료형을 모르는 상태에서 Class 클래스를 활용하여 그 클래스의 정보를 가져오고, 이 정보를 활용하여 인스턴스를 생성하거나 메서드를 호출하는 방식을 리플렉션 (reflection) 이라고 한다.   그럼 클래스의 Constructor, Method, Field 클래스를 사용하여 리플렉션 프로그래밍을 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package objectclass;  import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method;  public class StringClassTest {     public static void main(String[] args) throws ClassNotFoundException{         Class strClass = Class.forName(\"java.lang.String\");          Constructor[] cons = strClass.getConstructors();         for(Constructor c : cons) {             System.out.println(c);         }          System.out.println();         Field[] fields = strClass.getFields();         for(Field f : fields){             System.out.println(f);         }         System.out.println();         Method[] methods = strClass.getMethods();         for(Method m : methods){             System.out.println(m);         }     } }  Class 클래스를 가져오기위해 forName() 메서드를 사용한다. 이 메서드는 정적 메서드이므로 클래스를 생성하지 않아도 사용할 수 있으며, java.lang.String을 사용하여 Class를 가져왔다. 이제 String 클래스의 정보를 알 수 있는데, 출력결과를 보면 String 클래스의 여러 생성자를 볼 수 있다. 이렇게 Class 클래스와 java.lang.reflect 패키지에 있는 클래스를 활용하면 클래스 이름만 알아도 클래스의 생성자, 메서드등의 정보를 얻을 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Class-%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Java] Swing (2)",
        "excerpt":"간단한 로그인 프로그램  스윙의 기초나 대략 어떻게 사용하는지를 알아봤는데, 그냥 기초만 무작정 공부하기보다는  간단한 에제프로그램을 만들어보면서 익히는 것이 가장 어떤 툴이나 언어를 빨리 습득하는 방법이 아닐까 싶다  애초에 계산기 자체도 작은 프로젝트지만, 스윙은 또 처음 배우는 라이브러리기 때문에 숙달을 위해  느낌으로 아주 간단한 예제를 통해 스윙을 배워보도록 하려고 한다.   로그인프로그램은 간단하게 아이디와 비밀번호를 입력할 수 있는 패널을 만들어   아이디와 비밀번호가 서버에 있는 내용과 일치하면 로그인을 허락하는 방식이다.  계산기를 만들기 위해서는 특정한 버튼을 누르면 텍스트에리어에 숫자가 나오게 되고 이를 연산자로  처리해야하는데, 이러한 기능들을 숙달하기 위해서 간단하게 만들어 보도록하자   먼저 클래스의 이름을 LogIn으로 선언하고 이 프로그램의 뼈대를 만들어준다.  1 2 3 4 5 6 7 8 9 10 11 12 package swing;  import javax.swing.JFrame;  public class LogIn extends JFrame {     public LogIn(){              }     public static void main(String[] args){         new LogIn();     } }  LogIn 이라는 JFrame을 상속받는 클래스를 만들고, main함수에서 LogIn클래스를 실행하도록 해주었다.   그 다음 컨테이너의 대략적인 속성들을 지정하여 창을 띄울 수 있도록 해준다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package swing;  import javax.swing.JFrame;  public class LogIn extends JFrame {     public LogIn(){         setVisible(true);         setTitle(\"LogIn\");         setResizable(false);         setSize(600, 400);         setLocationRelativeTo(null);         setDefaultCloseOperation(EXIT_ON_CLOSE);     }     public static void main(String[] args){         new LogIn();     } }     setVisible() : rue로 함으로써 창이 보이도록 해주었다.   setTitle() :  창의 제목이 “LogIn”으로 뜨게 해주었다.   setResizable() : false로 설정하여 사이즈 조절이 불가능하게 설정하였다.   setSize() : 사이즈를 600 * 400 으로 설정했다.   setLocationRelativeTo() : 창을 정가운데에 띄우도록 한다.   setDefaultCloseOperation() : EXIT_ON_CLOSE를 매개변수로 입력해주면,   창을 닫으면 프로그램이 알아서 종료된다.      다음은 아이디의 컴포넌트가 들어갈 패널을 만들어 컨테이너에 넣어주도록 하자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package swing;  import javax.swing.*;  public class LogIn extends JFrame {     public LogIn(){         JPanel panel = new JPanel();         JLabel label = new JLabel(\"ID : \");         JTextField txtID = new JTextField(10);          panel.add(label);         panel.add(txtID);          add(panel);          setVisible(true);         setTitle(\"LogIn\");         setResizable(false);         setSize(600, 400);         setLocationRelativeTo(null);         setDefaultCloseOperation(EXIT_ON_CLOSE);     }     public static void main(String[] args){         new LogIn();     } }     panel 이라는 JPanel 인스턴스와 JLabel 의 새로운 인스턴스를 만들고,     이렇게 선언한 컴포넌트를 패널에 추가해준뒤, 이 패널을 컨테이너에 추가해준다.   그럼 이제 패스워드를 만들어 줄건데, JPasswordField()를 사용할 것이다.     우리가 인터넷에서 패스워드를 입력할 때, 패스워드는 입력은 가능하지만 *** 처럼 암호화되어 화면에 표시되는데,     이러한 입력을 도와주는 메서드이다.      아래 처럼 입력을 하면 화면에 암호화 되어 출력되는 것을 볼 수 있다.      다음은 JButton을 사용해 로그인 버튼을 만들어 준다.      이렇게 우리가 만들어 볼 프로그램의 UI가 대략 만들어졌다.     이제 이 UI에 기능을 추가해보자.   실제로 웹페이지에서의 로그인은 보안을 중요시 해야하기 때문에 복잡할 수 있겠지만,     지금 우리가 만드는 것은 단순하게 우리가 입력한 값이 저장된 아이디, 패스워드 값과 일치하면 로그인,     아니면 실패만 뜨면 되므로, 간단하게 구현할 수 있다.   addActionListener() 통해서 버튼에 로그인 기능을 구현해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package swing;  import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener;  public class LogIn extends JFrame {     ...              loginBtn.addActionListener(new ActionListener() {             @Override             public void actionPerformed(ActionEvent e) {                 String id = \"LMJ\";                 String pass = \"1234\";                  if(id.equals(txtID.getText()) &amp;&amp; pass.equals(txtPass.getText())){                     JOptionPane.showMessageDialog(null,\"로그인에 성공하였습니다.\",\"로그인 성공\",JOptionPane.INFORMATION_MESSAGE);                 }                 else{                     JOptionPane.showMessageDialog(null,\"로그인에 실패하였습니다.\",\"오류\",JOptionPane.ERROR_MESSAGE);                 }             }         });              ... }  간단하게 ID를 LMJ, Password를 1234로 설정해 주었는데, JOptionpane.showMessageDialog()를 사용하였다.       showMessageDialog()는 우리가 프로그램에서 보는 알림창을 띄워주는 메서드인데, 매개변수는 다음과 같다.      Component parentComponent : 메시지창이 어떤 Frame 에서 보이지게 될 것인지 지정해준다. 보통 null 을 사용한다.   Object message : 출력할 문자열을 써준다.   String title : 제목표시줄에 나타날 제목을 써준다.   int messageType : 메시지 종류를 지정해준다. ERROR_MESSAGE, INFORMATION_MESSAGE, WARNING_MESSAGE, QUESTION_MESSAGE, or PLAIN_MESSAGE 가 있다.   Icon icon : Icon 이미지를 설정한다.   이렇게 알림창을 간단히 설정 할 수 있게 해주는 메서드이다.       그럼 적용된 화면을 보도록 하면,      실패 알림창      성공 알림창   이렇게, 아주 간단한 로그인 프로그램을 Swing을 이용해 만들어 보았다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%EC%82%B0%EA%B8%B0-(2)/",
        "teaser": null
      },{
        "title": "[Programmers] 다리를 지나는 트럭 (Python3)",
        "excerpt":"문제  트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.   예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.                  경과 시간       다리를 지난 트럭       다리를 건너는 트럭       대기 트럭                       0       []       []       [7,4,5,6]                 1~2       []       [7]       [4,5,6]                 3       [7]       [4]       [5,6]                 4       [7]       [4,5]       [6]                 5       [7,4]       [5]       [6]                 6~7       [7,4,5]       [6]       []                 8       [7,4,5,6]       []       []           따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.   solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.   제한 조건     bridge_length는 1 이상 10,000 이하입니다.   weight는 1 이상 10,000 이하입니다.   truck_weights의 길이는 1 이상 10,000 이하입니다.   모든 트럭의 무게는 1 이상 weight 이하입니다.   입출력 예  |bridge_length    |weight|    truck_weights|    return|  |:—:|:—:|:—:|:—:|  |2|    10    |[7,4,5,6]    |8|  |100|    100    |[10]|    101|  |100|    100    |[10,10,10,10,10,10,10,10,10,10]|    110|  문제 풀이  처음에는 아예 실제 다리랑 똑같이 움직이는 큐를 만드려고 아예 0을 biridge_length만큼 데크로 만든 뒤 새로 들어오면 0이 popleft()되고 다음 차의 무게가 들어와 하나씩 밀리는 식으로 해서 그때마다 시간을 1초씩 추가해서 만들려고 했다. 사실 내심 시간초과가 뜰거라고 생각했는데, 진짜 시간 초과가 떠서 더 간단한 코드를 생각하게 되었다.   처음에는 모든 경우의 수를 다 제각각 코딩했었는데, 다시 간단하게 생각해보니 그냥 계속 time을 1씩 더하면서 큐를 밀어내주면 훨씬 간단하게 시간을 측정할 수가 있었다.   근데 이렇게 풀어도 자꾸 테스트 케이스 하나에서 시간초과가 떴다!     진짜 아무리봐도 더 줄일 수가 없다고 생각했는데 문제는 sum()이었다.   다리위의 차량들의 무게의 총합을 구하려고 sum(queue)를 사용하고 있었는데, 이게 시간복잡도를 꽤 잡아 먹고 있었다.   sum()을 사용하지말고 따로 다리위의 차량들의 무게를 따로 저장하는 변수를 만들어 차가 올라갈때나 내려올때 변수가 달라지게 만들었다. 앞으로 시간초과가 이유없이 뜬다면 sum() 함수를 없애줌으로써 시간을 절약할 수 있다는걸 알게 되었다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from collections import deque def solution(bridge_length, weight, truck_weights):     time = 0     queue = deque([0]* bridge_length)     bridge_weight = 0     while queue:         time+=1         out_truck = queue.popleft()                  if out_truck != 0:             bridge_weight-=out_truck                      if truck_weights:             if bridge_weight + truck_weights[0] &lt;= weight:                 in_truck = truck_weights.pop(0)                 queue.append(in_truck)                 bridge_weight+=in_truck                              else:                 queue.append(0)     return time   1 solution(2, 10, [7, 4, 5, 6])   1 8   잘못 풀었던 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import deque def solution(bridge_length, weight, truck_weights):          queue = deque(0 for _ in range(bridge_length))     time = 0          for i in range(len(truck_weights)):                  if sum(queue)+ truck_weights[i] &lt;= weight and 0 &lt; queue.count(0):             queue.popleft()             queue.append(truck_weights[i])             time+=1         else:             while 1:                 queue.popleft()                 queue.append(0)                 time+=1                 if queue.count(0) == bridge_length or sum(queue)+ truck_weights[i]&lt;= weight:                     queue.popleft()                     queue.append(truck_weights[i])                     break          while queue:         queue.popleft()         time+=1     return time  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8B%A4%EB%A6%AC%EB%A5%BC-%EC%A7%80%EB%82%98%EB%8A%94-%ED%8A%B8%EB%9F%AD/",
        "teaser": null
      },{
        "title": "[Programmers] 큰 수 만들기 (Python3)",
        "excerpt":"문제  어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는가장 큰 숫자를 구하려 합니다.   예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.   문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.   제한 조건     number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.   k는 1 이상 number의 자릿수 미만인 자연수입니다.   입출력 예  |number\t|k\t|return|  |:—:|:—:|:—:|  |”1924”|\t2\t|”94”|  |”1231234”\t|3|\t“3234”|  |”4177252841”|\t4|\t“775841”|   문제 풀이  풀고나니까 별로 안어려웠는데도 왜인지 발상이 너무 안 떠올라서 오래걸렸다. 생각하는걸 코드로 구현못하는건 그만큼 더 열심히 해야겠다고 생각하고 다음 문제를 풀게 되는데, 이렇게 발상 조차 안되서 코드 한줄도 못적고 노트에만 쓰고 있다보면 진짜 답답하고 나 자신한테 화가난다. 이번 문제도 그다지 어려운 알고리즘도 아닌데 도대체 왜 못떠올렸는지… 좀 패턴을 찾는 문제에 약한 것같다.   이 문제는 가장 큰 수를 만드는 문제이므로, 앞에서부터 리스트에 저장해가면서 만약 리스트의 가장 마지막 숫자가 다음 숫자보다 크다면 그 숫자를 바로 리스트에 추가하고, 다음 숫자보다 작다면 그 숫자보다 큰수가 나올때까지 리스트의 맨 마지막 값을 없애주고 다음 숫자를 추가하는 방식으로 가장 큰 수를 만들 수 있다.   또, 반드시 예외 처리를 해주어야하는데, 54321 처럼 내림차순의 모양을 띄는 숫자는 계속 리스트의 마지막 숫자가 다음숫자보다 크므로 삭제가 일어나지않기때문에, 가장 큰 수를 만드는 것은 뒤에서 부터 k만큼 삭제하는 것이므로, 따로 예외를 처리해주어 출력하도록 한다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  def solution(number, k):     result = []     number = list(number)     remove=0     for num in number:         if not result:             result.append(num)             continue         while result and result[-1] &lt; num:             if remove == k:                 result.append(num)                 break             result.pop()             remove+=1                      else:             result.append(num)                  if len(result) &gt; len(number)-k:         return \"\".join(result[:len(number)-k])          return \"\".join(result)                                 1 solution(\"54321\",2)   1 '543'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 카펫 (Python3)",
        "excerpt":"문제  Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.      Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.   Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.   제한사항     갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.   노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.   카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.   입출력 예  |brown|\tyellow\t|return|  |:—:|:—:|:—:|  |10|\t2\t|[4, 3]|  |8|\t1|\t[3, 3]|  |24\t|24\t|[8, 6]|   문제풀이  맨처음에는 좌표를 하나씩 늘려가면서 갈색과 노란색의 모든 경우의 수를 찾다가 같은 값이 나오면 그 좌표를 리턴하는 형식으로 코드를 짰는데 역시나 시간초과가 떴다.   그래서 조금 더 생각을 간단히 해서 굳이 모든 사각형의 크기가 아니라 안쪽의 노란색 사각형의 크기만 생각해보기로 했는데, 노란색 사각형은 결국 3,3인 사각형일 때 1이므로 여기서 가로로 사각형이 커지면 노란색 사각형도 같이 1증가하고 세로로 커지면 같이 세로로 1증가한다. 따라서 yellow에 주어진 넓이를 구성할 수 있는 사각형의 가로와 세로를 모두 구해준 후, 그 가로와 세로가 구성하는 큰 사각형이 brown의 넓이와 일치한다면 그때의 가로와 세로를 리턴해주면 된다.   코드   1 2 3 4 5 6 7 8 def solution(brown, yellow):     i = 1     while 1:         if yellow % i == 0:             if (i+2)*(yellow/i+2)-yellow == brown:                     return[max(i+2,yellow//i+2),min(i+2,yellow//i+2)]             i+=1   1 solution(10,2)   1 [4, 3]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%B9%B4%ED%8E%AB/",
        "teaser": null
      },{
        "title": "[Programmers] 타겟 넘버 (Python3)",
        "excerpt":"문제  n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.   -1+1+1+1+1 = 3     +1-1+1+1+1 = 3     +1+1-1+1+1 = 3     +1+1+1-1+1 = 3     +1+1+1+1-1 = 3   사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.   제한사항     주어지는 숫자의 개수는 2개 이상 20개 이하입니다.   각 숫자는 1 이상 50 이하인 자연수입니다.   타겟 넘버는 1 이상 1000 이하인 자연수입니다.   입출력 예  |numbers|\ttarget|\treturn|  |:—:|:—:|:—:|  |[1, 1, 1, 1, 1]\t|3\t|5|   입출력 예 설명  문제에 나온 예와 같습니다.   문제풀이  제한사항에 주어진 개수와 경우의 수가 매우 적어서 그냥 브루트포스로 combinations를 이용하여 모든 조합을 찾아서 답을 찾았다. 브루트포스로 푼다는 가정하에 combinations 메서드만 알면 난이도가 낮은 문제인 것 같다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 from itertools import combinations  def solution(numbers, target):     result = 0     for i in range(len(numbers)):             combi = list(combinations([i for i in range(len(numbers))],i))             for com in combi:                 change_num = numbers.copy()                                  for idx in com:                     change_num[idx] = -change_num[idx]                 if sum(change_num) == target:                     result+=1                return result   1 solution([1,1,1,1,1], 3)   1 5   노트  사실 브루트포스로 그냥 풀겠다고 마음먹을 때부터 100명중에 50등 정도하는 코드라고 생각하긴 했는데, 100명중에 1등 급인 코드가 진짜 말도안되게 아름답게 코드를 짜서 첨부한다. 난 언제 저렇게 될까…   1 2 3 4 5 6 7 def solution(numbers, target):     if not numbers and target == 0 :         return 1     elif not numbers:         return 0     else:         return solution(numbers[1:], target-numbers[0]) + solution(numbers[1:], target+numbers[0])   그러고보니까 이 문제의 분류가 dfs/bfs로 되어있었다.     그래서 나도 처음에는 dfs/bfs로 생각하다가 잘 안풀리길래, 제한사항 경우의 수를 보니 시간적합도 남아 돌겠다 싶어서 브루트포스로 풀어버렸다.   타겟넘버가 dfs/bfs 문제인 이유는 다음인덱스에 해당하는 numbers 원소를 더하거나 뺀값을 새로운 노드로 모두 생성해주고, 그 값로 만든 새로운 그래프에 하나씩 방문하면서 numbers의 합이 같을때마다 count해주면 되기 때문이다.   그래서 저 위 코드는 numbers에 존재하는 값을 target에다가 더하거나 빼서 target이 0이 나오면 1을 리턴하고 0이 아니면 0을 리턴한 후, numbers를 그 다음요소부터 [1:]로 인덱싱하여 재귀함수로 다시 solution을 호출하는 방식으로 numbers의 요소를 각각 +,-로 바꿔가며 계산하여 풀었다.   사실 보다보니까 음수가 난 여러개인 경우의 수도 있다고 생각했는데, 사실 답은 음수는 무조건 하나여서 문제 설명이 좀 부족한게 아닌가 하는 생각이 들었다. 예제를 더 주던지, 제한사항을 추가해야할듯…  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%83%80%EA%B2%9F%EB%84%98%EB%B2%84/",
        "teaser": null
      },{
        "title": "[Programmers] Weekly Challenge 2주차 (Python3)",
        "excerpt":"문제  대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.                  No.       0       1       2       3       4                       0       100       90       98       88       65                 1       50       45       99       85       77                 2       47       88       95       80       67                 3       61       57       100       80       65                 4       24       90       94       75       65                 평균       45.5       81.25       97.2       81.6       67.8                 학점       F       B       A       B       D           위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.      0번 학생이 평가한 점수는 0번 행에담긴 [100, 90, 98, 88, 65]입니다.   0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.   2번 학생이 평가한 점수는 2번 행에담긴 [47, 88, 95, 80, 67]입니다.        2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.  당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.     만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.       0번 학생이 받은 점수는 0번 열에 담긴 [100, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.   0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.   4번 학생이 받은 점수는 4번 열에 담긴 [65, 77, 67, 65, 65]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다.   4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.   제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.                  평균       학점                       90점 이상       A                 80점 이상 90점 미만       B                 70점 이상 80점 미만       C                 50점 이상 70점 미만       D                 50점 미만       F           학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.   제한사항     2 ≤ scores의 행의 길이(학생 수) ≤ 10   scores의 열의 길이 = scores의 행의 길이   즉, scores는 행과 열의 길이가 같은 2차원 배열입니다.   0 ≤ scores의 원소 ≤ 100   return 값 형식   0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.   입출력 예  |scores|\tresult|  |:—:|:—:|  |[[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]|\t“FBABD”|  |[[50,90],[50,87]]|\t“DA”|  |[[70,49,90],[68,50,38],[73,31,100]]|\t“CFD”|   입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.   입출력 예 #2     No.\t0\t1     0\t50\t90     1\t50\t87     평균\t50\t90     학점\tD\tA   1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.   입출력 예 #3  No.\t0\t1\t2     0\t70\t49\t90     1\t68\t50\t38     2\t73\t31\t100     평균\t70.33…\t40\t64     학점\tC\tF\tD   1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.      2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.   문제풀이  역시나 코드를 줄이는게 관건인 위클리 챌린지라 문제를 그저 풀고자 하면 푸는 것은 난이도가 쉽다. 근데 이 문제는 오히려 코드를 줄이는게 굉장히 마땅한 방법이 없어서, 고민하다 그냥 제출했는데 다른사람 풀이를 봐도, ‘이건 획기적으로 줄였다.’ ‘나는 왜 이 생각을 못했지?’ 싶은 풀이는 없고 그냥 한줄풀이를 한 사람의 좋아요 수가 가장 많았다. 저런 한줄코드는 오히려 가독성만 떨어지고 별로라 굳이 분석하고 싶지도 않았다. 다음 위클리 챌린지 때는 더 멋진 코드를 뽐낼 수 있을만한 문제로 나오면 좋겠다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def solution(scores):     result = []     student = [[]for _ in range(len(scores))]     for score in scores:         #print(score[i])         for k,j in enumerate(score):             student[k].append(j)     for i,stu in enumerate(student):         if stu[i] == max(stu) or stu[i] == min(stu):             if stu.count(stu[i])&lt;2:                 stu.remove(stu[i])                   for i in student:         aver = sum(i)/len(i)         print(aver)         if 90&lt;=aver:             result.append('A')         elif 80 &lt;= aver &lt;90:             result.append('B')         elif 70 &lt;= aver &lt;80:             result.append('C')             elif 50 &lt;= aver &lt;70:             result.append('D')         else:             result.append('F')     return \"\".join(result)   1 solution([[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]])   1 2 3 4 5 6 7 8 9 10 11 12 [[50, 47, 61, 24], [90, 88, 57, 90], [98, 99, 95, 100, 94], [88, 85, 80, 80, 75], [65, 77, 67, 65, 65]] 45.5 81.25 97.2 81.6 67.8      'FBABD'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Weekly-Challenge-2%EC%A3%BC%EC%B0%A8/",
        "teaser": null
      },{
        "title": "[Programmers] 위장 (Python3)",
        "excerpt":"문제  스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.  예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.                  종류       이름                       얼굴       동그란 안경, 검정 선글라스                 상의       파란색 티셔츠                 하의       청바지                 겉옷       긴 코트           스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.   제한사항     clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.   스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.   같은 이름을 가진 의상은 존재하지 않습니다.   clothes의 모든 원소는 문자열로 이루어져 있습니다.   모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다.   스파이는 하루에 최소 한 개의 의상은 입습니다.   입출력 예  |clothes|\treturn|  |:—:|:—:|  |[[“yellowhat”, “headgear”], [“bluesunglasses”, “eyewear”], [“green_turban”, “headgear”]]\t|5|  |[[“crowmask”, “face”], [“bluesunglasses”, “face”], [“smoky_makeup”, “face”]]|\t3|   입출력 예 설명  예제 #1  headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.     yellow_hat   blue_sunglasses   green_turban   yellow_hat + blue_sunglasses   green_turban + blue_sunglasses   예제 #2  face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.     crow_mask   blue_sunglasses   smoky_makeup   문제 풀이  처음에는 딕셔너리에 리스트로 종류에 따른 옷을 넣어서 그걸 또 조합으로 빼서 모든 경우의 수를 하나씩 더해가며 답을 구했는데, 모두 통과되는듯 싶더니 테스트 케이스 1번에서 계속 시간초과가 떴다. 다시 문제를 놓고 간단한 조합문제로 생각해보니까, 각각의 옷종류에 안입은 경우를 하나씩 추가해서 위의 예제 1로 예를 들면 headgear = [안입음, yellow_hat, grren_turban], eyewear = [안입음, blue_sunglasses] 으로 두면 두 종류이니까 3*2 = 6으로 모든 경우의 수를 구할 수 가 있었다. 여기서 아무것도 안입은 경우의 수 1을 빼주면 답이된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 def solution(clothes):     dic = {}     answer = 1          for cloth in clothes:         if cloth[1] in dic:             dic[cloth[1]]+=1         else:             dic[cloth[1]]= 1     for i in dic.values():         answer *= (i+1)     return answer-1   1 solution([[\"yellowhat\", \"headgear\"], [\"bluesunglasses\", \"eyewear\"], [\"green_turban\", \"headgear\"]]\t)   1 5   노트  라이브러리를 이용해 예쁘게 푼 코드가 있어서 첨부한다.     reduce라는 처음 써보는 메서드도 있었다.   1 2 3 4 5 6 def solution(clothes):     from collections import Counter     from functools import reduce     cnt = Counter([kind for name, kind in clothes])     answer = reduce(lambda x, y: x*(y+1), cnt.values(), 1) - 1     return answer   개수를 세려면 무조건 Counter를 써주는게 편하다. Counter를 잘쓰자   reduce 함수는 functools 라이브러리를 통해서 import한다.   1 from functools import reduce   reduce() 함수는 여러개의 데이터를 대상으로 주로 누적 집계를 내기 위해서 사용한다.     reduce(집계 함수, 순회 가능한 데이터 [, 초기값])   예를들어 유저 5명의 데이터를 임의로 생성해보자.   1 2 3 4 5 users = [{'mail': 'gregorythomas@gmail.com', 'name': 'Brett Holland', 'sex': 'M', 'age': 73}, {'mail': 'hintoncynthia@hotmail.com', 'name': 'Madison Martinez', 'sex': 'F', 'age': 29}, {'mail': 'wwagner@gmail.com', 'name': 'Michael Jenkins', 'sex': 'M', 'age': 51}, {'mail': 'daniel79@gmail.com', 'name': 'Karen Rodriguez', 'sex': 'F', 'age': 32}, {'mail': 'ujackson@gmail.com', 'name': 'Amber Rhodes', 'sex': 'F', 'age': 42}]   이 데이터에서 reduce 함수를 사용해 유저들의 나이 합을 구해보자.   1 reduce(lambda acc, cur : acc+cur[\"age\"], users,0)   1 227   reduce의 첫번째 파라미터는 함수가 들어가게 된다. 람다식이 들어올수도 있고, 정의 해놓은 함수일 수도 있다. 두번째 파라미터는 집계할 리스트, 세번재는 초기값을 받는다.   이번에는 유저 이메일만을 모아 목록으로 만들어보자.   1 reduce(lambda acc, cur: acc +[cur[\"mail\"]],users,[])   1 2 3 4 5 ['gregorythomas@gmail.com',  'hintoncynthia@hotmail.com',  'wwagner@gmail.com',  'daniel79@gmail.com',  'ujackson@gmail.com']   마찬가지로 첫번째 파라미터에 함수를 받고, acc의 초깃값을 []로 해준뒤, [cur[“mail”]]을 순차적으로 더해준다.   이렇게 reduce를 사용하면 간편하게 딕셔너리나 리스트의 값을 집계할 수 있다. 정말 유용한 라이브러리인 것 같으니 꼭 생각해주자.   딕셔너리하면 Counter, reduce 생각하기  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%9C%84%EC%9E%A5/",
        "teaser": null
      },{
        "title": "[Programmers] 순위 검색 (Python3)",
        "excerpt":"문제 설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]  카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.      코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다.   지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다.   지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다.   선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다.   인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.   예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.      코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?    물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.      코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?   코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?   backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가?   소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가?   코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가?   즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.      [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?   문제  지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,  각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.   제한사항     info 배열의 크기는 1 이상 50,000 이하입니다.   info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 “개발언어 직군 경력 소울푸드 점수” 형식입니다.   개발언어는 cpp, java, python 중 하나입니다.   직군은 backend, frontend 중 하나입니다.   경력은 junior, senior 중 하나입니다.   소울푸드는 chicken, pizza 중 하나입니다.   점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다.   각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.   query 배열의 크기는 1 이상 100,000 이하입니다.   query의 각 문자열은 “[조건] X” 형식입니다.   [조건]은 “개발언어 and 직군 and 경력 and 소울푸드” 형식의 문자열입니다.   언어는 cpp, java, python, - 중 하나입니다.   직군은 backend, frontend, - 중 하나입니다.   경력은 junior, senior, - 중 하나입니다.   소울푸드는 chicken, pizza, - 중 하나입니다.   ’-‘ 표시는 해당 조건을 고려하지 않겠다는 의미입니다.   X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다.   각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.   예를 들면, “cpp and - and senior and pizza 500”은 “cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?”를 의미합니다.  [입출력 예]  |info|\tquery|\tresult|  |:—:|:—:|:—:|  |[“java backend junior pizza 150”,”python frontend senior chicken 210”,”python frontend senior chicken 150”,”cpp backend senior pizza 260”,”java backend junior chicken 80”,”python backend senior chicken 50”]\t|[“java and backend and junior and pizza 100”,”python and frontend and senior and chicken 200”,”cpp and - and senior and pizza 250”,”- and backend and senior and - 150”,”- and - and - and chicken 100”,”- and - and - and - 150”]\t|[1,1,1,1,2,4]|   입출력 예에 대한 설명  지원자 정보를 표로 나타내면 다음과 같습니다.                  언어       직군       경력       소울 푸드       점수                               java       backend       junior       pizza       150                         python       frontend       senior       chicken       210                         python       frontend       senior       chicken       150                         cpp       backend       senior       pizza       260                         java       backend       junior       chicken       80                         python       backend       senior       chicken\t50                              “java and backend and junior and pizza 100” : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다.   “python and frontend and senior and chicken 200” : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다.   “cpp and - and senior and pizza 250” : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다.   ”- and backend and senior and - 150” : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다.   ”- and - and - and chicken 100” : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다.   ”- and - and - and - 150” : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.   문제풀이  이 문제만 잡고 거의 두시간을 풀었다…카카오 문제는 항상 풀때마다 유형도 새롭고 풀기도 까다로워서 공부하기 아주 좋은 문제들인 것 같다. 특히나 꼭 한가지의 개념을 정확히 알고 있어야 풀도록 나와서 그 개념을 모르면 시간초과가 계속 뜨거나 아예 풀 수가 없다.   이 문제는 일단 딕셔너리에 넣어서 푼다는 발상까지는 떠올릴 수 있지만, 중요한 것은 이진탐색을 알고 있느냐에 대한 문제였다. 이진탐색을 사용하지 않고 리스트에 접근해서 크기를 비교하면 무조건 시간초과가 뜬다.   어떤 리스트에서 특정 수보다 작거나 큰 수의 개수나 인덱스를 찾는 가장 빠른 방법은 이진탐색이다. 예를들어 a = [1,2,4,5] 에서 정렬된 순서를 유지하면서 3이 들어갈 수 있는 자리를 찾는경우, bisect 이진탐색을 사용하면 빠르게 찾을 수 있다.   1 2 3 a = [1,2,4,5]  print(bisect.bisect_left(a,3),bisect.bisect_right(a,3))   1 2 2   위처럼 3과 a를 매개변수로 넣어주면 a에서 3이 들어갈 인덱스인 2를 출력해준다.   이처럼 이진탐색은 순서에 맞는 위치를 찾는 방법이므로, 꼭 탐색전에 크기대로 정렬을 해주어야 메서드가 올바르게 동작한다.   만약 3보다 큰 숫자들의 개수를 알고 싶다면 다음과 같이 하면 된다.   1 len(a)-bisect.bisect_left(a,3)   1 2   그러므로 리스트에서 특정 요소가 들어갈 위치나, 특정요소보다 작은수, 큰수의 개수를 구할 때는 무조건 이진탐색을 이용하는 것이 시간복잡도가 가장 적게 문제를 풀 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import defaultdict from itertools import combinations import bisect def solution(info, query):     info_table = []     dic = defaultdict(list)     for i in info:         people = i.split()[:4]         score = int(i.split()[4])         for num in range(5):             for combi in combinations(people,num):                 dic[''.join(combi)].append(score)                       query_table = []     answer = []          for value in dic.values():         value.sort()     for q in query:         key = q.split()         score = int(key.pop())         key = ''.join(key)         key = key.replace('and', '').replace(' ', '').replace('-', '')         answer.append(len(dic[key])-bisect.bisect_left(dic[key],score))     return answer   1 solution([\"java backend junior pizza 150\",\"python frontend senior chicken 210\",\"python frontend senior chicken 150\",\"cpp backend senior pizza 260\",\"java backend junior chicken 80\",\"python backend senior chicken 50\"],[\"java and backend and junior and pizza 100\",\"python and frontend and senior and chicken 200\",\"cpp and - and senior and pizza 250\",\"- and backend and senior and - 150\",\"- and - and - and chicken 100\",\"- and - and - and - 150\"])   1 [1, 1, 1, 1, 2, 4]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%88%9C%EC%9C%84-%EA%B2%80%EC%83%89/",
        "teaser": null
      },{
        "title": "[Programmers] 괄호 회전하기 (Python3)",
        "excerpt":"문제 설명  다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.     (), [], {} 는 모두 올바른 괄호 문자열입니다.   만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다.   만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다.   대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x &lt; (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.   제한사항     s의 길이는 1 이상 1,000 이하입니다.   입출력 예  |s\t|result|  |:—:|:—:|  |”{}”|\t3|  |”}]()[{“|\t2|  |”[)(]”|\t0|  |”}}}”|\t0|   입출력 예 설명  입출력 예 #1          다음 표는 “{}” 를 회전시킨 모습을 나타낸 것입니다.  |x\t|s를 왼쪽으로 x칸만큼 회전\t|올바른 괄호 문자열?|  |:—:|:—:|:—:|  |0\t|”{}”|\tO|  |1|\t“](){}[”|\tX|  |2\t|”(){}[]”|\tO|  |3\t|”){}[](“|\tX|  |4\t|”{}”|\tO|  |5\t|”}{“|\tX|            올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다.       입출력 예 #2     다음 표는 “}]()[{“ 를 회전시킨 모습을 나타낸 것입니다.                  x       s를 왼쪽으로 x칸만큼 회전\t올바른 괄호 문자열?                         0       ”}]()[{“       X                 1       ”]()[{}”       X                 2       ”()[{}]”       O                 3       ”)[{}](“       X                 4       ”{}”       O                 5       ”{}]()[”       X              올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다.   입출력 예 #3     s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.   입출력 예 #4     s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.   문제풀이  괄호문제는 스택으로 풀었던 적이 있는데 또 까먹어서 괄호별로 딕셔너리를 만들어 숫자로 괄호가 닫혔는지 안닫혔는지 확인하다가 시간이 오래걸렸다.   자꾸 풀었던 알고리즘을 까먹는 것 같아서, 내일부터는 순차적으로 돌아가며 매일 다른 유형을 풀도록 해야겠다.   괄호가 만약 오른쪽으로 열린 괄호라면 스택에 넣어주고, 왼쪽으로 열린 괄호면 스택의 -1인덱스와 같은 지 확인해준뒤 같으면 stack.pop(), 다르면 append() 해주면 된다.  모든 반복문이 끝난 후 스택이 비어있으면 올바른 괄호이므로 answer+=1을 해준다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from collections import deque def solution(s):     q = deque(s)     answer = 0     if len(s) == 1:         return 0          left = ['[','{','(']     asci = {']':2,'}':2, ')':1}     for i in range(len(s)):         stack = []         for j in q:             if j in left:                 stack.append(j)             else:                 if stack and stack[-1] == chr(ord(j)-asci[j]):                     stack.pop()                 else:                     stack.append(j)         q.append(q.popleft())         if not stack:             answer+=1                      return answer   1 solution(\"[](){}\")   1 3   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B4%84%ED%98%B8-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] H-index (Python3)",
        "excerpt":"문제 설명  H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다.   어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다.   어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.   제한사항     과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.   논문별 인용 횟수는 0회 이상 10,000회 이하입니다.   입출력 예  |citations|\treturn|  |[3, 0, 6, 1, 5]|\t3|   입출력 예 설명  이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.  ※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다.   문제 풀이  이게 왜 2단계…?      근데 문제를 좀 헷갈리게 설명해놨다. 그래서 푸는시간보다 이해하는게 더 오래걸렸다.  코드   1 2 3 4 5 6 7 def solution(citations):     citations.sort()     l = len(citations)     for i in range(l):         if citations[i] &gt;= l-i:             return l-i     return 0   1 solution([3,0,6,1,5])   1 2   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/H-Index-2/",
        "teaser": null
      },{
        "title": "[Programmers] 더 맵게 (Python3)",
        "excerpt":"문제  매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.   섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)   Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.   Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.   #제한 사항     scoville의 길이는 2 이상 1,000,000 이하입니다.   K는 0 이상 1,000,000,000 이하입니다.   scoville의 원소는 각각 0 이상 1,000,000 이하입니다.   모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.   입출력 예  |scoville|\tK|\treturn|  |:—:|:—:|:—:|  |[1, 2, 3, 9, 10, 12]|\t7|\t2|   입출력 예 설명     스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.   새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5   가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]      스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.  새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13   가진 음식의 스코빌 지수 = [13, 9, 10, 12]   모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.   문제풀이  힙큐의 아주 기본이라고 할 수 있는 문제이다.     자꾸 몇개 틀려서 왜그런가 했는데, 힙큐를 사용하기 전에 정렬을 해주는 것을 까먹어서 계속 실패가 떴다. 예제가 정렬되어있는 문제는 항상 제한사항에 테스트 케이스가 정렬되는지 안되는지 꼭 확인 하도록 하자.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import heapq def solution(scoville, K):     new = 0     answer = 0     scoville.sort()     for i in range(len(scoville)-1):         new = 0         first = heapq.heappop(scoville)         second = heapq.heappop(scoville)          new = first + second*2         heapq.heappush(scoville, new)          answer +=1         if scoville[0] &gt;= K:             return answer             else:         return -1        1 solution([1, 2],7)   1 -1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8D%94-%EB%A7%B5%EA%B2%8C/",
        "teaser": null
      },{
        "title": "[Programmers] 프린터 (Python3)",
        "excerpt":"문제 설명  일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.      인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.   나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.   그렇지 않으면 J를 인쇄합니다.   예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.   내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.   현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.   제한사항  현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.  인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.  location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.   입출력 예  |priorities|\tlocation|\treturn|  |:—:|:—:|:—:|  |[2, 1, 3, 2]\t|2\t|1|  |[1, 1, 9, 1, 1, 1]|\t0|\t5|   입출력 예 설명  예제 #1     문제에 나온 예와 같습니다.   예제 #2     6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다.   문제 풀이  아주 기초적은 스택/큐 문제이다. 이것도 2단계라기엔 난이도가…  문제 그대로 만들어주면 풀 수 있다.   살짝 까다로운것은 숫자가 중복될 수 있어서 내가 원하는 location의 숫자가 출력됐을때 그 숫자가 원래 내가 원하던 자료인지인데, -로 마킹해주어서 풀었다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import deque  def solution(priorities, location):     priorities[location] = -priorities[location]     pri = deque(priorities)      count =0     while 1:         p = pri.popleft()         for i in pri:                         if abs(i) &gt; abs(p):                 pri.append(p)                 break         else:             if p &lt; 0:                 count+=1                 return count                  break             count+=1          return answer   1 solution([2,1,3,2],2)   1 1   노트  처음 본 라이브러리로 푼 코드가 있어서 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 def solution(priorities, location):     queue =  [(i,p) for i,p in enumerate(priorities)]     answer = 0     while True:         cur = queue.pop(0)         if any(cur[1] &lt; q[1] for q in queue):             queue.append(cur)         else:             answer += 1             if cur[0] == location:                 return answer   any는 요소중에 단 하나라도 참이면 True를 반환하는 함수이다. 여기서는 queue 안에 있는 요소를 하나씩 빼가면서 하나라도 출력예정 프린트보다 중요도가 큰게 있으면 True를 리턴하는데에 사용했다.   반대되는 함수로는 all이 있는데, all은 모두 참이어야만 True를 반환한다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%94%84%EB%A6%B0%ED%84%B0/",
        "teaser": null
      },{
        "title": "토스 NEXT 코딩 테스트 후기",
        "excerpt":"2021.08.12  방금 두시간 반여에 걸친 토스 채용 코딩테스트를 보고 왔다.      문제들 난이도는 그렇게 어렵지 않았는데, 신경써서 만든 문제들이다 보니까 유형도 새롭기도 하고, 무엇보다 잘 푼것 같은데 한 두개 테스트 케이스가 통과가 안되서 그거 붙잡다가 시간도 날리고 결국 풀지도 못해서 전체 문제의 반밖에 못풀었다…   사실 마저 풀어서 블로그에 올리려고 했는데.  문제 외부에 유출하면 안된다고 해서 오답노트는 개인적으로 해보려고 한다.   오늘 풀면서 느낀게 문제 푸는 방식을 조금 바꿔야겠다.     시간을 재고 시간안에 못풀면 틀리는 식으로 해서 많이 풀어야지, 하나 붙잡고 하다 버릇하니까 시간관리가 안된다.  그리고 문제 풀때 항상 노트를 갖고 필기를 하면서 풀도록 해야겠다. 막상 코딩테스트를 실제로 보니까 생각보다 머릿속에서 코드정리가 안되서 시간을 많이 낭비한 것 같다.   솔직히 뭐 될거라고 생각도 하나도 안했고, 문제도 잘풀거라 생각도 안하고 그냥 본 테스트인데.      생각보다 느낀점이 많은 것 같다. 앞으로도 코딩테스트 있으면 왠만하면 다 참가해보고 해야겠다는 생각이 들었는데,     솔직히 1년정도의 시간이면 자신 있을 것 같다는 생각이 들었다. 물론 뒤에 과제전형까지 다 포함해서…   다음 코딩테스트때는 더 나아진 실력으로 임하게 되도록 더 바짝 노력해야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%86%A0%EC%8A%A4-NEXT-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1080 행렬 (Python3)",
        "excerpt":"문제  0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.   행렬을 변환하는 연산은 어떤 3×3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 → 1, 1 → 0)   입력  첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.   출력  첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.   예제  예제 출력 2     3 4     0000     0010     0000     1001     1011     1001   예제 출력 1      2   문제 풀이  그리디 알고리즘 문제이다. 근데 문제가 너무 그리디 써서 풀면 풀겠지~ 하고 풀면 풀려서 조금 그랬다… 무조건 3*3을 뒤집는다는것 부터 그냥 처음부터 순서대로 계속 뒤집으면 풀릴 것 같아서 그렇게 풀었더니 쉽게 풀렸다.   근데 다 풀어놓고 for문 중첩을 많이해서 i,j를 두번 써버리는 바람에 뭐가 잘못된지도 모르고 한참을 헤맸다. for문 너무 중첩하지 말고 항상 함수로 분리해서 쓰는 습관을 들이자.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import sys   M,N = map(int,input().rstrip().split()) A = [list(map(int,input())) for i in range(M)] B = [list(map(int,input())) for i in range(M)]  result = 0 check = False      for i in range(M-2):     for j in range(N-2):          if A[i][j] != B[i][j]:                         for a in range(i,i+3):                 for b in range(j,j+3):                                         A[a][b] = 1-A[a][b]             result+=1  for i in range(M):     for j in range(N):         if A[i][j] != B[i][j]:             check = True  if check:     print(-1) else:     print(result)          1 2 3 4 5 6 7 8 3 4 0000 0010 0000 1001 1011 1001 2   1   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%ED%96%89%EB%A0%AC/",
        "teaser": null
      },{
        "title": "[BOJ] 10870 피보나치 수 5 (Python3)",
        "excerpt":"문제  피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.   이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.   n=17일때 까지 피보나치 수를 써보면 다음과 같다.   0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597   n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.   출력  첫째 줄에 n번째 피보나치 수를 출력한다.   예제 입력 1       10   예제 출력 1      55   문제 풀이  다이나믹 프로그래밍의 가장 기초인 피보나치 수열 구하기 문제이다.     다이나믹 프로그래밍이 어려워서 한번 다시 풀어보았다.  코드   1 2 3 4 5 6 7 8 n = int(input())      fibo = [0,1,1]  for i in range(3, n+1):     fibo.append(fibo[i-2] + fibo[i-1])      print(fibo[n])   1 2 10 55   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98-5/",
        "teaser": null
      },{
        "title": "[BOJ] 9095 1,2,3 더하기 (Python3)",
        "excerpt":"문제  정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.   1+1+1+1     1+1+2     1+2+1     2+1+1      2+2     1+3     3+1   정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.   출력  각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.  1 2 3 4 5 6 7 8 9 10 예제 입력 1      3    4    7    10  예제 출력 1    7    44    274      문제풀이  아 진짜 다이나믹 프로그래밍 너무 싫다. 이건 코딩이 아니라 수학문제 아니냐고…  수학적으로 점화식을 찾아야 한다는 생각으로 풀어야겠다. 아니면 다시 고딩때 배운 수열 점화식부분이라도 다시 봐야하나…   이 문제는 경우의 수를 쭉 숫자순서대로 쓰다보면 규칙이 나오는 걸 알 수 있다.   1의 경우 1개     2의 경우 2개     3의 경우 4개     4의 경우 7개     5의 경우 13개   자세히 보다보면, 5의 경우는 2,3,4를 더한 값, 4의 경우는 1,2,3을 더한순으로, 직전 세번째 숫자까지의 경우의 수를 더하면 해당 숫자의 경우의 수가 나온다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from itertools import permutations              result = [] T = int(input())  def solution(n):     if n == 1:         return 1     elif n == 2:         return 2     elif n == 3:         return 4     else:         return solution(n-1) + solution(n-2) + solution(n-3)      for i in range(T):     n = int(input())     print(solution(n))             1 2 3 1 4 7   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/1,2,3-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1463 1로 만들기 (Python3)",
        "excerpt":"문제  정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.      X가 3으로 나누어 떨어지면, 3으로 나눈다.   X가 2로 나누어 떨어지면, 2로 나눈다.   1을 뺀다.   정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.   입력  첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.   출력  첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.   예제   예제 입력 1             2   예제 출력 1          1   예제 입력 2          10   예제 출력 2         3   힌트  10의 경우에 10 -&gt; 9 -&gt; 3 -&gt; 1 로 3번 만에 만들 수 있다.   문제 풀이  이 문제는 다이나믹 프로그래밍, 즉 동적계획법으로 푸는 문제이다. 사실 그동안 다이나믹 프로그래밍 문제는 솔직히 뭔말인지 잘 이해가 안되서 안풀고 있었는데, 이제 모든 유형을 번갈아가면서 풀 예정이라 오늘 다이나믹 프로그래밍부터 풀어보았다.   다이나믹 프로그래밍은 작은 문제들을 해결해감으로써 큰 문제를 해결하는 문제로, 가장 좋은 예로 피보나치 수열이 있다. 피보나치 수열의 경우 n번째 피보나치 수는 n-1의 피보나치 수와 n-2의 피보나치 수의 합으로, 이미 계산한 결과를 통해 다음의 결과가 나오는 방식이다. 이렇게 이전의 작은 문제들이 큰 문제를 해결하는데에 필요한 알고리즘을 다이나믹 프로그래밍이라고 한다.   이 문제의 경우는 N을 1로 만들기 위한 최소의 경우의 수를 출력하는 문제였는데, 맨처음에는 if와 elif 문으로 3과 2로 나눠지는 경우, 1을 빼면 3이나 2로 나누어 지는 경우로 구분해서 다이나믹이라기보다는 그리디하게 3우선으로 나눠지면 최소의 경우의수가 나올 것이라는 가정으로 풀었다. 하지만 이 문제는 모든 상황에서 동일하게 이러한 가정이 맞지 않으므로, 다이나믹 프로그래밍으로 풀어야 했다.   1 부터 차례대로 생각해보면, 3의 경우의 수는 3으로 나누는 경우 1일때, 4는 자연스럽게 3을 만들기 위해서 1을 빼고, 3으로나누는 경우의수 2가 된다. 따라서 뒤의 숫자는 2나 3으로 나누어 떨어지지 않는다면, 반드시 이전의 숫자의 경우의 수에서 1을 빼주는 경우의 수가 추가가 될 수 밖에 없다. 2나 3으로 나누어 떨어지는 경우에는, 그 수를 2,3으로 나눠서 나오는 수의 경우에 수에서 1을 더한 값이 그 수의 경우의 수가 될 것이다. 그럼 1을 빼고 나누었을 때의 경우의수와 바로 2나 3으로 나누었을때의 경우의 수중에서 작은 값을 해당 인덱스에 저장해주면 된다.   따라서 배열에 0부터 3까지의 경우를 넣어준뒤, N까지 순차적으로 각 숫자의 대한 최소 경우에 수를 찾아가며 N에 다다르면 1로 만들기 위한 최소 경우의 수를 찾을 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 N = int(input()) dp = [0,0,1,1]  for i in range(4, N+1):     dp.append(dp[i-1]+1)          if i % 2 == 0:         dp[i] = min(dp[i], dp[i//2]+1)     if i % 3 == 0:         dp[i] = min(dp[i], dp[i//3]+1) print(dp[N])   1 2 10 3   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1932 정수 삼각형 (Python3)",
        "excerpt":"문제  1 2 3 4 5         7          3   8         8   1   0       2   7   4   4     4   5   2   6   5        위 그림은 크기가 5인 정수 삼각형의 한 모습이다.   맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.   삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.   입력  첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.   출력  첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.   예제 입력 1  1 2 3 4 5 6 5    7       3 8    8 1 0    2 7 4 4    4 5 2 6 5      예제 출력 1     30   문제 풀이  다이나믹 프로그래밍은 풀수록 더 머리가 아프다.      다른 알고리즘도 마찬가지지만, 다이나믹 프로그래밍 문제는 반드시 노트를 함께해야 헷갈리지 않게 빨리 문제를 풀 수 있을 것 같다. 그래도 이 문제를 머리를 싸매고 풀고나니 대충 다이나믹 프로그래밍을 어떻게 접근해야 하는지에 대해 좀 보이는 것 같다.   피보나치 수열과 비슷하게 생각해보면, 결국 아래의 요소는 위 왼쪽 대각과 위의 요소중에서 자신과 더했을때 더 큰값을 자신으로 바꾸면 가장 큰 수가 나오는 길이 어딘지 알 수 있다. 따라서 왼쪽위가 없는경우, 위쪽이 없는경우를 예외로 처리하고 나머지는 위 두 요소를 자신과 합했을 때 더 큰값을 자신으로 하게 하면 이 문제를 풀 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n = int(input()) triangle = [list(map(int,input().split())) for i in range(n)]  for i in range(1,len(triangle)):     for j in range(len(triangle[i])):         if j-1 &lt; 0:             triangle[i][j] += triangle[i-1][j]         elif j &gt; len(triangle[i-1])-1:             triangle[i][j] += triangle[i-1][j-1]         else:             triangle[i][j] = max(triangle[i][j] + triangle[i-1][j-1],triangle[i][j]+triangle[i-1][j]) print(max(map(max,triangle)))                                                     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 5 1 0 1 1 2 0 2 1 11 16 2 2 3 0 3 1 25 23 3 2 20 19 3 3 4 0 4 1 25 30 4 2 27 22 4 3 26 25 4 4 30   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EC%A0%95%EC%88%98-%EC%82%BC%EA%B0%81%ED%98%95/",
        "teaser": null
      },{
        "title": "[BOJ] 12865 평범한 배낭 (Python3)",
        "excerpt":"문제  이 문제는 아주 평범한 배낭에 관한 문제이다.   한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.   준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.   입력  첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.   입력으로 주어지는 모든 수는 정수이다.   출력  한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   4 7 6 13 4 8 3 6 5 12  예제 출력 1   14  문제 풀이  아무리 생각해도 안풀려서 풀이를 보고 풀었다. 이 문제는 DP중에서도 냅색(Knapsack) 알고리즘으로 풀어야 한다고 한다. DP는 참… 풀어도 풀어도 적응이 안된다.   냅색 알고리즘은     분할 가능 배낭문제 (담을 수 있는 물건을 나눌 수 있을때 ex) 설탕, 소금…)   0-1 배낭 문제 (담을 수 있는 물건이 나누어 질 수 없을때 ex) 담는다 or 안담는다)   분할하여 설명하면 다음과 같다.   1) x축에는 가방 1~K 까지의 무게, y축은 물건 N개 개수 만큼의 배열을 만들어준다.     2) 행을 차례대로 돌며 다음과 같은 알고리즘을 수행한다.   3-0) 현재 물건이 현재 돌고있는 무게보다 작다면 바로 [이전물건]같은무게를 입력해준다.      3-1) 현재 물건을 넣어준다. 물건을 넣은 뒤의 남은 무게를 채울 수 있는 최댓값(knapsack[i-1][j-weight])을 위의 행에서 가져와 더해준다.      3-2) 현재 물건을 넣어주는 것보다. 다른 물건들로 채우는 값(knapsack[i-1][j])을 가져온다.      4) 3-1과 3-2 중 더 큰 값을 knapsack[i][j]에 저장해준다. 이 값은 현재까지의 물건들로 구성할 수 있는 가장 가치 높은 구성이다.      5) knapsack[N][K]는 곧, K무게일 때의 최댓값을 가리킨다.   따라서 Knapsack[i][j]를 돌며 해당 i(물건)에 따른 j(무게)의 최댓값을 구하는 것인데, 무게인 j가 해당 물건의 무게보다 작은 경우는 가방에 넣지 못하므로, 앞의 물건의 최대값을 그대로 갖고, 무게 j가 물건의 weight와 같거나 크다면 해당 물건을 넣을수 있는 공간이 생겼다는 것이므로 그 물건이 없던값, [i][j-weight] 와 해당 물건이 들어가지 않은 값 [i-1][j]를 비교하여 더 큰값을 넣어주는 것을 반복하면 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 N, K = map(int, input().split())  feature = [[0,0]]  for i in range(N):     W,V = map(int, input().split())     feature.append([W,V])  Knapsack = [[0 for i in range(K+1)] for i in range(N+1)]  for i in range(1,N+1):     for j in range(1,K+1):         weight = feature[i][0]         value = feature[i][1]         if j &lt; weight:             Knapsack[i][j] = Knapsack[i-1][j]         else:             Knapsack[i][j] = max(value + Knapsack[i-1][j-weight], Knapsack[i-1][j])      print(Knapsack[-1][-1])         1 2 3 4 5 6 4 7 6 13 4 8 3 6 5 12 14   1 print(knapsack[N][K])   1 14   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%8F%89%EB%B2%94%ED%95%9C-%EB%B0%B0%EB%82%AD/",
        "teaser": null
      },{
        "title": "[BOJ] 1003 피보나치 함수 (Python3)",
        "excerpt":"문제  다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.   1 2 3 4 5 6 7 8 9 10 11 int fibonacci(int n) {     if (n == 0) {         printf(\"0\");         return 0;     } else if (n == 1) {         printf(\"1\");         return 1;     } else {         return fibonacci(n‐1) + fibonacci(n‐2);     }   fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.      fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.   fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다`.   두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.   fibonacci(0)은 0을 출력하고, 0을 리턴한다.   fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.   첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.   fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.   1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.   출력  각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   3 0 1 3 예제 출력 1   1 0 0 1 1 `  문제풀이  다이나믹 프로그래밍 문제로, 점화식을 만들어 풀면 된다.     맨처음에는 문제에 재귀함수가 그대로 나오길래, 엥? 왜 문제가 이러지 싶었는데 생각해보니까 저 재귀함수대로 0과 1을 호출할때마다 카운팅 해주면 무조건 시간초과가 날 수 밖에 없다.   그래서 1과 0을 저 재귀함수는 몇번씩 호출하는지 노트에 1부터 차근차근 써보니, 0은 N-1 과 N-2 의 0의 호출값을 더한 값이고, 1은 N-1의 0의 호출값과 1의 호출값을 더한값이었다. 따라서 이러한 점화식을 함수로 만들어주면 간단하게 풀 수 있다.   다이나믹 프로그래밍을 풀 때마다 느끼는거지만 이게 코딩실력을 테스트하기에 적합한가 싶다. 항상 코딩문제보다는 수학문제에 가깝다고 생각되니…   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 T = int(input()) result = []   def solution(N):     answer = [[1,0],[0,1]]     for i in range(2,N+1):         answer.append([answer[i-1][0]+answer[i-2][0],answer[i-1][0]+answer[i-1][1]])     return answer[-1]  for i in range(T):     N = int(input())     if N == 0:         result.append([1,0])     elif N == 1:         result.append([0,1])     else:         result.append(solution(N))      for i in result:     print(i[0],i[1])             1 2 3 1 40 63245986 102334155   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/",
        "teaser": null
      },{
        "title": "개발지원금 당첨되다...",
        "excerpt":"2021.08.18      토스에서 상위 50퍼센트 20명만 추첨해서 주는 100만원 개발지원금에 당첨되었다…     아니 이게 말이되나?? 거의 5000명이 지원한 시험에서 상위 50프로니까 2500명 잡고 0.8퍼센트 되는 아주 극악의 확률에 내가 당첨되다니… 사실 20명이라해서 기대를 안한 정도가 아니라 아예 까먹고 있었는데 메일을 받고 깜짝 놀랐다.   얼마전에 나이키 신발도 당첨되고 오늘도 그렇고 요즘 운이 너무 좋다…      모든게 잘풀린다 싶은 요즘 이런것 까지 족족 되버리니까 너무 행복하다.   사실 그동안 난 확률이 낮은 것들에 대한 기대가 몹시 낮아서, 항상 도전도 잘안하고 저게 되겠어~ 하는 마음가짐으로     그냥 귀찮아서 안했던 것들이 너무나 많았다. 하지만 아무것도 안하고 확률이 0인것과 도전하고 아주 극악의 1퍼센트도 안되는 확률을 얻는건 아주 큰차이라는걸 오늘 깨달았다.   누군가는 성공한 사람들의 성공에는 운이 매우 크게 작용했다고 하지만, 중요한 건 그 극악의 운을 만들려 모두가 귀찮아하고 두려워하는 일에 도전했기에 그러한 운이 당첨된게 아닐까 하는 생각을 해본다.   앞으로 공부 더 열심히 해야겠다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%86%A0%EC%8A%A4-NEXT-%EA%B0%9C%EB%B0%9C%EC%A7%80%EC%9B%90%EA%B8%88-%EB%8B%B9%EC%B2%A8%EB%90%98%EB%8B%A4/",
        "teaser": null
      },{
        "title": "[Java] 플레이그라운드 with TDD, 클린코드 - AssertJ (1)",
        "excerpt":"시작하면서…  자바로 간단한 프로젝트를 만들어보려 했는데, 그냥 무작정 혼자 만들다가는 나쁜 버릇이 들 것 같아서     강의 하나를 수강하기로 했다. 특히나 자바는 객체지향이라는 개념을 사용하는 언어이고, 난 대부분 절차지향 언어만  사용해봤었기 때문에, 아직 간단한 책 한권으로는 객체지향으로 정확히 어떻게 프로그램을 구현하는지에 대한 감이 없기 때문에,  오히려 이대로 혼자 프로젝트를 진행하면, 결과물은 그런대로 작동할 수 있겠으나 코드 자체는 유지보수가 어렵고, 객체지향의 강점이  하나도 드러나지 않는 나쁜코드가 될 거라는 생각이 들었다. 개발자로써 알고리즘 자체를 짜는 것도 중요하지만 모두가 같이 일하는 환경에서는 직관적이고 유지보수가 편하게 코드를 작성하는것도 아주 중요한 덕목이라는 생각이 들었다.   그래서 이러한 관련 강의를 찾다가 아주 평이 좋은 강의를 발견해서 수강하며 블로그에 남겨두려한다.     이 강의의 좋은 점은 내용도 좋지만, 주로 미션위주의 강의라 내가 직접 만들어보며 어떤게 잘못되었고 어떤게 올바른 코드인지 알 수 있다는 것이었고, 테스트주도형 개발도 함께 배울 수 있을 뿐만 아니라 실제 개발처럼 깃허브로 버젼을 푸쉬해가며 미션을 진행 해볼 수 있다는 것이었다. 그래서 별 고민없이 바로 결제하고 수강을 시작했다.   첫번째 미션은 숫자야구게임을 만드는것이다. 그럼 시작해보자.   단위테스트  자바는 대부분의 기능을 클래스로 구현해놓고, 그 클래스들을 메인메서드에서 동작시킨다.    메인 메서드는 프로그램을 시작할 뿐만 아니라 구현한 프로그램을 테스트하는데도 사용하는데, 테스트 주도 개발을 하려면 어떻게 메인메서드에서 구현한 프로그램을 테스트 할 수 있는지 알아야 한다.   그럼 간단한 사칙연산 프로그램을 만들어 프로그램을 테스트 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package TDD;  public class Calculator {     int add(int a, int b){         return a+b;     }     int subtract(int a, int b){         return a-b;     }     int multiply(int a, int b){         return a*b;     }     int divide(int a, int b){         return a/b;     }     public static void main(String[] args){         Calculator cal= new Calculator();         System.out.println(cal.add(3,4));         System.out.println(cal.subtract(5,4));         System.out.println(cal.multiply(2,6));         System.out.println(cal.divide(8,4));     } }   위 코드를 보면 클래스 Calculator에 해당하는 프로덕션 코드 부분과, main에 해당하는 테스트 코드 부분이 있다. cal이라는 인스턴스를 만들어 준 뒤, 아래에 사칙연산을 실제로 실행시켜봄으로써 이 코드가 정상적으로 작동하는지 확인해보았는데, 이러한 메인메서드 테스트는 문제점이 존재한다.   main method 테스트 문제점     프로덕션 코드와 테스트 코드가 하나에 존재한다. 이로인해 클래스 크기가 커지고 복잡도가 증가한다.   테스트 코드가 실제 서비스에 같이 배포된다.   main method 하나에서 여러 개의 기능을 테스트 하기 때문에 복잡도가 증가한다.   method 이름을 통해서 어떤 부분을 테스트 하는 것인지 알기가 힘듬   테스트 결과를 사람이 수동으로 확인해야한다.   이러한 main method를 사용한 테스트가 가지는 문제점을 해결하기 위해 등장한 것이 바로 JUnit 이다.   JUnit  JUnit은 단위 테스트 Framework로, System.out으로 번거롭게 테스트 케이스를 확인하지 않도록 해주는 도구이다. 프로그램 테스트 시 걸릴 시간도 관리할 수 있게 해주며, 오픈소스 플러그인 형태로 Eclipse에 포함되어있다. 개발을 진행하면서, 어느정도의 개발이 진행되면 반드시 프로그램에 대한 단위 테스트는 필수로 진행해주어야 한다.   그럼 단위 테스트를 어떻게 진행해야 하는지 알아보자.   String 클래스에 대한 학습 테스트  깃허브에서 내려받은 폴더에 있는 StringTest 클래스가 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 package study;  import org.junit.jupiter.api.Test;  import static org.assertj.core.api.Assertions.assertThat;  public class StringTest {     @Test     void replace() {         String actual = \"abc\".replace(\"b\", \"d\");         assertThat(actual).isEqualTo(\"adc\");     } }   replace 함수메서드를 실행하면 테스트가 가능하다.   그럼 StringTest에 다음 요구사항을 새로운 test case로 추가해보자.   AssertJ  여기서 요구하는 테스트를 하기 위해서는 AsserJ에 대해서 알아야한다.   AssertJ는 자바 테스트를 위해 좀 더 풍부한 문법을 제공하며, 메서드 체이닝을 통해 더 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리이다.   위의 replace를 테스트한 코드를 다시 살펴보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 package study;  import org.junit.jupiter.api.Test;  import static org.assertj.core.api.Assertions.assertThat;  public class StringTest {     @Test     void replace() {         String actual = \"abc\".replace(\"b\", \"d\");         assertThat(actual).isEqualTo(\"adc\");     } }  actual이라는 문자열 “abc”.replace(“b”,”d”), abc에서 b를 d로 바꾸는 객체를 만들고,  assertThat(actual).isEqualTo(“adc”) 로 실제로 replace 메서드가 우리가 원하는 값인 “adc”를 출력하는지를 확인해준다.   이처럼 AssertJ는 간편하게 테스트 코드를 작성할 수 있도록 도와주는 오픈소스이다.      그럼 몇가지 더 유용한 사용법을 한번 알아보자.   Test Fail Message  JUnit5 에서는 마지막 인자값에 as()를 통해 테스트 실패 메시지를 명시해주어 테스트가 실패했을때 출력되는 메시지를 만들 수 있다.   인물에 대한 정보를 담는 Character 이라는 클래스가 있고, 그 안에 있는 getAge() 메서드를 테스트 한다고하자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Person {     String name;     int age;     String tribe;      public Person(String name, int age, String tribe) {         this.age = age;         this.name = name;         this.tribe = tribe;     }      public int getAge(){         return age;     }     public String getName(){         return name;     }  }  이 Character 메서드는 이름, 나이, 종족을 멤버변수로 갖고, 나이를 반환하는 getAge()와 이름을 반환하는 getName() 메서드를 갖고있다. 우리가 만약 getAge() 메서드가 테스트코드에서 실패한다면, 이 이름의 사람의 나이를 확인해보라는 메시지 창을 띄우고 싶은 경우라면, 아래와 같이 AssertJ를 이용하여 코드를 작성할 수 있다.   만약 테스트코드가 실패하게 하면 이 사람의 나이를 다시한번 확인해보라는 문구를 넣고싶다면, 아래와 같이 하면된다.   1 2 3 4 5 6 7 8 9 10 11 12 @Test     public void Character() {         Character frodo = new Character(\"Frodo\", 33, \"HOBBIT\");         // failing assertion, remember to call as() before the assertion, not after !          assertThat(frodo.getAge()).as(\"check %s's age\", frodo.getName()).isEqualTo(100);     }           &gt;&gt;&gt; [check Frodo's age]  &gt;&gt;&gt; expected: 100 &gt;&gt;&gt; but was : 33  isEqualTo를 사용하여 우리가 원하는 기댓값과 같은 결과를 출력하는지 확인해보았고, 33이 나와야하지만 100이 나왔기 때문에 우리가 삽입해주었던 문장인 “check [이름] age” 문장이 출력되었다.   이렇게 유용한 메서드인 as()를 사용할 때 주의 해야할 점이 있는데, 바로 assertion이 수행되기 전에 사용해야한다는 것이다. 마지막에 as를 사용하면 에러를 동반하게 된다.      따라서 반드시 as()는 assertion이 수행되기 전에 사용해주어야한다.   Filtering Assertions  특정 filter를 자바 람다식을 이용하여 표현할 수 있는 유용한 기능이다. 아래 예제코드를 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package TDD;  public class Human {     String name;     int age;      public Human(String name, int age){         this.name = name;         this.age = age;     }      public String getName(){         return name;     }  }   Human 이라는 클래스를 만들어주고, name과 age를 멤버변수로 선언해준 뒤 나이를 가져오는 getAge()메서드를 만들어준다.     그리고 테스크 코드를 만들어 아래와 같이 작성한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test    public void filterTest() {        List&lt;Human&gt; list = new ArrayList&lt;&gt;();        Human kim = new Human(\"Kim\", 22);        Human park = new Human(\"Park\", 25);        Human lee = new Human(\"Lee\", 22);        Human jack = new Human(\"Jack\", 23);         list.add(kim);        list.add(park);        list.add(lee);        list.add(jack);         assertThat(list).filteredOn(human -&gt; human.getName().contains(\"a\")).containsOnly(park, jack);    }  filterdOn을 사용하여 안에 람다식을 통해 “a”가 포함된 단어를 필터링해주고, 이 추출된 단어들이 park과 jack이 맞는지 테스트 해주는 코드이다.   이처럼 filter 기능을 사용하면 특정 케이스들만 골라 올바르게 동작하는지 테스트 해볼 수 있다.   또 객체의 프로퍼티를 검증할 수도 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test     public void filterTest() {         List&lt;Human&gt; list = new ArrayList&lt;&gt;();         Human kim = new Human(\"Kim\", 22);         Human park = new Human(\"Park\", 25);         Human lee = new Human(\"Lee\", 22);         Human jack = new Human(\"Jack\", 23);          list.add(kim);         list.add(park);         list.add(lee);         list.add(jack);          assertThat(list).filteredOn(\"age\", 22).containsOnly(kim, lee);     }  위의 코드와 코드는 같지만, 프로퍼티에 접근해서 값을 검증하고 있다. age가 22인 객체는 kim과 lee이다.      만약 반대로 값이 포함되는 않는 경우도 아래의 메서드를 통해 간결하게 검증할 수 있다.      not   in   notIn   1 ssertThat(list).filteredOn(\"age\", notIn(22)).containsOnly(park, jack);  이렇게 하면 age가 22가 아닌 객체를 검증한다.   프로퍼티 추출하기  테스트르르 위해 리스트에있는 객체들을 검증하려면 반복문에서 이름을 하나하나 꺼내와서 또 다른 리스트에 담고 비교하는 과정을  거쳐야한다. 하지만 extracying()을 사용하면 아주 간편하게 해결할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test     public void filterTest() {         List&lt;Human&gt; list = new ArrayList&lt;&gt;();         Human kim = new Human(\"Kim\", 22);         Human park = new Human(\"Park\", 25);         Human lee = new Human(\"Lee\", 22);         Human jack = new Human(\"Jack\", 23);          list.add(kim);         list.add(park);         list.add(lee);         list.add(jack);          assertThat(list).extracting(\"name\").contains(\"Kim\", \"Park\", \"Lee\", \"Jack\");     }  위 코드 처럼  extracting을 사용하면, 알아서 name의 프로퍼티를 갖는 값들만 추출하여 검증해준다.   String assertions  String assertions는 다양한 메서드를 통해 간단하게 문자열을 검증할 수 있도록 도와준다.  1 2 3 4 5 6 7 @Test     public void string(){         String expression = \"This is a string\";          assertThat(expression).startsWith(\"This\").endsWith(\"string\").contains(\"a\");     }   위 코드처럼 직관적으로 startsWith이면 This로 시작하는지를 검증해주고, endsWith은 끝나는 단어가 string인지 검증해준다.   Exception 처리 테스트  AssertJ는 예외처리를 가독성있게 할 수 있도록 도와주는 assertThatThrownBy()라는 메서드를 제공한다.  기존의 에외 처리 테스트는  1 2 3 4 5 6 @Test     public void exception(){         Throwable thrown = catchThrowable(()-&gt; {throw new Exception(\"Error\");});          assertThat(thrown).isInstanceOf(Exception.class).hasMessageContaining(\"Error\");     }  이렇게 thrown 이라는 객체를 만들어 주어야 하지만, assertThatThrownBy() 를 사용해주면  1 2 3 4 5 @Test   public void exception(){      assertThatThrownBy(()-&gt;{ throw new Exception(\"Error\");})         .isInstanceOf(Exception.class).hasMessageContaining(\"Error\");   }  다음과 같이 가독성있게 코드를 짤 수 있다.   또 자주 쓰이는 예외처리에 대해서는 이미 정의된 함수를 제공하는데,      assertThatNullPointerException   assertThatIllegalArgumentException   assertThatIllegalStateException   assertThatIOException   다음과 같이 4가지이다. 사용법은 아래와 같다.  1 2 3 4 5 6 7 @Test    public void exception_example(){        assertThatIOException().isThrownBy(() -&gt; {throw new IOException(\"Error\");})                .withMessage(\"Error\")                .withMessageContaining(\"Error\")                .withNoCause();    }  자주 쓰이는 이 4가지 예외 타입이 아니라면, 다음과 같이 해주면 된다.  1 2 3 4 5 6 7 @Test    public void exception_example(){        assertThatExceptionOfType(IOException.class).isThrownBy(() -&gt; {throw new IOException(\"Error\");})                .withMessage(\"Error\")                .withMessageContaining(\"Error\")                .withNoCause();    }   그럼이제 과제에서 요구한 사항들을 하나하나 코딩해보자.   요구사항 1     “1,2”을 ,로 split 했을 때 1과 2로 잘 분리되는지 확인하는 학습 테스트를 구현한다.   “1”을 ,로 split 했을 때 1만을 포함하는 배열이 반환되는지에 대한 학습 테스트를 구현한다.   힌트     배열로 반환하는 값의 경우 assertj의 contains()를 활용해 반환 값이 맞는지 검증한다.   배열로 반환하는 값의 경우 assertj의 containsExactly()를 활용해 반환 값이 맞는지 검증한다.     1 2 3 4 5 6 7 8 9 @Test   void split(){       String[] actual = \"1,2\".split(\",\");       String[] actual2 = \"1,\".split(\",\");        assertThat(actual).contains(\"1\",\"2\");       assertThat(actual2).containsExactly(\"1\");    }          String 배열을 만들어 그 안에 “1,2”인 actual 과 “1,”인 actual2를 만들었다.      actual 들을 split() 메서드를 통해 나눠 준뒤, 우리가 원하는 결과값인 값을 만족하는지를 테스트 해줄 수 있다.       요구사항 2     “(1,2)” 값이 주어졌을 때 String의 substring() 메소드를 활용해 ()을 제거하고 “1,2”를 반환하도록 구현한다.     1 2 3 4 5 6 7 8 9 @Test  void substring(){      String actual = \"(1,2)\";      String subActual = actual.substring(1, actual.length()-1);       assertThat(subActual).isEqualTo(\"1,2\");    }          substring() 메서드로 괄호를 제거하고 출력갑과 기댓값이 같은지 확인하도록 구현하였다.       요구사항 3     “abc” 값이 주어졌을 때 String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져오는 학습 테스트를 구현한다.   String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져올 때 위치 값을 벗어나면 StringIndexOutOfBoundsException이 발생하는 부분에 대한 학습 테스트를 구현한다.   JUnit의 @DisplayName을 활용해 테스트 메소드의 의도를 드러낸다.   이 요구사항은 앞서 배운 예외처리의 두가지 방법으로 해결할 수 있다.     먼저 assertThatThrownBy( ) 로 구현하는 경우,  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //요구사항 3-1    @Test    @DisplayName(\"charAt()으로 특정 위치 문자 가져오기\")    void charAt1() {        String actual = \"abc\";         assertThat(actual.charAt(0)).isEqualTo('a');        assertThat(actual.charAt(1)).isEqualTo('b');        assertThat(actual.charAt(2)).isEqualTo('c');         assertThatThrownBy(() -&gt; {            char val = actual.charAt(3);            throw new Exception(\"범위 초과\");        }).isInstanceOf(IndexOutOfBoundsException.class).hasMessageContaining(\"String\");    }  이렇게 할 수 있고,       좀 더 가독성있게 코드를 짜고 싶다면 assertThatExceptionOfType을 사용하면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 //요구사항 3-2     @Test     @DisplayName(\"charAt으로 특정 위치 문자 가져오기 - assertThatExceptionOfType 으로 Exception 처리\")     void charAt2(){         String actual = \"abc\";         assertThatExceptionOfType(IndexOutOfBoundsException.class)                 .isThrownBy(()-&gt;{                     char val = actual.charAt(3);                     System.out.println(val);                     throw new Exception(\"범위 초과\");                 }).withMessageContaining(\"String\");      }  ","categories": ["java"],
        "tags": [],
        "url": "/java/%EC%88%AB%EC%9E%90%EC%95%BC%EA%B5%AC-(1)/",
        "teaser": null
      },{
        "title": "[BOJ] 2206 벽 부수고 이동하기 (Python3)",
        "excerpt":"문제  N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.   만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.   한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.   맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.   입력  첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.   출력  첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.   예제  1 2 3 4 5 6 7 8 9 10 11 예제 입력 1   6 4 0100 1110 1000 0000 0111 0000  예제 출력 1   15  1 2 3 4 5 6 7 8 9 예제 입력 2   4 4 0111 1111 1111 1110  예제 출력 2   -1  문제 풀이  맨 처음에는 맵을 돌면서 1인경우에는 벽을 깼다고 가정하고 잠깐 1을 0으로 바꾼뒤 dfs를 한번 돌리고, 끝까지 도달하면 result에 최단거리를 넣어주고 아니면 넣지않는 식으로 모든 1에 대한 벽을 깬 경우를 구했다. 이렇게 하니까 답은 같게 나왔지만, dfs를 모든 좌표마다 한번씩 실행하므로 시간초과가 떴다.   틀린 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 from collections import deque  n,m = map(int,input().split())    count = 0  dx = [1,-1,0,0] dy = [0,0,1,-1]  q = deque()  def dfs(graph):     visited = [[0 for _ in range(m)]for _ in range(n)]     q.append([0,0])     visited[0][0] += 1     while q:         x,y = q.popleft()                  for i in range(4):             sx = x+dx[i]             sy = y+dy[i]              if 0 &lt;= sx &lt; n and 0&lt;= sy &lt; m and graph[sx][sy] == 0 and visited[sx][sy]== 0:                 q.append([sx, sy])                 visited[sx][sy]= visited[x][y]+1                      if visited[n-1][m-1] == 0:         return -1     else:         return visited[n-1][m-1]      graph = []    for i in range(n):     graph.append(list(map(int, input())))  result = []  for i in range(n):     for j in range(m):         if graph[i][j] == 1:             graph[i][j] = 0             answer = dfs(graph)             if answer == -1:                 graph[i][j] = 1                 continue             else:                 result.append(answer)                 graph[i][j] = 1         else:              answer = dfs(graph)             if answer == -1:                 continue             else:                 result.append(answer)                  if result:     print(min(result)) else:     print(-1)   1 2 3 4 5 6 7 8 6 4 0100 1110 1000 0000 0111 0000 15   그래서 해답을 검색해서 보니, 3차원 배열을 사용하는 문제였다. 사실 해답을 보고도 3차원 배열로 하려니까 헷갈려서 생각을 하느라 어려웠는데, 역시 말로 보는것 보다 직접 코딩한번 해보는게 훨씬 이해가 빨랐다.   3차원 배열의 visited를 생성해준다. 원래 visited는 nm의 크기의 0이나 False를 갖는 이차원 배열이지만, 이번에는 nm 크기의 [0,0]을 갖는 3차원 배열이다. 원래의 dfs처럼 [0]의 인덱스의 값에 경로의 값만큼을 세주다가, 벽을 만나면 그 벽을 부쉈다고 가정하고 [1]의 인덱스에 경로를 저장하기 시작한다. 그럼 [0]의 인덱스는 벽을 부수지 않았을때의 최단경로이고, [1]의 인덱스는 벽을 부수고 갔을때의 최단경로가 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from collections import deque  def dfs():         q.append([0,0,0])     visited[0][0][0] = 1          while q:         x,y,z = q.popleft()         if x == n-1 and y == m-1:             return visited[x][y][z]         for i in range(4):             sx = x+dx[i]             sy = y+dy[i]              if 0 &lt;= sx &lt; n and 0&lt;= sy &lt; m:                 if graph[sx][sy] == 1 and z == 0:                     visited[sx][sy][1] = visited[x][y][0]+1                     q.append([sx,sy,1])                                      elif graph[sx][sy] == 0 and visited[sx][sy][z] == 0:                     visited[sx][sy][z] = visited[x][y][z]+1                     q.append([sx,sy,z])     return -1                      n,m = map(int,input().split())  count = 0  dx = [1,-1,0,0] dy = [0,0,1,-1]  q = deque() visited = [[[0]*2 for _ in range(m)]for _ in range(n)]      graph = []  for i in range(n):     graph.append(list(map(int, input())))  print(dfs())  answer1 = visited[n-1][m-1][0] answer2 = visited[n-1][m-1][1]      1 2 3 4 5 6 7 8 6 4 0100 1110 1000 0000 0111 0000 15   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/2206-%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0/",
        "teaser": null
      }]
