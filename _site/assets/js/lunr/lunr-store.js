var store = [{
        "title": "[BOJ] 2003 수들의 합 2(Python3)",
        "excerpt":"문제  N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.   출력  첫째 줄에 경우의 수를 출력한다.   예제  1 2 3 4 5 6 예제 입력 1   4 2 1 1 1 1  예제 출력 1   3  1 2 3 4 5 예제 입력 2   10 5 1 2 3 4 2 5 3 1 1 2  예제 출력 2    문제 풀이  아무리 풀어도 자꾸 시간초과가 떠서 몹시 화가났다…   맨처음에는 for문으로 하나씩 좌표를 방문해가며 0부터 해당 좌표까지의 합의 모든 경우의수를 구해 m과 비교했는데, 이러면 중복되는 계산이 많아 시간초과가 계속 뜬다.   이 문제는 투포인터로 풀어야 시간초과를 피할 수 있는 문제이다. 투 포인터는 왼쪽과 오른쪽의 두개의 포인터가 이동하면서 문제를 풀어내는 방식의 알고리즘으로, 중복이 적어 빠르게 좌표계를 이동하며 값을 얻을 수 있다.   start와 end를 각각 0과 1로 선언해주고, 이 포인터를 기준으로 슬라이싱해가며 합을 구한다. 합이 m과 같다면 경우의수를 세는 변수인 answer를 +1해주고, m보다 합이 작은경우는 end를 +1, m보다 크다면 start를 +1 해가며 모든 경우의수를 계산해준다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 n, m = map(int, input().split()) lst = list(map(int, input().split()))  start = 0 end = 1 answer = 0  while end &lt;= n and start &lt;= end:     hap = sum(lst[start:end])          if hap == m:         answer += 1         end += 1     elif hap &lt; m:         end += 1     else:         start+= 1       print(answer)                 1 2 3 4 2 1 1 1 1 2   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/2003-%EC%88%98%EB%93%A4%EC%9D%98-%ED%95%A9-2/",
        "teaser": null
      },{
        "title": "일기를 쓴다는 다짐",
        "excerpt":"2021.03.28  오늘부터 일기를 쓰기로했다.  요즘 월가아재라는 분이 고등학교때부터 20년가까이 쓴일기 블로그를 읽고있는데, 인생에대한 여러가지 고찰과 그때 그 때의 감정들을 짧게 모아놓은 것을 보니 마치 한편의 문학작품을 읽는 듯하여 큰 감동을 받았다. 마치 몇년 전 본 영화 보 이후드를 봤을때의 그런느낌. 그건 영화로 각색한 내용이기라도 했지, 이 일기는 정말 한사람의 실제적인 인생의 하루하루 의 발자취를 따라가는 느낌이라 마치 그 사람의 인생을 고등학교때부터 옆에서 지켜보는 느낌이 들었다.  그래서 사실 모두의 인생은 기록되지 않아서 그렇지, 기록한다면 한명 한명의 인생이 한편의 영화이고 문학작품이라는 생 각에 나도 일기를 쓰려한다. 그저 지나가는 인생의 순간들을 영화로 만들수는 없는 노릇이니, 나의 글로나마 이 블로그에 잡아두려는 생각?  원래는 인스타에다 쓸까 생각했지만, 호들갑 같기도 하고, 또 인스타그램이라는 플랫폼 자체가 글을 쓰기에는 적합하지가 않다 보니까… 어차피 누가 보리라 생각하지도 않고, 내가 볼거니까 사실 어디에 써도 상관없지만 그래도 어느정도의 책임 감을 갖기위해 공개적인 장소였으면 했다. 얼마나 오래갈지 모르겠지만, 나름의 루틴으로 만들어놓으면 꾸준히하지않을 까??  10년뒤, 누군가가 나의 블로그를 정주행하게 될때 이 첫 일기를 보면 무슨생각을 할까… 일기에 담은 나의 인생이 블로그를 보러온 누군가에게 인사이트가 되었으면 한다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%BC%EA%B8%B0%EB%A5%BC-%EC%93%B4%EB%8B%A4%EB%8A%94-%EB%8B%A4%EC%A7%90/",
        "teaser": null
      },{
        "title": "운동",
        "excerpt":"2021.03.29  아침에 일어나서 운동 후 피부과를 다녀왔다.  요즘따라 운동은 참 가성비가 떨어지는 행위중에 하나라는 생각이 든다.  한창 운동을 시작했을때는  나름 즐겁게 시작해서 우울하고 나약했던 내 스무살에 활력이 되어주기도 하여 고마운 마음에 어느덧 집에 벤치프레스까지 사다가  갖다놓을 정도로 재미를 붙인 취미였지만,  이제는 도통 몸이 슬슬  변하지 않는다.  물론 최근에는 변할정도로  열심히 하지도 않았거니와 식단을 제대로 한것도  아니지만, 그래도 이정도로 맨날 한시간씩 꾸준히  해주는데 성과가 안나오는건 좀 아니지싶다.  식단을하고 운동강도를 늘리자니 도저히  가성비가 안맞다는 생각도 들고…  몸만드는건 뒤지게 어려운데 그 리턴이 너무  작은것 같다.  겨우 얻을수있는거라곤 옷입으면 티도 잘안나는  몸이라니. 물론 빡세게 해서  옷밖으로 나오게 만들면 되지않느냐고 하지만,  그럼 더 큰 노력을 부어주어야하고,  사실 그건 나같은 나약이에겐 버거운 수준이다.  물론 몸을 열심히 멋지게 만드는 사람들이  가성비가 나오지도 않는 일을 한다고  폄하하는게 아니다.  사람마다 추구하는 가치는 다르고 누군가는 그  보상이 충분하다고 생각하기에 그렇게 열심히  운동을 하는것이니까. 오히려 그 고난의 길을  매일 걷는 그 사람들이 존경스럽다.  식욕을 끊어내고 그 무거운 바벨을 드는게  얼마나 고통스러운지는 깔짝 운동해본 나도 잘 아니까…  게다가 운동이 가진 긍정적인 힘을 나도  경험해봤기에 아주 잘안다. 사실 운동의 진정한  순기능이 아닐까? 몸이 아주 조금이라도 변하고 중량이 조금이라도 느는곳에서 아주 큰 긍정적 에너지와 자신감. 나도 물 론 크게 경험해봤고, 느껴봤지만…!!! 그래도 힘들고 하기 싫은걸 어떡해…  요즘따라 몸이 성치가 않다.  피부과에 가서 오늘도 약을 4개나 처방받아왔는데, 환절기가 되면 비염과 알러지 두피염 등등… 온갖 피부질환이 찾아온다.  원래는 이정도는 아니었는데 꼴에 나이를 먹는다고 나이가 들수록 심해지는것 같다.  갑자기 진짜 저런 어거지 단어가 없다라고 생각했던  반오십이라는 단어가 새삼 떠오른다.  이제는 진짜 건강관리를 해야할까…?  알러지로 벗겨진 눈꺼풀과 빨간 두피염을 보며, 그래도 운동을 더 열심히 해야겠다는 다짐이 든다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "비트코인",
        "excerpt":"2021.03.30  오랫동안 갖고있었던 코인이 어제 20프로가까이 올랐다.  그래서 원래 갖고있던 다른 코인종목을 처분하고 추격매수를 했는데 8프로대로 마감 후 오늘이 되니 약하락 상태이다. 어제는 돈을 잔뜩벌어 신났는데 다시 원상태로 돌아온 허무함.  오히려 다른 종목에서의 손실을 포함하면 잃었다.  주식과 비트코인등 각종 금융투자를 하면서, 인간의 욕심이 얼마나 지독한지 깨닫는다. 거기다 인간의 이성이란건 아주 흐릿해서 조금만 요동쳐도 이성이 마비되버리는데, 내가 얼마나 나약한 존재인지 깨닫게 된다. 욕심 때문에 팔아야할때 팔지못하고, 두려움 때문에 사야할때 사지못한다. 결국 인간의 감정이 0퍼센트로 관여되지 않는 기계만이 수익을 얻을수 있는것일까.  하지만 몇몇 주식시장에서 큰 수익을 내는 사람들을 보면  그들은 오히려 인간의 그 알수없는 뭔가의 느낌에 기대서 매매를 하기도 한다.  사실 인간의 알수없는 느낌으로 매매를 해서 돈을 번다는것이 이해가 가지않는다.  증권가 은어로 ‘메사끼’가 있다고 하는데 내가 생각하기엔  확률이 만들어내는 아주 운이좋은 확률의 수혜자가 아닐까 싶다.  가위바위보를 백번연속 이길 확률에 대하여 생각해볼 떄  불가능한 확률이라고 생각하겠지만, 101명이서 토너먼트로 가위바위보를 진행한다면  100번을 연속으로 우승하는 1등은 반드시 탄생하게 된다.  금융시장도 결국 버느냐 잃느냐의 50퍼센트의 확률의 반복이 일어나는 경우의 수로 본다면,  생각보다 연속으로 백번정도 이길확률은 물론 아주 적지만, 대한민국 총인구로 미루어보았을때,  그리 작은 확률은 아니다. 게다가 주식이나 비트코인의 상승이 크거나, 시드머니가 큰 경우는 백번 이길필요도 없기 때문 에, 확률 상 운이 좋게 돈을 버는 사람들은 꽤 많이 나올수 있다는 생각이다.  물론 버느냐 잃느냐가 장전체가 상승장이냐 하락장이냐에 따라 50퍼센트는 당연히 아니겠지만,  확률상으로 우연이 만들어준 주식고수가 탄생하기 쉽다는말이다.  사실 이런 생각이 무슨 생각이 있을까.  내가 돈을 벌지도 못하는데 그저 남의 성공이 운에 기대서 이루어졌다는 생각은 그냥 열등감일 뿐.   다시 욕심을 끊어내고  차가운 이성을 머리에 챙기고  그 머리가 멍해지는 차트를 보러 다시간다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/",
        "teaser": null
      },{
        "title": "메타디움",
        "excerpt":"2021.04.01  여러분 메타디움 사세요  메타디움 사면 돈을 그냥 준다니까?? 돈이 복사가 된다고!   문득 그런생각을 했다. 인간이 경제적 자유를  누리려면 얼마의 돈이 통장에 있어야할까?  뭐 굳이 경제적 자유라는게 진짜 원하는거  명품이고 뭐고 다 사는거 말고, 그냥 돈얼마있나  통장 안보고 먹고싶은거 남 사주는것도 아니고 그냥 내거는 다 사먹을 수 있는정도… 나이가 먹으면 모르겠지만 지금은  2천만원 정도 있으면 그냥  통장안보고 살 수 있지 않을까??  20대에는 행복의 허들이 굉장히 낮다는 생각이 든다 20대때 가지고있는 중형차, 아니 준준형 차는 30대의 외제차보다 효용가치가 높다는 말이있다.  하지만 인간의 욕심이 끝이없고 벌어도 벌어도 얼마만 더 있으면 좋겠다 생각이 들겠지…  오히려 지금의 천만원이 십년뒤의 1억보다 행복할 수도 있겠다는 생각을 했다. 요즘 데이트를 언제할지 정할때마다 통장 을 먼저보고 데이트할돈걱정을 하는내 모습이 좀 그래서 그냥 한번 생각해봤다.  오늘 메타디움이 많이 올라서  40만원을 넘게 벌었다.  맛있는거 사먹어야지.  예진이도 내일 맛있는것 좀 사줘야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%A9%94%ED%83%80%EB%94%94%EC%9B%80/",
        "teaser": null
      },{
        "title": "꽁돈",
        "excerpt":"2021.04.02  여자친구를 기다리며 공부를 하려고 일찍왔다.  나름 꾸준히 매일 일기를 쓰고 있는데  이거 블로그에다 내 사생활을 얼마만큼 여기다 써도되는지가 고민이다. 원래 남들한테 다 숨기면서까지 안보여주는게 일 기장인데 이걸 블로그에다 쓰자니 참 솔직하게 쓰기가 그렇기도 하면서 어차피 아무도 안볼텐데 뭘 걱정하지? 이런생각도 들고, 뭐 사실  사생활이랄게 나한테 있나 싶다  어제 돈을 꽤 벌어서 통장에 여유가 생겼다.  돈번 기념으로 친구를 데려다 대광어를 사줬는데,  투자로 번돈 꽁돈이라고 생각하고 막쓰다가는  빈털터리 되기 쉽상인걸 알면서도 솔직히 저번에  내가 추천한 종목 물렸던걸로 맘고생 한것도 있고해서 그냥 시원하게 사줬다. 내 아까운 4만원… 참 4만원 짜리 물건 살때 는 오만가지 생각을 다하면서 먹을걸 살때는 아무런 감정이 없으니, 인간의 식욕이 물건의 소유욕보다 상위에 있는것은 확 실한듯 하다.  아침에 아빠한테 전화가 와서 잔소리를 한참 들었다.  어제 코인으로 돈을 벌어서 돈을 너가 너무 쉽게 생각하는거 같다. 일해서 벌어봐야 돈의 소중함을 안다. 이런 이야기들. 난 전혀 돈을 쉽게 생각하지않는다. 세상사 어려운거 천지지만 돈만큼 어려운게 없다. 자본주의 사회에서 돈이가지는 위상 이 어느정도 인지 뼈저리게 알고, 쉽게 벌었다고도 생각안한다. 가기다가 벌때는 쓰러질듯이 벌기 힘들면서도, 써버릴때는 얼마나 쉬운가?? 막상 돈 쓸때는 그렇게 행복하지도 않다.  트레이더들이 괜히 각종 스트레스성 질병을 달고사는게 아니라는걸 요즘 절실히 느낀다. 차트위에 그려진 파란색만큼 끔 찍한게 있을까? 아무것도 사지않았는데 내 돈이 사라지는 느낌. 게다가 버는 행복은 잃을때의 불행에 비하면 체감상 십분 의 일정도도 안되는것 같다. 따라서 나의 모든 감정을 가져가고 남는건 그동안의 불행의 십분의 일정도되는 행복과 돈. 그 돈을 위해 감정적 스트레스를 등가교환함 셈이다. 이렇게 계속하여 이 스트레스의 수치를 감소시켜놓아야 한다. 아직도 투 자의 금액이 조금만 커져도 차트를 보는 시간이 늘어나고, 정신적 스트레스가 커진다. 이러한 스트레스와 계속 부딪히면서 무뎌져야 한다. 그러한 하락을 버틴자만이 수익을 낼 수있다.  오늘도 차트를 안보겠다는 다짐을 하며 어플을 지운다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%BD%81%EB%8F%88/",
        "teaser": null
      },{
        "title": "비, 그리고 단장과 봉사",
        "excerpt":"2021.04.03  비가 내린다.  3주째 연속 주말마다 비가온다.  저저번주 봉사갈때도 왔고 저번주에 봉사갈때도 왔고 이번주도 온다.  비가 내릴때 밖에 있으면 그것만큼 짜증나는 일이 없지만,  또 집에 누워서 빗소리를 듣고있자면 또 나름의 정취에 창문을 열고 그 소리를 가만히 듣고 있게된다.  오늘은 봉사 안가길 잘했다. ᄒᄒ  뭐 잠깐 설명하자면,  이번학기부터 작년 2학기에 들어갔던 봉사동아리의 단장을 맡게되었다.  2학년때 학교 중앙동아리 회장이후로 다시는 이런 동아리같이 득도 없고 힘들기만한 단체의 장은 맡지 않기로 결심했지만, 이 감투라는게 또 중독성이 있는건지 어쩌다 보니 2학기때 세번나간 동아리의 단장이 되어버렸다. 솔직히 중앙동아리 회장때 욕도 오질나게 먹고 힘든일도 많았어서 걱정했는데,  이번 동아리 회장은 솔직히 할만하고 재미도 있다.  동아리가 다른건지, 내가 그만큼 이 작은 단체의 회장은 담을만한 그릇이 된건지는 모르겠지만  새로운 사람들도 많이 만나고 또 좋은 인맥들도 많이 쌓는 것 같아서 나름 만족하고 있는 상태다.  사실 2학년때 회장시절을 돌이켜보면, 욕먹을만도 했다.  그때는 어떻게 행동해야하는지도 잘몰랐고 솔직히 맨날 놀기만 해서 일처리도 대충대충 했던것 같다.  동아리가 또 여초였어서 나름의 힘든점도 있기도 했고, 선배들도 좀 옛날 사고방식을 가진 사람이 많기도 했지만 그래도 그때 내가 그러한 위치를 담을만한 그릇이 아니었다는건 지금이되서야 깨닫는다.  난 항상 지금 내가 가장 이성적이고 어른스럽다 생각하지만, 돌아보면 항상 그때의 나는 어리석었고 비이성적이다. 혼자서 나름의 성찰을 하는것으로 위안삼아야할까. 그렇기엔 또 지금 이 정도면 다 큰것 같단말이지…  그래서 이번엔 나름 사람들 관리하는 스킬도 늘었고 낯도 많이 두꺼워져서 단장활동에 아주 만족하고있다.  그리고 원래 같으면 휴학하고 그냥 집 공부 여자친구 집 공부 여자친구 반복이었을텐데,  단장 활동으로 또 나름 서류처리할 것도 많고 만남도 잦아서 삶에 활기가 도는 느낌이다.  어제는 얼굴도 모르는 동아리 선배님이 밤에전화하셔서, 얼굴 한번 보고싶다고  오는 택시비 가는 택시비 다줄테니까 지금 올 수있냐고 하셨다.  또 막상 찍어보니 왕복 택시비면 10만원이 넘는 거리라서  그 분도 부담스러우실 것 같아 정중하게 담에 뵙자고 했지만, 너무 감동받았다.  세상에 어떤사람이 얼굴도 모르는 사람에게 한번 보고싶다고  오는 택시비, 가는 택시비 줘가며 와달라고 하겠는가. 너무 그 마음이 고마워서  다음에 부르시면 진짜 만사 제치고 가겠노라고 약속드렸다.  단장이라는 이유로 이렇게 누가 챙겨줄때마다 그 마음씨가 고맙고 이 단체에서 오는 소속감에서  뭔지 모를 따뜻함이 느껴진다. 나도 다음에 돈 많이 벌어서 후배 회장에게 저렇게 하겠다는 다짐도 하게되고… 저번주에 봉사가서 삽질을 오지게 하고오긴 했지만, 또 하루만 지나도 추억이니까…  그래도 매주 비도오고 추웠는데 2주 동안 꼬박꼬박 다 참여한것으로  단장의 책임감은 다한걸로 치고, 하루만 쉬어보겠다.  사실 뭐 아무도 내가 안간다고 뭐라안하겠지만, 이왕 하는거 책임감 있는 사람으로 남고싶다.  요즘따라 휴학하길 잘했다는 생각이 든다.  사실 이대로 졸업했으면 진짜 방향성없는 이상한 사람이 될뻔했는데,  1년정도 나라는 사람이 어떤사람인지, 내가 뭘하고싶은지, 나의 인생의 목표는 무엇인지 여유롭게 생각을 할 수 있게되어 너무 행복하다.  그저 생각뿐 아니라 지식면으로도 더 성장할 수 있는 1년 휴학이 되기를 바라며 비가 내리는 주말에 스터디 카페에서 몇자 끄적여본다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B9%84,-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EB%8B%A8%EC%9E%A5%EA%B3%BC-%EB%B4%89%EC%82%AC/",
        "teaser": null
      },{
        "title": "낭만이 있던 시절",
        "excerpt":"2021.04.04  일요일은 뭔가 늘어진다. 아니 사실 토요일도…  휴학하고 사실상 날백수 상태라 주말이란 개념이 없는 수준인데도, 요상하게 주말만 되면 늘어진다. 평소같으면 아침에 일어나서 운동부터 하고 아침이면 스터디카페에 왔을텐데  여섯시반에 깨버리더니, 자고 일어나니까 여덟시반, 밥 먹는다고 뒹굴거리다가 열두시가 되서야 집밖을 겨우겨우 기어나왔다. 어제 맥주를 먹어서 그런가 몸이 굼뜬 느낌이다.  어제는 오랜만에 보민이가 청라에 와서 맥주를 한잔 마셨다.  원래는 맨날같이 질리도록 보고 연락하던 동네친구들이 이제 나이를 먹었다고 여간 바쁜게 아니다. 자취하는 놈들은 얼굴 한번보기가 몇달에 한번이고, 이사간 놈은 진짜 반년에 한번이다.  그것도 내가 날잡고 정왕을 가야 볼 수 있으니, 이 얼마나 삭막한 일인가.  물론 코로나도 한몫한다. 코로나가 집에 있게 만들어 놓으니까 그게 적응되서 그런가  다들 밖에 나오려고들을 하지않는다. 이렇게 코로나로 마스크를 쓴지도 어느덧 1년  나만 적응이 안된건지, 나는 아직도 이 생활이 너무나 불편하다.  그런 소재의 영화들이 있다. 엄청난 질병이 창궐하여, 모두가 고립되고 군대가 길거리를 통제하며, 시민들은 마스크를 쓰고 다니고 사회 시스템은 마비, 경제는 대공황… 모조리 혼돈의 카오스… 물론 영화처럼 그런 혼돈의 카오스는 일어나지않았다지만,  이런일이 내 인생에 직접 들이닥칠 줄이야. 한치 앞도 모르는게 세상일이라지만,  무슨놈의 병이 영화마냥 창궐해서 맨날 마스크를 쓰고 다녀야하고, 모든 축제와 행사는 사라졌으며 모든 식당은 10시면 닫아 버리는 이러한 사태를 내가 겪고 있다니, 얼탱이가 없다.  어제도 맥주를 먹다 10시가 되서 밖을 나와 한참을 방황하다가 엑슬루 1층에서 그냥 앉아서 마저남은 이야기를 나눴다. 그마저도 11시에 쫓겨나, 재밌는 이야기 시작도 못하고 집에 와버렸다.  개같은 코로나.  코로나가 뺏어간것들은 수도 없이 많지만,  내가 가장 짜증나는건 내 인생에 낭만이란것들을 뺏어갔다는 거다. 밤늦게 친구들과 맥주를 마시거나, 문득 혼자 영화관에가서 영화를 보고 여자친구 손을 잡고 봄꽃길을 걷는 그런것들 말이다.   코로나가 생기기전의 삶을 생각해보면, 참 낭만적이고 행복했다는 생각이 든다. 활기를 띄는 대학교, 봄꽃을 보러온 사람들, 북적북적한 번화가…  사람은 이렇게 꼭 뭔가를 뺏겨야 그 시절이 행복했다고 깨닫는다.  인생은 저때가 좋았지… 저때가 행복했지…하며  그 순간엔 그게 행복인지도 모른채 그 순간을 떠나보내는것의 반복인것 같다.  코로나가 없어지고 저 행복을 다시 돌려받게되도 한달, 아니 일주일이면 또 익숙해져서 다시 저 행복을 막 대하게 되겠지…  그래도 진짜 한번만 다시 돌려줘라 내 행복…소중하게 대해줄게 제발.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%82%AD%EB%A7%8C%EC%9D%B4-%EC%9E%88%EB%8D%98-%EC%8B%9C%EC%A0%88/",
        "teaser": null
      },{
        "title": "영어",
        "excerpt":"2021.04.05  4월의 첫 월요일이 왔다. 2021년의 4분의 1이 지나버렸다는 뜻.  1년이 참 긴것 같으면서 짧다. 작년도 사실 너무나 빨리 지나가버렸는데, 이게 코로나 때문에 더 심한 것 같다. 오늘은 아침에 일어나서 운동을 하고 와서 아침에 뉴욕타임즈 모닝 브리핑을 한번 쓱 읽고 스터디카페로 왔다. 근데 뉴스읽고 빠릿빠릿하게 왔어야 했는데 또 잠깐쉰다는게 한시간 내리 쉬어버리고 여기왔다.  왜이렇게 인간은 나약한것인가… 또 이렇게 후회할거면서 말이야  오늘부터 영어공부를 같이 시작했다.  사실 영어에 대해 크게 고민하고 있지 않았고, 내심 불안하기는 해도 나중에 몰아서 해버리면 된다는  안일한 생각때문에 영어 공부를 열심히 한적이 없다. 이렇게 피일차일 미루다 나중에 고생한다는거 알면서도 지금은 영어보다 다른 공부가 중요하다는 생각에 미뤄왔었다.  근데 공부를 해보면 할수록 영어가 얼마나 중요한지 절실히 깨닫는다.  특히나 데이터사이언스의 대부분의 정보는 영어로 되어있고, 어떠한 학문이던지 최신논문에서  트렌드를 읽어내려면 영어 독해 능력은 필수다. 심지어 변화가 빠르고 트렌드가 자주 바뀌는 이러한 업계들은. 상시 새로 쏟아져 나오는 논문들어 읽어내야 한다.  새로운 지식들과 새로운 시야를 가지려면, 새로운 언어를 익히는만큼 쉬운방법도 없다는걸 알면서  나는 왜 맨날 이 공부를 미뤄왔을까…  어릴때 집안 기둥을 뽑아서라도 외국에 살다왔어야 했다는 생각이 들었다.  어차피 그때 갔다와봤자 영어실력은 안늘고 놀다오기만 했을것 같기도하고…  그래서 어제 영어공부에 대해 고민을 저녁내내 했다.  토익을 하자니 내가 원하는 공부방향이 아니었다. 난 지금 토익 점수도 중요하지만 이번 휴학기간동안 영어 그 자체의 언어에 대한 실력을 키우고 싶었다. 실제 쓰는 회화나 표현들을 습득해야 하는데 토익은 좀 내가 원하는 방향성과 안맞을 뿐더러, 지금 그만큼의 시간을 투자할 여유가 없다.  드라마 같은거나 영화는 좀… 공부하는건지 안하는건지 모르겠다는 생각.  그래서 그냥 어제 뉴욕타임즈를 구독해버렸다.  하루에 무조건 아침에 한시간내지 두시간은 뉴욕타임즈를 독해하기로 했다.  원래는 경제지식도 좀 얻고, 나름의 어려운 용어들이 섞여있는 이코노미스트를 구독하려 했는데  너무 비싸다. 언제 쯤 되어야 저정도 돈은 자기계발을 위해 쓸수 있게되는걸까.  어쨌든 시사지식도 얻을 수 있고 영어공부도 되니 일석이조라는 생각에 구독했는데,  이게 생각만큼 안읽힌다. 그래도 어느정도 의미파악은 될줄 알았는데 전혀 읽히지가 않는다. 어느정도 친숙하고 내용을 알고있는 기사같은 경우는 문장의 모호한 부분이 예측이 되지만, 오늘 읽은 요르단 왕자 구금에 대한 기사는 배경지식이 전혀 없으니,  인물 관계가 복잡한게 이해가 도통 안되서 기사 하나를 삼십분을 넘게 해석했다.  너무 안읽혀 짜증나 죽는줄 알았지만, 뭐 나름 공부하는 기분 안들고 재밌게 읽고왔다.  이러한 공부의 가장 중요한점은 매일매일 꾸준히 하는게 거의 80퍼센트니, 하루도 안빠지고 할수 있도록 루틴으로 만들어서 자연스럽게 무조건 읽는다고 생각해야겠다.  올해의 목표는 영어로 된 온라인 강의를 완벽하게는 아니더라도  검색해보면서 들으면 들을 수 있을 정도로 영어실력을 키우는것이 1차 목표, 내년까지 꾸준히 해서 내후년에는 미국에 있는 학교의 온라인 석사 학위를 따보는게 일단 현재 시작한 영어공부의 최종목표다.  단기적으로는 무작위성이 작용하여 어떻게 될지 모르지만,  장기적으로 우상향하는 추세는 확실하게 보이게 된다. 머나면 목표일지라도 추세를 만들도록 꾸준히 노력하자.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%98%81%EC%96%B4/",
        "teaser": null
      },{
        "title": "연아퀸",
        "excerpt":"2021.04.06  아침에 오지게 뒹굴다 두시가 다되어서야 여기왔다.  뉴욕타임즈는 읽었지만 그걸 감안해도 너무 나태했다.  이따 저녁에 회의겸 술자리도 있어서 오늘 공부시간이 더 적을텐데 왜 더 뒹굴게 되는것일까…   사람들이 흔하게 저지르는 실수중에 매몰비용의 오류가 있다.  어떠한 일이 잘못되어가고 있음을 알고있는데, 그동안 투자한 비용과 시간이 아까워 쉽게 포기하지 못하는 경우들. 근데 그 반대라고 해야하나? 이것도 무슨 오류가 있는지는 모르겠지만 사람 심리가 그런게 있는것 같다.  예를들어 오늘같은 경우이다. 어차피 놀건데 오늘 그냥 하루 통으로 놀아버릴까?  하는 생각이 들어 더 시간을 낭비하게 된것 같다.  인간의 생존본능중에 어떠한 점과 직결되길래, 이런 유혹은 이렇게나 달콤한걸까…  돈을 쓸때도 마찬가지이다. 이왕 쓰는거 아끼면 좋은데, 조금만 금액이 커져도 에이 그냥 쓰는김에 쓰지 뭐~ 하면서 불필요한 지출을 해버리는건 늘상 있는일이다.  그리고 트레이딩을 할때는 또 얼마나 멍청한가? 천천히 분할 매수하고 분할 매도 하면 되는것을,  눈앞의 호가창의 흔들림을 보다보면 내 차가웠던 이성은 덩달아 흔들려 마치 내가 지금사지않으면  이 차트가 날아가버릴것 같은 망상에 빠져들고는 한다.  결국 한번에 급하게 풀매수.  사람들은 왜이렇게 똑똑한 머리를 갖고도 멍청한 짓을 반복하며 사는걸까…  이성이란게 너무나도 약하다고 느껴질때마다,  우리도 결국 본능에 충실해 사는 동물의 유전자의 노예라는 생각이 든다.  인생이란건 결국 유전자의 새겨진 짐승의 본능과 감정들을 끊어내고, 본능을 쫓는 짐승이 아닌 인간이라고 증명해내는 과정인것 같다.   김연아가 했던말이 문득 떠오른다.  ‘무슨 생각을 하면서 스트레칭하세요??’ ‘무슨 생각을 해… 그냥 하는거지…’  저래야 성공하나보다…  그냥 생각하고 재지말고 그냥 하자.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%97%B0%EC%95%84%ED%80%B8/",
        "teaser": null
      },{
        "title": "안주",
        "excerpt":"2021.04.07  오늘은 데이트라 공부를 안한다.  내일도 안한다. 그래도 셤기간이라 봉사를 안가도  되니까, 주말이 여유로워 그때 보충할 생각이다.  어제 슬슬 하던 공부가 재밌어지는걸 느꼈다.  이제 코딩 기본적인걸 다 떼서 어느정도의 데이터  가공이 가능해지니까 시간가는줄 모르고 어제 코딩을 했다. 역시 기초통계학 먼저 하기보다 프로젝트를 하나 잡고 실제적 인 결과를 내면서 이론을 병행하고자 했던 방향성이 더 나에게 맞았던것 같다.  이론으로 기초를 탄탄히 하고 시작하면 물론 그 나름의 장점이 있겠지만, 내 성격에는 동기부여도 안될뿐더러, 어디다 써 야하는지 방향성을 모르고 이론만 줄창하게 되어서 싫었다. 아직 갈길이 천리만리이지만, 남들과 경쟁하는것도 아니고 나 의 실력을 천천히 쌓는과정이라고 생각하며 하루하루 꾸준히 하는것. 그게 목표다. 한걸음씩 눈앞만 보면서 걷다보면, 뒤 를 돌아봤을때는 꽤 많은 걸음을 내딛은  이후일테니까.   내일은 유튜브 촬영을 하기로했다. 무려 조원희 선수랑 염기훈 선수랑 축구를 한다. 말이 안된다.  어떻게 이런기회가! 이래서 인맥이 중요하고 친구를 잘둬야 하나보다. 보민이가 슛포러브 여행 다녀온걸 보고 너무 부럽 고 신기했는데, 그 콩고물이라도 좀 받아먹는것 같아서 다행이다. 어제 보민이가 물어보자마자 진짜 뒤도안돌아보고 수락 했다. 살다보면 공부보다도 이러한 소중한 경험을 할 기회가 더 중요하다는 생각이 든다. 내가 살면서 저런 대단한 사람과 축구를 하고 유튜브에 나올일이 뭐가 있는가!!  벌써 너무 기대가 된다. 심지어 돈도 준다니…   이렇게 돈내고도 할 수 없는 경험을 돈받고 한다니 내일이 너무나 기대된다. 한편으로는 근데 우리같은 쩌리 다섯명이 진 짜 필요한건지 의문이다. 막상 가면 우리같은 애들 한 30명있는거 아닌지 모르겠다…   그래도 30명중에 한명이면 어떠냐.  앞으로 50년간 술자리 안주가 필요없지 싶다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%95%88%EC%A3%BC/",
        "teaser": null
      },{
        "title": "이거해조 원희형",
        "excerpt":"2021.04.09  한시가 넘어서야 비몽사몽 일어났다.  일곱시에 깼지만, 애매하게 공부하러 일어나야하는데… 더 자고싶은데… 라는 두개의 생각이 겹쳐서  제대로 잠도 못자고 공부도 못하고 운동도 못하고 죽도밥도 안됐다. 이럴거면 그냥 편하게 잠이나 잘걸.  가끔 그냥 포기해버리고 쉬어버리는 선택이 종종필요한걸까 아니면 이거마저 극복하고 책상에 앉아야 하는걸까… 아니 근데 내 체력이 줄어든건지, 오랜만에 뛰면 원래 그런건지 사실 어제 촬영가서 뛴건 30분도  안 뛴것 같은데 어제부터 해서 오늘 아침까지 진짜 죽는줄 알았다.   요즘 유산소를 안하긴 했지만 이정도로 내 몸이 약해졌을 줄이야. 아침에 유산소까지 포함해야 되나 싶다.  어제 촬영은 굉장히 재밌었다. 그런 프로축구선수가 축구하는 모습을 하는것도 신기했고  우리가 그 선수 돌파를 막아볼일이 뭐가 있겠는가. 끝나고 사진도 오지게 찍었다.   조원희 선수, 염기훈 선수 둘다 진짜 멋있고 완전 젠틀했다. 촬영 내내 자신들이 제일 힘들텐데  우리한테 힘들겠다고 걱정해주고, 분위기도 계속 띄우시려고 노력하시는 모습이 역시 프로답다는 생각이 들었다. 촬영도 한시간 연장되고, 날씨도 더웠으며, 컨텐츠 자체도 엄청 어려운 미션을 될때까지 계속 하는거라 굉장히 짜증도 나고 화도 좀 낼법한데, 진짜 끝날때까지 불평 하나도 없이 스태프들이랑 분위기 띄워가면서 진짜 될때까지 계속했다. 특히 세션부분이 진짜 한시간넘게 걸렸는데, 그 체력이 존경스러웠다. 한 스무번은 넘게 시도했는데 아마 일반인이었으면 열번도 못하고 쓰러졌을거다. 근데 더 놀라운건 그렇게 체력을 소모하고도  혼자서 우리 다섯명을 달고 다니며 날아다니셨다. 사실 1대5 자체는 우리가 너무나 유리해서  처음에는 우리가 우세했는데, 우리가 간과했던건 프로와의 체력차이였다.  초반에야 당연히 5명이니 한명이 뚫기가 어려워 실패했지만, 시도가 계속 될수록 프로선수와의 체력격차가 났다. 전력질주 몇번에 우리는 체력이 동나버렸고, 마지막 갈때쯤에는 진짜 쫓아갈 수가 없었다.  솔직히 처음에는 생각보다 쉽게 막아서 역시 프로도 다구리앞에 장사 없다 싶었지만, 일반인과 비교할 수 없는 체력이 정말 놀라웠다…   그리고 추가로 유튜브 진짜 쉽지않다는 생각이 들었다.  일단 텐션이 미쳐버렸다. 편집된 영상으로 볼때야 음악도 있고 편집도 속도감이 있어서 그냥 별생각 없이 보지만, 라이브는 굉장히 조용하고 스태프들도 많아서 그렇게 자연스럽게 하기 굉장히 민망한 분위기이다.  근데 진짜 녹화 시작하자마자 미쳐버리는 텐션의 조원희 선수를 보고 역시 프로는… 다르구나..  라는 생각이 들었다. 방송이 쉬운일이 아니구나 싶었다.  어쨌든 대기시간도 길었고 햇빛도 쨍해서 끝나고 완전히 녹초가 되었지만, 진짜 재밌는 경험이었고 앞으로 평생 못잊을 경험을 한것 같아 너무 좋았다.   추가로 유튜브는 담주 화요일날 올라올 예정이라고한다.  이틀이나 공부를 쉬었으니, 오늘부터 다시 또 열심히 해야지…  나도 누군가가 나와 함께했던 순간이 인생에 특별한 경험이 되는 사람이 되고싶다는 생각이 들었다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%B4%EA%B1%B0%ED%95%B4%EC%A1%B0-%EC%9B%90%ED%9D%AC%ED%98%95/",
        "teaser": null
      },{
        "title": "천만원",
        "excerpt":"2021.04.12  우스갯소리로 맨날 아빠한테 했던 소리가 있다.  ‘나 천만원만 줘요~~ 진짜 투자좀 시드있게 해보게~’  ‘천만원 아들 주고 맘대로 해보라고 해보는게 진짜 인생경험이라니까???’ 그럴때마다 우리 아빠는 넌 돈의 무게를 너무 가볍게안다. 직접 벌어봐야 한다. 이렇게 말씀하시고는 했다.  이상하게 나는 천만원에 대한 동경이 있었다. 이 블로그에 한번 쓴적도 있듯이 뭔가 지금 나이에는 천만원이 있으면 모든게 해결될 것 같은 그런 기분, 마치 최저시급 만원마냥 근거도 없고 논리도 없지만 왠지 그 쯤은 있어야하지않나~ 했던 생각들. 마치 천만원이 있으면 나의 경제적인 자유가 확보될듯한 꿈같은 이야기… 주식이나 비트코인 할때도 항상 입버릇 처럼 천만원은 벌어야지~ 를 달고 살았다.   근데 갑자기 덜컥 천만원이 생겨버렸다.  아빠는 어릴때부터 그랬다.   내가 뭘 말하면 그에대해 잔소리를 겁나게 하시고는,  이내 나를 믿고 항상 그대로 하게 해주셨다.  컴퓨터 사달라 했을때도 그랬고, 핸드폰 사달라 할때도 그랬고, 휴학한다고 했을때도 그랬고, 집팔리게 청소 빡세게 하면 백만원 준다고 했을때도 집팔렸는데 바로 안주고 잔소리 겁나게 하고 줬다. 맨날 어차피 줄거면서 왜 이렇게 잔소리를 하고 주는지 싶었는데,  천만원도 줄줄이야…   오랜만에 아빠의 눈물을 봤다.  살면서 아빠가 우시는 모습을 본게 손에 꼽는다.  나만이 아니라 모든 아들들이 아빠의 눈물을 볼 일은 흔치 않을테지만,  내가 기억하기로는 태어나서 두번째 눈물이다.  첫번째는 4년전 집앞 꼬치집에서 나한테 이혼을 말하시며 미안하다고 하셨을 때인데, 난 아직도 그때 그 꼬치집에서의 순간이 마음 한켠에 남아 아리게 남아있다.   아빠는 내가 어릴때부터 투자에 관심이 많으셨다.  주식부터 부동산까지 모든 투자를 항상 해오셨고, 부동산은 관련학과로 새로 공부하여 대학교까지 졸업하셨다.  항상 공무원의 대출의 유리한점을 이용해 부동산을 구매해오셨고, 주식도 꾸준히 매매하며 재산을 불렸다.  돈에 대해서 항상 잔소리하시고, 아끼고 사셔서 누가보면 구두쇠라 하는 사람도 있을 수 있겠지만  나한테는 돈을 아끼신 적이 없었다. 용돈은 항상 또래 이상의 수준이었고, 난 태어나서 내가 원한걸  못가져본적이 한번도 없다. 악기를 한달마다 때려쳐도 새로운 악기를 원하면 항상 사다주셨고, 배우고 싶은게 있으면 항상 다 시켜주셨다. 성인이 되서도 올림픽 보고 삘받아서 유도 배우고 싶다니까 유도도 시켜줬다.   가족들 하고싶은건 다 해주시고는, 자기쓸돈은 아껴서 악착같이 투자하셨다.  그렇게 모으고 레버리지를 땡겨서 투자한 돈은 경제상승의 기류를 타고 흐르고 흘러 점점 몸집이 불어났고,  중간에 이혼으로 인해 주춤하기도 했지만, 불어난 돈은 아파트를 두채나 구매하게 만들었고  마침내 얼마 전, 크게 오른 아파트를 처분하고 레버리지를 전부 청산했다.  (물론 정부의 정책으로 인해 반강제로 처분하긴 했지만.) 아파트가 팔리고,모든 빚이 없어진 날,  아빠는 내가 해준 안주와 소주 한병으로 그 날을 자축하셨다. 25년 가까이 하신 투자가 결실을 맺은 순간이었다.   어제는 할아버지가 백신을 맞으셔서 경과도 지켜보고, 이사온 집도 구경할 겸  새로 이사온집에 오셔서 주무시고 가셨다. 오랜만에 3부자가 아라뱃길 나들이를 좀하고, 점심을 어죽을 먹었다. 저녁엔 회와 소고기를 먹으며 아빠와 할아버지는 소주한잔을 하시며, 오랫동안 이야기를 나누셨다.  그리고 다음날, 할아버지는 아빠에게 천만원짜리 수표를 주셨다. 새차 사는데 보태라시면서…  아빠는 그 천만원을 보고 생각이 많아지셨는지 눈물을 보이셨고, 난 태어나서 두번째로 아빠의 눈물을 봤다.  아빠는 그 돈을 새차에 보태지 않으셨다.   내가 농담처럼 하던 말을 맘에 담아두셨던걸까. 그 수표를 나에게 건네셨다.  너가 쓰고싶은데 쓰라고, 너의 미래를 위해서 쓰라고, 그렇게 천만원이 덜컥 생겨버렸다.  막상 천만원이 생기니 경제적 자유같은건 하나도 생각이 안난다.  이 돈을 어떻게 불려야 할까. 어떻게 내 미래를 위해 사용해야할까.   난 태어나서 통장에 200위로는 모아본적이 없는데, 이렇게 덜컥 큰돈이 생겨도 될까.  사람은 돈을 담을 수 있는 그릇의 크기가 정해져있어서, 그 그릇이 커지지 않으면  아무리 큰돈이 들어와도 그 그릇이상은 탕진하게 된다고, 그래서 로또 당첨자들의 대부분은 그 그릇에 넘치는 돈을 탕진하게 된다는, 그런 이야기가 생각났다. 내 그릇은 과연 천만원을 담을만한 그릇일까?   그릇이 작으면 어거지라도 키워서 담아야지. 이게 어떤돈인데. 이 돈은 세상에서 제일 값지게 쓸거다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%B2%9C%EB%A7%8C%EC%9B%90/",
        "teaser": null
      },{
        "title": "완벽한 하루",
        "excerpt":"2021.04.13  오늘은 첫번째 기념일이다.  바람이 조금씩 불어오는 바람과 쏟아지는 햇살, 귀에는 내가 가장 좋아하는 노래들,  기분이 너무나 행복해진다.   통장엔 천만원, 자리를 잡기 시작한 내 공부, 목표가 확고해져 하루하루가 낭비없는 삶.  요즘따라 진짜 모든일이 잘풀리고 행복하다! 행복의 체감은 불행에 비하면 아주 작고, 아주 한순간이며, 삶의 대부분의 순간은 불행을 견뎌내는 것의 반복이라는걸 알기에   행복의 순간을 이렇게 글로적어서 남겨둔다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%99%84%EB%B2%BD%ED%95%9C-%ED%95%98%EB%A3%A8/",
        "teaser": null
      },{
        "title": "본능의 노예",
        "excerpt":"2021.04.15  요 몇일 너무 공부가 안된다…  갑자기 큰 돈이 생기는 바람에 머릿속에 온통 돈생각 뿐이다. 돈, 돈, 돈…   문득 그런생각이 들었다. 내 공부에 대한 미래효용가치는 얼마일까?  내가 하루에 얼마를 벌면, 그날은 공부를 안한게 더 이득인 하루인걸까??  과거의 인간은 시시때때로 찾아오는 아사의 위험이나, 거처를 당장 마련하지 않으면 얼어죽을수도 있는, 당장 눈앞에 닥친 위기를 해결하지 않으면 죽음에 이를 수 있는 상황속에서 살았다.  따라서 인간의 지금까지의 역사의 대부분은, 미래에 닥칠 위기나 이득을 계산하고 행동하는것보다는 눈앞의 위기와 이득을 계산하고 행동하는것이 생존확률을 더 높일 수 있었을것이다.  이렇게 유전자에 각인된 행동방식은 지금까지로 이어져, 인간은 멀리있는 이득과 손해보다는 당장 눈앞에 있는  이득과 손해에 집중하도록 진화하였다. 인간은 머리나 이성적으로는 당장의 절제가 미래에 훨씬 도움이 된다는것을 인식하고 있으면서도, 뇌가 주는 강렬한 자극들은 눈앞에 있는 작은 이득을 위해  멀리있는 큰 이득들을 포기해버리도록 만든다.   사람은 항상 눈앞의 편안함… 눈앞의 이득, 눈앞에 있는 달콤함을 얻기위해 자신의 미래를 끌어다 쓰곤 한다.  나도 항상 그렇다. 나중에 혹독한 다이어트로 고생할 것을 알면서, 눈앞의 맛있는 고칼로리의 음식을 먹어치우고,  나중에 땅을 치고 후회 할것을 알면서 당장 누워서 핸드폰을보고 뒹굴거린다.  삶은 어쩌면 인간에 유전자의 새겨진 본능들과 싸워 이겨내는 순간의 연속일지 모르겠다.  그래서 나는 이러한 인간행동학? 적인 요소에 관한 사실이 담긴 글들이나 영상을 보는 것을 무척이나 좋아한다. 나의 본능이 왜 그러한지를 깨달으면, 그래도 어느정도 나의 본능임을 인정하고 그것을 억지로 억누르려기보다는 우회하여 최대한 그러한 본능이 작동해버리지 않도록 나를 격리 할 수 있기 때문이다.   오늘 아침에 투자에 대한 그릇된 본능에서 나를 격리 하는 방법에 대한 글을 아주 흥미롭게 읽었다.  투자를 RPG게임처럼 하지말고, 오토배틀러 장르처럼 해야한다는 내용이었다. 무슨 말이냐면,  RPG게임처럼 장이 열린시간에 내가 하나하나직접 조종해서 투자를 하면 인간의 뇌에서 오는 뇌동매매의 본능을 끊어내는 것이 불가능한 상황에 나를 놓아두는 것이니, 내가 정비와 세팅을 해주고 게임이 시작되면 알아서 싸우는 오토배 틀러 장르처럼 투자하라는 것이다. 한마디로 장전에 세팅하고 매수한뒤, 오토배틀러 장르의 게임처럼  전투가 다 끝나고 결과를 확인하라는 뜻이다. 그리고 그 결과를 바탕으로 또 다음 전투를 정비하고, 세팅하면 된다.  이 글을 읽고 정말 반성을 많이했다. 인간의 본능은 아주 소수의 사람들만이 끊어낼수 있는 것이며, 그 사람들도 한순간의 본능에 잠식당해 나가 떨어지는 경우가 수두룩하다.   내가 그걸 건방지게 끊어낼 수 있다고 생각하고 행동하다가는,  인간의 유전자에 뿌리박힌 본능에게 된통 당할 수 밖에 없는것이다.  몇천년간 쌓여온 나의 본능을 나는 절대로 이길 수 없다는 생각을 갖고, 절대 정면승부 해서는 안된다.  아예 본능이 활동할 수 있는 상황에서 나를 격리시켜버리자.   지금부터 진짜 빡세게 공부한다. 진짜!!!! 구라아니고.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B3%B8%EB%8A%A5%EC%9D%98-%EB%85%B8%EC%98%88/",
        "teaser": null
      },{
        "title": "욕심",
        "excerpt":"2021.04.16  어제 도지코인에 넣고잔 640만원이 천만원이 되었다. 360만원을 벌은셈이다.  이러고 또 결국 본능을 이기지 못하고 단타를 치다 마지막에 50정도를 날려서 310만원의 수익을 올렸다.  50프로 가까이되는 어마어마한 수익, 총시드로 봐도 20퍼센트가 넘는 수익률을 하루에 올린것이다.  번돈으로 그동안 액정도 깨지고 배터리도 다되어서 너무 불편했던 핸드폰을 바꿨다.  내가 아이폰 프로모델 라인을 사게되는 날이 올줄이야!   그동안 대학교갈때 아빠가 사준 아이폰 6s를 4년간 쓰고, 폰굳이 좋은거 써야하나 싶어서 중고로 사서 1년좀 넘게 아이폰 X를 썼었다. 다시는 새폰 안사겠다는 생각을 했었는데, 또 돈이 생기기도 했고, 막상 중고 써보니까  배터리 효율이 너무 닳아서 뭐만하면 배터리가 다되는 바람에, 불편해서 도저히 못쓰겠더라.  태어나서 한번도 내돈으로 새 핸드폰을 사본적도 없고 해서,  아이폰12pro 그래파이트 하나를 사고, 돈도 벌었겠다 토끼같은 여자친구 뭐라도 사주고 싶은 마음에  요즘 어디가면 시끄러워서 공부가 잘안된다고 하던게 맘에 걸려서,  여자친구집으로 에어팟프로를 하나 배송시켜놨다.  물론 서프라이즈라 말은 아직안했다. ᄒᄒ  에어팟프로 케이스도 하나 사주려고 은근슬쩍 지금쓰는 에어팟  케이스 사준다고 거짓말하고 케이스고르라고 계속 했는데,  내가 에어팟프로 사주려는 것도 모르고 고르기 귀찮다고 짜증냈을다! 내일 너 에어팟 받으면 보자 진짜.   어제만 해도 한 50만원 아니 40만원이라도 벌었으면 좋겠다고 생각하고 잠들었는데, 진짜 이 인간의 욕심이  답이없다. 사실 매매자체를 욕심안부리고 잘한것 같은데, 자꾸 그대로 뒀으면 600을 벌었느니 하는 생각이  머리에 가득찬다. 310을 벌고도 마치 290만원을 잃은 사람마냥 기분이 그렇다.  310만원. 얼마나 큰돈인가. 300만원은 나의 용돈 40만원을 기준으로 8개월 가량을 한푼도 안쓰고 모아야하는 돈이며, 대부분의 30대 중반 직장인의 월급 실수령액정도되는 큰 돈이다. 이 어마어마한 돈을  벌고도 지금 불평과 아쉬움의 마음이 있다니.  얼마나 욕심이 가득하고 지독한 생각인지 모르겠다.  심지어 난 평생 300만원이 넘는돈을 통장에 가져본적이 없다.  그만큼 커다란 돈을 벌었으면, 말도안되는 상황 가정하면서  상상속의 돈을 잃었다고 하지말고, 제발 좀 감사하고 즐거워 할줄알아라.   돌이켜보면 이번매매는 사실 운좋게 맞아떨어져 큰 돈을 벌었지만, 반성해야한다.  시드머니의 절반가까이를 한 종목에 때려박았으며, 심지어 그 종목은 왜 오르는지도 알 수가 없는 그런 종목이었다. 일론머스크의 언급? 그건 인정이긴하다만, 한종목에 그 돈을 넣고 어제 잠을 잔 나도 정말 강심장이긴하다.  이제 코인은 어느정도 비중을 줄이고, 주식을 할생각이다. 좀 금액이 커지면 옵션 공부를 좀해서 풋옵션이나 콜옵션 매수 를 해보려한다. 콜옵션 같은걸 매수하면 아무래도 손절못치는 내 본능을 억지로 가둘수있지 않을까 하는 생각에, 자금이 더 커지면 옵션에 대해서도 생각을 좀 해봐야겠다.   돈이 없으면 불행하지만, 돈을 벌어도 크게 행복하진 않은가보다.  사실 지금 내가 가진 돈과 오늘 번돈은 학생기준으로 볼때 정말 어른들에게는 1,2억의 가치를 가진돈인데도, 지금 크게 행복하다거나 기분이 좋다는 생각이 들지는 않는다.  오히려 날씨좋은날 바람이 살살부는 거리를 여자친구랑 걷는다던가, 비가오는날 침대에 누워서 빗소리를 듣는것, 혹은 좋아하는 영화가 개봉해 영화관 특유의 냄새를 맡으며 영화가 시작하기전의 광고를 보는것.  이런것들이 훨씬 행복하고 좋다.   막상 내일이 되면, 도착한 최신핸드폰과 사랑하는 여자친구가 좋아하는 모습을 보고 또 다시 열렬한 자본주의의 노예가 되겠지만.   그것이 돈자체가 주는 행복따위의 보잘것 없는 것이 아니라,  내가 내돈으로 핸드폰을 처음 샀다는 성취감, 그리고 선물을 받은 여자친구의 행복한 미소에서 오는 고결한 행복임을 아는 사람이 되었으면 좋겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%95%EC%8B%AC/",
        "teaser": null
      },{
        "title": "도박",
        "excerpt":"2021.04.18  어제 하루종일 두통으로 인해 머리가 지끈 지끈 아프고  밥을 먹어도 소화가 안됐다. 감기기운이라고 둘러댔지만, 이유를 알고있었다.  그놈의 코인때문에 이틀동안 밥먹으면서도, 운동하면서도, 공부를 하면서도 차트를 켜놓고 있었기 때문이다.  사람이 극심한 스트레스로 머리가 아프다는 걸 이틀간 태어나서 처음 겪었다.  진입하자마자 물리면, 하루종일을 후회로 보내며 ‘아 왜 내가 거기서 들어갔지’, ‘진짜 한번만 오르면 본전에 팔고 다시는 코인 안한다.’의 반복… 심지어 다시 올랐을때는 다시 그득한 욕심이 기어 올라와 팔지도 않고,  결국 또 손실로 이어진다. 이렇게 어제 하루에만 150가량을 날렸다.  그동안 벌기만 했지, 이정도의 금액을 잠깐 사이에 잃어본적은 없다.  난 얼마전만 해도 하루하루가 요즘 너무 행복하다고 생각했는데, 이틀동안 이렇게 불행할수가 없었다.   머리가 아프기도 하고, 더 차트를 보고있다가는 정신병에 걸릴것 같아서  그냥 그대로 잠들기도 하고 유튜브를 보기도 하고 했다. 그 중에 슈카님의 유튜브 채널을 봤는데,  갑자기 정신이 차려졌다. 물론 비트코인에 관한 이야기가 아닌 20대 30대에 관한 이야기들이었지만  그 중에서 요즘 20대 30대가 단기에 큰수익을 올릴수 있는 코인시장에 다들 미쳐있다는 이야기.  단기간의 큰 변동성을 가진 투자는 절대 행복할 수가 없다고 했다.  나는 뭘 위해서 투자를 하는지 생각했다. 물론 돈을 벌기 위해 하는거지만, 나는 돈을 왜버는가??  돈벌어서 나의 여유로움으로 행복하고 싶어서 나는 돈을 벌고싶다.   그 관점에서 볼때, 비트코인 투자는 뭔가 잘못되었다.  돈을 벌어도 벌어도 만족스럽지도 않고, 성취감도 하나도 없다. 이건 나의 실력과 지혜로 얻어낸것이라는 생각이 전혀 안든다. 내가 이 코인을 왜 선택했으며, 왜 이 가격에 샀는지, 어떤 가격에 팔건지에 대한 아무런 기준이없다. 홀짝 도박을 할때, 홀을 고른 사람에게 왜 홀을 골랐는지에 대해 물어본다면 이렇게 말할 것이다.   ‘그냥 느낌이 좋았다’   나도 마찬가지다. 그냥 느낌이 좋았고, 뭔가 오를것 같아서 샀다. 이걸 과연 투자라고 볼 수 있을까?  옛날에 영상같은걸 틀면 앞에 광고로 나오던 그래프게임 도박이 생각났다.  비트코인과 그 불법도박이 과연 다른점이 있을까.  호재들은 모두 기술력일뿐 코인의 가격과는 직결되는 부분이 없으며,   결제수단으로 이용할수 있는건 비트코인 하나외에는 하나도 없다.  실체가 전혀 없고, 이 코인을 만든 회사나 사람이 무엇을 하는지, 정말 그걸 하긴 하는지에 대한 아무런 증거도 찾을 수 가 없다.   그래서 난 오늘부터 비트코인을 접기로 했다.  운이 좋아서 그래도 돈을 벌은 상태로 정신을 차렸다는 사실에 감사한다.  운이 나빴다면 50프로의 수익이 아니라, 50프로의 손실 후 정신을 차릴 수도 있었다. 이것은 정말 엄청난 행운이었기에, 정말 다행이라는 생각이 들었다.  하지만 가장 중요한것은 나를 믿지 않는것이다.   내 본능은 또 차트를 볼것이며, 또 그 유혹에 무조건적으로 흔들릴 것이고, 나는 또 비트코인을 매수하게 될 것이다. 그 전에 미리 나를 그러한 본능의 상황에 놓이지 않게 해야한다. 내일이 되면 케이뱅크 계좌는 바로 해지할것이고, 업비트는 탈퇴할것이다. 저 비트코인이 올라 10억이 된다해도, 그렇게 벌어들인 돈은 도박판에서 딴 돈과 같다. 도박으로 딴돈은 결국 반복되는 도박의 반복끝네 잃어야 그 악의고리가 끊긴다.  아니, 어쩌면 평생 안끊길수도 있다. 도박으로 돈을 딴 후에 정신을 차렸음에 감사한다.  그렇게 어제 모든 돈을 출금하고 앱을 삭제해버렸다. 그리고 오늘, 비트코인은 폭락했다.  운이 참 좋았다고 생각했다. 하루만 더 갖고있었더라면, 지금쯤 얼마나 괴로운 하루가 또 되었을지  상상도 하기 싫다.   코인으로 번돈으로 맥북을 한대 더 구입했다.  이로써 코인으로 번돈은 모두 사용했다. 쉽게 번돈이라 쉽게 써지는걸까.  다시 처음부터 오늘 천만원을 받았다는 생각으로 정상적인 방법으로 투자하겠다. 잃더라도 얻는게 있고, 배우는게 있겠지.  내일이 기대된다. 이번에는 꼭 행복과 돈, 두마리 토끼를 다 잡고싶다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%8F%84%EB%B0%95/",
        "teaser": null
      },{
        "title": "주식",
        "excerpt":"2021.04.19  오늘부터 주식을 좀 열심히 해볼 생각이다.  다시 공부하려니까 너무 어렵다. 그래도 공부해서 투자할수 있다는게 얼마나 큰 행운인지.  코인 도박판에서 정신 차렸으니, 열심히 다시 해서 수익률을 크게 올려볼 생각이다.  영어에 데이터 공부에 투자 공부까지… 내가 세가지를 다 잡을 수 있을까.  지금 보다 더욱 더 치열하게 살고, 부지런해져야 한다는 생각에 벌써 머리가 아프다.  요즘따라 하루가 이렇게 짧았나 싶다. 물론 이런생각 하면서도 누워서 핸드폰하고, 뒹굴고 하는시간 없애는건 왜이렇게 힘든지 모르겠다. 시간표를 아예 짜서 그대로 행동해야겠다.  그냥 재량껏 하려고 하니까 이런일이 벌어지는것 같기도 하고.   옛날에 봤던 무슨 실험프로그램에서 남편한테 일시키는 법  이런식으로 해서 나온적이 있었다. 뭐 해달라고 그냥 추상적으로 말하지말고 몇시까지 이거를 어떻게 해줘~~ 하면서 말을 하면 들어준다는 그런 실험. 놀랍게도 그냥 추상적으로 말했을때는 뒹굴거리던 남편이  시간과 행동을 정확하게 정해주자, 그 시간전에 그 일을 끝냈다.  실제로 남자들은 계약이라는 개념에 민감하게 반응하기 때문에,  시간적 제약이나 어떠한 조건에 대한 제약을 걸면  지키려는 경향이 강하다고 한다.   그래서 나도 오늘부터 나에대한 시간적 제약을 좀 걸생각이다. 내일은 오늘보다 열심히 살기를 바라면서…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%A3%BC%EC%8B%9D/",
        "teaser": null
      },{
        "title": "코딩",
        "excerpt":"2021.04.23  최근에 다시 주식을 시작하면서,  주식에 관한 데이터를 뽑아내는 프로그래밍을 하고있다.  근데 이게 도통 어떤 데이터가 연관성이 있는지 감이 잘안잡힌다.  일단 뉴스기사와 각종 지수를 크롤링해서 엑셀로 저장하는 프로그램까지는 코딩을 했는데,  더 무엇을 해야할지 잘 감이 안잡힌다. 공부가 부족해서일까…  아무튼 주식뿐만이 아니라 왠만한 단순 반복작업들을 모두 코딩으로 자동화 해보려 한다.   앞으로 한 10년만 지나도 코딩이 특별한 기술이 아니라, 현재의 엑셀처럼 누구나 보편적으로 사용하는  기술이 될거라는 생각이 들었다. 개인의 업무를 자동화 할수 있다는 건 엄청난 메리트이니까 누구나 이 이점을 알게되면 너도 나도 코딩으로 자신의 프로그램을 만들어 단순업무들을 자동화 시키는 날이 조만간 올것 같다.  오르비의 라끄리 대표의 글을 오랜만에 오르비에 찾아가서 읽었다.   이 사람이 쓴 글을 볼때마다 많은 인사이트를 받는다. 이 정도로 똑똑한 사람이 사적으로 쓴 글을 접해볼 기회가  잘없어서 그럴까? 읽을때마다 새로운 생각이 나도 덩달아 들고, 문장 한구절 한구절마다 감탄하게 된다.  머리도 똑똑한데, 어떻게든 자신의 시간을 철저히 사용하려고 폴더 하나하나 책상정리 하나하나 한번에 찾을 수 있게끔 분 류와 정리를 완벽히 해놓는다는 이야기를 보고는 정말 많은 생각이 들었다. 저 사람 보다 머리도 안좋은 내가 저렇게 노력 하지 않아서야 무슨일을 이룰 수 있겠냐는 생각을 했다. 삶에 저정도로 나는 치열한적이 있었나.  괜시리 나도 컴퓨터의 폴더를 정리해보았다.   저렇게 이악물고 시간을 아끼려는 사람 앞에서,  나는 지나가는 시간의 흐름을 그저 놓아 보내주고 있는건 아닌지 많은 생각이 들었다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%BD%94%EB%94%A9/",
        "teaser": null
      },{
        "title": "공부...",
        "excerpt":"2021.04.29  어느정도 재미를 붙이고 하던 공부가 난관에 봉착했다.  머리가 너무 아프다. 도대체 뭐 부터 해야하는지도 모르겠고 난이도는 너무 높다.  재밌는건 딱 내가 이해할수 있을때까지였고 그 위로는 재미가 하나도 없다…  하긴, 공부가 재밌을리가 없지. 사실 난이도도 난이도지만 어느 방향으로 공부해야하는지 감이 안잡혀서 어렵고 힘들고, 머리아프다. coursera 강의를 따라가려 하니 자막이없고 유튜브 강의들은 질이 너무 떨어진다. 이래서 영어를 배워야 하는건가…   영어를 못하니 질좋은 강의들을 수강 조차 할수가 없다. 사실상 인터넷이라는 도구의 기능을 영어를 못하면 한 30퍼센트밖에 활용을 못하는셈이 되는 것 같다. 영어…영어..!!  어쨌든 방향을 잃었을때 가장 좋은방법은 책을 사는 것 같아서  더럽게 비싼 4만원 짜리 책을 한권 구매하려고 한다.  다시 차근차근 책부터 떼고, 뭘 해볼 생각이다.   자기계발에 돈아끼면 안된다지만, 4만원이 너무 아깝다… 거지같은 도서정가제  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B3%B5%EB%B6%80/",
        "teaser": null
      },{
        "title": "임신",
        "excerpt":"2021.04.30  어제 밤에 월가아재님이 쓰신 블로그에서 잠겨있는 시황을 어떻게 하면 볼 수 있을까 구글 캐시를 뒤지다가, 월가아재님이 쓰신 임신 부터 출산까지의 경험을 적은 일기를 발견했다. 정작 시황은 하나도 못보고, 어제 저녁에 그 글을 읽었다. 아직 나이가 어려서, 주변에 임신에 대한 경험에 대해 들어본적도 없고, 내가 접한 출산이라고 해봤자 기껏해야 친 인척들의 출산소식정도? 였다. 근데 꽤나 상세하고 디테일하게 아기를 낳는다는 일의 무게와 찾아오는 수 많은 어려움, 그 리고 그 놀라운 출산의 기쁨에 대한 내용까지 담겨 있어,  글을 읽고 많은 생각을 하게 만들었다.   임신이 힘들다 힘들다 하지만, 저렇게 상세하게 적힌 경험들을 과연 내가 감내할수 있을까 하는 생각이 들었고, 모든 어머 니들이 저러한 고통, 누군가는 더 큰 고통을 감내하고 새로운 생명을 세상에 낳았다는게 놀라웠다. 나같은 뭣도아닌 사람 도 저렇게 무거운 짐을 견뎌 낼 수 있을까?   이러한 감상에 젖으면서도, 저 글은 감정과 경험 뿐만아니라 임신이 부부관계에 미치는 영향이나, 임신중에 어떠한 요소들 이 아이의 발달과 지능에 영향을 미치는지 월가아재님께서 여러 논문들과 통계를 읽고 정리해둔 자료와 함께있어서 감성 과 이성이 한데에 있어, 감정적으로 아기를 무조건 낳아야 겠다!! 라는 기분이 들기보다는, 생명을 만들기 위해서 내가 감 수해야할 손해와 얻어야 할 이득에 대해 다시금 생각해보게 만들었다. 아기를 낳는 다는건 인간이 경험 할 수 있는 중에 가 장 황홀하고 경이로운 경험이지만, 그 시기와 과정에 대해서는 아주 크나큰 준비와 고찰이 필요하다는 생각이 들었다.   많은사람들이 아기를 낳으면 부부가 더 돈독해지고 행복해질것 이라 말하지만, 통계적으로는 미국 등 10개 선진국에서 진 행된 연구에 따르면 결혼 만족도는 첫 출산 이후 15년간 지속 감소했고, 자식이 집을 떠나고 나서야 서서히 증가했다. 또, 양측에 합의 없이 한쪽의 요구만으로 진행한 임신 후 다툼을 가진 부부는 통계적으로 100퍼센트 이혼했다. 다들 단순히 감정적으로 돈독해지겠지~~ 라고 안일하게 생각하지만, 아이를 낳는 다는건 이토록 불행해질수 있는 거대한 리스크를 짊 어진 일인것이다. 그렇기에 출산은 정말 양쪽이 모두 준비가 된 상태에서, 합의하에 큰 계획을 갖고 만반의 준비하에 진행 하여야 리스크를 최대한 줄일 수 있는것이다.  또 글을 읽다보니, 나는 이 글을 읽으며 세상은 얼마나 불공평한가에 대해 생각을 했다.   출산까지의 과정은 사실상 아이의 평생을 좌우하는 큰 요인인데, 지적 수준이 낮거나 생활수준이 낮은 가정에서 태어난 아이는 이 세상에 나온 처음부터 남들보다 뒤쳐진대로 시작한다는 느낌이 들었다. 저 일기에 써있듯이 임신에는 통계적으 로 증명되지 않는 여러가지 낭설들과 속설들이 즐비하고, 임신상태에서는 정말 생각보다도 더욱 절대적인 안정이 필요한 데, 지적수준이 낮은가정에서는 오류에 대한 검증 없이 저러한 낭설과 속설들, 심각하게는 아이의 발달과 지능을 저하시키는 행위들을 행할것이고, 생활수준이 낮은 가정에서는 완전한 안정을 취하지 못할 것이다. 지적 수준이 낮은 가정은 대개 생활수준이 낮을 가능성이 높으므로, 이 두가지 요인들은 동시에 발생할 가능성이 매우 높다.   그렇게 여러가지 요인들에 의해 선천적으로 능력이 저하된 아이는 또 낮은 지적수준의 대물림을 받게 되는것이고, 이러한 일은 몇대를 걸쳐 반복될 확률이 매우 클것이다. 우리 사회는 항상 노력하면 누구나 성공 할 수 있다고, 마치 공평한 출발 선에서 시작한것 처럼 말하지만, 나의 노력여부에 관계없이, 이미 뱃속에서 부터 크나큰 격차를 갖고 다른 출발선에 서게 되는것이다.   세상은 항상 불편한 진실과 마주하기 싫어, 그러한 진실들을 회피하고 듣기 좋은 거짓말로 포장하려 한다. 그리고 누군가는 그러한 진실과 마주하지 않은 댓가를 치룬다. 그것도 몇대에 걸쳐서…   사람들은 부모욕에 굉장히 민감하다. 또 인종차별에 대한 것은 어떤가?? 지역이나 출신에 대한 욕만큼 화가나고  듣기 싫은건 없다. 키나 외모에 대한 욕도 동일하게 사회적으로 금기시 되는 것중에 하나이다. 이렇듯 사람들은  이제 앞으로 내가 바꿀수 있는 것에 대한 모욕보다는, 이미 정해져서 돌이킬 수 없는 것에 대한 모욕에 가장 민감하게 반응 한다. 하물며 사회에 태어날때부터 존재하는 이러한 격차에 언급하는것은 사람들에게 얼마나 불쾌할까. 아마 어떤 국회의 원이나 정치인이 이러한 문제점에 대해 이에 따른 복지 정책이 필요하다고 언급 한다 해도, 그는 이러한 불편한 진실을 말 한 댓가로 사회적인 매장을 당할 수 밖에 없을 것이다.   개선하고 보완해야할 문제점에 대해 인식하고 해결하지만 너무나 큰 불편함을 마주하는 사회가 치루는 비용이 더 클지, 이 러한 불편함을 그저 감성적인 부분들로 포장하고 모두가 불편하지 않은 상황에서 발생하는 불평등한 격차에서 사회가 치 루는 비용이 클지는, 나같은 바보는 모르겠다. 어쩌면 이미 전자보다는 후자가 비용이 적다고 분석한 결과에 따라서 지금 의 사회가 돌아가고 있을지도 모르고, 사실 둘다 정답이 아닐수도 있다.  모두가 평등을 원하지만, 사실은 모두가 평등해지고 싶지 않아 한다는 생각이 들었다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9E%84%EC%8B%A0/",
        "teaser": null
      },{
        "title": "블로그 챌린지, 빠니보틀",
        "excerpt":"2021.05.01  안그래도 요즘 일기쓰는게 살짝 귀찮아지기도 했고 쓰다보면 30분씩 쓰게 되서  자꾸 안쓰고 몇일에 한번 썼는데, 블로그 챌린지인가 뭐시기를 진행해서 2주동안 빠지지 않고 일기를 쓰면  네이버페이로 16000원을 준단다. 마침 일기 쓰고있는데 잘됐다 싶어서 하기로 했다. 여러 계정으로 해서 돈좀 두둑히 챙 겨야겠다. 요즘은 이렇게 조금만 시간을 들이면 돈이나 상품을 주는 여러 이벤트들이 다양한데, 이런것만 찾아서 잘 받아 챙겨도 쏠쏠하겠다는 생각이 든다. 얼마전에 친구가 아하토큰 출석만 해도 돈준다 했을때 하기만 했어도 지금 한 7-8만원 은 꽁으로 얻는건데, 그때 왜 안했을까. 세상에는 의외로 하기만 하면 돈을 주는데 귀찮아서 사람들이 안하는 것들이 꽤있 다. 정보가 부족하기도 하겠지만, 알면서도 안하는 것들. 예를들어 봉사동아리에서 만난 형은 나이키 운동화 래플을 여러 개를 해서 리셀을 하는데, 돈이 꽤 쏠쏠하단다. 물론 나도 래플 그동안 많이 해봤지만, 그것보다는 좀 더 귀찮게 해야된다. 온 가족 계정을 쓸어서 응모하고 운동화 하나당 사이트가 여러개라 계정 파는게 여간 귀찮은게 아닐테니. 근데 이글 쓰다 보니까 문득 해야겠다는 생각이 들기도 하고 갑자기?? 살면서 중요한게 저거 내가하면 더 잘할것 같은데? 싶으면 직접 해 봐야 하는것 같다. 근데 나는 아는 주민번호가 끽해야 내거 포함 4-5개밖에 없는데 괜찮은지 모르겠다. 일기쓰다 보니까 생각난건데 그냥 프로그램화해서 자동화 하면 되겠는데? 홈페이지 자체적으로 봇방지 해놓았으려나…   요즘은 빠니보틀 유튜브 보는거에 푹 빠졌다. 나 여행 그렇게 좋아하지도 않는데 보다보면 진짜 여행이 너무 가고싶어진 다. 물론 인도나 그런 후진국들 다니는 거 보면 유튜브로만 재밌지 절대 가고싶지는 않다. 사실 어릴 때는 월터의 상상은 현실이 된다 라는 영화에 나온 아이슬란드가 너무 예뻐서 아이슬란드 가보는게 꿈이었는데, 살다보니까 또 흐지부지 됐다. 참 여행이란게 돈도많이 들고 시간도 많이 들어서 어릴때가자니 돈이없고, 나이들고 가자니 시간이 없는것 같다. 이런 각 박한 현실에 여행다니고 유튜브 편집해서 올리면 여행비가 나온다니 얼마나 행복한 인생일까?? 물론 뭐 개꿀이라던가 이 런말이 아니라, 그냥 부러워서 하는 말이다…  빠니보틀을 보다보면 사실 진짜 별것도 없는데 영상이 너무 재밌다. 막 웃긴 얘기를 하는것도 아니고 엄청난 편집이나 스 토리가 있는 것도 아닌데, 그냥 계속 보게 된다. 여행지 그 자체가 컨텐츠여서 그렇기도 하지만, 빠니보틀 사람자체에서 나 오는 매력이 오진다. 그걸 우리나라 여행편을 보다가 깨달았다. 아 이거 여행지만 컨텐츠인줄 알았는데, 사람 자체가 컨텐 츠구나… 재밌네… 하는 생각들. 사람자체가 호감인 컨텐츠들은 진짜 무서운것 같다. 유튜브를 보다보면 금방 또 질려서 한창 맨날 보던 채널들 영상이 어느순간 10개씩 쌓이다가 안보게 되는데, 침착맨이나 빠니보틀처럼 사람 그 자체가 컨텐 츠인 영상들은 그냥 하루종일 켜놓고 본거 또보고 무편집으로 보고 설거지 하면서 보고 잘때는 들으면서 자게된다. 침착맨 님이랑 주호민님 먹방 하는 영상은 농담아니고 전체 재생목록을 한 세번씩 봤다. 침투부로도 시간이 녹아내리는데 요즘 빠 니보틀까지 합세해서 아주 아이패드를 놓지를 못하겠다.   어제 읽은 글중에 자신의 행복을 무시하지 말라는 내용의 글을 읽었다. 남들 무슨 명품두르고 여행다니는거만 행복이 아니 라 그냥 혼자 티비보면서 치킨 먹는 행복도 행복이니까 무시하지 말라는 요지의 글이었다. 사실 생각해보면 그냥 혼자 방 에서 치킨먹으면서 유튜브 보는 행복이 어디 좋은곳에 여행가고 비싼걸 살때의 행복과 큰차이 있나 싶다. 솔직히 혼자 침 대누워서 유튜브 볼때가 어마어마하게 행복할때도 많은데, 사람들은 그게 쉽다는 이유로 거기서 오는 행복을 많이 무시하 는것 같다. 나도 어제 침대에서 빠니보틀 유튜브 볼때 얼마나 행복했는데 ᄒᄒᄒᄒ  행복이란게 참 어려우면서도 별거없는것같다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B8%94%EB%A1%9C%EA%B7%B8-%EC%B1%8C%EB%A6%B0%EC%A7%80,-%EB%B9%A0%EB%8B%88%EB%B3%B4%ED%8B%80/",
        "teaser": null
      },{
        "title": "맥북",
        "excerpt":"2021.05.02  더 현대 서울에 데이트하러 가는중이다.  원래같으면 일기 그냥 오늘 안썼는데 블로그 챌린지 돈받아야해서 오늘도 쓴다… 돈벌기가 어디 쉽나.  최근에 산 물건중에 가장 맘에 들고 만족감이 드는 맥북에 대해 몇자 적어보려한다. 솔직히 코인으로 번돈으로 홧김에 옆 에 친구가 부추겨서 샀는데, 충동 구매한 물건이 이렇게 만족스럽고 후회가 없을수가 없다. 진짜 돈이 안아까운정도가 아 니라 이 정도면 진짜 돈 더 받아야 하는거 아니야? 이런 생각이 든다.  m1칩 진짜 아무리 봐도 외계인 갈아서 만든게 아니면 말이안된다. 애플 지하에 진짜 외계인 고문중인게 아닐까?  물론 인텔이나 다른 회사들도 기술력으로는 충분히 만들 수 있는 물건인건 알고있다. 하지만 하드웨어와 소프트웨어를 다 직접 제작하는 애플만이 할 수 있는 짓인것도 분명한 사실이다. 120만원이 안되는 돈으로 이런 성능의 노트북을 쓸 수 있다니…   나 솔직히 아이폰에 아이패드에 에어팟에 앱등이는 솔직히 맞다. 그래도 애플워치도 안쓰고 아이패드도 내 사용목적에 맞 게 그냥 7세대 쓰는 나름 ‘실용적’ 앱등이다. 아이폰쓰는거 호구라고? 솔직히 맞다. 알면서도 다 감성으로 쓴다고 생각하고 쓴 앱등이 맞다…   근데 솔직히 에어팟프로랑 맥북 m1은 인정해줘야 한다. 이정도면 가성비다. 진짜. 5월에는 아이패드에도 m1칩 넣어서 나온다는데, 진짜 진지하게 구매 고민중이다 m1 아이패드프로가 99만원밖에 안한다니… 지금 아이패드랑 펜슬 처분하면 한 30만원 좀 넘게 나올거고 아이패드 프로랑 펜슬 2세대하면 한 120 이니까 90에 산다고 생각하면 진짜 너무 싸다.   그리고 맥북 솔직히 제일 큰 장점은… 예쁘다는거다.  전자기기가 예뻐서 뭐하냐고 하겠지만 진짜 솔직히 성능 안좋아도 간지로 쓰던건데 성능까지 갖추니까 다른 노트북 회사 들이 걱정 될정도다… 맥북을 펴고 공부를 하다보면 마치 성공한 커리어맨이 되어가는 느낌이 들며, 스타벅스에서도 꿀리 지 않는 간지를 챙길 수 있다.  일기 오늘 너무 대충 헛소리 쓴것 같다. 어쨌든 이 글 보는 여러분, 무조건 맥북사세요 맥북 진짜 개좋아요 맥북 최고야 맨 날 들고다니고싶어!!!!!  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%A7%A5%EB%B6%81/",
        "teaser": null
      },{
        "title": "유혹",
        "excerpt":"2021.05.03  진짜 뒹굴거리고 혼자 침대에서 계속 누워있다가 겨우 나왔다.  그동안 생각해보니까 거의 여자친구 만나는 날 빼고는 공부 하루도 안빼먹어서  아 하루정도는 좀 뒹굴거리고 침투부랑 빠니보틀 유튜부나 24시간 연속으로 돌려버릴까? 이런 생각을 하다가 그냥 또 막상 그러고 저녁되면 현타올것 같아서 나와버렸다.  막상 오니까 오늘 날씨도 좋고 예진이가 공부하면서 먹으라고 딸기 요거트 스무디도 사줘서 나오길 잘했다는 생각이 든다. 얘두라 고마어어~~~~   요즘 자꾸 돈이 생기니까 지출에 욕심이 생긴다.  아 불릴라고 있는 돈이네 왜 자꾸 쓸려그려~ 어릴때 부터 느낀건데, 난 약간 소비욕? 소장욕 같은게 있다.  물론 누구나 다 있겠지 사실. 어쨌든 어릴때부터 뭐 하나씩 꽂혀서 그걸 줄창 사곤했는데, 아주 어릴땐 건프라였고 한때는 신발이었으며, 옷까지 갔다가 또 요즘은 옷을 안산다. 그러고서는 지금은 전자기기에 꽂힌것 같다.  물론 어릴때 부터 전자기기를 꾸준히 좋아했지만, 이게 구매력이 생기니까 너무 무섭다.  돌아보면 또 별생각 안들텐데…   한창 신발에 꽂혔을때는 진짜 거의 하루종일 신발 뭐 새로나오나 보고, 래플하고, 줄서서 신발도 사보고 했는데, 그때는 마치 평생 신발을 취미로 할것같다는 생각이 들정도로 신발에 열심이었다.  근데 지금은 시들해지고 하니까 진짜 신발 뭐나오는지 요즘 뭐있는지 하나도 모른다.  지금 전자기기도 와 이건 무조건 사야돼 진짜! 하다가도 몇달뒤면 그냥 시들해지겠지…  솔직히 아이패드 프로 새로나온거 사도 유튜브보고 필기하고 끝아닌가?  싶다가도 아니 m1칩이면 뭐라도 좀 하지 않을까,,, 하는 생각이든다. 또 나는 그 업종으로 갈거니까~~ 하면서 자꾸 지름신이 강림하는데, 이걸 막기가 힘들다.  아니 사실 막기가 싫다. 아 언제나와 진짜 나오자마자 질러버릴라…  최근에는 또 오큘러스 퀘스트2에 꽂혔다.  솔직히 vr막상 사면 얼마 하지도 않을것 같고 막 그런데,  좀 베타테스터 병이 옛날부터 있어서 자꾸 뭐 신기술 비스무리 한거 나오면 남들보다 먼저 사가지고 자랑하고 싶고 막 와 이걸 안해봤어~~ 진짜 니네 인생 손해보고 있네;;  이러면서 유세부리고 싶다.   전형적인 앱등이 테슬라충 마인드…  그래서 에어팟 프로가 출시됐을때 , 한국 정발도 안됐는데 해외 구매자 통해서  웃돈을 주고 그걸 샀다. 34만원 가량 주고샀으니 얼마나 호구인지… 그러고 나서 2주뒤엔가 바로 한국정발되었고, 지금은 24만원이면 새거를 살 수 있다.  흑우도 이런 흑우가 있나.  요즘은 쿠팡 로켓배송에 너무 꽂혔다,  오늘시키면 오늘밤 내지 내일 새벽만 되도 내가 배송한 물건이 있다니… 심지어 싼것만 되는것도 아니고 이번에 산 맥북도 지르자마자 다음날 새벽에 와있었다.   나는 어릴적, 택배가 너무나도 싫었다. 물론 그때는 지금보다 택배가 오래 걸리기도 했지만,  그걸 감안하더라도 항상 아빠가 뭐를 사준다고 약속하면  인터넷이 한참은 싼데도 항상 마트에 가서 오늘 사자고 졸랐었다.  아빠한테는 당연히 씨알도 안먹힐 소리였고, 나는 그 택배가 오기전까지 시간이 더디게 가는 것을 느끼며 한밤 한밤 세가며 오매불망 그 택배를 기다리곤했다.  그때는 돈의 가치보다 당장 내가 이걸 갖고 싶다는 소유욕이 더 컸었다.  하지만 이제는 돈의 가치를 잘 알기때문에  그 택배를 별생각없이 기다리는 나이가 되었다.  근데 쿠팡 로켓배송이 아주 성행을 하고, 좀 웃돈을 주고도 당장 오늘이나 내일 배송받기를 원하는 사람들이 많은걸 보니, 인간의 본능은 역시 끊어내기가 쉽지않나보다.  그 돈이면 그냥 더 주고 오늘받고 말지!   사람들 마음속에 숨어있던 어린아이를 자극하는 그런 사업이 돈이 되지 싶다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9C%A0%ED%98%B9/",
        "teaser": null
      },{
        "title": "사이킷런(1) 보스턴 주택가격 예측모델",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런(1) 보스턴 주택가격 예측모델  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0(1)-%EB%B3%B4%EC%8A%A4%ED%84%B4-%EC%A3%BC%ED%83%9D%EA%B0%80%EA%B2%A9-%EC%98%88%EC%B8%A1%EB%AA%A8%EB%8D%B8/",
        "teaser": null
      },{
        "title": "게으름",
        "excerpt":"2021.05.04  게으름의 늪에 빠졌다…  왜 자꾸 여섯시면 기상하던 몸이 요즘따라  아홉시는 넘어야 침대에서 일어나게 되는지 모르겠다.  뭔가의 동기부여가 심하게 떨어진것 같이 모든게 귀찮고 자꾸 쉬고 싶다. 공부가 좀 막혀서 그렇지 싶다…   더닝크루거 효과라는 현상이 있다.  어떠한 지식을 습득할때, 지식을 습득하기 시작했을때가 가장 자신이 많이 한다고 생각하고,  점점 그 지식에 대한 조예가 깊어질수록 오히려 자신이 더 모른다고 생각하게 된다는 현상.  무식한 사람이 더 자신감 있고 확신에 차있는 것도 이러한 현상에 비롯된다.  나도 얼마전까지만 해도 알아가기 시작하는 과정이 너무 즐겁고 보람찼는데,  어느수준 이상 지식을 습득하고나니, 솔직히 말해서 너무 어렵고 뭘 해야 할지 모르겠다는 생각이 자꾸 든다. 뭐 긍정적으로 생각하면 내가 어느정도 지식수준에 이르렀다는 것이겠고,  부정적으로 말하면 이제는 공부가 즐겁지 않게 될것 이라는 것이다.  처음에는 조금의 노력으로도 많은 지식을 얻을 수 있어서  노력에 대한 고통보다 무언가를 알아가는 기쁨이 더 컸는데,  이제는 하루에 한개의 개념도 이해가 될까 말까의 수준이 되어버려서  너무나 답답하고 짜증이난다. 뭐 도통 이해가 되어야 다음 스텝으로 나가는데… 계속 한부분을 붙잡고 있으면 내가 머리가 멍청한가 하는 생각이 들면서 영 책을 들여다 보기가 싫다.   그래서 차라리 여기 블로그에다 공부한 내용 써가면서 연재나 할까 싶다.  혼자 공부하니까 좀 집중도 안되고, 나름 블로그 같은데다 쓰면 누가 보지는 않아도  내가 공부한거에 대한 흔적이 남는거니까 뿌듯하기도 하고, 물론 뭔가 편집을 한다는 에너지가 더 들어가 진도가 더 느려질 수도 있겠지만, 지금도 어차피 공부가 안되서  진도가 안나가는데 더 좋으면 좋았지 나쁜점이 없지 싶다…   사실 투자 관련도 꾸준히 쓸라 했는데, 생각보다 투자는 맨날 쓸 필요가 없어서 내용 채울게 그다지 없다. 그냥 간간히 분석할때가 종목 갈아탈때나 쓰고 해야지, 내가 무슨 전업 투자자도 아니고…   괜히 무슨 맨날 할것처럼 제목을 날짜로 써붙여놓고 ‘장전시황’ 이래놨다.  어쨌든 계속 공부 방법을 바꿔가며 신선함이 느껴지도록 여러 방법을 강구해봐야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B2%8C%EC%9C%BC%EB%A6%84/",
        "teaser": null
      },{
        "title": "네이버, 비트코인",
        "excerpt":"2021.05.06  네이버 오늘일기 챌린지가 조기종료되었다.  아 나름 이거 돈도 벌고 일기도 꾸준히 쓸려고 했는데…  근데 네이버가 진행한 이벤트치고 종료된 정황이 너무 얼척없긴했다. 자기들이 시작해놓고 뭔 갑자기 돈부담된다고 조기종료를 하는지, 이정도 참여율이 나올거라고는 예상을 못한게 신기하다.   요즘 젊은 사람들은, 물론 나도 그렇지만, 돈에 완전 바짝 관심이 몰려있는것 같다.  뭐가 돈좀 된다고 하면 우르르 달려가서 모든 이득을 챙기려한다.  신발 리셀이 돈이 된다는 소리에 이제 래플은 하늘의 별따기가 되었고, 각종 사이트에서 홍보용으로  뿌리는 포인트나 돈 소식은 커뮤니티를 타고 퍼져서, 진짜 하루 이틀이면 모두 소진된다.  어제 봤었던 뉴스에는 신용카드 혜택을 최대한 이득을 보려는 사람들의 이야기가 나왔는데,  신용카드 혜택중에 천원 이하 단위는 할인해주는 카드가 있어서 그걸로 항상 990원 내지 900원으로  끝금액을 맞춰서 결제를 한단다. 7000원짜리 밥을 먹으면 100원짜리 동전을 준비해뒀다가  6900원만 결제를 한다거나, 주유소에서 한번에 기름을 넣는게 아니라 틈틈히 9900원 어치씩 기름을  넣는다 하는 식으로 신용카드 혜택을 받으려는 사람들이 요즘 늘어나고 있다고 한다.  또 얼마전에 토스에서 한 랜덤 주식 1주 증정 이벤트는 어땠었나? 물론 랜덤이라 재미요소도 있어서  참여율이 높았던 것도 있지만, 돈준다는 소식에 우르르 몰려서 다 받아갔다. 이런 요즘 흐름에서 2주동안 한줄일기만 써도 16000원을 준다는데 누가 참여를 안할까. 계정 네다섯개씩 돌려가며 받아가려고 하지.  경제수준이 올라가면서 다들 돈이나 투자에 대해 관심이 많아진건지,  아니면 정말로 어차피 집도 못사고 힘드니까 다들 돈에 미쳐사는건지는 모르겠다.  물론 나도 똑같지만 뭐…   어제 다시 비트코인을 시작했다. 그렇게 비트코인 안한다고 쑈를 하더니 왜 다시 시작했냐고?  나는 이성적으로 생각해서 비트코인을 안하겠다고 말한건데, 다시 이성적으로 생각해보니 그때는 오히려  그 심적인 고통때문에 감정적으로 안하겠다고 한것 같다. 이성적으로 생각해보니, 비중 10퍼센트 정도는 저기에 안넣을 이유가 없다. 10퍼센트 정도라면 내 감정이 요동치지 않을것이고, 일에 집중하면서 투자 할 수 있다. 다만 조심해야 할것은 내가 이미 저 상황에 노출된만큼, 본능을 못이기고 금액을 늘릴 가능성이 있는데,  어차피 시드 다 주식에 있어서 더 돈도 없다.   이더리움 클래식은 어제 돈을 넣자마자 오늘 벌써 20퍼센트가 넘는 수익률을 보이고 있다. 진짜 아무리 생각해도 얼탱이가 없네. 뭐 별생각 없이 그냥 없는돈인셈 치고 넣어두면 시드는 적어도 수익률이 괜찮을것 같다.   이걸로 벌어서 아이패드사야지.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%84%A4%EC%9D%B4%EB%B2%84,-%EB%B9%84%ED%8A%B8%EC%BD%94%EC%9D%B8/",
        "teaser": null
      },{
        "title": "변동성",
        "excerpt":"이 글은 유튜브 ‘월가아재’ 영상을 보고 공부한 내용을 기록한 글입니다.   변동성이란?  변동성이란   당연하겠지만 가격이 얼마나 ‘변동’하는지에 대한 수치이다.  어떠한 상품의 수익률의 표준편차로 계산한 값이며, 리스크의 일반적인 개념으로도 사용한다.   변동성의 종류에는 크게 두가지가 있는데,  첫번째는 실제 변동성(Actual Volatility): 실제로 가격이 얼마나 변동하는지에 대한 수치   두번째는 내재 변동성(Implied Volatility): 시장이 생각하는 변동성   실제 변동성은 실제로 가격이 변화한량을 말한다. 예를 들어 과거 실제 변동성이라고 하면   과거 특정기간(30일, 1년)간의 실제적인 변동성의 수치를 말할 것이다.  단, 현재 실제 변동성은 개념적으로는 존재하나, 현재라는것은 매번 변하고 있으므로 측정이 불가하다.   이 두가지 개념중에서 일반적으로 더 중요하게 받아들여지는건 내재변동성인데   이 내재 변동성은 시장참여자들이 생각하고 있는 변동성이다.   이 내재변동성은 말그대로 ‘내재’된 변동성이라 직접적인 측정이 불가한데   개념을 정확히 알기위해 먼저 옵션에 대해 이해해야 한다.   옵션은 어떠한 상품을 미래에 특정한 가격으로 사거나, 팔 수 있는 권리인데   사는 옵션을 콜옵션, 판매하는 옵션을 풋옵션이라 한다.   이러한 옵션은 옵션프리미엄이라는 가격을 지불하고 그 권리를 구매하게 되는데,   만약 1월 1일 만기인 행사가 100원의 콜옵션을 10의 프리미엄을 주고 구매했다고 치자.   만약 만기에 상품의 가격이 80원 이라면, 이 상품을 굳이 100원의 가격을 주고 살 필요는 없으니.   프리미엄 10을 손해보고 그 권리를 포기 하면 된다.   따라서 콜옵션은 수익은 무한대이지만, 손해는 -10으로 제한된다.      따라서 위의 그래프와 같이 아무리 상품의 가격이 하락해도 손실은 -10으로 제한된다.   ​   반대로 상품의 가격이 올라 150원이 된다면, 우리는 그 콜옵션의 권리를 행사하여, 행사가인 100원에   그 상품을 구매하게 되고, 차익 50원에서 프리미엄가격인 10원을 뺀 40원의 이익을 얻게된다.   이렇게 보면 마치 콜옵션이 손실은 제한적이고 리스크는 한정되어 있어 마냥 좋아 보이겠지만,   만약 콜옵션매수가 아닌 그냥 상품자체를 매수 했다면, 50원의 차익을 얻을것을 40원으로 줄인것이다.   따라서 하방 리스크를 제한하는 대신, 얻을수 있는 수익의 그래프를 아래로 내린 셈이 된다.   ​  반대로 풋옵션은 반대로 팔권리 이므로 가격이 떨어질수록 수익은 늘어나고,   가격이 올랐을때는 콜옵션과 동일하게 프리미엄만큼의 손실을 보고 권리를 포기하면 된다.     하지만 옵션에 있어서 가장 중요한 것은, 저 권리를 구매 할수 있는 프리미엄의 가격이다.      왼쪽의 경우는 프리미엄가격이 100, 오른쪽은 1000인데, 이러한 프리미엄의 가격차이 때문에   왼쪽은 2100만 가격이 넘어가도 수익이 나지만, 오른쪽은 3000을 넘어야 겨우 수익이 나기 시작한다.   이러한 프리미엄의 가격은 어떻게 결정될까??   ​  보통 옵션의 가격은 블랙숄즈 모델을 통해 계산되는데,   이 모델은 다섯가지의 인풋을 가진다.   ​     행사가격 : 콜옵션의 경우 행사가격이 낮을수록 옵션이 비쌈   당연히 싸게 살수 있는 권리일수록 더 많은 차익을 남길 수 있으니 옵션의 가격이 비싸다.   ​     현재 상품 가격 : 콜옵션의 경우는 현재상품 가격이 높을수록 옵션이 비싸다.   만기가 한달남았는데 이미 콜옵션의 행사가와 가까운 가격이라면, 한달만에 충분한 상승을 노릴 수 있기 때문에,   현재상품가격이 낮았을때 보다 프리미엄이 비싸다.   ​  ​- 만기까지 남은시간 : 만기까지 시간이 많이 남았을수록 옵션이 비쌈           이자율 : 이자율이 높을수록 미래 상품가격이 많이 오를것으로 기대되어 (콜)옵션이 비쌈            변동성 : 변동성이 높을수록 가격이 많이 오를 가능성이 있기 때문에, 옵션이 비싸다.       (많이 내릴 가능성도 같이 높아지는 것이지만, 그 경우에는 행사하지 않으면 되는 ‘권리’이기 때문에 상관없음)   ​  이 다섯가지 인풋중 ‘변동성’만은 시장에서 직접적으로 관찰이 불가능한 변수이다.   하지만 블랙숄즈 모델은 [행사가격, 상품가격, 만기, 이자율, 변동성] 을 입력하면 옵션가격을 출력해주기 때문에,   우리는 네가지 인풋을 넣고, 시장에서 직접 관찰 가능한 옵션가격을 공식에 대입하면,   등식이 성립되는 변동성값을 찾아낼수 있다.   ​  따라서 시장 참여자들이 결정한 옵션가격을 미루어 볼때, 그들이 기대하는 미래 변동성이   바로 ‘내재변동성’이다.   ​  이러한 내재변동성을 지수로 나타낸게 VIX지수인데 ,   이 지수가 바로 S&amp;P 500 옵션가격에서 계산되는 내재 변동성이다.   따라서 옵션 가격이 비싸면 VIX지수도 높고, 옵션 가격이 쌀때는 VIX지수가 낮다.   ​  대체로 주가지수와 변동성지수는 역상관관계인데,   주가가 폭락할때 높게 치솟으며, 이번에 코로나 사태때는 신고점을 갱신했다.   왜 변동성 지수와 주가지수는 역의 상관관계를 가질까?   ​  대략 네가지의 이유가 있는데,      공급측면: 주가는 상승할때는 천천히 상승하지만, 하락할때는 공포심리에 의해   패닉셀이 나오면서 급격하게 하락하는 성질이 있다. (변동성 지수는 Fear Indexf라고도 한다.)   즉, 하락장에서는 실제 변동성이 높아지기 때문에 옵션 매도자 입장에서는 그만큼 손실을 볼 위험이   커지는 것이므로, 더 비싼 옵션가격을 요구하게 된다.   ​     수요 측면: 하락장에서 불확실성이 높아지면, 옵션 매수를 통해 그 리스크를 헷지하려는 수요가 늘어나기 때문에 옵션의 가격이 비싸진다.   ​     매매 측면: 주가 지수 움직임에 옵션가격이 영향을 받지만, 옵션시장의 매매 때문에   주가 지수가 영향을 받기도 한다.( 다음 게시물에서 자세히 설명)   ​  4.내재 변동성구조 측면: 심화내용이므로 패스   그렇다면 우리는 이러한 변동성을 왜 알아야할까?   바로 옵션시장에서 벌어지는 일들이 주식 시장에 영향을 미치기 때문이다.   예) 소프트 뱅크 손정의 회장이 테크기업 콜옵션을 매수하는데, 왜 나스닥은 상승할까?   예) 대다수의 헤지펀드들이 보유한 옵션 포지션은 어떤 형태이고, 이는 주식 시장에 어떤 영향을 미칠까?   ​  먼저 이러한 질문들에 대한 답을 알기위해선   옵션시장의 중요한 참여자, 유동성 공급자에 대해서 알아야 한다.   유동성 공급자 (Liquidity Provider) = 마켓메이커 (Market Makre)로,   매수/매도 호가를 제시하는 사람이다.   ​  주식의 경우는 잡주가 아닌이상 항상 사고팔고 하는 사람이 많기때문에   유동성 공급자가 없더라도 충분히 서로가 서로에게 매수, 매도를 할 수 있다.   하지만 옵션의 경우는 행사가, 만기일에 따라서 수백, 수천가지의 옵션이 존재하기 때문에   특정한 옵션을 사거나 팔려고 할때 그 반대 포지션이 없을 확률이 매우크다.   따라서 유동성 공급자, 마켓메이커들이 이러한 매수 매도세에 항상 반대 포지션을 취해줌으로써   시장에 유동성을 공급한다.   ​  그렇다면 무조건 반대 포지션을 취하는 마켓메이커는 이러한 행동을 왜 하는걸까?   마켓메이커의 기본원칙은 매수호가와 매도호가의 차이 = 호가 스프레드를 끊임없이 모으는것이다.   매수호가 101 - 매도호가 103인 경우, 가격은 중간값인 102   누군가가 마켓메이커에게 101에 매도하면, 마켓메이커는 102보다 1 싸게 매수   누군가가 마켓메이커에게 103에 매수하면, 마켓메이커는 102보다 1 비싸게 매도   이런 식으로 시장의 방향과 상관없이 계속 매수 매도를 반복하며 이 1의 확률적 우위   ‘엣지’를 모아간다.   그렇다면 만약 매수포지션을 취했는데 시장이 내린다면 손해인데 이러한 상황은 어떻게 할까?   사실 매수했을때 떨어지는 경우도 있겠지만, 매수했을때 오르는 경우도 있을 것이기 때문에   장기적으로 계속 매수 매도를 반복하면 이러한 손해/이익은 상쇄된다는 가정하에 이 행위를 반복한다.   이것이 마켓메이커의 기본원칙이다.   물론 마켓메이커도 시장이 오를것같다 내릴것 같다는 뷰는 반영을한다.   이러한 원칙 때문에 마켓메이커 입장에서는 갖고있는 포지션이 적으면 적을수록 좋다.   따라서 가장 이상적인 상황은 사려는 사람과 팔려는 사람이 항상 많아서   포지션을 갖고있는 시간이 최소화되는 상황이다.   하지만 이렇게 유동성이 항상 많을 수 없기 때문에 마켓메이커에게는   무조건적으로 필수불가결하게 포지션이 쌓일수 밖에 없다.   따라서 이러한 포지션을 관리하기 위해 비슷한 만기일의 비슷한 행사가의 반대 포지션을 취하려한다.   예를 들어 애플 주식의 1/31만기 150행사가 콜옵션을 매수하게 되면,   비슷한 만기와 행사가인 1/31만기 155행사가 콜옵션을 매도할 기회가 오면 적극적으로 매도한다던지 하는식으로   최대한 비슷한 포지션을 매수 매도 하며 리스크를 최대한 중립으로 만들어,   오로지 엣지에서 오는 이득만을 취하려고 노력한다.   ​  자 다시 아까의 질문으로 돌아가서,   손정의 회장이 기술주 콜옵션을 사서 나스닥이 상승했는가? 에 대한 질문에 대해 다시 생각해보자.   이 질문은 하나처럼 보이지만 사실은,           누군가 기술주 콜옵션을 매수하면, 기술주 주식도 같이 오르는가?            손정의 회장이 매수한 콜옵션이 나스닥을 움직일 정도로 사이즈가 큰가?       이 두가지에 대한 질문으로 볼 수 있다.   손정의 회장이 콜옵션을 매수하게 되면 옵션 시장에는 어떠한 변화가 일어날까?   대규모의 콜옵션을 매수하려고 하면 그 물량은 마켓메이커들이 받아낼 것이다.   그렇게 되면 손정의 회장은 매수포지션, 마켓메이커는 매도포지션을 잡게되고,   위에서 설명했다시피 마켓메이커는 시장의 하락과 상승에 베팅하는 것이 아니므로 최대한 중립적인 포지션을 위해   리스크 헷지를 위한 기술주 현물 주식을 매수한다.   행사가와 주식가가 똑같다고 가정할때 그렇다면 마켓메이커는   콜옵션 매도와 주식의 비율을 어떻게 조정해야 가장 중립적인 포지션을 취할 수 있을까?      먼저 주식가격과 행사가격이 동일하다고 가정할 때,   콜옵션 매도 포지션과 주식매수 포지션을 1:1로 콜옵션을 100개 매도, 주식을 100개 매수했을 경우에는   오른쪽의 보라색 그래프와 같이 풋옵션 매도 포지션을 취한것과 같은 포지션이 된다.   이렇게 되면 주식이 내리면 돈을 잃게 됨으로 헷지가 아니다.      그렇다면 이번에는 콜옵션 매도 포지션과 주식매수 포지션을 2:1로 콜   옵션 매도 100개, 주식 매수 50개의 포지션을취했을 경우를 보자.   위와 동일하게 보라색 선이 이 포지션의 그래프이다.   이렇게 되면 완전히 풋이 되는것이 아니고 콜과 풋의 중간인 좌우 대칭이 된다.   따라서 크게 상승하거나 크게 하락하지만 않으면 되는 중립적인 상태가 되는데, 이처럼 헷지는   상승과 하락에 관계없도록 델타, 즉 ‘방향성’에 대한 노출을 줄이는 것이다.   따라서 콜인지 풋인지는 중요하지 않고, 변동성 자체가 중요하다.   이렇기 때문에 옵션은 방향성 매매가 아니고 변동성 매매임을 알 수 있다.   그렇다면 만약 현재 주식가격이 행사가보다 훨씬 낮다면 어떻게 될까?   위와 동일하게 옵션과 주식을 100개와 50개를 매도 매수했다고 가정했을때,   보라색 손익 그래프는 그 모양 그대로 위로 올라가게 된다.   반대로 주식 가격이 행사가 보다 높은 경우는, 보라색 손익그래프가 모양그대로 아래로 내려가게 될것이다.   근데 다시 생각해보자, 헷지를 하는 이유는 위 아래 모두 동일하게 방향성에 대한 중립상태를 만드는 것인데   만약 주식가격이 더 싼경우에는 주식을 50개 매수 할경우에,   주식이 오를때 더 이익이 많이 나게 손익그래프가 바뀌게됨으로 오르는것을 원하게되고   주식가격이 비싼경우에는 손익그래프가 주가가 내릴때 최대한의 이득이 나오게되어 주가가 내리는걸 원하게된다.   따라서 만약 주식가격이 행사가 보다 싼경우에는 주식수를 줄이고,   주식가격이 행사가 보다 비싼경우에는 주식수를 늘려서 비중을 조절하여야   주식의 방향성이 어디로 가던 중립적인 손익그래프를 얻을 수 있는것이다.   이러한 주식가격의 움직임에 대한 옵션 가격의 민감도를 ‘옵션 델타’(Delta) 라고 하는데,   델타가 0이면, 주식가격이 움직여도 옵션가격에는 아무 영향이 없다는 것이고,   델타가 1이면 주식가격이 움직이는 만큼 그대로 옵셕가격이 따라 움직인 다는것,   델타가 0.5 이면 주식가격의 50퍼센트만큼 옵션가격이 움직인다는 것이다.   예를들어 행사가 100의 콜옵션의 경우      주식가격이 10일 때, 주식가격이 9가 되던 11이 되던, 콜옵션을 행사할 가능성은 거의 없기 때문에   휴지조각과 다름없다. = 델타 0      주식가격이 500일 때, 옵션가격은 거의 주식가격과 동일하게 움직인다. = 델타 1   -주식가격이 행사가와 동일한 100일때, 행사 될확률과 안될 확률이 반반이므로, = 델타 0.5   이러한 델타는 옵션이 행사될 확률로 해석하기도 한다.(엄밀히 말하면 정확하지는 않지만, 대부분의 확률이 그러함)   따라서 상품가격이 오를수록 콜옵션의 델타가 상승한다. 따라서 헷지를 더욱 많이 해야한다.   자 다시 손정의 회장이 콜옵션을 매수 했을때의 상황을 가정해보자.   아마 아무런 대비책 없이 콜옵션을 쌩으로 매수 했을 확률은 매우 적지만,   정말 쌩으로 콜옵션을 매수했다고 가정하자. 그랬다면 행사가가 현재가격보다 높은 싼 옵션을 매수 했을 것이다.   옵션은 세가지 종류로 부를 수 있는데      내가격 옵션 (in the money) : 이미 이익구간에 들어가있는 옵션, 매수하자마자 행사해도 이익임      델타 0.5 이상       중가격 옵션 (at the money) : 주식가격과 행사가가 동일한 옵션,      델타 0.5       외가격 옵션 (out of the money) : 아직 행사가가 먼 옵션,      델타 0.5 미만    ​  내 가격은 바로 행사해도 이익이 나므로 비싸다. 따라서 손정의식 배팅의 의미를 두려면   아마도 외가격 콜옵션을 매수 했을 가능성이 크다.   델타를 0.1이라고 가정하면, 콜옵션을 매도한 마켓메이커는 이러한 포지션을 헷지해주기위해   예를들어 1조정도의 매수를 매도로 받아주었다면 천억원 정도의 주식을 매수했을것이다.   근데 이러한 상황에서 주가가 오르게 된다면, 이러한 헷지를 위해 주가가 오를때마다 주식의 비중을 늘리기 위해   더많은 주식을 매수해야만 방향성에 대한 헷지를 할 수 있다.   따라서 이러한 예가 옵션매수가 왜 현물 주식에 영향을 미치는지에 대한 이유이다.   따라서 우리가 옵션시장에서 무슨일이 일어나는지 알지 못하면,   그저 주식의 움직임이 무작위적으로만   볼 수 밖에 없는 것이다.   ​  따라서 옵션시장에 집중하여 거대 헤지펀드들이 어떠한 포지션을 취하고 있는지에 집중하면,   어느정도 확률적 우위를 선점 할 수 있다.  ","categories": ["finance"],
        "tags": ["금융","변동성","주식"],
        "url": "/finance/%EB%B3%80%EB%8F%99%EC%84%B1/",
        "teaser": null
      },{
        "title": "인플레이션",
        "excerpt":"이 글은 유튜브 ‘월가아재’ 영상을 보고 공부한 내용을 기록한 글입니다.  서론  요즘 주식시장에서 가장 사람들이 주의깊게 보고 있는것이 바로 인플레이션인데, 과연 코로나로 인한 경기침체로 인해서 여러국가들이 어마어마한 역대급 부양책을 실시하고있는 만큼, 과연 인플레이션이 올까 말까에 대한 관심이 아주 뜨겁다. 미국 재무부 장관 옐런은 얼마전 금리가 올릴것이라 발언했다가 수습했지만, 나스닥과 다우지수는 크게 하락했었다. 원자재값과 주식모두 하루가 멀다하고 상승중인 이 추세에 과연 인플레가 올것인지, 아니면 파월의 발언처럼 인플레의 기조는 일시적인 것 뿐이며, 장기적인 인플레 상승의 추세로 접어들지는 않을것인지, 앞으로 투자에 있어 중요하다고 생각되어 영상을 찾던 중 마침 월가아재 채널에 이에대한 정리가 올라와서 한번 블로그에 정리해보려 한다. 이 영상은 Man Group의 논문인 ‘The Best Strategies for Inflationary Times’를 참고하였다.   ​왜 인플레이션은 채권가격 형성에 영향을 미칠까?  인플레는 두가지 종류가 있는데, 기대 인플레(Expected Inflation)와 예상치 못한 인플레(Unexpected Infaltion)가 있다. 이 중 기대인플레이션은 이미 채권가격에 반영되어 있기 때문에, 중요한것은 예상치 못한 인플레이션인데, 인플레율의 변화율을 말한다고 생각하면 된다.   ​   인플레이션이 증가하면, 돈의가치가 빠르게 떨어지기 때문에, 채권 가격이 하락하여 채권금리가 상승한다.   채권은 고정적인 이자를 지급하기 때문에 인플레이션이 증가하면 그 고정이자에서 인플레이션분을 뺀 가격이 수익이 되는 것이기 때문에 사람들은 더 낮은 가격에 채권을 사려고 하고, 채권 가격이 내려가면 채권 금리가 상승하게된다. 또, 인플레이션이 증가한다는것은 미래에 대한 불확실성이 늘어난다는 것이기 때문에, 금리가 상승한다.   인플레이션은 주식가격에도 타격을 주는데, 첫째로는 인플레이션의 수치 변동성이 커지면 그만큼 시장에 불확실성이 증가하는것이기 때문에, 기업으로 하여금 계획, 투자, 운영을 소극적으로 만들게되고 시장점유율이 높은 기업들은 인플레로 인한 원가상승의 부담을 소비자에게 전가할수 있겠지만, 그렇지 못한 기업들이 대부분이기 때문에 기업들의 마진하락으로 이어진다. 또, 인플레이션은 미래경기에 대해 악영향이므로 미래에 대한 소득이 하락하게되고, 기업들의 경우 설비투자를 할 경우 그러한 설비들의 감가상각을 비용처리하여 절세를 할 수 있는데, 인플레가 있을경우에는 이 감가상각비용이 지나치게 낮게 인정되어 세금 손해를 보게된다. 마지막으로 이러한 인플레이션은 리스크 프리미엄을 증가시키므로, 먼 미래에 수익이 있는 기업들의 할인율을 증가시켜, 주가를 하락시킬 수 있다. 따라서 먼미래에 수익이 많은 성장주 일수록 큰타격을 입게된다.   자 그렇다면 인플레이션에 대해 이야기 하기전에,   ‘인플레이션이 왔다’라고 할 수 있게되는 인플레이션 시기(Regime)에 대해서 정의부터 하고 알아보도록 하자.  인플레를 정의하기는 매우 어려운데, 이는 인플레이션이 질적인 향상을 반영하지 않기 때문이다.  예를들어 지금의 스마트폰의 성능은 90년대에 300억하던 슈퍼컴퓨터의 성능을 뛰어넘는데, 이러한 인플레 수치는 물건자체의 질적인 향상은 반영하지 않는다.   그렇기 때문에 인플레의 정의에 있어서 가장 중요한것은 시장 컨센서스라고 할 수있는데, 다시말해 시장 참여자들이 미래 인플레이션을 어떻게 생각하고 있고, 최대한 많은 시장 참여자들이 보는 지표가 중요하다고 할 수있다.   이 논문에서는 CPI Headline Infalation을 기준으로 인플레를 정의하였고, 인플레이션 시기라 함은 연간 인플레율이 2퍼센트보다 상당히 높게 지속되는 기간으로 보통 정의하며, 이 논문에서는 5퍼센트 이상의 수치가 나온 지점부터를 인플레시기의 시작으로 보고있다.   이 논문은 지난 백여년간의 세계 경제에 있어 인플레이션 시기를 8번의 사건으로 정의했는데,           세계 2차대전 초기(1941-1942)            세계 2차대전 직후(1946-1947)            한국 전쟁 시기 (1950-1951)            브레튼우즈 체제 말기 (1966-1970)            1차 오일 쇼크(1973-1974)            이란 혁명 (1977-1980)            레이건 호황(1987-1990)            중국 수요 호황 (2007-2008)       이러한 정의를 바탕으로 주식과 채권의 인플레이션 시기 수익률을 알아보도록 하자.      왼쪽 그래프를 보면 가로축은 인플레이션 상승률, 세로축은 주가를 나타낸다.   금색선은 인플레 상승률이 중간값보다 낮은때이고, 파란색은 인플레 상승률이 중간값보다 높은 값을 가질때인데,   인플레 상슬률이 중간값보다 낮을때는 인플레가 상승하면 주가도 따라 상승하지만, 인플레 상승률이 중간값보다 낮을때는 인플레 증가에따라 주가가 하락한다. 보통 인플레가 낮다가 올라올때는 경기 상승시기, 인플레가 평균에서 높은 값으로 올라갈때는 경기 과열시기로 볼 수 있기 때문에 직관적으로도 그럴 수 있다고 느껴진다.   오른쪽 그래프도 마찬가지도 비슷한의미를 갖는 그래프인데, 인플레이션과 주가와의 상관관계를 나눈 그래프로, 인플레 상승시기의 인플레율을 하위부터 20퍼센트의 덩어리로 나누어놓은 것으로, 인플레율이 하위 20프로일때만 양의 상관관계를 갖고, 나머지는 모두 음의 상관관계를 갖는것을 알 수 있다.   ​  ​  ​ 그에 비해 국채의 경우는 그래프와 상관관계 모두 인플레 상승률에 관계없이 인플레가 상승하면 국채 가격은 하락하는것을 알 수 있다   ​  ​빨갛게 칠해진 부분이 실질 수익률, 맨 오른쪽 t stat 이 통계적 유의미성(*이 쳐져있을시 통계적으로 유의미하다는 뜻임)   또 인플레시기의 주식 섹터별 수익률을 보면 에너지 섹터만이 통계적 유의미성이 떨어지기 때문에 제외하고, 나머지 모든 섹터가 마이너스 실질수익률을 기록했다. 금융주의 경우는 금리상승이 호재로 작용하여 수익률이 높다고 생각할 수 있지만, 기업들의 파산율이 높아짐에따라 금리상승에 대한 이익보다 그로인한 손해가 더 크기 때문에 실질 수익률은 높지 않음을 알 수 있다.   이러한 수치들은 그야말로 과거의 수치들이기 때문에 현재에 그대로 적용하기에는 무리가 있다.   하지만 원자재의 경우 인플레 시기에, 인플레를 감안하더라도 아주 높은 실질 수익률을 기록했다.   ​  ​마찬 가지로 초록색부분 실질 수익률, t stat이 통계적 유의미성  ​  ​​   ​마찬가지로 상관관계에 대한그래프를 보아도, 원자재는 인플레가 상승하기만 하면   덩달아 상승하는 양의 관계를 갖는 다는 사실을 알 수 있다.   ​본 논문은 지속성이 있는 인플레가 왔다고 가정할때의 각 자산의 수익률을 분석한것으로,   ​  이러한 과거의 데이터들이 올해에 지속성이 있는 인플레가 올지 안올지는 별개의 문제이다.   게다가 이것은 100년치의 데이터를 분석했다지만 여전히 과거의 데이터일 뿐, 앞으로의 인플레이션의 경향은   또 달라질수도 있다는것에 주의하여야 한다. 과거와 현재가 인플레에 대해 다른 점을 꼽아 보자면 아래의 내용들을 꼽을 수 있는데,           과거와 달리 현재는 미국의 셰일혁명으로 인해 원유 수입의존도가 매우 낮아지고, 전기차가 상용화 되기 시작함과 동시에 과거와 달리 기술개발로 인한 원유의 사용효율이 증가해 원유에서 오는 인플레 압력이 매우 낮아졌다.            과거의 미국은 제조업 중심국가라 인플레에 민감하게 경기가 반응했지만, 현재는 GDP 11퍼센트만 제조업이며  많은 자본들이 물리적 설비 투자 보다는 무형의 자산에 집중되어 있어, 인플레에 강건한 모습을 보이고 있다.       따라서 이러한 관점에서, 우리는 인플레와 성장이라는 두가지 측면에서 시나리오를 생각해보아야한다.   인플레와 성장, 또 이것을 두가지로, 나누어 보면   일시적 인플레 vs 지속되는 인플레   강한 성장 vs 성장 둔화   따라서 저 네가지를 조합하여 나올수 있는 네가지 시나리오들에 대해 동일한 확률 25퍼센트를 배정해 놓고, 경제지표나 각종 지표들의 발표들을 주시하여 그에따라 각 시나리오에 대한 확률을 조금씩 변경하여 포트폴리오에 적용하는것이 필요하다. 이러한 확률들의 계산 결과에 따라 가장 다른시나리오들에 비해 확률적 우위가 있는 상품을 찾아 내며 대응하는것이, 승률을 높일 수 있는 가장 좋은 방법일 것이다.   나의 생각  오늘 내용을 통해 인플레이션이 왔던 과거의 데이터를 살펴봄으로써, 인플레가 왔을때 각 금융상품군들이 인플레에 어떻게 반응하는지를 알아보았다. 물론 이것들은 과거의 데이터이며, 과거와 현재의 경제 상황이 크게 달라진만큼 저위의 논문에서 나온것처럼 금융 상품들이 반응하지 않을 수도 있다는 점을 주의해야겠지만, 원자재가 인플레시기에 수익률이 좋다는 사실은 크게 변하지 않을것 같다는 생각이 든다. 결국 원자재는 현금가치하락에 따라 당연히 필연적으로 가격이 오를 수 밖에 없으니 과거와 특별히 달라진 상황이 없을것같다는 예측이 맞을 것 같다.   현재 내 포트폴리오에는 원자재인 농산물과 구리가 있고, 주식 상품군이 두개가 있다. 지금 추세는 원자재와 주식 모두가 우상향하고 있다고 느껴지는데, 그렇다는것은 저 위의 논문대로라면 인플레 상승 초입에 나타나는 현상이 라고 볼 수 있지만, 아직까지 나온 지표들로 인플레가 왔다고 판단하기에는 이르다고 생각된다. 하지만 나는 아직은 인플레상승에 대한 시장의 우려가 평균보다 높다고 생각해, 인플레 초기에 수익을 볼 수 있는 주식상품고 원자재를 모두 가지고 있는채로 대응 해보려 한다. 이후 인플레 우려가 줄어든다고 생각하면 원자재 비중을 줄이고, 인플레 우려가 오히려 증가한다고 느껴지면, 주식상품 비중을 줄임으로써 확률적 우위를 쌓아보도록 할것이다.  ","categories": ["finance"],
        "tags": ["금융","인플레이션","주식"],
        "url": "/finance/%EC%9D%B8%ED%94%8C%EB%A0%88%EC%9D%B4%EC%85%98/",
        "teaser": null
      },{
        "title": "사이킷런 (2)  캘리포니아 주택가격 예측 모델",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런 (2) 캘리포니아 주택가격 예측 모델  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0-(2)-%EC%BA%98%EB%A6%AC%ED%8F%AC%EB%8B%88%EC%95%84-%EC%A3%BC%ED%83%9D%EA%B0%80%EA%B2%A9-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8/",
        "teaser": null
      },{
        "title": "오큘러스",
        "excerpt":"2021.05.10  몇일동안 고민했던 오큘러스 퀘스트2를 질렀다.  아마 내일 도착할것 같다. 아 그냥 미리 살걸.  고민 하던사이 64GB는 품절되서 강제로 14만원을 더주고 256GB로 샀다.   뭐 어차피 용량 많이 필요하다고는 하는데, 보니까 게임더 별로 없던것 같더만….  게임도 좀 하고 영화도 보고 운동도 그걸로 해볼까 생각중이다.  언젠가 한번쯤 제대로 된 vr을 한번 해보고 싶었는데,  오큘러스가 vr치고 말도 안되는 가격과 성능으로 나와줘서 작년 출시부터 너무 사고 싶었지만 돈이 없어서 그냥 생각도 안 하고 있었는데, 뭐 요즘 돈도 많이 생겼기도 하고 요즘같이 중고 시장이 잘되어있는 시대에 그냥 좀 사서 하다가 재미없으 면 중고로 처분해버리면 되는데 뭐 크게 고민할거 있나 싶어서 샀다.  지금 물량도 크게 많지 않아서 감가도 적은편이라, 그냥 재미없으면 싸게 렌탈했다 치고 팔아버릴 셈이다. 물론 게임이 좀 비싸서 한달은 써야게임값은 뽑으려나…   지금 보고 있는 게임은 언틸유폴, 뭐 복싱하는거랑, 비트세이버정도 생각하고 있다.  하프라이프 알릭스는 진짜 꼭해봐야 한다하는데, 집 컴퓨터 사양이 안되서 집에서는 못할것같고 날잡고 친구네 가서 하루동안 조져버릴까 생각중이다.   어릴때는 터치라는 기술이 너무 신기하고 갖고싶었는데, 어느새 터치는 거의 일상이 되었고 이제는  맨날 맨날 새로운 기술이 나온다. 심지어 가격도 낮아져서 솔직히 한 2년여전만 해도 vr기기는 기본 백오십만원은 줘야 의 미있는 체험이 가능했는데, 이제는 40만원으로도 즐길수가 있다. 기술의 발전이 가속도가 붙는다고는 하지만 요즘은 진짜 하루하루가 신기술의 연속인것같다.   이 일기를 쓰는도중 택배 출고문자가 왔다. 무슨 어제 저녁에 주문했는데 출고하나는 오지게 빠르네.  빨리 내일이 됐으면 좋겠다. 아 그냥 금요일날 살걸. 나이가 먹어도 택배 기다리는건 세상에서 제일 어렵다. 이러니 쿠팡 로켓배송이 불티나게 팔리겠지.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%98%A4%ED%81%98%EB%9F%AC%EC%8A%A4/",
        "teaser": null
      },{
        "title": "요즘",
        "excerpt":"2021.05.11  세상이 언제는 안혼란했겠냐 하지만 요즘처럼 혼란한 시대가 있나싶다.  물론 우리 아빠는 나한테 맨날 좋은 시대에 태어났음을 감사하라고 하지만 내가 진짜 좋은 시대에 태어났는지 모르겠다. 물론 아빠가 고생해서 이뤄놓은 기반을 내가 누리는 건 맞고, 애처럼 이걸 당연하다고 생각하면서 살지도 않는다. 내가 말 하는거는 이 시대와 세대에 대한 이야기인데 아무래도 아빠는 그냥 별 관심이 없으셔서 그런가 잘 모르시는 것 같다. 이런 작은 차이들이 사회에서는 크게 벌어진채로 나타나는걸까?   코로나로 인해 주변에는 취업했다 하는 사람이 거의없고, 경제는 어느정도 나아지긴 했지만 아직도 모든 경제 지표는 바닥 에 머물러있다. 백신은 나같은 20대는 언제 구경 할 수 있을지도 모를 상황이 되어버렸고 사람들은 이제 한계에 다다른것 같다. 다들 코로나 초반의 방역의지는 온데간데 없다. 집에 있기만 하니까 답답하기도 하고, 북적하던 대학가에서는 아무 소리도 없다. 하지만 이런것들은 아무래도 좋다. 이런건 다 병때문이기도 하고, 어쩔 수 없는 것들이며, 인간의 힘으로는 막을 수 없는 자연재해 같은거라고 치자.   내가 가장 요즘 힘든건 갈등과 혐오다. 인터넷만 켜면 온갖 갈등과 혐오가 만연하다. 이렇게까지 갈등이 치솟은 적이 있었 나 싶다. 지역갈등도, 좌우갈등도 이정도는 아니었다. 사람들은 누가 잘못을 저지르만은 계속 지켜보다가 사소한 잘못이라 도 하면 진짜 기다렸다는 듯이 물어뜯고 돌을 던진다. 맨날 하루하루가 지날때마다 새로운 폭로가 터지고, 사건이 터지고, 신나는건 유튜브 렉카들 밖에 없다. 코로나로 받는 스트레스들을 그렇게 풀고는 하는걸까?  그 중에서 가장 심한건 뭐니뭐니해도 남녀갈등이다. 이건 진짜 답이 없다. 도대체 누가 시작한지도 모를 이 지독한 갈등은 내가 겪어본 갈등중에 가장 심하고, 답답하며, 가장 재앙에 가깝게 느껴진다. 다른 갈등에서 발생하는 혐오들은 누가 공개 적인 자리에서 그러한 발언을 하면 당연하게 미친놈 취급을 받는다. 그리고 그 갈등은 솔직히 그들만의 것이다. 혐오를 하 고자 하는이들의 것. 일반인들은 그에대해 별생각이 없으며, 아무도 그걸 염두에 두고 살아가지 않는다.   근데 이 남녀 갈등은 수위가 선을 넘었다. 어떠한 갈등이 이렇게 노골적이고 저급하게 서로 싸우는 수준일수가 있을까? 아 무런 논리도 없고 논의도 없고 토론도 없고, 그저 원색적인 서로에 대한 욕설과 비꼬기 밖에 없다. 왜 가장 서로 사랑하고 아껴주어야 할 남녀가 이토록 갈등에 빠졌는지 도저히 모르겠다. 서로에 대한 불신이 이제는 일상생활까지 넘어와 실제로 주변의 친구들을 보면 사상에 대한 고민을 할 정도다. 내 주변에는 정상적이고 건강한 생각을 가진 사람들 밖에 없는데, 도 대체 왜 맨날 일어나는 사건사고들의 사람들은 그렇게 혐오에 가득 차있는 것일까.   내가 더 화가나는건 아무 어른들도 이걸 언급하지도 않고, 중재하려고 하지 않는다. 그동안의 좌우갈등, 지역갈등, 세대갈등등은 누군가가 항상 목소리를 냈으며 관심을 가져주었고, 중재했다. 그래선 안된다는 목소리가 항상있었고 해결방안에 대한 논의도 활발한 편이었다. 근데 도대체 왜 이 남녀갈등에 있어서는 아무도 이게 문제라고 말을 안하고 부추기기만 하 는것인지 모르겠다. 난 내가 느끼는 가장 큰 사회문제인데, 정치권에서는 자꾸 아니라고만 한다. 그런건 존재하지않는다고 못들은 척을 한다. 이미 남녀 표가 갈려서 그 중간에서 목소리를 내기엔 돌아올 수 없는 강을 건너버린 것일까? 도대체 이 긴 남녀갈등은 어디까지 가야 서로 지쳐서 그만둘까. 왜 가장 서로 사랑하고 즐거워야 할 20대의 남녀들이 이런 혐오와 갈 등속에서 서로를 의심하고 비난하고 싸워야 하는건지 모르겠다.   난 이렇게 이념과 세대, 성별갈등이 일어나는 책임이 어느정도 유튜브에 있다고 생각한다.  소위 ‘알고리즘’이라고 불리우는 이 기능. 내가 어떠한 영상에 관심이 있어서 그 영상을 켜면 계속 그와 관련되고, 비슷한 성향의 영상만 보여준다. 물론 제작 의도는 사용자로 하여금 관심이있는 영상을 더 보여주면 영상시청 시간이 늘어날 것이 고, 광고의 효과도 탁월할 것이라는 생각이었겠지만, 이게 이념이나 갈등에 대한 영상이라면 이건 진짜 재앙이 된다.   이러이러한 주장이 맞다고 말하는 영상이나 게시물을 시청하면, 알고리즘은 계속해서 그 주장이 맞다고 주장하는 영상만 계속 보여주고, 이는 편향된 의견을 머리에 주입시킨다. 편향된 의견만 듣다보면 점점 그 주장이 맞다고 생각하게 되고, 더 욱 그러한 성향의 영상만 접하다보면 한 일주일만 지나도 그 사람의 사상은 한쪽에 편향되어버릴것이다. 게다가 영상컨텐 츠는 아주 매력적이다. 진실에대해 깊이 생각할 필요도 없으며, 쉽게 머리에 주입할 수 있게 10분여내로 요약하여 아주 잘 편집되어 있고, 댓글들은 보통 이미 편향된 사람들이기 때문에 모두가 그 주장에 동조하고 있는 의견들 밖에 없다. 글은 읽 기 귀찮고 머리가 아프니 그냥 영상을 보는 경우가 많은데, 이쯤되면 뇌는 사고를 하나도 안하고 그냥 그 정보를 받아들인다.   사람들은 몇년전만 해도 글을 읽었다. 페이스북은 글이 그래도 주인 sns였고, 영상이 있긴 했지만 대부분 글과 함께 첨부 된, 글을 뒷받침 하고자 하는 영상이었다. 하지만 글을 읽는 행위보다는 영상을 보는 행위가 더 매력적이고, 자극적인 행위 라는걸 사람들은 알았다. 그래서 페이스북이 담당하던 자리는 유튜브로 점점 바뀌게 되었다. 유튜브도 그때는 이렇게 영상 시간이 짧지 않았다. 몇년 전 컨텐츠를 보면 그래도 대부분 2-30분여의 컨텐츠가 꽤 있고, 편집속도도 지금에 비하면 아주 템포가 느리다. 사람들은 긴 영상마저 보기 귀찮아 하고, 더 요약된 정보와 재미를 원했다. 유튜브의 영상 편집 템포는 점 점 짧아졌고, 영상길이는 점점 10분도 안되는 길이에 이르르기 시작했다. 근데 사람들은 이것도 길다고 느끼기 시작했다. 짧은시간에 한영상만 보기보다는 여러 영상을 보면서 새로운 자극을 계속 느끼고 싶어했다. 그래서 이제는 틱톡이 유행하 기 시작했다. 사람들은 더 짧은시간안에 많은 자극을 느낄 수 있었고 아무 생각없이 그 짧은 영상의 정보를 받아들였다. 그 래서 유튜브는 이에 질세라 유튜브 Shorts를 베타테스트 하고 있다.   영상으로 된 짧게 요약된 정보는 뇌에 아주 자극적이다. 알아듣기 아주 쉽고 생각할 필요없이 정보를 받아들일 수 있다. 거 기다 유튜브는 나의 흥미를 아주 잘 파악해 내 뇌가 즐거워할만한 영상을 쏟아주니, 난 그냥 가만히 서서 그걸 누리면 된 다. 하지만 요약된 정보일수록 왜곡은 아주 쉽고, 내가 생각할 영역은 줄어든다.  이렇게 자꾸 누워서 쏟아지는 정보를 받고 있자니 서로의 잘못된 사상은 더욱 강화되고 무조건 내 생각이 맞다고 생각 하게 되는것 같다. 대화라는건 또 얼마나 귀찮고 힘든일인지, 다들 방구석에서 키보드로만 이야기하니 갈등이 사라질리가 없 다. 몇년전만 해도 주요한 갈등 사안에 있어서는 토론프로그램에서 특집 편성을 하기도 하고, 네티즌끼리 영상 컨텐츠로 다루기도 했지만, 지금은 토론에 대한 프로그램은 거의 없고 한가지 의견만을 주장하는 영상밖에 없는 것같다.   이미 2-30대의 자발적인 의지로는 이 갈등을 해소하기 불가능한 지점에 이르렀다는 생각이든다. 제발 이제라도 정치권이던 언론이던 나서서 이 싸움이 잘못됐다는걸 좀 알려줬으며 좋겠다.  애초에 남녀갈등은 누가 더 꿀빤다 누가 더 차별받는다에 대한, 한쪽이 차별받으면 한쪽이 우세하고, 한쪽이 우세하면 한 쪽이 차별받는 영역이 아니다. 각자가 차별받는 부분에 대해 해결점을 제시해야하는 부분이다.   여성의 경력단절이 문제라고 하면 그걸 해결할 만한 방법을 찾으면 되고, 군복무에 따른 손해가 문제라고 한다면 그 역시 그에 대한 해결방안을 찾으면 된다.  애초에 하나를 해결한다고 한 성별이 차별받는, 그러한 시소에 놓여진 관계가 아니다. 제발 이 지독한 갈등이 어떤 방식에서라도 빨리 끝났으면 좋겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%94%EC%A6%98/",
        "teaser": null
      },{
        "title": "투자",
        "excerpt":"2021.05.17  저번주만 해도 빨간불이던 계좌가 파랗게 물들었다. 수익 날때 적당히 매도했어야 했는데… 얼마전에 천영록 대표가 매도타이밍에 대해 말한 영상을 시청했는데, 그 영상이 너무나 인상깊어서 매도 타이밍을 놓친 것 같기도 하다.   영상의 요지를 쉽게 축약하면, 손절은 빠르게, 익절은 최대한 늦게 해서 계좌에  파란불을 모두 지우고 빨간불만 남겨놓으라는 영상이었다. 이렇게 해야하는 이유를 몇가지 들었는데,  첫번째는 손절은 물론 괴로운 일이지만, 수익이 마이너스인 종목은 더 마이너스의 추세로 갈 확률이 높고 플로스인 종목은 더 플러스로 갈 확률이 높기때문이고, 두번째는 그러한 플러스 종목은 심리적 우위를 가져다 주어 조금 더 손절은 쉽게, 익 절은 어렵게 하게 될것이라는 이유에서다.   심지어 손절이 매우 고민되는 종목이라면 다시 팔고 바로 다시 사는 것도 추천했다. 물론 수수료와 세금이 들어가겠지만, 내 머리가 인식하는 손절액이 작아져 다시 심리적 우위를 가질 수 있을 뿐만아니라, 신기하게도 매도하는 순간 다시 사고 싶은 마음이 안들 경우에는 과감히 손절을 그대로 진행 할 수 있다는 것에서 그렇다는 것이었다.   물론 투자를 하다보면, 정말로 심리적 우위라는게 존재하기는 한다는걸 나도 안다. 나도 어떻게든 내 뇌를 속이려고 손실 이 난 계좌는 비용을 제외한채로 눈에 보이는 손실액을 더 낮춰보려고도 하고, 실제로 비트코인을 투자할때는 다시 팔고 바로 다시사거나, 평단가를 임의로 수정하기도 한다. ( 주식과 달리 코인은 내 평단가를 임의로 수정가능하다.)   하지만 아무래도 이러한 요지의 발언을 하신게 아무래도 장투로 가치투자를 하는 사람들에게  하는 말이었지 싶다. 천대표는 심지어 세자릿수 수익률만 가득찬 계좌를 만들어보라고 했는데, 단기~중기의 매매에서 세 자리 수익률을 계좌에 가득 채우는건 사실상 힘들지 싶다.   어쨌든 장기투자에 관점에서 말했던, 단기투자의 관점에서 말했던 간에, 손절은 과감히 하고 익절은 망설여야 하는건 맞는 말이기에 어느정도 적용할 부분이 있다 싶어 얼마전 수익이 날때 조금 더 욕심을 부렸던건데, 그게 독이 된것 같다. 근데 쓰다 보니까 이거 오늘 일기였는데 어째 점점 매매일지에다 올려야할 내용이 되가는것 같은데? 아무튼 이제는 머리좀 쓰고 매매한다고 생각했는데 아직도 뇌동매매 할때가 간혹 있는것 같다.   사실 매수한 종목들도 근거가 좀 부족하고, 계좌 자체를 어느정도의 전략을 갖고 기록하면서 수익권이 나오면 한번에 청산하는 습관을 들여야겠다.  요즘 드는 생각이 공부던 투자던 뭐던 기록하고 측정하여 개선할 방향이 좀 보이지 싶다.  그냥 머릿속으로만 이러이러하니까 이렇게 해야지~ 하고 계획하면 손해보는 게 좀 많은듯. 측정하는거 물론 귀찮고 시간많이 들지만, 그걸로 효율을 끌어올린다고 생각하고 아끼지 말아야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%88%AC%EC%9E%90/",
        "teaser": null
      },{
        "title": "사이킷런 (3) 손글씨 분류 모델 ",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런 (3) - 손글씨 분류 모델  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0-(3)-%EC%86%90%EA%B8%80%EC%94%A8-%EB%B6%84%EB%A5%98-%EB%AA%A8%EB%8D%B8/",
        "teaser": null
      },{
        "title": "일론머스크",
        "excerpt":"2021.05.18  요 몇일간 일론머스크 때문에 비트코인시장이 완전히 휘청했다.  나도 100만원정도 도지코인을 갖고있는데, 사실 도지코인은 그렇게 세게 안맞아서 별 타격은 없었다. 애초에 물려서 몇일에 한번 볼까 말까이기도 하고….   비트코인 자체에 가치가 있다고는 생각안하지만, 10퍼센트 정도는 포트폴리오에 추가할만하다고 생각했다. 10퍼센트정도면 괜찮겠지~ 하고 투자했는데 다시 생각 해보니까 비중이 좀 큰것 같기도 하다.  한 몇개월정도 보고 투자하기에 비트코인은 변동성은 좀 커도 나름 괜찮은 상품같다.  물론 중요한 점은 금액이 커지면 안된다는것. MDD가 너무 커서 큰 금액으로 한번 물리면, 아니 돈을 벌어도 잠을 잘 수가 없다. 실제로 비트코인에 큰 금액을 투자 하고있을 떄는 아침 여섯시도 전에 맨날 눈이 떠졌다. 이런 비트코인에 인생을 걸고 큰 금액을 투자하는 사람들은 지금 어떤 기분이 들까.  어제는 비트코인 폭락에 못견딘 사람 한명이 뛰어내리겠다고 한강 다리에 올라갔다가 다시 반등하는 비트코인을 보고 내려오는 웃지 못할 해프닝도 있었는데,  참 세상 돌아가는게 언제는 안 웃겼나 싶지만서도 요즘은 좀 오바지 싶다.   비트코인붐은 언제 끝날까. 어제 연준이 비트코인을 유동성 주머니로 사용하는게 아닐까라는 의견에 대한 영상을 봤는데, 물론 그분은 뇌피셜이라고 덧붙이며 말했지만 정황상 그게 맞다는 생각이 들었다.  나도 너무나 이상할정도로 비트코인에 대해 규제를 안하는 이 스탠스가 이상하다고 생각은 했는데,  그냥 사람들이 너무 많이사서 진짜 욕먹을까봐 규제 안하나? 이 정도 였다.  솔직히 이 엄청난 변동성에 올라탈 생각만 했지, 왜 규제를 안하는가에 대한 이유에 대한건 생각안해봤었다.  영상에 대해 간단히 설명하자면, 지금 연준에서 시행하고 있는 역사적 최대의 부양정책에서는 필연적으로 과한 유동성으로 인한 버블이 낄 수 밖에 없는데, 이러한 버블의 위험을 지금 비트코인이라는 유동성 주머니가 모두 받아 내주고 있다는 것이다. 시장에 공급되어 주식, 부 동산, 원자재로 향해야 할 이 유동성들이 전부 비트코인으로 쏠리고 있는 이 상황에서 굳이 이렇게 꿀같은 상황을 연준이 제재를 가할 필요가 없다. 심지어 이 유동성 주머니는 규제 해버리면 바로 꺼내 쓸 수 있어서, 테이퍼링이나 금리인상이 슬 슬 필요할 시기에는 바로 제재를 가해 이 곳으로 모여있는 유동성을 다시 꺼낼 수 도있는 상황, 심지어 비트코인의 폭락은 주식이나 부동산 폭락에 비해 시장이 받아들이는 충격도 아주 작으며 정부 입장에서는 책임도 없다시피한 수준이다. 따라서 연준과 미국 정부가 이 과열된 비트코인 시장을 하나의 유동성 주머니로써 사용하고 있는건 아닐까? 라는 가정 수준의 영상이었다.   물론 말한사람도 그냥 뇌피셜이고 추측이라 했지만,  솔직히 정황상 미국은 비트코인을 왜 제재하지않는가? 에대한 가장 논리적이고 타당한 이유가 아닐까 싶다.  또 코인얘기를 하자면 일론머스크를 빼놓을 수 없는데  진짜 세계 1위부자(물론 지금은 아니지만)이자 성공한 사업가가 저런식으로 행동하는게  너무 웃기긴하다. 역시 자유의 나라 미국이라 그런가, 정부가 싫어하는짓만 골라서 하는데도 의외로 하는짓에 비해 미국 정부한테 별로 안혼나는듯 하다.   사실 자율주행사업이나 항공우주사업이나 결국에는 정부의 눈치를 봐야할 수 밖에 없는 사업인데  저렇게 밉보이는 짓만 골라서 하다가 진짜 골로 가는건 아닌지, 물론 내가 세계 1위부자 걱정할 처지는 아니지만 요즘은 진짜 선을 넘는것 같아 걱정이다. 물론 저러고 뒤에서는 바이든앞에서 무릎꿇고 있을지 모르겠다.  약간 주류들, 기성세대들에게 반발하는 이미지를 가져감으로써 어떠한 사업상의 이득을 보려고 하는것같은데  갑자기 비트코인을 테슬라 결제에 사용하게 한다더니 또 돌연 취소해서 주가를 폭락시키고, 도지코인을 언급해서  가격을 오지게 띄우더니 또 무슨 도지-x 인공위성을 띄우고 결제 수단을 도지코인으로 한단다.  이번에 비트코인 결제 지원을 취소한 이유를 비트코인의 엄청난 전기사용량으로 인한 환경 문제를 들던데,  전력소모가 적은 코인으로 선택한게 도지코인일수도 있겠다 싶다는 생각이 들었다. 이미 3년여전부터 개발자들한테 지원 을 했고 계속 개발자들과 컨택했다는 사실이 밝혀졌는데, 설마 이러한 전력소모가 어마어마한 비트코인의 대체제로 코인 을 찾던 도중 도지 코인을 찾게 되었고, 이를 실제 결제수단으로 사용하기위해 계속 언급하고 띄워 도지코인의 네트워크를 형성하기 위한 초석이었다면??   물론 그냥 뇌피셜이고 개소리지만, 일론머스크라면 그럴수도 있겠다는 생각이 든다. 나보다 똑똑한 사람이니까 다 생각이 있겠지…   마침 일론머스크에 관한 내용을 쓰고있는데  아빠가 주문한 테슬라 모델3가 2분기 인도가 힘들다는 카톡이 왔다. 미안해 욕안할게 머스크 차 좀 빨리줘~~~  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%BC%EB%A1%A0%EB%A8%B8%EC%8A%A4%ED%81%AC/",
        "teaser": null
      },{
        "title": "반복",
        "excerpt":"2021.05.22  왜 사람은 같은 실수를 반복하게 되는걸까…  방금 눈앞에서 20만원이 사라졌다. 아 김연준 개패고싶네  안한다 해놓고 또하고 안한다 해놓고 또하고 중독성이 거의 뭐 도박급이다.  심지어 한번 잃으면 그거 복구하려고 눈에 불을켜고 막 도파민이 분비 되는 느낌이 들면서 돌아버리겠다.  주식으로 건강하게 잘 투자 하고있었구만 코인으로 순식간에 날려버리다니  원칙을 세웠으면 지켜야되는데 참 말을 안듣는다. 이렇게 일기를 쓰고 또 나중에 또 하겠지 그러기 위해선 아예 내가 실수할 환경자체에 놓이는 상황을 만들지 말아야한다.  나를 제발 믿지 말자.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B0%98%EB%B3%B5/",
        "teaser": null
      },{
        "title": "아이패드",
        "excerpt":"2021.05.24  아이패드를 질렀다.  m1이 들어가서 도저히 참지못하고 질러버렸다. 사실 사봤자 유튜브랑 필기밖에 안하는데 대체 왜…   wwdc때 아이패드 뭐 새로운 기능이라도… 발표해주겠지…  램도늘리고 m1칩까지 박아놓고 ipadOS만 쓰라는건 말도 안된다.   요즘 거기다가 자꾸 스마트 키보드 까지 발표하는걸보니 심상치가 않다.  팀쿡아~~   아이패드도 맥os비스무리하게 쓰게 해줘라~~ 부탁할게~~  아 맞다 오늘부터 오늘일기 챌린지 15000원짜리 시작이다. 꾸준히 써야지. 벌어서 애플펜슬 사는데 보태야겠다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%95%84%EC%9D%B4%ED%8C%A8%EB%93%9C/",
        "teaser": null
      },{
        "title": "사이킷런 (4) 중고차 가격예측",
        "excerpt":"URL   네이버 블로그에서 이전하여 URL로 남깁니다.   Link : 사이킷런 (4) 중고차 가격예측  ","categories": ["machinelearning"],
        "tags": ["머신러닝","사이킷런","선형회귀"],
        "url": "/machinelearning/%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0-(4)-%EC%A4%91%EA%B3%A0%EC%B0%A8-%EA%B0%80%EA%B2%A9%EC%98%88%EC%B8%A1/",
        "teaser": null
      },{
        "title": "블로그",
        "excerpt":"2021.05.26  어제 거의 다 써놓은 중고차 가격예측모델 공부 글을 다 날려버렸다. 개열받네.   네이버 블로그 자동저장 기능을 너무 맹신하고 맨날 글쓴채로 노트북 덮어놓다가 당했다.   진짜 거의 다써서 한 세줄만 더 쓰면 됐었는데…  물론 어차피 공부할거 다했고 블로그에 글 올리던 안올리던 큰 상관은 없지만 이거 나름 쌓이는 맛에 뿌듯한맘으로 공부하는건데 다 날리니까 화가난다.   내가 다시 써서 해놓는다 꼭 ᅳᅳ  오늘 이거 다시 써놓고   시황 분석좀 하고  다음 분석할 데이터셋 하나 찾아놓고 하루 마무리 해야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%B8%94%EB%A1%9C%EA%B7%B8/",
        "teaser": null
      },{
        "title": "숏",
        "excerpt":"2021.05.28  진짜 숏 다시는 안잡는다….  물론 숏이라기보다는 변동성을 산거지만 숏이랑 다를바없는 포지션이다.   인플레를 앞두고 그래도 17-18정도에서 바닥은 지지 해줄줄 알았는데 왜 지하실까지 가냐….   숏포지션은 대부분 손실이 야금야금나고 수익이 한번에 치솟게 되는데, 이번에 수익 났을때 청산을 안해서 너무 고점에 물 려있다보니까 어느정도 확률적우위가 있다고 생각함에도 누적되는 손해가 너무 겁이난다.   오늘 밤에 발표되는 pce가 어느정도 이 포지션의 분수령이 될텐데, 아무래도 지표가 좋게나온다면 속쓰려도 여기서 잘라 야되지 싶다. 앞으로 하락배팅은 진짜 생각많이하고 신중에 신중을 기해서 매수타이밍도 뒤로 한참 미뤄서 해야겠다는 생 각이든다.   진짜 앞으로는 스프레드 딱 잡고 포지션 청산해가면서 매매 할테니까 한번만 살려주세요….  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%88%8F/",
        "teaser": null
      },{
        "title": "오늘일기",
        "excerpt":"2021.05.31  아 쓰고싶을 때 써야 재밌는건데   오늘일기 이거때문에 맨날 강제로 쓰니까 나의 행복을 하나 잃은 기분이다. 15000원에 나의 행복을 뺏어가다니  책임져라 네이버 ᅳᅳ   생각나는 글감 있을때만 쓰고싶은데 맨날 쥐어짜니까 글이 안나온다.  나중에 취업이나 뭐 지원할때 블로그가 도움이 될것같다는 생각이 들었다.   원래는 그렇게까지 생각을 해서 블로그에 공부한거 올린건 아니었는데,  공부한 내용을 깃허브나 블로그를 꾸준히 쓰면 나중에 어디 지원할때 실제로 도움이 많이 된다고한다. 공부글좀 더 열심히 써야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%98%A4%EB%8A%98%EC%9D%BC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "채권",
        "excerpt":"이 글은 유튜브 ‘월가아재’ 영상을 보고 공부한 내용을 기록한 글입니다.   채권이란?  이자를 주는 증권  발행주체 : 국가(국채), 회사 (회사채), 지자체 (지방채)  -&gt; 어떤 회사의 주식을 사면 그 회사에 대한 주주(소유자)가 되는 것이고, 어떤 회사의 채권을 사면 그회사에 대한 채권자 (빚) 가 되는 것.   채권의 방식  채권의 방식은      무이자 할인채 (zero coupon bond) : 이자없이 발행시 할인해서 발행   ex) 100달러 채권을 95달러에 팔고 만기때 100달러를 줌      이자 지급 채권: 액면가에 판매해서 이자를 주고 만기 때 액면가를 돌려줌   ex) 액면가 100달러 채권을 판매하여 6개월마다 2.5달러를 주고 만기 때 102.5달러를 상환      다양한 방식들 : 고정금리 (Fixed Rate), 변동금리(Floating Rate), 인플레 연동, 영구채, 각종 옵션이 포함된 채권 등등     채권투자 수익       은행 예금 수익 = 이자 수익   채권 투자 수익 = 이자 수익 + 자본손익   주식 투자 수익 = 배당 수익 + 자본손익   ​  이렇게 채권은 예금과 주식의 중간에 위치한 자산.   채권은 가격이 떨어져도 만기가 된다면 액면가 그대로를 돌려 받을 수 있다.   그러나 부도/자산의 경우는 액면가도 손실이 가능하다 (그럼에도 주식보다는 보통 상환순위가 우선이기 때문에, 부도시에 처분하는 자산을 주식보다 먼저 상환받을 수 있다.)   따라서 원금 손실을 피하고싶은 은퇴에 가까운 투자자들에게 필수적인 상품인데,  이러한 특성때문에 경기 침체 시기에 좋은 자산으로 분류된다.(주식과 역의 상관관계)   하지만 이러한 특성들은 지나치게 채권을 일반화한 내용인데,   이러한 채권내에서도 다양한 채권이 존재한다. 어떠한 채권은 주식보다도 위험할수도 있고, 경제가 호황일때 같이 이익을 보는 채권도 있다.   채권은 크게 우량채권과 하이일드 (High-yield)채권으로 분류되는데, 신용평가 등급 BBB이상을 우량채라 하고,   그 미만을 하이일드 채권이라 한다.   우량 채권들은 확실히 주식시장이 침체 될때에도 안정적인 수익률을 가져다준다.   그러나 하이일드 채권은 주식시장과 비슷한 움직임을 보이기도 하는데,   어떠한 채권은 수익률이 주식을 넘어서기도 한다.   채권 이자율  회사채 이자율은 무위험 이자율(국채) + 리스크 프리미엄  리스크 프리미엄 = 리스크가 높을수록 이자도 높다.      신용도   신용이 높은 주체일수록 저금리로 대출 가능, 따라서 채권이자가 가장 낮음      만기   만기가 길수록 각종 리스크에 노출되므로 이자 상승      경제 상황   경제 흐름이 안좋을수록 부도 위험이 높아 이자가 높음   이러한 금리는 시장 금리의 변동에 따라 채권가격이 그 반대로 움직이는데,  예를들면 이해가 쉽다.   ​  한 회사가 100달러 액면가에 매년 4퍼센트의 이자, 4달러를 주는 채권을 발행했는데,   만약 시중금리가 1퍼센트 상승한다면 새로 발행되는 다음 채권은 5퍼센트, 5달러의 이자를 주어야 하는데   이렇게 되면 원래의 4퍼센트 채권의 수요가 없어지기 때문에 가격이 100달러보다 낮게 거래되게 된다.   예를들어 해당 채권의 가격이 80달러로 낮아진다면, 새로 발행된 채권과 동일한   5퍼센트의 수익을 올릴 수 있게 된다.   하지만 이러한 가정은 실제와는 조금 다른데, 채권에는 만기에 받을 수 있는 금액이 있기 때문에,   실제로는 위의 예처럼 20퍼센트씩 하락하지는 않는다.   예를들어 2년만기 100달러 채권이라 할때 4퍼센트 채권은 2년 후 만기때 108달러(쉬운 이해를 위해 복리는 무시한다.)를 받게되고, 5퍼센트 채권은 2년 후 만기때 110달러를 받게되므로 4퍼센트 채권은 98달러의 가격이 되면 5퍼센트 채권과 같은 가치를 갖게 된다. 따라서 대략 금리가 1퍼센트 상승하면 채권가격은 1퍼센트 하락한다고 볼 수 있다.   이때 이 가격민감도는 채권의 만기가 많이 남아있을수록 더 높은데, 이러한 개념을 Duration이라한다.   이러한 채권의 가격을 결정하는 시중금리에 영향을 주는 요인들은 세가지가 있는데,           중앙은행이 정하는 기준 금리            인플레이션 및 인플레이션 기대심리            돈에 대한 수요(대출, 투자)와 공급 (유동성)       ​   채권이 좋은 시기는 언제일까?  보통 사람들은 저금리, 저성장 시대기 때문에 예금이자나 채권이자가 낮아 주식말고는   수익을 많이 내기가 힘들다고 생각한다. 하지만 채권과 주식의 가격은 금리 자체보다는 금리 변화에 민감하다.   작년부터 올해로 이루어진 상승은 낮은금리에서 연준이 금리를 제로금리 수준으로 낮추었기 때문에 주가의 상승폭이 컸던 것이지, 저금리 자체가 주가의 상승을 불러일으킨건 아니다.   ​  고성장 고금리 시대와 저성장 저금리 시대 두개만을 놓고보면 채권의 매력도가 높은건 사실이지만,   고성장 고금리 시대건 저성장 저금리 시대건 그 상황 자체의 사이클안에서의 경기 변화에 따른 금리 변화가 어떻게 되는지가 중요하다.     ​  위 이미지는 2018년 PIMCO 라는 투자회사에서 만든 경기 싸이클에 대한 금융상품들의 매력도를 나타낸 인포그래픽이다. 하지만 주의 할점이 있는데,   ​  왼쪽하단의 저성장 저인플레 부분을 보면 과거에는 일반적인 경제 침체시기로, 그림에는 주식은 부정적, 채권은 긍정적, 원자재는 부정적으로 되어있다. 몇년전의 경우 저성장과 저인플레가 오면 연준은 금리를 낮추고 다시 경기가 살아날때까지 기다리는 경향이 컸기 때문에 주식의 매력도가 낮아졌지만, 최근에 바뀐 연준의 스탠스 때문에 현재의 기조에서는 만약  저성장 저인플레가 온다면 성장주가 가장 매력적이게 되었다. 저성장 저인플레에서는 연준이 곧 돈을 풀것이기 때문이다.   위의 사이클대로 보자면 채권은 경기 침체 시기 또는 경기가 침체에서 회복하기 시작할때에,   즉, 인플레 압력이 낮을 때, 성장속도가 느릴때에 이렇게 두가지인데 이럴경우 연준은 금리를 내릴 가능성이 커니고, 따라서 시중금리 하락 가능성이 높을수록 유리한 채권의 매력도가 증가한다. 하지만 여기서 주의해야 할점은   지금 말하는 채권은 ‘국채’와 ‘우량채’에 한해서이다. 하이일드 채권은 주식과 비슷한 움직임을 보이기 때문에 저성장 저인플레에서는 하락한다.   ​  개별채권의 금리는 국채금리 +가산금리로 이루어지는데, 여기서 가산금리는 개별채권의 가격에서   무위험 이자율인 국채금리를 뺀 값으로, 신용도가 낮아 위험도가 큰 상품일수록 가산금리가 높다.   따라서 가산금리는 시장위험의 척도로 볼 수 있다.   실제로 2008년 금융위기때, 가산금리는 주가 폭락전 어느정도 상승하면서 선행지표로서의 의미를   나타내기도 했다.   또 이러한 지표중 하나로 CDS가 있는데 CDS는 신용리스크를 회피하기 위한 보험상품으로   CDS매수자는 CDS매도자에게 일정 금액을 정기적으로 지불하고, CDS매도자는 기초자산 상품이 부도나 파산했을때, 큰금액을 지불해준다.따라서 부도 위험이 커지거나 시장의 리스크가 커지면, CDS스프레드는 높아진다.   다시 채권으로 돌아와서 그럼 채권을 만약 매매한다고 했을 때 고려해야 할 정보들을 생각해보자.   먼저 가장 먼저 고려할것은 신용도이다. 현재 경기가 어떤 사이클에 위치해있고, 이에 따라 우량채를 매수할것인지,   하이일드 채권을 매수할것인지 선택해야 하고 두번째로는 만기를 고려해보아야 한다.   채권에서의 만기는 주식에서의 Beta 개념으로, 만기가 길수록 만기때 받을 수 있는 액면가와 이자보다는 현재 채권의 가격이 더 중요해지기 때문에 만기가 긴 채권의 변동성은 주식시장에 버금가는 변동성을 보인다.   이러한 두가지를 생각했다면, 채권이 갖는 리스크에 대해서 생각해보자.   간략하게 이 리스크를 4가지로 나눌 수 있는데,      시중 금리의 상승으로 인한 채권 가격 하락   앞서 설명 했듯이, 시중금리의 상승은 다음 채권의 이자율을 높이기 때문에 이미 발행된 채권의 가격은 하락한다.      시중 금리의 하락으로 인한 재투자 리스크   만기가 되면 약속된 이자를 받고 다음 채권을 또 매수해야 하는데, 금리가 하락하면 이전과 동일한 이자를 보장하는   상품에 투자할 수 없기 때문에 수익률이 낮아진다. 이를 재투자 리스크라 한다.      기업의 부도/파산   말그대로 해당 채권의 기업이 부도/파산으로 인해 채무를 이행할 여력이 없어지는 리스크를 말한다.      기업의 신용등급 하락   특히 BBB등급 채권의 경우, 하나만 신용등급이 하락해도 기관의 대량매도세가 나올 수 있는데   기관의 경우는 BBB등급 이상의 채권만 보유해야하는 조건등이 있는 경우가 많아, BBB등급 채권은 한등급의 신용도만 하락해도 기관의 대량매도세로 인해 가격이 크게 하락할 수 있다.   이렇듯 채권은 국제 경제에 미치는 영향이 매우 크고, 채권들의 몇몇 지표는 시장의 리스크 센티먼트를 알 수 있는 지표기 때문에 이것이 채권을 직접 매매하지 않더라도 채권의 동향을 예의주시해야할 이유이다.  ","categories": ["finance"],
        "tags": ["금융","채권","주식"],
        "url": "/finance/%EC%B1%84%EA%B6%8C/",
        "teaser": null
      },{
        "title": "차긁음",
        "excerpt":"2021.06.02  약 3년여전 제주도에서 차를 도랑에 빠뜨린이후로 오늘 또 하나의 업적을 달성했다.   아빠차 끌고나갔다가 주차장에서 옆휀더를 벽에다 긁었다. 그래도 다행이라면 항상 대물이나 대인사고는 안낸다는 점이 라고 해야하나…   핑계좀 대자면 주차장이 무슨 자동차를 엘레베이터에서 넣어가지고 층을 이동하는 진짜 듣도보도 못한 방식이어서 거기다 차 넣다가 긁었다.   근데 진짜 차사고는 날때마다 참 기분이 쇼킹하다   나이먹고는 어릴때 진짜 큰 잘못을 했을때 느끼던 그 가슴철렁하고 와 진짜 x됐다하는 감정을 느낄일이 별로 없는데, 차긁 거나 사고나면 진짜 몰컴하다 걸린 초딩마냥 가슴이 쿵쾅쿵쾅뛴다.   오늘 긁어서 9월에 아빠차 새로나오면 끌고 놀러가려고 했던 계획은 물거품이 되었다….  하긴 어차피 바꿀차라 아빠가 그냥 이눔시끼 소리하고 끝냈지 저거 새차였으면 난 뒤졌다.   그래도 9월에 차나올때쯤이면 아빠가 까먹지않을까? 몰래라도 내가 끌고나간다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%B0%A8%EA%B8%81%EC%9D%8C/",
        "teaser": null
      },{
        "title": "[BOJ] 2720 세탁소 사장 동혁 (Python3)",
        "excerpt":"문제  미국으로 유학간 동혁이는 세탁소를 운영하고 있다. 동혁이는 최근에 아르바이트로 고등학생 리암을 채용했다.   동혁이는 리암에게 실망했다.   리암은 거스름돈을 주는 것을 자꾸 실수한다.   심지어 $0.5달러를 줘야하는 경우에 거스름돈으로 $5달러를 주는것이다!   어쩔수 없이 뛰어난 코딩 실력을 발휘해 리암을 도와주는 프로그램을 작성하려고 하지만, 디아블로를 하느라 코딩할 시간이 없어서 이 문제를 읽고 있는 여러분이 대신 해주어야 한다.   거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, $0.25)의 개수, 다임(Dime, $0.10)의 개수, 니켈(Nickel, $0.05)의 개수, 페니(Penny, $0.01)의 개수를 구하는 프로그램을 작성하시오. 거스름돈은 항상 $5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다. 예를 들어, $1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 거스름돈 C를 나타내는 정수 하나로 이루어져 있다. C의 단위는 센트이다. (1달러 = 100센트) (1&lt;=C&lt;=500)   출력  각 테스트케이스에 대해 필요한 쿼터의 개수, 다임의 개수, 니켈의 개수, 페니의 개수를 공백으로 구분하여 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   3 124 25 194 예제 출력 1   4 2 0 4 1 0 0 0 7 1 1 4   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 test = int(input()) change = [] def get_change(change):     quarter = change//25     dime = change%25//10     nickel = change%25%10//5     penny = change%25%10%5//1          return [quarter,dime,nickel,penny]  result = [] for i in range(test):     change.append(int(input()))     result.append(get_change(change[i])) for i in range(test):     for j in range(4):         print(result[i][j], end=' ')     print(end = '\\n')                  1 2 3 4 5 2 124 25 4 2 0 4  1 0 0 0    #  ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%84%B8%ED%83%81%EC%86%8C-%EC%82%AC%EC%9E%A5-%EB%8F%99%ED%98%81/",
        "teaser": null
      },{
        "title": "[Programmers] 신규 아이디 추천 (Python3)",
        "excerpt":"문제  카카오에 입사한 신입 개발자 네오는 “카카오계정개발팀”에 배치되어, 카카오 서비스에 가입하는 유저들의 아이디를 생성하는 업무를 담당하게 되었습니다. “네오”에게 주어진 첫 업무는 새로 가입하는 유저들이 카카오 아이디 규칙에 맞지 않는 아이디를 입력했을 때, 입력된 아이디와 유사하면서 규칙에 맞는 아이디를 추천해주는 프로그램을 개발하는 것입니다.  다음은 카카오 아이디의 규칙입니다.   아이디의 길이는 3자 이상 15자 이하여야 합니다.  아이디는 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.) 문자만 사용할 수 있습니다.  단, 마침표(.)는 처음과 끝에 사용할 수 없으며 또한 연속으로 사용할 수 없습니다.   “네오”는 다음과 같이 7단계의 순차적인 처리 과정을 통해 신규 유저가 입력한 아이디가 카카오 아이디 규칙에 맞는 지 검사하고 규칙에 맞지 않은 경우 규칙에 맞는 새로운 아이디를 추천해 주려고 합니다.   신규 유저가 입력한 아이디가 new_id 라고 한다면,                  1단계       new_id의 모든 대문자를 대응되는 소문자로 치환합니다.                 2단계       new_id에서 알파벳 소문자, 숫자, 빼기(-), 밑줄(_), 마침표(.)를 제외한 모든 문자를 제거합니다.                 3단계       new_id에서 마침표(.)가 2번 이상 연속된 부분을 하나의 마침표(.)로 치환합니다.                 4단계       new_id에서 마침표(.)가 처음이나 끝에 위치한다면 제거합니다.                 5단계       new_id가 빈 문자열이라면, new_id에 “a”를 대입합니다.                 6단계       new_id의 길이가 16자 이상이면, new_id의 첫 15개의 문자를 제외한 나머지 문자들을 모두 제거합니다.                 만약, 제거 후 마침표(.)가 new_id의 끝에 위치한다면 끝에 위치한 마침표(.) 문자를 제거합니다.                         7단계       new_id의 길이가 2자 이하라면, new_id의 마지막 문자를 new_id의 길이가 3이 될 때까지 반복해서 끝에 붙입니다.           예를 들어, new_id 값이 “…!@BaT#*..y.abcdefghijklm” 라면, 위 7단계를 거치고 나면 new_id는 아래와 같이 변경됩니다.   1단계 대문자 ‘B’와 ‘T’가 소문자 ‘b’와 ‘t’로 바뀌었습니다.  “…!@BaT#..y.abcdefghijklm” → “…!@bat#..y.abcdefghijklm”     2단계 ‘!’, ‘@’, ‘#’, ‘’ 문자가 제거되었습니다.  “…!@bat#..y.abcdefghijklm” → “…bat..y.abcdefghijklm”  3단계 ‘…‘와 ‘..’ 가 ‘.’로 바뀌었습니다.  “…bat..y.abcdefghijklm” → “.bat.y.abcdefghijklm”     4단계 아이디의 처음에 위치한 ‘.’가 제거되었습니다.  “.bat.y.abcdefghijklm” → “bat.y.abcdefghijklm”     5단계 아이디가 빈 문자열이 아니므로 변화가 없습니다.  “bat.y.abcdefghijklm” → “bat.y.abcdefghijklm”     6단계 아이디의 길이가 16자 이상이므로, 처음 15자를 제외한 나머지 문자들이 제거되었습니다.  “bat.y.abcdefghijklm” → “bat.y.abcdefghi”      7단계 아이디의 길이가 2자 이하가 아니므로 변화가 없습니다.  “bat.y.abcdefghi” → “bat.y.abcdefghi”   따라서 신규 유저가 입력한 new_id가 “…!@BaT#*..y.abcdefghijklm”일 때, 네오의 프로그램이 추천하는 새로운 아이디는 “bat.y.abcdefghi” 입니다.   신규 유저가 입력한 아이디를 나타내는 new_id가 매개변수로 주어질 때, “네오”가 설계한 7단계의 처리 과정을 거친 후의 추천 아이디를 return 하도록 solution 함수를 완성해 주세요.   제한사항  new_id는 길이 1 이상 1,000 이하인 문자열입니다.  new_id는 알파벳 대문자, 알파벳 소문자, 숫자, 특수문자로 구성되어 있습니다.  new_id에 나타날 수 있는 특수문자는 한정됩니다.   입출력 예   1 2 3 4 5 6 no\tnew_id\tresult 예1\t\"...!@BaT#*..y.abcdefghijklm\"\t\"bat.y.abcdefghi\" 예2\t\"z-+.^.\"\t\"z--\" 예3\t\"=.=\"\t\"aaa\" 예4\t\"123_.def\"\t\"123_.def\" 예5\t\"abcdefghijklmn.p\"\t\"abcdefghijklmn\"  입출력 예에 대한 설명  1 2 입출력 예 #1 문제의 예시와 같습니다.  1 2 3 4 5 6 7 8 9 입출력 예 #2 7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다. 2단계 \"z-+.^.\" → \"z-..\" 3단계 \"z-..\" → \"z-.\" 4단계 \"z-.\" → \"z-\" 5단계 변화 없습니다. 6단계 변화 없습니다. 7단계 \"z-\" → \"z--\"  1 2 3 4 5 6 7 8 9 입출력 예 #3 7단계를 거치는 동안 new_id가 변화하는 과정은 아래와 같습니다. 1단계 변화 없습니다. 2단계 \"=.=\" → \".\" 3단계 변화 없습니다. 4단계 \".\" → \"\" (new_id가 빈 문자열이 되었습니다.) 5단계 \"\" → \"a\" 6단계 변화 없습니다. 7단계 \"a\" → \"aaa\"  1 2 입출력 예 #4 1단계에서 7단계까지 거치는 동안 new_id(\"123_.def\")는 변하지 않습니다. 즉, new_id가 처음부터 카카오의 아이디 규칙에 맞습니다.  1 2 3 4 5 6 7 8 9 입출력 예 #5 1단계 변화 없습니다. 2단계 변화 없습니다. 3단계 변화 없습니다. 4단계 변화 없습니다. 5단계 변화 없습니다. 6단계 \"abcdefghijklmn.p\" → \"abcdefghijklmn.\" → \"abcdefghijklmn\" 7단계 변화 없습니다. solution.py   코드   1 new_id = \"=.=\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import re  def solution(new_id):     a = re.sub('[^a-z\\d\\-\\_\\.]','', new_id.lower())     a = re.sub('[.]+','.', a)     a = re.sub('^[.]','',a)     if(a == ''):         a = 'a'     a = a[0:15]     a = re.sub('[.]$','',a)     if(len(a)&lt;=2):         while(len(a)&lt;3):             a = a + a[-1]              return a   1 solution(new_id)   1 'aaa'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%8B%A0%EA%B7%9C-%EC%95%84%EC%9D%B4%EB%94%94-%EC%B6%94%EC%B2%9C/",
        "teaser": null
      },{
        "title": "[Programmers] 크레인 인형뽑기 게임 (Python3)",
        "excerpt":"문제  게임개발자인 “죠르디”는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.  “죠르디”는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.   게임 화면은 “1 x 1” 크기의 칸들로 이루어진 “N x N” 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 “5 x 5” 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 “1 x 1” 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.   만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.   크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)  게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.   제한사항  board 배열은 2차원 배열로 크기는 “5 x 5” 이상 “30 x 30” 이하입니다.  board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.  0은 빈 칸을 나타냅니다.  1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.  moves 배열의 크기는 1 이상 1,000 이하입니다.  moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.   입출력 예  |board|\tmoves|\tresult|  |:—:|:—:|:—:|  |[[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]\t|[1,5,3,5,1,2,1,4]|\t4|   입출력 예에 대한 설명  입출력 예 #1  인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.   1 2 board = [[0,0,0,0,0],[0,0,1,0,3],[0,2,5,0,1],[4,2,4,4,2],[3,5,1,3,1]]\t moves = [1,5,3,5,1,2,1,4]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def solution(board, moves):     a = [0]     num = 0     for i in moves:         for j in range(0,len(board[0])):             if(board[j][i-1]&gt;0):                 if(board[j][i-1] == a[-1]):                     a.pop()                     num +=2                     board[j][i-1] = 0                 else:                     a.append(board[j][i-1])                     board[j][i-1] = 0                 break             else:pass     return num   1 solution(board, moves)   1 2 3 4 5 6 7 8 [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 5, 0, 1], [0, 2, 4, 0, 2], [0, 5, 1, 3, 1]] [0, 4, 2, 3, 4]      4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%81%AC%EB%A0%88%EC%9D%B8-%EC%9D%B8%ED%98%95%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[Programmers] 키패드 누르기 (Python3)",
        "excerpt":"문제  스마트폰 전화 키패드의 각 칸에 다음과 같이 숫자들이 적혀 있습니다.  이 전화 키패드에서 왼손과 오른손의 엄지손가락만을 이용해서 숫자만을 입력하려고 합니다.  맨 처음 왼손 엄지손가락은 * 키패드에 오른손 엄지손가락은 # 키패드 위치에서 시작하며, 엄지손가락을 사용하는 규칙은 다음과 같습니다.  엄지손가락은 상하좌우 4가지 방향으로만 이동할 수 있으며 키패드 이동 한 칸은 거리로 1에 해당합니다.   왼쪽 열의 3개의 숫자 1, 4, 7을 입력할 때는 왼손 엄지손가락을 사용합니다.     오른쪽 열의 3개의 숫자 3, 6, 9를 입력할 때는 오른손 엄지손가락을 사용합니다.     가운데 열의 4개의 숫자 2, 5, 8, 0을 입력할 때는 두 엄지손가락의 현재 키패드의 위치에서 더 가까운 엄지손가락을 사용합니다.     만약 두 엄지손가락의 거리가 같다면, 오른손잡이는 오른손 엄지손가락, 왼손잡이는 왼손 엄지손가락을 사용합니다.   순서대로 누를 번호가 담긴 배열 numbers, 왼손잡이인지 오른손잡이인 지를 나타내는 문자열 hand가 매개변수로 주어질 때, 각 번호를 누른 엄지손가락이 왼손인 지 오른손인 지를 나타내는 연속된 문자열 형태로 return 하도록 solution 함수를 완성해주세요.   제한사항  numbers 배열의 크기는 1 이상 1,000 이하입니다.      numbers 배열 원소의 값은 0 이상 9 이하인 정수입니다.      hand는 “left” 또는 “right” 입니다.      “left”는 왼손잡이, “right”는 오른손잡이를 의미합니다.     왼손 엄지손가락을 사용한 경우는 L, 오른손 엄지손가락을 사용한 경우는 R을 순서대로 이어붙여 문자열 형태로 return 해주세요.   입출력 예  |numbers|\thand|\tresult|  |:—:|:—:|:—:|  |[1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]\t|”right”\t|”LRLLLRLLRRL”|  |[7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]\t|”left”\t|”LRLLRRLLLRR”  |[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\t|”right”\t|”LLRLLRLLRL”|   입출력 예에 대한 설명  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 입출력 예 #1 순서대로 눌러야 할 번호가 [1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5]이고, 오른손잡이입니다. 왼손 위치\t오른손 위치\t눌러야 할 숫자\t사용한 손\t설명 *\t#\t1\tL\t1은 왼손으로 누릅니다. 1\t#\t3\tR\t3은 오른손으로 누릅니다. 1\t3\t4\tL\t4는 왼손으로 누릅니다. 4\t3\t5\tL\t왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5\t3\t8\tL\t왼손 거리는 1, 오른손 거리는 3이므로 왼손으로 8을 누릅니다. 8\t3\t2\tR\t왼손 거리는 2, 오른손 거리는 1이므로 오른손으로 2를 누릅니다. 8\t2\t1\tL\t1은 왼손으로 누릅니다. 1\t2\t4\tL\t4는 왼손으로 누릅니다. 4\t2\t5\tR\t왼손 거리와 오른손 거리가 1로 같으므로, 오른손으로 5를 누릅니다. 4\t5\t9\tR\t9는 오른손으로 누릅니다. 4\t9\t5\tL\t왼손 거리는 1, 오른손 거리는 2이므로 왼손으로 5를 누릅니다. 5\t9\t-\t-\t 따라서 \"LRLLLRLLRRL\"를 return 합니다.  1 2 입출력 예 #2 왼손잡이가 [7, 0, 8, 2, 8, 3, 1, 5, 7, 6, 2]를 순서대로 누르면 사용한 손은 \"LRLLRRLLLRR\"이 됩니다.  1 2 입출력 예 #3 오른손잡이가 [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]를 순서대로 누르면 사용한 손은 \"LLRLLRLLRL\"이 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 import numpy as np def solution(numbers, hand):     left = [[3,0]]     right = [[3,2]]     wh = []     phone = [[1,2,3],              [4,5,6],              [7,8,9],              ['*',0,'#']]      for i in numbers:         for j in range(0,4):             if i in phone[j]:                 k = phone[j].index(i)                 if k == 0:                     left.append([j,k])                     wh.append('L')                                          break                 if k == 2:                      right.append([j,k])                     wh.append('R')                                         break                 else:                     if abs(right[-1][0]-j)+abs(right[-1][1]-k)&gt;abs(left[-1][0]-j)+abs(left[-1][1]-k):                         left.append([j,k])                         wh.append('L')                          break                     if abs(right[-1][0]-j)+abs(right[-1][1]-k)&lt;abs(left[-1][0]-j)+abs(left[-1][1]-k):                         right.append([j,k])                         wh.append('R')                                                 break                     else:                         if hand == 'right':                             right.append([j,k])                             wh.append('R')                                                      break                         else:                             left.append([j,k])                             wh.append('L')                                                     break                              else: pass                                       return \"\".join(wh)    1 2 numbers =[1, 3, 4, 5, 8, 2, 1, 4, 5, 9, 5] hand = 'right'   1 solution(numbers, hand)   1 'LRLLLRLLRRL'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%82%A4%ED%8C%A8%EB%93%9C%EB%88%84%EB%A5%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 2016년 (Python3)",
        "excerpt":"문제 설명  2016년 1월 1일은 금요일입니다. 2016년 a월 b일은 무슨 요일일까요? 두 수 a ,b를 입력받아 2016년 a월 b일이 무슨 요일인지 리턴하는 함수, solution을 완성하세요. 요일의 이름은 일요일부터 토요일까지 각각 SUN,MON,TUE,WED,THU,FRI,SAT  입니다. 예를 들어 a=5, b=24라면 5월 24일은 화요일이므로 문자열 “TUE”를 반환하세요.   제한 조건  2016년은 윤년입니다.  2016년 a월 b일은 실제로 있는 날입니다.   (13월 26일이나 2월 45일같은 날짜는 주어지지 않습니다)   입출력 예  |a|b|result|  |:—:|:—:|:—:|  |5|\t24|\t“TUE”|   코드   1 2 3 import datetime  datetime.date(2016,a,b).weekday()   1 3   1 2 3 4 5 import datetime def solution(a, b):     day = ['MON','TUE','WED','THU','FRI','SAT','SUN']          return day[datetime.date(2016,a,b).weekday()]   1 solution(a,b)   1 'TUE'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/2016%EB%85%84/",
        "teaser": null
      },{
        "title": "[Programmers] 3진법 뒤집기 (Python3)",
        "excerpt":"문제 설명  자연수 n이 매개변수로 주어집니다. n을 3진법 상에서 앞뒤로 뒤집은 후, 이를 다시 10진법으로 표현한 수를 return 하도록 solution 함수를 완성해주세요.  제한사항  n은 1 이상 100,000,000 이하인 자연수입니다.   입출력 예  |n|result|  |:—:|:—|  |45|\t7|  |125\t|229|   입출력 예 설명   입출력 예 #1  답을 도출하는 과정은 다음과 같습니다.  n (10진법)\tn (3진법)\t앞뒤 반전(3진법)\t10진법으로 표현  45\t1200\t0021\t7  따라서 7을 return 해야 합니다.   입출력 예 #2  답을 도출하는 과정은 다음과 같습니다.  n (10진법)\tn (3진법)\t앞뒤 반전(3진법)\t10진법으로 표현  125\t11122\t22111\t229  따라서 229를 return 해야 합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 def solution(n):     a = []     num = 0     while n&gt;0:         if n%3 == 0:             n = n/3             a.append(0)          if n%3 == 1:             n = (n-1)/3             a.append(1)          if n%3 == 2:             n = (n-2)/3             a.append(2)     for i in range(0,len(a)):         num += a[len(a)-1-i]*pow(3,i)     return num   1 2 n = 45 solution(n)   1 7   1 int('0021',3)   1 7   n 진수 만드는 코드   1 2 3 4 5 tmp = ''     while i:         tmp += str(i % n)         i = i // n    n진수는 그냥 int를 이용해서 바로 10진수로 출력 가능하다.(tmp는 str이어야함.)   1 answer = int(tmp, 3)  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/3%EC%A7%84%EB%B2%95-%EB%92%A4%EC%A7%91%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 가운데 글자 가져오기 (Python3)",
        "excerpt":"문제 설명  단어 s의 가운데 글자를 반환하는 함수, solution을 만들어 보세요.   단어의 길이가 짝수라면 가운데 두글자를 반환하면 됩니다.   제한사항  s는 길이가 1 이상, 100이하인 스트링입니다.   입출력 예  |s\t|return|    |:—:|:—:|  |”abcde”\t|”c”|  |”qwer”\t|”we”|   1 2 3 4 5 6 7 8 9 10 def solution(s):           if len(s)%2 != 0:         n = len(s)//2         print(str(s[n]))     else:         n = len(s)/2         print(s[int(n)]+s[int(n-1)])                 1 2 s = \"abcdef\" solution(s)   1 dc   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%80%EC%9A%B4%EB%8D%B0-%EA%B8%80%EC%9E%90-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 두 개 뽑아서 더하기 (Python3)",
        "excerpt":"문제 설명  정수 배열 numbers가 주어집니다. numbers에서 서로 다른 인덱스에 있는 두 개의 수를 뽑아 더해서 만들 수 있는 모든 수를 배열에 오름차순으로 담아 return 하도록 solution 함수를 완성해주세요.  제한사항  numbers의 길이는 2 이상 100 이하입니다.  numbers의 모든 수는 0 이상 100 이하입니다.   입출력 예  1 2 3 numbers\t    result [2,1,3,4,1]\t[2,3,4,5,6,7] [5,0,2,7]\t[2,5,7,9,12]   입출력 예 설명  1 2 3 4 5 6 7 8 입출력 예 #1 2 = 1 + 1 입니다. (1이 numbers에 두 개 있습니다.) 3 = 2 + 1 입니다. 4 = 1 + 3 입니다. 5 = 1 + 4 = 2 + 3 입니다. 6 = 2 + 4 입니다. 7 = 3 + 4 입니다. 따라서 [2,3,4,5,6,7] 을 return 해야 합니다.  1 2 3 4 5 6 7 입출력 예 #2 2 = 0 + 2 입니다. 5 = 5 + 0 입니다. 7 = 0 + 7 = 5 + 2 입니다. 9 = 2 + 7 입니다. 12 = 5 + 7 입니다. 따라서 [2,5,7,9,12] 를 return 해야 합니다.   코드   1 2 3 4 5 6 7 8 9 from itertools import combinations  def solution(numbers):     a = []     n = list(combinations(numbers,2))     for i in range(0, len(n)):         a.append(sum(n[i]))          return sorted(list(set(a)))   1 solution(numbers)   1 2 3 4 5 6 7 [(2, 1), (2, 3), (2, 4), (2, 1), (1, 3), (1, 4), (1, 1), (3, 4), (3, 1), (4, 1)]      [2, 3, 4, 5, 6, 7]   1 numbers = [2,1,3,4,1]  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%91%90-%EA%B0%9C-%EB%BD%91%EC%95%84%EC%84%9C-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 내 p와 y의 개수 (Python3)",
        "excerpt":"문제설명  대문자와 소문자가 섞여있는 문자열 s가 주어집니다. s에 ‘p’의 개수와 ‘y’의 개수를 비교해 같으면 True, 다르면 False를 return 하는 solution를 완성하세요. ‘p’, ‘y’ 모두 하나도 없는 경우는 항상 True를 리턴합니다. 단, 개수를 비교할 때 대문자와 소문자는 구별하지 않습니다.  예를 들어 s가 “pPoooyY”면 true를 return하고 “Pyy”라면 false를 return합니다.   제한사항  문자열 s의 길이 : 50 이하의 자연수  문자열 s는 알파벳으로만 이루어져 있습니다.   입출력 예  1 2 3 s\t        answer \"pPoooyY\"\ttrue \"Pyy\"\t    false   입출력 예 설명  입출력 예 #1      ‘p’의 개수 2개, ‘y’의 개수 2개로 같으므로 true를 return 합니다.     입출력 예 #2     ‘p’의 개수 1개, ‘y’의 개수 2개로 다르므로 false를 return 합니다.   코드   1 s=\"ytp\"   1 2 3 4 5 6 7 8 def solution(s):     s = s.lower()     if s.count('p') == s.count('y'):             return True     if len(s)== 0:         return True     else:          return False   1 solution(s)   1 True   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-p%EC%99%80-y%EC%9D%98-%EA%B0%9C%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] 비밀지도 (Python3)",
        "excerpt":"문제  비밀지도  네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다. 그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다. 다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.           지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.            전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다. 각각 “지도 1”과 “지도 2”라고 하자. 지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다. 지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.            “지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.            암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.       secret map  네오가 프로도의 비상금을 손에 넣을 수 있도록, 비밀지도의 암호를 해독하는 작업을 도와줄 프로그램을 작성하라.   입력 형식  입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.  1 ≦ n ≦ 16  arr1, arr2는 길이 n인 정수 배열로 주어진다.  정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다. 즉, 0 ≦ x ≦ 2n - 1을 만족한다.   출력 형식  원래의 비밀지도를 해독하여 ‘#’, 공백으로 구성된 문자열 배열로 출력하라.   입출력 예제  1 2 3 4 5 6 7 8 9 10 11 매개변수\t값 n\t      5 arr1\t [9, 20, 28, 18, 11] arr2\t [30, 1, 21, 17, 28] 출력\t    [\"#####\",\"# # #\", \"### #\", \"# ##\", \"#####\"]  매개변수\t값 n\t      6 arr1\t [46, 33, 33 ,22, 31, 50] arr2\t [27 ,56, 19, 14, 14, 10] 출력\t    [\"######\", \"### #\", \"## ##\", \" #### \", \" #####\", \"### # \"]  코드   1 2 3 n = 6 arr1 = [46, 33, 33 ,22, 31, 50] arr2 = [27 ,56, 19, 14, 14, 10]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def solution(n,arr1,arr2):     num = []     all_map = []     for i,j in zip(arr1, arr2):         num.append(bin(i|j)[2:n+2])          for i in num:         temp = \"\"         i = list(i)          for j in range(0, n):             if len(i) &lt; n:                 i.insert(0,'0')                  for j in range(0,n):             if i[j] == '1':                 temp+=\"#\"             else:                 temp+=\" \"         all_map.append(temp)                               return all_map   1 solution(n,arr1,arr2)   1 ['######', '###  #', '##  ##', ' #### ', ' #####', '### # ']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B9%84%EB%B0%80%EC%A7%80%EB%8F%84/",
        "teaser": null
      },{
        "title": "[Programmers] 소수 찾기 (Python3)",
        "excerpt":"문제 설명  1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요.  소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.  (1은 소수가 아닙니다.)   제한 조건   n은 2이상 1000000이하의 자연수입니다.  입출력 예  1 2 3 n\tresult 10\t4 5\t3   입출력 예 설명  1 2 3 4 5 입출력 예 #1 1부터 10 사이의 소수는 [2,3,5,7] 4개가 존재하므로 4를 반환  입출력 예 #2 1부터 5 사이의 소수는 [2,3,5] 3개가 존재하므로 3를 반환   코드   1 n = 1000   1 2 3 4 5 6 7 8 9 10 def solution(n):     num = set(range(2,n+1))          for i in range(2, n+1):         if i in num:             num-=set(range(i*i,n+1,i ))             p = range(i,n+1,i )                      return len(num)   1 solution(n)   1 168   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%86%8C%EC%88%98-%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 같은 숫자는 싫어 (Python3)",
        "excerpt":"문제 설명  배열 arr가 주어집니다. 배열 arr의 각 원소는 숫자 0부터 9까지로 이루어져 있습니다. 이때, 배열 arr에서 연속적으로 나타나는 숫자는 하나만 남기고 전부 제거하려고 합니다. 단, 제거된 후 남은 수들을 반환할 때는 배열 arr의 원소들의 순서를 유지해야 합니다. 예를 들면,  arr = [1, 1, 3, 3, 0, 1, 1] 이면 [1, 3, 0, 1] 을 return 합니다.  arr = [4, 4, 4, 3, 3] 이면 [4, 3] 을 return 합니다.  배열 arr에서 연속적으로 나타나는 숫자는 제거하고 남은 수들을 return 하는 solution 함수를 완성해 주세요.   제한사항  배열 arr의 크기 : 1,000,000 이하의 자연수  배열 arr의 원소의 크기 : 0보다 크거나 같고 9보다 작거나 같은 정수   입출력 예  1 2 3  arr\t            answer [1,1,3,3,0,1,1]\t   [1,3,0,1] [4,4,4,3,3]\t       [4,3]   입출력 예 설명  입출력 예 #1,2  문제의 예시와 같습니다.   코드   1 2 3 4 5 6 7 8 def solution(arr):     result = []     for i in range(0,len(arr)-1):         if arr[i] != arr[i+1]:             result.append(arr[i])     result.append(arr[-1])          return result   1 arr = [1,1,3,3,0,1,1]   1 solution(arr)   1 [1, 3, 0, 1]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%99%EC%9D%80-%EC%88%AB%EC%9E%90%EB%8A%94-%EC%8B%AB%EC%96%B4/",
        "teaser": null
      },{
        "title": "[Programmers] 나누어 떨어지는 숫자 배열 (Python3)",
        "excerpt":"문제 설명  array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요.  divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.   제한사항  arr은 자연수를 담은 배열입니다.  정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.  divisor는 자연수입니다.  array는 길이 1 이상인 배열입니다   입출력 예  1 2 3 4 arr\t            divisor        return [5, 9, 7, 10]\t  5\t          [5, 10] [2, 36, 1, 3]\t  1\t          [1, 2, 3, 36] [3,2,6]\t         10\t          [-1]  입출력 예 설명   입출력 예#1  1 2 arr의 원소 중 5로 나누어 떨어지는 원소는 5와 10입니다.  따라서 [5, 10]을 리턴합니다.  입출력 예#2  1 arr의 모든 원소는 1으로 나누어 떨어집니다. 원소를 오름차순으로 정렬해 [1, 2, 3, 36]을 리턴합니다.   입출력 예#3  1 3, 2, 6은 10으로 나누어 떨어지지 않습니다. 나누어 떨어지는 원소가 없으므로 [-1]을 리턴합니다`   코드   1 2 3 4 5 6 7 8 9 def solution(arr, divisor):     result = []     for i in range(0, len(arr)):         if arr[i]%divisor == 0:             result.append(arr[i])     if len(result) == 0:         result.append(-1)     result.sort()             return result   1 2 arr = [5,9,7,10] divisor = 5   1 solution(arr, divisor)   1 [5, 10]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%82%98%EB%88%84%EC%96%B4-%EB%96%A8%EC%96%B4%EC%A7%80%EB%8A%94-%EC%88%AB%EC%9E%90-%EB%B0%B0%EC%97%B4/",
        "teaser": null
      },{
        "title": "[Programmers] 다트 게임 (Python3)",
        "excerpt":"문제  카카오톡에 뜬 네 번째 별! 심심할 땐? 카카오톡 게임별~  Game Star  카카오톡 게임별의 하반기 신규 서비스로 다트 게임을 출시하기로 했다.   다트 게임은 다트판에 다트를 세 차례 던져 그 점수의 합계로 실력을 겨루는 게임으로,   모두가 간단히 즐길 수 있다.   갓 입사한 무지는 코딩 실력을 인정받아  게임의 핵심 부분인 점수 계산 로직을 맡게 되었다. 다트 게임의 점수 계산 로직은 아래와 같다.           다트 게임은 총 3번의 기회로 구성된다.            각 기회마다 얻을 수 있는 점수는 0점에서 10점까지이다.            점수와 함께 Single(S), Double(D), Triple(T) 영역이 존재하고 각 영역 당첨 시 점수에서 1제곱, 2제곱, 3제곱 (점수1 , 점수2 , 점수3 )으로 계산된다.            옵션으로 스타상() , 아차상(#)이 존재하며 스타상() 당첨 시 해당 점수와 바로 전에 얻은 점수를 각 2배로 만든다. 아차상(#) 당첨 시 해당 점수는 마이너스된다.            스타상()은 첫 번째 기회에서도 나올 수 있다. 이 경우 첫 번째 스타상()의 점수만 2배가 된다. (예제 4번 참고)            스타상()의 효과는 다른 스타상()의 효과와 중첩될 수 있다. 이 경우 중첩된 스타상(*) 점수는 4배가 된다. (예제 4번 참고)            스타상(*)의 효과는 아차상(#)의 효과와 중첩될 수 있다. 이 경우 중첩된 아차상(#)의 점수는 -2배가 된다. (예제 5번 참고)            Single(S), Double(D), Triple(T)은 점수마다 하나씩 존재한다.            스타상(*), 아차상(#)은 점수마다 둘 중 하나만 존재할 수 있으며, 존재하지 않을 수도 있다.       0~10의 정수와 문자 S, D, T, *, #로 구성된 문자열이 입력될 시 총점수를 반환하는 함수를 작성하라.   입력 형식  “점수|보너스|[옵션]”으로 이루어진 문자열 3세트.  예) 1S2D*3T  점수는 0에서 10 사이의 정수이다.  보너스는 S, D, T 중 하나이다.  옵선은 *이나 # 중 하나이며, 없을 수도 있다.   출력 형식  3번의 기회에서 얻은 점수 합계에 해당하는 정수값을 출력한다.     예) 37   입출력 예제  1 2 3 4 5 6 7 8 예제\tdartResult\tanswer\t설명 1\t1S2D*3T\t      37\t 11 * 2 + 22 * 2 + 33 2\t1D2S#10S\t   9\t 12 + 21 * (-1) + 101 3\t1D2S0T\t       3\t 12 + 21 + 03 4\t1S*2T*3S\t  23\t 11 * 2 * 2 + 23 * 2 + 31 5\t1D#2S*3S\t   5\t 12 * (-1) * 2 + 21 * 2 + 31 6\t1T2D3D#\t      -4\t 13 + 22 + 32 * (-1) 7\t1D2S3T*\t      59\t 12 + 21 * 2 + 33 * 2   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import re  def solution(dartResult):          bonus = {'S':1, 'D' : 1, 'T' : 3}     m = re.compile(\"[0-9]+[SDT]{1}[*#]?\")     result = m.findall(dartResult)     score = 0     for i in result:         score = i[0]**bonus(i[1])         if i[2] == '#':             score                    return score                                   1 dartResult = \"1S2D*3T\"   1 solution(dartResult)   1 'T'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8B%A4%ED%8A%B8-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[Programmers] 두 정수 사이의 합 (Python3)",
        "excerpt":"문제 설명  두 정수 a, b가 주어졌을 때 a와 b 사이에 속한 모든 정수의 합을 리턴하는 함수, solution을 완성하세요.   예를 들어 a = 3, b = 5인 경우, 3 + 4 + 5 = 12이므로 12를 리턴합니다.   제한 조건  a와 b가 같은 경우는 둘 중 아무 수나 리턴하세요.  a와 b는 -10,000,000 이상 10,000,000 이하인 정수입니다.  a와 b의 대소관계는 정해져있지 않습니다.   입출력 예  1 2 3 4 a\tb\treturn 3\t5\t12 3\t3\t3 5\t3\t12   코드   1 2 a = 3 b = 3   1 2 3 4 5 6 7 8 9 10 def solution(a,b):     result = 0     if a &gt; b:         temp = a         a = b         b = temp     for i in range(a,b+1):         result += i     return result            1 solution(a,b)   1 3   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%91%90-%EC%A0%95%EC%88%98-%EC%82%AC%EC%9D%B4%EC%9D%98-%ED%95%A9/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 내 마음대로 정렬하기 (Python3)",
        "excerpt":"문제 설명  문자열로 구성된 리스트 strings와, 정수 n이 주어졌을 때, 각 문자열의 인덱스 n번째 글자를 기준으로 오름차순 정렬하려 합니다. 예를 들어 strings가 [“sun”, “bed”, “car”]이고 n이 1이면 각 단어의 인덱스 1의 문자 “u”, “e”, “a”로 strings를 정렬합니다.   제한 조건  strings는 길이 1 이상, 50이하인 배열입니다.  strings의 원소는 소문자 알파벳으로 이루어져 있습니다.  strings의 원소는 길이 1 이상, 100이하인 문자열입니다.  모든 strings의 원소의 길이는 n보다 큽니다.  인덱스 1의 문자가 같은 문자열이 여럿 일 경우, 사전순으로 앞선 문자열이 앞쪽에 위치합니다.   입출력 예  1 2 3 strings\t                n\treturn [\"sun\", \"bed\", \"car\"]\t1\t[\"car\", \"bed\", \"sun\"] [\"abce\", \"abcd\", \"cdx\"]\t2\t[\"abcd\", \"abce\", \"cdx\"]  입출력 예 설명   입출력 예 1   “sun”, “bed”, “car”의 1번째 인덱스 값은 각각 “u”, “e”, “a” 입니다. 이를 기준으로 strings를 정렬하면 [“car”, “bed”, “sun”] 입니다.   입출력 예 2   “abce”와 “abcd”, “cdx”의 2번째 인덱스 값은 “c”, “c”, “x”입니다. 따라서 정렬 후에는 “cdx”가 가장 뒤에 위치합니다. “abce”와 “abcd”는 사전순으로 정렬하면 “abcd”가 우선하므로, 답은 [“abcd”, “abce”, “cdx”] 입니다.   코드   1 2 3 def solution(strings,n):     return sorted(strings,key=lambda x:(x[n],x))        1 2 strings = [\"sun\", \"bed\", \"car\"] n = 1   1 solution(strings, n)   1 ['car', 'bed', 'sun']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4-%EB%A7%88%EC%9D%8C%EB%8C%80%EB%A1%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 내림차순으로 배치하기 (Python3)",
        "excerpt":"문제 설명   문자열 s에 나타나는 문자를 큰것부터 작은 순으로 정렬해 새로운 문자열을 리턴하는 함수, solution을 완성해주세요.  s는 영문 대소문자로만 구성되어 있으며, 대문자는 소문자보다 작은 것으로 간주합니다.   제한 사항  str은 길이 1 이상인 문자열입니다.   입출력 예  1  s\t      return \"Zbcdefg\"\t\"gfedcbZ\"   코드   1 2 def solution(s):     return \"\".join(sorted(s, reverse=True))   1 s = \"AbDcdefg\"   1 solution(s)   1 2 3 4 5 6 7 ['g', 'f', 'e', 'd', 'c', 'b', 'D', 'A']      'gfedcbAD'   1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%82%B4%EB%A6%BC%EC%B0%A8%EC%88%9C%EC%9C%BC%EB%A1%9C-%EB%B0%B0%EC%B9%98%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 다루기 기본 (Python3)",
        "excerpt":"문제 설명  문자열 s의 길이가 4 혹은 6이고, 숫자로만 구성돼있는지 확인해주는 함수, solution을 완성하세요. 예를 들어 s가 “a234”이면 False를 리턴하고 “1234”라면 True를 리턴하면 됩니다.   제한 사항  s는 길이 1 이상, 길이 8 이하인 문자열입니다.   입출력 예  1 2 3    s\treturn \"a234\"\tfalse \"1234\"\ttrue  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import re def solution(s):     p = re.compile('[a-z]+')     m = p.search(s)     if m:         return False      else:         if (len(s) == 4 or len(s)==6):             return True                           else:             return False          1 s = \"\"   1 solution(s)   1 False   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%8B%A4%EB%A3%A8%EA%B8%B0-%EA%B8%B0%EB%B3%B8/",
        "teaser": null
      },{
        "title": "[Programmers] N개의 최소공배수 (Python3)",
        "excerpt":"문제 설명  두 수의 최소공배수(Least Common Multiple)란 입력된 두 수의 배수 중 공통이 되는 가장 작은 숫자를 의미합니다. 예를 들어 2와 7의 최소공배수는 14가 됩니다. 정의를 확장해서, n개의 수의 최소공배수는 n 개의 수들의 배수 중 공통이 되는 가장 작은 숫자가 됩니다. n개의 숫자를 담은 배열 arr이 입력되었을 때 이 수들의 최소공배수를 반환하는 함수, solution을 완성해 주세요.   제한 사항  1 2 arr은 길이 1이상, 15이하인 배열입니다. arr의 원소는 100 이하인 자연수입니다.   입출력 예  1 2 3 arr\t        result [2,6,8,14]\t168 [1,2,3]\t    6  코드   1 arr = [1,2,3]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import pdb def solution(arr):     time = 1     num =0          for i in range(0,len(arr)):         time *= arr[i]         for i in range(1,time+1):         for j in arr:             if i%j == 0:                 num+=1         if num == len(arr):             return i             break         else:             num = 0                 1 get_big(15, 20)   1 5   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/N%EA%B0%9C%EC%9D%98-%EC%B5%9C%EC%86%8C%EA%B3%B5%EB%B0%B0%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] JadenCase 문자열 만들기 (Python3)",
        "excerpt":"문제 설명  JadenCase란 모든 단어의 첫 문자가 대문자이고, 그 외의 알파벳은 소문자인 문자열입니다. 문자열 s가 주어졌을 때, s를 JadenCase로 바꾼 문자열을 리턴하는 함수, solution을 완성해주세요.   제한 조건  s는 길이 1 이상인 문자열입니다.  s는 알파벳과 공백문자(“ “)로 이루어져 있습니다.  첫 문자가 영문이 아닐때에는 이어지는 영문은 소문자로 씁니다. ( 첫번째 입출력 예 참고 )   입출력 예  1 2 3 s\t                     return \"3people unFollowed me\"\t \"3people Unfollowed Me\" \"for the last week\"\t     \"For The Last Week\"  코드   1 s = \"my NAMe   4s    3injae\"   1 2 3 4 5 6 7 8 9 10 11 def solution(s):     s = s.lower().split()     result = []     for i in s:         i = list(i)         print(i)         i[0] = i[0].upper()         result.append(\"\".join(i))              return \" \".join(result)        1 solution(s)   1 'My Name   4s    3injae'   1 s.lower().split()   1 ['my', 'name', 'is', 'minjae']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-JadenCase-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 피보나치 수 (Python3)",
        "excerpt":"문제 설명  피보나치 수는 F(0) = 0, F(1) = 1일 때, 1 이상의 n에 대하여 F(n) = F(n-1) + F(n-2) 가 적용되는 수 입니다.  예를들어  1 2 3 4     F(2) = F(0) + F(1) = 0 + 1 = 1     F(3) = F(1) + F(2) = 1 + 1 = 2     F(4) = F(2) + F(3) = 1 + 2 = 3     F(5) = F(3) + F(4) = 2 + 3 = 5  와 같이 이어집니다.  2 이상의 n이 입력되었을 때, n번째 피보나치 수를 1234567으로 나눈 나머지를 리턴하는 함수, solution을 완성해 주세요.   제한 사항     n은 1이상, 100000이하인 자연수입니다.   입출력 예  1 2 3 n\treturn 3\t2 5\t5  입출력 예  피보나치수는 0번째부터 0, 1, 1, 2, 3, 5, … 와 같이 이어집니다.  코드   1 n = 5   1 2 3 4 5 6 def solution(n):     a = 0     num = [0,1]     for i in range(0,n+1):         num.append(num[i]+num[i+1])         return num[-3]%1234567   1 solution(n)   1 5   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] 행렬의 곱셈 (Python3)",
        "excerpt":"문제 설명  2차원 행렬 arr1과 arr2를 입력받아, arr1에 arr2를 곱한 결과를 반환하는 함수, solution을 완성해주세요.   제한 조건  행렬 arr1, arr2의 행과 열의 길이는 2 이상 100 이하입니다.  행렬 arr1, arr2의 원소는 -10 이상 20 이하인 자연수입니다.  곱할 수 있는 배열만 주어집니다.   입출력 예  1 2 3 4 5 6 7 8 9 10 11 arr1\t                   \t         [[1, 4], [3, 2], [4, 1]]\t    [[2, 3, 2], [4, 2, 4], [3, 1, 4]]  arr2 [[3, 3], [3, 3]] [[5, 4, 3], [2, 4, 1], [3, 1, 1]]  return [[15, 15], [15, 15], [15, 15]] [[22, 22, 11], [36, 28, 18], [29, 20, 14]]  코드   1 2 3 4 arr1 = [[1, 4]]   arr2 = [[3],         [3]]    1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solution(arr1, arr2):          result = []     for x1 in range(len(arr1)):         su2 = []         for y2 in range(len(arr2[0])):             su = []             for y1 in range(len(arr1[0])):                 su.append(arr1[x1][y1]*arr2[y1][y2])                 print(su)             su2.append(sum(su))              result.append(su2)                  return result   1 solution(arr1, arr2)   1 2 3 4 5 6 7 8 [3] [3, 12]      [[15]]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%ED%96%89%EB%A0%AC%EC%9D%98-%EA%B3%B1%EC%85%88/",
        "teaser": null
      },{
        "title": "[Programmers] 문자열 압축 (Python3)",
        "excerpt":"문제 설명  데이터 처리 전문가가 되고 싶은 “어피치”는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다.  간단한 예로 “aabbaccc”의 경우 “2a2ba3c”(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, “abcabcdede”와 같은 문자열은 전혀 압축되지 않습니다. “어피치”는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다.  예를 들어, “ababcdcdababcdcd”의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 “2ab2cd2ab2cd”로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 “2ababcdcd”로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다.  다른 예로, “abcabcdede”와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 “abcabc2de”가 되지만, 3개 단위로 자른다면 “2abcdede”가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다.  압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.   제한사항  1 2 s의 길이는 1 이상 1,000 이하입니다. s는 알파벳 소문자로만 이루어져 있습니다.   입출력 예  1 2 3 4 5 6 s\t                         result \"aabbaccc\"\t                 7 \"ababcdcdababcdcd\"\t         9 \"abcabcdede\"\t             8 \"abcabcabcabcdededededede\"\t 14 \"xababcdcdababcdcd\"\t         17  입출력 예에 대한 설명  입출력 예 #1      문자열을 1개 단위로 잘라 압축했을 때 가장 짧습니다.   입출력 예 #2      문자열을 8개 단위로 잘라 압축했을 때 가장 짧습니다.   입출력 예 #3      문자열을 3개 단위로 잘라 압축했을 때 가장 짧습니다.   입출력 예 #4      문자열을 2개 단위로 자르면 “abcabcabcabc6de” 가 됩니다.      문자열을 3개 단위로 자르면 “4abcdededededede” 가 됩니다.      문자열을 4개 단위로 자르면 “abcabcabcabc3dede” 가 됩니다.      문자열을 6개 단위로 자를 경우 “2abcabc2dedede”가 되며,       이때의 길이가 14로 가장 짧습니다.   입출력 예 #5      문자열은 제일 앞부터 정해진 길이만큼 잘라야 합니다.      따라서 주어진 문자열을 x / ababcdcd / ababcdcd 로       자르는 것은 불가능 합니다.      이 경우 어떻게 문자열을 잘라도 압축되지 않으므로 가장 짧은 길이는 17이 됩니다.   코드   1 s = \"avcavcdede\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import re  def solution(s):         strlist = []     if len(s) == 1:         return 1     for i in range(1,len(s)//2+1):         result = \"\"                          temp = s[:i]         num = 1         for j in range(i,len(s),i):             if s[j:j+i] == temp:                 num += 1              else:                 if num == 1:                     num = \"\"                 result += str(num)+temp                 temp = s[j:j+i]                 num = 1          if num == 1:             num = \"\"         result += str(num)+temp         strlist.append(len(result))         temp = \"\"                                                        return min(strlist)   1 solution(s)   1 ['avcavcdede', 'avcavc2de', '2avcdede', 'avcavcdede', 'avcavcdede']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%AC%B8%EC%9E%90%EC%97%B4-%EC%95%95%EC%B6%95/",
        "teaser": null
      },{
        "title": "[Programmers] 방문길이 (Python3)",
        "excerpt":"문제  게임 캐릭터를 4가지 명령어를 통해 움직이려 합니다. 명령어는 다음과 같습니다.      U: 위쪽으로 한 칸 가기   D: 아래쪽으로 한 칸 가기   R: 오른쪽으로 한 칸 가기   L: 왼쪽으로 한 칸 가기   캐릭터는 좌표평면의 (0, 0) 위치에서 시작합니다. 좌표평면의 경계는 왼쪽 위(-5, 5), 왼쪽 아래(-5, -5), 오른쪽 위(5, 5), 오른쪽 아래(5, -5)로 이루어져 있습니다.   방문길이1_qpp9l3.png   예를 들어, “ULURRDLLU”로 명령했다면   방문길이2_lezmdo.png   1번 명령어부터 7번 명령어까지 다음과 같이 움직입니다.   방문길이3_sootjd.png   8번 명령어부터 9번 명령어까지 다음과 같이 움직입니다.   방문길이4_hlpiej.png   이때, 우리는 게임 캐릭터가 지나간 길 중 캐릭터가 처음 걸어본 길의 길이를 구하려고 합니다. 예를 들어 위의 예시에서 게임 캐릭터가 움직인 길이는 9이지만, 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다. (8, 9번 명령어에서 움직인 길은 2, 3번 명령어에서 이미 거쳐 간 길입니다)   단, 좌표평면의 경계를 넘어가는 명령어는 무시합니다.   예를 들어, “LULLLLLLU”로 명령했다면  방문길이5_nitjwj.png      1번 명령어부터 6번 명령어대로 움직인 후, 7, 8번 명령어는 무시합니다. 다시 9번 명령어대로 움직입니다.   방문길이6_nzhumd.png   이때 캐릭터가 처음 걸어본 길의 길이는 7이 됩니다.  명령어가 매개변수 dirs로 주어질 때, 게임 캐릭터가 처음 걸어본 길의 길이를 구하여 return 하는 solution 함수를 완성해 주세요.   제한사항  dirs는 string형으로 주어지며, ‘U’, ‘D’, ‘R’, ‘L’ 이외에 문자는 주어지지 않습니다.  dirs의 길이는 500 이하의 자연수입니다.   입출력 예   1 2 3 dirs\t      answer \"ULURRDLLU\"\t  7 \"LULLLLLLU\"\t  7   https://programmers.co.kr/learn/courses/30/lessons/49994?language=python3   1 dirs = \"LULLLLLLU\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 def solution(dirs):     nx,ny,x,y = 0,0,0,0     result = set()     answer = 0     for i in dirs:         print(i)         if i == 'U':             if ny == 5:                 continue             else:                 ny+=1         if i == 'D':             if ny == -5:                 continue             else:                 ny-= 1         if i == 'R':             if nx == 5:                 continue             else:                 nx+=1         if i == 'L':             if nx == -5:                 continue             else:                 nx-=1         if (nx,ny,x,y) not in result:             result.add((nx,ny,x,y))             result.add((x,y,nx,ny))                          answer+=1                      x,y = nx, ny              return answer        1 solution(dirs)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 L (-1, 0, 0, 0) U (-1, 1, -1, 0) L (-2, 1, -1, 1) L (-3, 1, -2, 1) L (-4, 1, -3, 1) L (-5, 1, -4, 1) L L U (-5, 2, -5, 1)      7   1 a = set()   1 2 a.add((1,2)) a.add((3,4))   1 2 for i in \"dird\":     print(i)   1 2 3 4 d i r d   1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B0%A9%EB%AC%B8%EA%B8%B8%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[Programmers] 숫자의 표현 (Python3)",
        "excerpt":"문제 설명  Finn은 요즘 수학공부에 빠져 있습니다. 수학 공부를 하던 Finn은 자연수 n을 연속한 자연수들로 표현 하는 방법이 여러개라는 사실을 알게 되었습니다. 예를들어 15는 다음과 같이 4가지로 표현 할 수 있습니다.  1 2 3 4     1 + 2 + 3 + 4 + 5 = 15     4 + 5 + 6 = 15     7 + 8 = 15     15 = 15  자연수 n이 매개변수로 주어질 때, 연속된 자연수들로 n을 표현하는 방법의 수를 return하는 solution를 완성해주세요.   제한사항  n은 10,000 이하의 자연수 입니다.   입출력 예  1 2 n\tresult 15\t4  입출력 예 설명  입출력 예#1  문제의 예시와 같습니다   1 2 n = 30    1 2 3 4 5 6 7 8 9 10 11 12 13 def solution(n):     answer = 0     for i in range(n+1):         result = 0         for j in range(i,n+1):             result += j             if result == n:                 answer+=1                 break             elif result &gt; n:                 break     return answer    1 solution(n)   1 4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%88%AB%EC%9E%90%EC%9D%98-%ED%91%9C%ED%98%84/",
        "teaser": null
      },{
        "title": "[Programmers] 최댓값과 최솟값 (Python3)",
        "excerpt":"문제 설명  문자열 s에는 공백으로 구분된 숫자들이 저장되어 있습니다. str에 나타나는 숫자 중 최소값과 최대값을 찾아 이를 “(최소값) (최대값)”형태의 문자열을 반환하는 함수, solution을 완성하세요.  예를들어 s가 “1 2 3 4”라면 “1 4”를 리턴하고, “-1 -2 -3 -4”라면 “-4 -1”을 리턴하면 됩니다.   제한 조건  s에는 둘 이상의 정수가 공백으로 구분되어 있습니다.   입출력 예  1 2 3 4 s                return \"1 2 3 4\"\t     \"1 4\" \"-1 -2 -3 -4\"\t \"-4 -1\" \"-1 -1\"        \t \"-1 -1\"  코드   1 s = \"1 2 3 4\"   1 2 3 4 5 6 def solution(s):     a = []     for i in s.split():         a.append(int(i))          return \" \".join([str(min(a)),str(max(a))])   1 solution(s)   1 '1 4'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%B5%9C%EB%8C%93%EA%B0%92%EA%B3%BC-%EC%B5%9C%EC%86%9F%EA%B0%92/",
        "teaser": null
      },{
        "title": "[Programmers] 최솟값 만들기 (Python3)",
        "excerpt":"문제 설명  길이가 같은 배열 A, B 두개가 있습니다. 각 배열은 자연수로 이루어져 있습니다.   배열 A, B에서 각각 한 개의 숫자를 뽑아 두 수를 곱합니다. 이러한 과정을 배열의 길이만큼 반복하며, 두 수를 곱한 값을 누적하여 더합니다. 이때 최종적으로 누적된 값이 최소가 되도록 만드는 것이 목표입니다. (단, 각 배열에서 k번째 숫자를 뽑았다면 다음에 k번째 숫자는 다시 뽑을 수 없습니다.)     예를 들어 A = [1, 4, 2] , B = [5, 4, 4] 라면  A에서 첫번째 숫자인 1, B에서 첫번째 숫자인 5를 뽑아 곱하여 더합니다. (누적된 값 : 0 + 5(1x5) = 5)   A에서 두번째 숫자인 4, B에서 세번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 5 + 16(4x4) = 21)   A에서 세번째 숫자인 2, B에서 두번째 숫자인 4를 뽑아 곱하여 더합니다. (누적된 값 : 21 + 8(2x4) = 29)  즉, 이 경우가 최소가 되므로 29를 return 합니다.   배열 A, B가 주어질 때 최종적으로 누적된 최솟값을 return 하는 solution 함수를 완성해 주세요.   제한사항  1 2 배열 A, B의 크기 : 1,000 이하의 자연수 배열 A, B의 원소의 크기 : 1,000 이하의 자연수   입출력 예  1 2 3 A\t        B\t        answer [1, 4, 2]\t[5, 4, 4]\t29 [1,2]\t    [3,4]\t    10  코드   1 2 A = [1,4,2] B = [5,4,4]   1 2 3 4 5 6 7 8 def solution(A, B):     A.sort()     B.sort(reverse = True)     result = 0     for i,j in zip(A,B):         result +=(i*j)     return result            1 solution(A,B)   1 29   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%B5%9C%EC%86%9F%EA%B0%92-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] N진수 게임 (Python3)",
        "excerpt":"문제 설명  N진수 게임  튜브가 활동하는 코딩 동아리에서는 전통적으로 해오는 게임이 있다. 이 게임은 여러 사람이 둥글게 앉아서 숫자를 하나씩 차례대로 말하는 게임인데, 규칙은 다음과 같다.  숫자를 0부터 시작해서 차례대로 말한다. 첫 번째 사람은 0, 두 번째 사람은 1, … 열 번째 사람은 9를 말한다.  10 이상의 숫자부터는 한 자리씩 끊어서 말한다. 즉 열한 번째 사람은 10의 첫 자리인 1, 열두 번째 사람은 둘째 자리인 0을 말한다.  이렇게 게임을 진행할 경우,  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 0, 1, 1, 1, 2, 1, 3, 1, 4, …  순으로 숫자를 말하면 된다.  한편 코딩 동아리 일원들은 컴퓨터를 다루는 사람답게 이진수로 이 게임을 진행하기도 하는데, 이 경우에는  0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, …  순으로 숫자를 말하면 된다.  이진수로 진행하는 게임에 익숙해져 질려가던 사람들은 좀 더 난이도를 높이기 위해 이진법에서 십육진법까지 모든 진법으로 게임을 진행해보기로 했다. 숫자 게임이 익숙하지 않은 튜브는 게임에 져서 벌칙을 받는 굴욕을 피하기 위해, 자신이 말해야 하는 숫자를 스마트폰에 미리 출력해주는 프로그램을 만들려고 한다. 튜브의 프로그램을 구현하라.   입력 형식  진법 n, 미리 구할 숫자의 갯수 t, 게임에 참가하는 인원 m, 튜브의 순서 p 가 주어진다.  2 ≦ n ≦ 16  0 ＜ t ≦ 1000  2 ≦ m ≦ 100  1 ≦ p ≦ m   출력 형식  튜브가 말해야 하는 숫자 t개를 공백 없이 차례대로 나타낸 문자열. 단, 10~15는 각각 대문자 A~F로 출력한다.   입출력 예제  1 2 3 4 n\tt\tm\tp\tresult 2\t4\t2\t1\t\"0111\" 16\t16\t2\t1\t\"02468ACE11111111\" 16\t16\t2\t2\t\"13579BDF01234567\"   1 2 3 4 n = 16 t = 16 m = 2 p = 2   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def getnum(a, n):     num = []          while a&gt;0:         if a%n == 0:             num.append(int(a%n))             a = a/n                                            else:             num.append(int(a%n))             a = a//n     if len(num)== 0:         return ['0']                  for i in range(len(num)):         if num[i] == 10:             num[i] = 'A'         elif num[i] == 11:             num[i] = 'B'         elif num[i] == 12:             num[i] = 'C'         elif num[i] == 13:             num[i] = 'D'         elif num[i] == 14:             num[i] = 'E'         elif num[i] == 15:             num[i] = 'F'         else:             num[i] = str(num[i])     return list(reversed(num))  def solution(n,t,m,p):     num = []     result = []          for i in range(0,m*t):         num  = num + getnum(i,n)         if len(num) &gt;m*t:             break              if m==p:          for i in range(len(num)):             if (i+1)%m == 0:                              result.append(num[i])         else:         for i in range(len(num)):             if (i+1)%m == p:                               result.append(num[i])          return \"\".join(result[:t])                      1 getnum(0,1)   1 ['0']   1 a = [10,12,13,14]   1 2 solution(n,t,m,p)            1 '13579BDF01234567'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/N%EC%A7%84%EC%88%98-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[Programmers] 다음 큰 숫자 (Python3)",
        "excerpt":"문제 설명  자연수 n이 주어졌을 때, n의 다음 큰 숫자는 다음과 같이 정의 합니다.   1 2 3 조건 1. n의 다음 큰 숫자는 n보다 큰 자연수 입니다. 조건 2. n의 다음 큰 숫자와 n은 2진수로 변환했을 때 1의 갯수가 같습니다. 조건 3. n의 다음 큰 숫자는 조건 1, 2를 만족하는 수 중 가장 작은 수 입니다. 예를 들어서 78(1001110)의 다음 큰 숫자는 83(1010011)입니다. 자연수 n이 매개변수로 주어질 때, n의 다음 큰 숫자를 return 하는 solution 함수를 완성해주세요.   제한 사항  n은 1,000,000 이하의 자연수 입니다.   입출력 예  1 2 3 n\tresult 78\t83 15\t23   입출력 예 설명  입출력 예#1  문제 예시와 같습니다.   입출력 예#2  15(1111)의 다음 큰 숫자는 23(10111)입니다.   코드   1 n = 78   1 2 3 4 def solution(n):     for i in range(n+1,1000000):         if list(bin(n))[2:].count('1') == list(bin(i)).count('1'):             return i   1 solution(n)   1 83   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8B%A4%EC%9D%8C-%ED%81%B0-%EC%88%AB%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Programmers] 땅따먹기 (Python3)",
        "excerpt":"문제 설명  땅따먹기 게임을 하려고 합니다. 땅따먹기 게임의 땅(land)은 총 N행 4열로 이루어져 있고, 모든 칸에는 점수가 쓰여 있습니다. 1행부터 땅을 밟으며 한 행씩 내려올 때, 각 행의 4칸 중 한 칸만 밟으면서 내려와야 합니다. 단, 땅따먹기 게임에는 한 행씩 내려올 때, 같은 열을 연속해서 밟을 수 없는 특수 규칙이 있습니다.  예를 들면,  1 2 3 | 1 | 2 | 3 | 5 | | 5 | 6 | 7 | 8 | | 4 | 3 | 2 | 1 |  로 땅이 주어졌다면, 1행에서 네번째 칸 (5)를 밟았으면, 2행의 네번째 칸 (8)은 밟을 수 없습니다.  마지막 행까지 모두 내려왔을 때, 얻을 수 있는 점수의 최대값을 return하는 solution 함수를 완성해 주세요. 위 예의 경우, 1행의 네번째 칸 (5), 2행의 세번째 칸 (7), 3행의 첫번째 칸 (4) 땅을 밟아 16점이 최고점이 되므로 16을 return 하면 됩니다.   제한사항  행의 개수 N : 100,000 이하의 자연수  열의 개수는 4개이고, 땅(land)은 2차원 배열로 주어집니다.  점수 : 100 이하의 자연수   입출력 예  1 2 land\t                        answer [[1,2,3,5],[5,6,7,8],[4,3,2,1]]\t16   입출력 예 설명  입출력 예 #1  문제의 예시와 같습니다.   코드   1 land = [[1,2,3,5],[5,6,7,100],[4,3,2,100]]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solution(land):     locate = -1     result = 0     for i in range(len(land)-1):         for j in range(len(land[0])):             locate = land[i].index(max(land[i]))             if j == locate:                 land[i+1][j] = land[i+1][j]+sorted(land[i])[2]                                              else:                 land[i+1][j] = land[i+1][j]+max(land[i])                          return max(land[-1])   1 solution(land)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 [10, 6, 7, 100] else [10, 11, 7, 100] else [10, 11, 12, 100] else [10, 11, 12, 103] if [107, 3, 2, 100] else [107, 106, 2, 100] else [107, 106, 105, 100] else [107, 106, 105, 112] if      112   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%95%85%EB%94%B0%EB%A8%B9%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 올바른 괄호 (Python3)",
        "excerpt":"문제 설명  괄호가 바르게 짝지어졌다는 것은 ‘(‘ 문자로 열렸으면 반드시 짝지어서 ‘)’ 문자로 닫혀야 한다는 뜻입니다. 예를 들어   1 2 \"()()\" 또는 \"(())()\" 는 올바른 괄호입니다. \")()(\" 또는 \"(()(\" 는 올바르지 않은 괄호입니다.   ’(‘ 또는 ‘)’ 로만 이루어진 문자열 s가 주어졌을 때, 문자열 s가 올바른 괄호이면 true를 return 하고, 올바르지 않은 괄호이면 false를 return 하는 solution 함수를 완성해 주세요.   제한사항  문자열 s의 길이 : 100,000 이하의 자연수  문자열 s는 ‘(‘ 또는 ‘)’ 로만 이루어져 있습니다.  코드   1 s = \")(\"   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def solution(s):     a = []     a.append(s[0])          if s[0] == ')':                 return False     for i in range(1,len(s)):         if len(a)== 0:             a.append(s[i])             if a[0] == ')':                 return False         elif a[-1] == s[i]:             a.append(s[i])         else:             a.pop()     if len(a) == 0:         return True      else:         return False            1 solution(s)   1 False   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%98%AC%EB%B0%94%EB%A5%B8-%EA%B4%84%ED%98%B8/",
        "teaser": null
      },{
        "title": "[Programmers] 압축 (Python3)",
        "excerpt":"문제 설명  신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.   어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.   LZW 압축은 다음 과정을 거친다.      길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.   사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다.   w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다.        입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다.            단계 2로 돌아간다.  압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.       색인 번호\t1\t2\t3\t…\t24\t25\t26    단어\t     A\t B\t C\t … X\t Y   Z       예를 들어 입력으로 KAKAO가 들어온다고 하자.     현재 사전에는 KAKAO의 첫 글자 K는 등록되어 있으나, 두 번째 글자까지인 KA는 없으므로, 첫 글자 K에 해당하는 색인 번호 11을 출력하고, 다음 글자인 A를 포함한 KA를 사전에 27 번째로 등록한다.   두 번째 글자 A는 사전에 있으나, 세 번째 글자까지인 AK는 사전에 없으므로, A의 색인  번호 1을 출력하고, AK를 사전에 28 번째로 등록한다.   세 번째 글자에서 시작하는 KA가 사전에 있으므로, KA에 해당하는 색인 번호 27을 출력하고, 다음 글자 O를 포함한 KAO를 29 번째로 등록한다.   마지막으로 처리되지 않은 글자 O에 해당하는 색인 번호 15를 출력한다.     1 2 3 4 5   현재 입력(w)\t다음 글자(c)\t출력\t사전 추가(w+c)   K\t          A\t            11\t 27: KA   A\t          K\t            1\t 28: AK   KA\t          O\t            27\t 29: KAO   O\t\t                    15\t           이 과정을 거쳐 다섯 글자의 문장 KAKAO가 4개의 색인 번호 [11, 1, 27, 15]로 압축된다.   입력으로 TOBEORNOTTOBEORTOBEORNOT가 들어오면 다음과 같이 압축이 진행된다.  현재 입력(w)\t다음 글자(c)\t출력\t사전 추가(w+c)  T\tO\t20\t27: TO  O\tB\t15\t28: OB  B\tE\t2\t29: BE  E\tO\t5\t30: EO  O\tR\t15\t31: OR  R\tN\t18\t32: RN  N\tO\t14\t33: NO  O\tT\t15\t34: OT  T\tT\t20\t35: TT  TO\tB\t27\t36: TOB  BE\tO\t29\t37: BEO  OR\tT\t31\t38: ORT  TOB\tE\t36\t39: TOBE  EO\tR\t30\t40: EOR  RN\tO\t32\t41: RNO  OT\t\t34   입력 형식  입력으로 영문 대문자로만 이뤄진 문자열 msg가 주어진다. msg의 길이는 1 글자 이상, 1000 글자 이하이다.   출력 형식  주어진 문자열을 압축한 후의 사전 색인 번호를 배열로 출력하라.   입출력 예제                  msg       answer                       KAKAO       [11, 1, 27, 15]                 TOBEORNOTTOBEORTOBEORNOT       [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]                 ABABABABABABABAB       [1, 2, 27, 29, 28, 31, 30]           코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def solution(msg):     answer = []     a = [\"a\"]     dic = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")     msg = msg+'.'     for i in range(len(msg)):         for j in reversed(range(len(msg)+1)):                              if len(a[-1])&gt;2:                 a[-1] = a[-1][:-1]                 break                             if msg[i:j] in dic:                 answer.append(dic.index(msg[i:j])+1)                 dic.append(msg[i:j+1])                 a.append(msg[i:j+1])                 break                                                 return answer   1 solution(msg)   1 [20, 15, 2, 5, 15, 18, 14, 15, 20, 27, 29, 31, 36, 30, 32, 34]   1 msg = \"TOBEORNOTTOBEORTOBEORNOT\"  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%95%95%EC%B6%95/",
        "teaser": null
      },{
        "title": "[Programmers] 가장 큰 정사각형 찾기 (Python3)",
        "excerpt":"문제 설명  1와 0로 채워진 표(board)가 있습니다. 표 1칸은 1 x 1 의 정사각형으로 이루어져 있습니다. 표에서 1로 이루어진 가장 큰 정사각형을 찾아 넓이를 return 하는 solution 함수를 완성해 주세요. (단, 정사각형이란 축에 평행한 정사각형을 말합니다.)   1 2 3 4 5 6 7 8 9 10 11 12 13 예를 들어 1\t2\t3\t4 0\t1\t1\t1 1\t1\t1\t1 1\t1\t1\t1 0\t0\t1\t0 가 있다면 가장 큰 정사각형은 1\t2\t3\t4 0\t1\t1\t1 1\t1\t1\t1 1\t1\t1\t1 0\t0\t1\t0 가 되며 넓이는 9가 되므로 9를 반환해 주면 됩니다.   제한사항   1 2 3 4 표(board)는 2차원 배열로 주어집니다. 표(board)의 행(row)의 크기 : 1,000 이하의 자연수 표(board)의 열(column)의 크기 : 1,000 이하의 자연수 표(board)의 값은 1또는 0으로만 이루어져 있습니다.   입출력 예  1 2 3 board\t                                    answer [[0,1,1,1],[1,1,1,1],[1,1,1,1],[0,0,1,0]]\t9 [[0,0,1,1],[1,1,1,1]]\t                    4   입출력 예 설명  입출력 예 #1  위의 예시와 같습니다.   입출력 예 #2   1 2 | 0 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 |  로 가장 큰 정사각형의 넓이는 4가 되므로 4를 return합니다.   코드   1 board =[[1]]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(board):     a = []      for row in range(1,len(board)):         for column in range(1,len(board[0])):             if board[row][column] &gt;= 1:                 board[row][column] = min(board[row-1][column],board[row][column-1],board[row-1][column-1])+1                  a.append(board[row][column])             else:                 a.append(board[row][column])     if len(a) == 0:         answer = 1     else:         answer = max(a)**2          return answer   1 solution(board)   1 1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A0%95%EC%82%AC%EA%B0%81%ED%98%95-%EC%B0%BE%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 방금 그 곡 (Python3)",
        "excerpt":"방금그곡  라디오를 자주 듣는 네오는 라디오에서 방금 나왔던 음악이 무슨 음악인지 궁금해질 때가 많다. 그럴 때 네오는 다음 포털의 ‘방금그곡’ 서비스를 이용하곤 한다. 방금그곡에서는 TV, 라디오 등에서 나온 음악에 관해 제목 등의 정보를 제공하는 서비스이다.   네오는 자신이 기억한 멜로디를 가지고 방금그곡을 이용해 음악을 찾는다. 그런데 라디오 방송에서는 한 음악을 반복해서 재생할 때도 있어서 네오가 기억하고 있는 멜로디는 음악 끝부분과 처음 부분이 이어서 재생된 멜로디일 수도 있다. 반대로, 한 음악을 중간에 끊을 경우 원본 음악에는 네오가 기억한 멜로디가 들어있다 해도 그 곡이 네오가 들은 곡이 아닐 수도 있다. 그렇기 때문에 네오는 기억한 멜로디를 재생 시간과 제공된 악보를 직접 보면서 비교하려고 한다. 다음과 같은 가정을 할 때 네오가 찾으려는 음악의 제목을 구하여라.     방금그곡 서비스에서는 음악 제목, 재생이 시작되고 끝난 시각, 악보를 제공한다.   네오가 기억한 멜로디와 악보에 사용되는 음은 C, C#, D, D#, E, F, F#, G, G#, A, A#, B 12개이다.   각 음은 1분에 1개씩 재생된다. 음악은 반드시 처음부터 재생되며 음악 길이보다 재생된 시간이 길 때는 음악이 끊김 없이 처음부터 반복해서 재생된다. 음악 길이보다 재생된 시간이 짧을 때는 처음부터 재생 시간만큼만 재생된다.   음악이 00:00를 넘겨서까지 재생되는 일은 없다.   조건이 일치하는 음악이 여러 개일 때에는 라디오에서 재생된 시간이 제일 긴 음악 제목을 반환한다. 재생된 시간도 같을 경우 먼저 입력된 음악 제목을 반환한다.   조건이 일치하는 음악이 없을 때에는 “(None)”을 반환한다.   입력 형식  입력으로 네오가 기억한 멜로디를 담은 문자열 m과 방송된 곡의 정보를 담고 있는 배열 musicinfos가 주어진다.     m은 음 1개 이상 1439개 이하로 구성되어 있다.   musicinfos는 100개 이하의 곡 정보를 담고 있는 배열로, 각각의 곡 정보는 음악이 시작한 시각, 끝난 시각, 음악 제목, 악보 정보가 ‘,’로 구분된 문자열이다.   음악의 시작 시각과 끝난 시각은 24시간 HH:MM 형식이다.   음악 제목은 ‘,’ 이외의 출력 가능한 문자로 표현된 길이 1 이상 64 이하의 문자열이다.  악보 정보는 음 1개 이상 1439개 이하로 구성되어 있다.   출력 형식  조건과 일치하는 음악 제목을 출력한다.   1 2 m = \"CC#BCC#BCC#BCC#B\" musicinfos = [\"03:00,04:27,FOO,CC#B\", \"03:00,03:30,F1,CC#B\"]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 import re def solution(m, f):     result = []     m = m.replace('A#','a')     m = m.replace('B#','b')     m = m.replace('C#','c')     m = m.replace('D#','d')     m = m.replace('E#','e')     m = m.replace('F#','f')     m = m.replace('G#','g')          for i in f:         s = re.split('[,]',i)                      s[3] = s[3].replace('A#','a')         s[3] = s[3].replace('B#','b')         s[3] = s[3].replace('C#','c')         s[3] = s[3].replace('D#','d')         s[3] = s[3].replace('E#','e')         s[3] = s[3].replace('F#','f')         s[3] = s[3].replace('G#','g')                          hour = int(s[1][0:2])-int(s[0][0:2])         minu = int(s[1][3:5])-int(s[0][3:5])         time = hour*60+minu         melody = \"\"              if len(result)== 0:         return \"(None)\"      if len(result) &gt;1:         result = sorted(result,key = lambda x: -x[0])         return result [0][-1]       return result[0][1]         1 solution(m,musicinfos)   1 '(None)'   1 0%3   1 0   1 b = 'ABCD#EF#'   1 b.index('C')   1 4   1 2 b = [['b',12], ['a',12]] sorted(b,key= lambda x: x[1])   1 [['b', 12], ['a', 12]]   1 b =[\"03:00,03:30,FOO,CC#B\"]   1 int(b[0][0:2])   1 3   1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B0%A9%EA%B8%88%EA%B7%B8%EA%B3%A1/",
        "teaser": null
      },{
        "title": "[Programmers] 파일명 정렬 (Python3)",
        "excerpt":"파일명 정렬  세 차례의 코딩 테스트와 두 차례의 면접이라는 기나긴 블라인드 공채를 무사히 통과해 카카오에 입사한 무지는 파일 저장소 서버 관리를 맡게 되었다.   저장소 서버에는 프로그램의 과거 버전을 모두 담고 있어, 이름 순으로 정렬된 파일 목록은 보기가 불편했다. 파일을 이름 순으로 정렬하면 나중에 만들어진 ver-10.zip이 ver-9.zip보다 먼저 표시되기 때문이다.   버전 번호 외에도 숫자가 포함된 파일 목록은 여러 면에서 관리하기 불편했다. 예컨대 파일 목록이   [“img12.png”, “img10.png”, “img2.png”, “img1.png”]일 경우, 일반적인 정렬은 [“img1.png”, “img10.png”, “img12.png”, “img2.png”] 순이 되지만, 숫자 순으로 정렬된 [“img1.png”, “img2.png”, “img10.png”, img12.png”] 순이 훨씬 자연스럽다.   무지는 단순한 문자 코드 순이 아닌, 파일명에 포함된 숫자를 반영한 정렬 기능을 저장소 관리 프로그램에 구현하기로 했다.   소스 파일 저장소에 저장된 파일명은 100 글자 이내로, 영문 대소문자, 숫자, 공백(“ “), 마침표(“.”), 빼기 부호(“-“)만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.   파일명은 크게 HEAD, NUMBER, TAIL의 세 부분으로 구성된다.     HEAD는 숫자가 아닌 문자로 이루어져 있으며, 최소한 한 글자 이상이다.   NUMBER는 한 글자에서 최대 다섯 글자 사이의 연속된 숫자로 이루어져 있으며, 앞쪽에 0이 올 수 있다. 0부터 99999 사이의 숫자로, 00000이나 0101 등도 가능하다.        TAIL은 그 나머지 부분으로, 여기에는 숫자가 다시 나타날 수도 있으며, 아무 글자도 없을 수 있다.       파일명\t             HEAD\t        NUMBER\t          TAIL    foo9.txt\t      foo            9\t               .txt    foo010bar020.zip  foo            010\t           bar020.zip    F-15\t          F-\t         15\t               (빈 문자열)       파일명을 세 부분으로 나눈 후, 다음 기준에 따라 파일명을 정렬한다.      파일명은 우선 HEAD 부분을 기준으로 사전 순으로 정렬한다. 이때, 문자열 비교 시 대소문자 구분을 하지 않는다. MUZI와 muzi, MuZi는 정렬 시에 같은 순서로 취급된다.   파일명의 HEAD 부분이 대소문자 차이 외에는 같을 경우, NUMBER의 숫자 순으로 정렬한다. 9 &lt; 10 &lt; 0011 &lt; 012 &lt; 13 &lt; 014 순으로 정렬된다. 숫자 앞의 0은 무시되며, 012와 12는 정렬 시에 같은 같은 값으로 처리된다.   두 파일의 HEAD 부분과, NUMBER의 숫자도 같을 경우, 원래 입력에 주어진 순서를 유지한다. MUZI01.zip과 muzi1.png가 입력으로 들어오면, 정렬 후에도 입력 시 주어진 두 파일의 순서가 바뀌어서는 안 된다.   무지를 도와 파일명 정렬 프로그램을 구현하라.   입력 형식  입력으로 배열 files가 주어진다.     files는 1000 개 이하의 파일명을 포함하는 문자열 배열이다.   각 파일명은 100 글자 이하 길이로, 영문 대소문자, 숫자, 공백(“ “), 마침표(“.”), 빼기 부호(“-“)만으로 이루어져 있다. 파일명은 영문자로 시작하며, 숫자를 하나 이상 포함하고 있다.   중복된 파일명은 없으나, 대소문자나 숫자 앞부분의 0 차이가 있는 경우는 함께 주어질 수 있다. (muzi1.txt, MUZI1.txt, muzi001.txt, muzi1.TXT는 함께 입력으로 주어질 수 있다.)   출력 형식  위 기준에 따라 정렬된 배열을 출력한다.   입출력 예제  1 2 3 4 입력: [\"img12.png\", \"img10.png\", \"img02.png\", \"img1.png\", \"IMG01.GIF\", \"img2.JPG\"] 출력: [\"img1.png\", \"IMG01.GIF\", \"img02.png\", \"img2.JPG\", \"img10.png\", \"img12.png\"] 입력: [\"F-5 Freedom Fighter\", \"B-50 Superfortress\", \"A-10 Thunderbolt II\", \"F-14 Tomcat\"] 출력: [\"A-10 Thunderbolt II\", \"B-50 Superfortress\", \"F-5 Freedom Fighter\", \"F-14 Tomcat\"]   코드   1 files = [\"img12.png\", \"img10.png\", \"img02.png\", \"img1.png\", \"IMG01.GIF\", \"img2.JPG\"]   1 2 3 4 5 import re def solution(files):     temp = [re.split('([0-9]+)',s) for s in files]     sort = sorted(temp, key = lambda x: (x[0].lower(),int(x[1])))         return [\"\".join(i) for i in sort]   1 solution(files)   1 ['img1.png', 'IMG01.GIF', 'img02.png', 'img2.JPG', 'img10.png', 'img12.png']   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%8C%8C%EC%9D%BC%EB%AA%85-%EC%A0%95%EB%A0%AC/",
        "teaser": null
      },{
        "title": "[Programmers] 가장 큰 수 (Python3)",
        "excerpt":"문제 설명  0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요.   예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다.   0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.   제한 사항     numbers의 길이는 1 이상 100,000 이하입니다.   numbers의 원소는 0 이상 1,000 이하입니다.   정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.   입출력 예  numbers          \treturn  [6, 10, 2]\t        “6210”  [3, 30, 34, 5, 9]\t“9534330”   1 numbers =[0,0,0,0,0]   1 2 3 4 5 6 7 def solution(numbers):     n = []     for i in numbers:         n.append(str(i))     a = sorted(n, key = lambda x:x*3)          return str(int(\"\".join(reversed(a))))   1 solution(numbers)   1 '0'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] 스킬 트리 (Python3)",
        "excerpt":"문제 설명  선행 스킬이란 어떤 스킬을 배우기 전에 먼저 배워야 하는 스킬을 뜻합니다.   예를 들어 선행 스킬 순서가 스파크 → 라이트닝 볼트 → 썬더일때, 썬더를 배우려면 먼저 라이트닝 볼트를 배워야 하고, 라이트닝 볼트를 배우려면 먼저 스파크를 배워야 합니다.  위 순서에 없는 다른 스킬(힐링 등)은 순서에 상관없이 배울 수 있습니다. 따라서 스파크 → 힐링 → 라이트닝 볼트 → 썬더와 같은 스킬트리는 가능하지만, 썬더 → 스파크나 라이트닝 볼트 → 스파크 → 힐링 → 썬더와 같은 스킬트리는 불가능합니다.   선행 스킬 순서 skill과 유저들이 만든 스킬트리1를 담은 배열 skill_trees가 매개변수로 주어질 때, 가능한 스킬트리 개수를 return 하는 solution 함수를 작성해주세요.   제한 조건     스킬은 알파벳 대문자로 표기하며, 모든 문자열은 알파벳 대문자로만 이루어져 있습니다.   스킬 순서와 스킬트리는 문자열로 표기합니다.            예를 들어, C → B → D 라면 “CBD”로 표기합니다           선행 스킬 순서 skill의 길이는 1 이상 26 이하이며, 스킬은 중복해 주어지지 않습니다.   skill_trees는 길이 1 이상 20 이하인 배열입니다.   skill_trees의 원소는 스킬을 나타내는 문자열입니다.            skill_trees의 원소는 길이가 2 이상 26 이하인 문자열이며, 스킬이 중복해 주어지지 않습니다.           입출력 예   1 2 skill\tskill_trees\t                      return \"CBD\"\t[\"BACDE\", \"CBADF\", \"AECB\", \"BDA\"]\t2   입출력 예 설명     BACDE”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트립니다.   “CBADF”: 가능한 스킬트리입니다.   “AECB”: 가능한 스킬트리입니다.   “BDA”: B 스킬을 배우기 전에 C 스킬을 먼저 배워야 합니다. 불가능한 스킬트리입니다.   코드   1 2 skill = \"CBD\" skill_trees = [\"BACDE\", \"CBADF\", \"AECB\", \"BDA\"]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def solution(skill, skill_trees):     result = 0     for i in skill_trees:         a = []         tf = True                  for j in range(len(i)):             if i[j] in skill:                 a.append(i[j])                          for k in range(len(a)):             if a[k] != skill[k]:                 tf = False         if tf == True:             result += 1     return result                          1 solution(skill,skill_trees)   1 2   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%8A%A4%ED%82%AC%ED%8A%B8%EB%A6%AC/",
        "teaser": null
      },{
        "title": "관성",
        "excerpt":"2021.06.23  오랜만에 블로그에 일기를 쓴다.   최근에 깃허브에 재미가 들려서 이게 블로그랑 어느정도 비슷한 성격을 띄다보니까  깃허브쓰랴 블로그쓰랴 귀찮아서 최근에는 깃허브에만 코드를 업로드 했는데, 해보니까 앞으로도  블로그에 코드 올리는일은 잘 없을듯하다… 다른 공부는 모르겠지만 코딩관련 공부에 글쓰는건 깃허브가 너무 편하고 좋 아서 네이버 블로그에는 불편해서 이제 못올리겠다.   그럼에도 일기랑은 또 다른 성격이라서 블로그도 꾸준히 써야하는데 요즘 나태해져서 다시 또 정신을 차리고 꾸준히 블로 그를 쓸 다짐을 한다.   요즘 근황을 잠깐 돌아보자면, 사실 나태해졌다고 하지만 요즘처럼 공부 많이 한적이 없다.  하나에 몰두하게 되면 다른것에 소홀해지는게 당연한건지 공부량을 늘리니까 다른게 너무 귀찮아져서 운동이고 블로그고 안한지 너무 오래됐다. 육체적인 건강과 정신적인 건강을 위해서 시작한 두가지인데  조금 바빠도 두개 다 꼬박꼬박 다시 시작해야겠다는 생각을 매일 하면서도, 이게 관성이 한번 사라지니까 다시 시작하는게 너무너무너무 귀찮고 하기가 싫다… 몸에 좋은거는 왜이렇게 하기가 귀찮은지 모르겠다.   주식은 ktb 투자증권을 늦게나마 다시 진입해서 좀 벌고..  숏으로 좀 벌고… 장이 너무 혼란한것 같아서 당분간 공부에 집중도 안되고, 방향성 매매를 하기에는 서치할 여력이 없어 서 단순하게 채권금리 떨어지길래 성장주가 좋겠거니~ 하고 카카오에 장기적 느낌으로 넣었는데, 너무 잘올라서 당황스 러웠다. 저번주랑 이번주해서 거의 170가까이 벌었으니 뭐… 이정도면 아주 만족스럽다.   그래도 오늘 아침에는 운동을 하고 좀 일찍 스터디카페로 출근했으니, 다시 관성을 붙여서 더더 열심히 살아야겠다. 요즘따라 자꾸 열시 열한시까지 자고 이거 습관도 다시 아침으로 돌려서 운동하고 와서 아홉시 열시에는 스터디카페에 몸 을 붙일 수 있도록 하는게 단기적인 목표다. 오랜만에 글쓰니까 또 재밌기도 하고??   잘 모르고 있었는데 이렇게 글을 쓰다보니까 객관적으로도 요즘 인생이 참 잘풀리고 있었구나 하는 생각이 든다.  얼마전에 명상에 관해서 쓴 좋은 글을 하나 읽어서, 아침 루틴에 명상도 한번 포함시켜보려 한다. 한번에 이렇게 여러가지 계획하면 망하는 경우가 태반이던데…   그래도 관성을 붙이는김에 좀 힘들어도 여러개 한번에 루틴으로 만들어놓으면 한달뒤에 훨씬 편하다.  인생은 원래 콜드터키법이다.   힘들어?? 그거 원래그런거야. 견디면 괜찮아져~  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B4%80%EC%84%B1/",
        "teaser": null
      },{
        "title": "[Programmers] 시저 암호 (Python3)",
        "excerpt":"문제 설명  어떤 문장의 각 알파벳을 일정한 거리만큼 밀어서 다른 알파벳으로 바꾸는 암호화 방식을 시저 암호라고 합니다. 예를 들어 “AB”는 1만큼 밀면 “BC”가 되고, 3만큼 밀면 “DE”가 됩니다. “z”는 1만큼 밀면 “a”가 됩니다. 문자열 s와 거리 n을 입력받아 s를 n만큼 민 암호문을 만드는 함수, solution을 완성해 보세요.   제한 조건  공백은 아무리 밀어도 공백입니다.  s는 알파벳 소문자, 대문자, 공백으로만 이루어져 있습니다.  s의 길이는 8000이하입니다.  n은 1 이상, 25이하인 자연수입니다.   입출력 예  1 2 3 4 s\t    n\tresult \"AB\"\t1\t\"BC\" \"z\"  \t1\t\"a\" \"a B z\"\t4\t\"e F d\"   코드   1 2 s = \"a B z\" n = 1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(s,n):     alpha_lower= [\"abcdefghijklmnopqrstuvwxyz\"]     alpha_upper= [\"abcdefghijklmnopqrstuvwxyz\"]     alpha_upper = list(alpha_upper[0].upper())     alpha_lower = list(alpha_lower[0])     result = \"\"         for i in range(0, len(s)):         if s[i] == ' ':             result += ' '         else:             if s[i].islower() == True:                 result += alpha_lower[(alpha_lower.index(s[i])+n)%26]             if s[i].islower() == False:                 result += alpha_upper[(alpha_upper.index(s[i])+n)%26]     return result   1 solution(s,n)   1 'b C a'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%8B%9C%EC%A0%80-%EC%95%94%ED%98%B8/",
        "teaser": null
      },{
        "title": "[BOJ] 17224 APC는 왜 서브태스크 대회가 되었을까? (Python3)",
        "excerpt":"문제  현정이는 APC에 한 번이라도 나가보고 싶다는 소망이 있다. 하지만 이 소망은 여태까지 단 한 번도, 그리고 앞으로도 이루어질 리 없기 때문에 현정이가 입버릇처럼 하게 된 말이 있는데…   현정 : 아~~ 나도 APC 참가만 했으면 상금 받는 건데~~~~~  준표 : … 그건 아닌 것 같은데?  현정이의 근거 없는 자신감이 눈꼴신 준표는 출제 중에 평가한 문제 난이도를 통해 현정이의 예상 점수를 알려주고 현정이가 현실을 받아들일 수 있도록 도와주고자 한다.   현정이는 L 만큼의 역량을 가지고 있어 L보다 작거나 같은 난이도의 문제를 풀 수 있다. 또한 현정이는 코딩이 느리기 때문에 대회 시간이 부족해 K개보다 많은 문제는 해결할 수 없다. 어떤 문제에 대해 쉬운 버전을 해결한다면 100점을 얻고, 어려운 버전을 해결한다면 여기에 40점을 더 받아 140점을 얻게 된다. 어려운 버전을 해결하면 쉬운 버전도 같이 풀리게 되므로, 한 문제를 해결한 것으로 계산한다.   현정이가 APC에 참가했다면 최대 몇점을 얻을 수 있었을지 알려주자.   입력  첫 줄에 문제의 개수 N, 현정이의 역량 L, 현정이가 대회중에 풀 수 있는 문제의 최대 개수 K가 주어진다.   둘째 줄부터 N개의 줄에 걸쳐 1 ~ N번째 문제의 쉬운 버전의 난이도 sub1, 어려운 버전의 난이도 sub2 가 순서대로 주어진다.   출력  현정이가 APC에 참가했다면 얻었을 점수의 최대값을 출력한다.   제한  1 2 3 4 5 6 7 1 ≤ N ≤ 100 1 ≤ L ≤ 50 1 ≤ sub1 ≤ sub2 ≤ 50 서브태스크 1 (100점) K = N 서브태스크 2 (40점) 0 ≤ K ≤ N   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 예제 입력 1  복사 4 8 4 1 8 4 5 6 20 9 12 예제 출력 1  복사 380 1번, 2번 문제의 어려운 버전을 해결해 2×140 = 280점을, 3번 문제의 쉬운 버전을 해결해 100점을 얻어 총 380점을 얻는다.  현정이가 4문제를 풀 수 있을 정도로 대회 시간은 충분하지만, 4번 문제는 현정이에겐 너무 어려워서 풀 수 없다.  예제 입력 2  복사 8 7 5 1 3 2 5 3 5 4 8 5 8 6 9 6 7 7 10 예제 출력 2  복사 660 예제 입력 3  복사 8 9 5 1 8 3 10 4 5 5 20 7 12 8 15 9 50 14 14 예제 출력 3  복사 580 힌트 예제2, 3은 서브태스크1에서는 나오지 않는다.   전통적으로 APC는 쉬운 버전의 문제를 먼저 푸는 것이 정신건강과 안정적인 득점을 위해 좋다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 N,L,K = map(int, input().split()) ##문제의 개수 N, 현정이의 역량 L, 현정이의 최대 풀이 문제 개수 K  difficult = [] for i in range(N):     difficult.append(list(map(int, input().split()))) #difficult 리스트에 서브태스크1,2를 리스트로 묶어서 넣는다. difficult. sort() #서브태스크 1의 난이도를 기준으로 정렬 score_list = []   for problem in difficult:     if L &gt;= problem[1]:#역량보다 sub2 문제의 난이도가 적거나 같다면 스코어 +100         score_list.append(140)     else: #sub 2문제를 못풀경우         if L &gt;= problem[0]: #역량보다 sub1 문제의 난이도가 적거나 같다면 스코어 +100             score_list.append(100)         else:             pass score = 0 for i in range(K):      if len(score_list) == 0: #리스트가 비었으면 for문 종료         break     score += max(score_list) #max값을 score에 더해주고     score_list.remove(max(score_list)) #더한 max값은 리스트에서 제거           print(score)                   1 2 3 4 5 6 4 8 4 1 8 4 5 6 20 9 12 380   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/APC%EB%8A%94-%EC%99%9C-%EC%84%9C%EB%B8%8C%ED%83%9C%EC%8A%A4%ED%81%AC-%EB%8C%80%ED%9A%8C%EA%B0%80-%EB%90%98%EC%97%88%EC%9D%84%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[BOJ] 2839 설탕 배달 (Python3)",
        "excerpt":"문제  상근이는 요즘 설탕공장에서 설탕을 배달하고 있다. 상근이는 지금 사탕가게에 설탕을 정확하게 N킬로그램을 배달해야 한다. 설탕공장에서 만드는 설탕은 봉지에 담겨져 있다. 봉지는 3킬로그램 봉지와 5킬로그램 봉지가 있다.   상근이는 귀찮기 때문에, 최대한 적은 봉지를 들고 가려고 한다. 예를 들어, 18킬로그램 설탕을 배달해야 할 때, 3킬로그램 봉지 6개를 가져가도 되지만, 5킬로그램 3개와 3킬로그램 1개를 배달하면, 더 적은 개수의 봉지를 배달할 수 있다.   상근이가 설탕을 정확하게 N킬로그램 배달해야 할 때, 봉지 몇 개를 가져가면 되는지 그 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N이 주어진다. (3 ≤ N ≤ 5000)   출력  상근이가 배달하는 봉지의 최소 개수를 출력한다. 만약, 정확하게 N킬로그램을 만들 수 없다면 -1을 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 예제 입력 1  복사 18 예제 출력 1  복사 4 예제 입력 2  복사 4 예제 출력 2  복사 -1 예제 입력 3  복사 6 예제 출력 3  복사 2 예제 입력 4  복사 9 예제 출력 4  복사 3 예제 입력 5  복사 11 예제 출력 5  복사 3  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 n = int(input()) #설탕  result = 0 #봉지수  while n&gt;=0:     if n%5 == 0: #5의 나머지가 0인경우         result += n//5         print(result) # 5로 나눈 몫이 답         break     n-= 3 # 5로 나눠지지 않으면, 나눠질때까지 3을 빼준다.     result+= 1 #빼면 봉지 하나 추가 else: #while이 거짓이 되어 종료되면     print(-1)                  1 2 18 4   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%84%A4%ED%83%95-%EB%B0%B0%EB%8B%AC/",
        "teaser": null
      },{
        "title": "[BOJ] 1946 신입사원 (Python3)",
        "excerpt":"문제  언제나 최고만을 지향하는 굴지의 대기업 진영 주식회사가 신규 사원 채용을 실시한다. 인재 선발 시험은 1차 서류심사와 2차 면접시험으로 이루어진다. 최고만을 지향한다는 기업의 이념에 따라 그들은 최고의 인재들만을 사원으로 선발하고 싶어 한다.   그래서 진영 주식회사는, 다른 모든 지원자와 비교했을 때 서류심사 성적과 면접시험 성적 중 적어도 하나가 다른 지원자보다 떨어지지 않는 자만 선발한다는 원칙을 세웠다. 즉, 어떤 지원자 A의 성적이 다른 어떤 지원자 B의 성적에 비해 서류 심사 결과와 면접 성적이 모두 떨어진다면 A는 결코 선발되지 않는다.   이러한 조건을 만족시키면서, 진영 주식회사가 이번 신규 사원 채용에서 선발할 수 있는 신입사원의 최대 인원수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 20)가 주어진다. 각 테스트 케이스의 첫째 줄에 지원자의 숫자 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N개 줄에는 각각의 지원자의 서류심사 성적, 면접 성적의 순위가 공백을 사이에 두고 한 줄에 주어진다. 두 성적 순위는 모두 1위부터 N위까지 동석차 없이 결정된다고 가정한다.   출력  각 테스트 케이스에 대해서 진영 주식회사가 선발할 수 있는 신입사원의 최대 인원수를 한 줄에 하나씩 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 예제 입력 1  복사 2 5 3 2 1 4 4 1 2 3 5 5 7 3 6 7 3 4 2 1 4 5 7 2 5 6 1 예제 출력 1  복사 4 3   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import sys T = int(input()) #테스트 케이스를 입력으로 받는다.  rank = []  for i in range(T):     score = 0     N = int(input()) #지원자의 숫자를 입력으로 받는다.          for i in range(N):         new_paper, new_interview = map(int, input().split())#서류점수와 면접점수를 받음         rank.append([new_paper, new_interview])     rank.sort(key = lambda x: x[0])          result = 1       standard = rank[0][1]     for i in range(1, len(rank)):         if rank[i][1] &lt; standard:             result += 1         standard = rank[i][1]                         print(result)            1 2 3 4 5 6 7 8 9 10 1 7 3 6 7 3 4 2 1 4 5 7 2 5 6 1 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%8B%A0%EC%9E%85-%EC%82%AC%EC%9B%90/",
        "teaser": null
      },{
        "title": "휴학 반년 결산",
        "excerpt":"2021.07.04  어느덧 2021년의 6월이 지나가버리고 7월이 되었다.  1년의 절반이 훌쩍 가버렸다. 여러가지 계획한 것이 있었고, 그 계획들이 바뀌고 다시 새워지고 반복을 한 끝에  드디어 어느정도 명확한 목표가 생긴 것 같다. 휴학을 한 큰 이유중에 하나가 내가 도대체 무엇을 하고 살고 싶은지, 어떤 일을 하고싶은지에 대한 목표가 하나도 없어서, 이대로는 무슨 공부를 해도 헛걸음이 될 것같다는 생각때문이었다.   내 전공인 전자공학은 내가 목표했던 방향과 아예 달랐고, 그 상태에서는 뭐 공부를 할라고 해도 공부가 되지를 않았다. 전 역 후 불타오르던 공부욕은 금방 식어버렸고, 사실 3학년 2학기를 그냥 ‘내가 이걸 배워서 도대체 어디다 쓰지…’ 하는 생 각만 하며 보냈던것 같다. 전과를 하기에는 너무나 많이 지나 버린것 같기도 하고, 1,2학년때 망쳐놓은 학점들은 내가 뭘 도전해보고 싶던간에 내 발목을 잡았다. 그렇게 솔직히 지친마음 반, 내가 뭘하고 싶은지 생각 좀 해봐야겠다 반… 그리고 지섭이가 휴학한다길래 혼자서 학교다닐 자신이 없는 마음도 조금 포함해서 휴학을 때렸다. 솔직히 휴학을 결정하고 초반 에는 불안한 마음도 컸고, 남들은 앞으로 달려갈때, 난 이미 남들보다도 뒤쳐져있는 상태인데도 여기에 주저앉아 쉬는게 맞나 싶었다.   휴학을 하고 시간을 보내며 어떻게 살것인가에 대한 생각을 많이 했다. 첫번째는 어떻게 하면 행복하게 살수 있을까에 대한 생각. 두번째로는, 정확하게 난 무엇을 하며 살고 싶은가에 대한 생각.   난 어릴때부터 단순하게 돈이 많으면 행복할거라고 생각했고, 아마 많은 사람들도 그렇게 생각하고 있을 것이다.  일을 많이하고 돈을 많이 주는 직업과, 일은 적게 하는 대신에 돈을 적게 주는 직업이 있다면 당연히 전자를 골랐었다. 난 남들앞에서 돈쓰는것도 좋아하는 편이었고, 명품이나 자동차처럼 남들에게 보여주기 위한 제품들에 관심이 많아서, 그런 욕구가 좀 많았다. 개뿔도 없으면서…   하지만 휴학동안 많은걸 겪기도 하고, 여러 글들을 보면서 많은 생각이 바뀌었다.  우선 돈에서 오는 행복은 일정수준 이상부터는 그 행복량이 빠르게 줄어든다는 것.  돈은 생각만큼 그렇게 큰 행복을 가져다 주지않는다. 돈에서 오는 행복은 log의 그래프로 증가하는데,  내가 정말 돈이 부족해서 생활이 불편할 정도의 소득 수준이라면 그 생활의 불편함이 해소되는 과정에서는 돈에서 오는 행 복량이 클 수 있지만, 어느정도 소득 수준이상부터는 그 정도가 크게 감소하는데,  금액적으로는 약 8500만원의 연봉 이상부터는 행복도가 아주 미미하게 증가한다.   그리고 또, 4월 즈음에 비트코인으로 큰 돈을 벌어 보면서, 돈이 주는 행복이 아주 미미하다는 것, 특히 일확천금이 주는 행복은 아주 미미하다는걸 깨달았다. 많은 복권당첨자들과 도박중독자들이 왜 불행을 겪는지 몸소 체험하면서, 앞으로 내 인생에서 짧은기간안에 큰 리스크를 감당하며 돈을 버는 일은 절대로 금하기로 했다.   그래서 나는 내 인생에서 돈을 크게 우선순위로 두지 않도록 하기로 했다. 물론 꾸준한 투자는 당연히 할것이지만, 노동소 득이 자본소득보다 하위에 있다고 생각하지 않기로 했다. 집값이 천정부지로 뛰고, 옆에서는 너도 나도 코인과 주식, 부동 산으로 벼락부자가 되어가는걸 보면 항상 많은 유혹이 생기겠지만, 그게 내 인생을 잡아먹는다면 혹여나 그 운에 당첨되서 큰돈을 벌어도 더큰돈과 더 큰 운을 찾아 결국에는 불행에 다다를 것이다.   난 그래서 그냥 내가 하고싶은걸 열심히 하면서, 너무 일과 돈에 잡아먹히는 삶은 살고싶지 않게됐다.  옛날에는 워라밸거리는 사람들을 보며 배부른 소리한다고 했던적도 있었는데 내가 틀렸었다는 것을 깨달았다.  정말 상위 1프로를 지향하며 하루에 10시간이 넘게 일하며 성공을 원하는 사람들도 있겠지만, 그 인생이 행복할 확률은 크지 않다는 걸 알게 되었다.   그래서 다시 내가 뭘진짜 하고싶은지 생각해봤다.   난 어릴때부터 코딩을 너무너무 좋아했다. 근데 자꾸 클수록 단순한 프로그래머 말고 더 더 높은것, 멋진걸 하고 싶은 마음 에 허세만 잔뜩들어서 하고싶지도 않은 멋진 직업을 자꾸 꿈꿨고, 머신러닝이니 AI니 금융이니 하고 싶은지, 내가 잘할 수 있는지도 모르는 방향으로 공부를 했다. 결국 저 세가지를 공부하며 즐거웠던 이유는 코딩이었고,   나는 다시 프로그래머가 되고 싶어졌다.  이러한 반년의 휴학을 결산하여 이뤄낸 것들을 모아보자면,           명확한 목표가 생겼다.  이제 어떤 직업을 갖고 어떤 일을 하며 살고싶은지 정확하고 디테일한 목표가 생겼다.            돈에 대해서 많은 깨달음을 얻었다.  인생에 대한 방향이 돈이 아닌 행복이 되었다.            코딩실력이 늘었다.   머신러닝을 공부하고 최근에는 코딩테스트를 열심히 공부하여 코딩실력이 많이 늘었다.            공부의 습관화   휴학을 하고 공부방법에 대해서도 많이 고민하고 개선하면서, 어느정도 공부의 효율성이 많이 올라갔다.       그래서 남은 휴학기간의 목표는 아래 네가지이다.           영어 실력 향상  프로그래머로써 영어는 매우 중요하다. 인터넷에서 얻는 정보의 대부분은 영어로 되어있는데, 특히나 프로그래머로써의 원하는 정보들은 대다수가 영어이다.            프로그래머로써의 포트폴리오 채우기  내가 무엇을 공부하고, 어떤 방향성을 가졌는지 나 혼자 공부해서는 아무도 알아주지않는다. 꾸준히 블로그에 기록하고, 커밋하고 무언가를 남겨야 한다. 기억하지말고 기록해야 나의 기억을 다른 사람도 이해해준다.            투자를 통한 자산증가  단기간에 큰 수익률을 올리는 것에서 이제 손을 떼고, 연 수익률 딱 15퍼센트를 목표로 천천히 매매하는 것을 목표로 지속 가능한 투자를 하는것이 목표이다.            오프라인 개발자 모임 참여  혼자 방구석에서 공부해서는 수많은 길이 있는지도 모른채로 한길만 택해서 나아갈 뿐이다.  또, 포트폴리오로 나를 증명하는것 보다, 남이 나를 증명해주는것이 백배는 효과적이다. 내 실력을 알아줄 다른 사람들을 사귀어야 한다.       남은 6개월도 힘내서, 1년결산때는 좀더 의미있는 결과를 자신한테 보여줬으면 좋겠다.   사실 6개월 동안의 결산이라고 해봤자 그냥 마냥 하기만 할뿐 어디에도 기록하지 않아서 추상적인 결과가 전부인데, 이제 는 내 성과를 기록할 장치들을 많이 만들어 놓아서 12월이 끝나고 쓰는 결산에서는 확실한 기록들을 가져와 내가 6개월동 안 얼마나 성장했는지 수치적으로 알 수 있도록 명확하게 쓰도록 할 것 이다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%9C%B4%ED%95%99-%EB%B0%98%EB%85%84-%EA%B2%B0%EC%82%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 5585 거스름돈 (Python3)",
        "excerpt":"문제  타로는 자주 JOI잡화점에서 물건을 산다. JOI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 언제나 거스름돈 개수가 가장 적게 잔돈을 준다. 타로가 JOI잡화점에서 물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때, 받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성하시오.   입력  입력은 한줄로 이루어져있고, 타로가 지불할 돈(1 이상 1000미만의 정수) 1개가 쓰여져있다.   출력  제출할 출력 파일은 1행으로만 되어 있다. 잔돈에 포함된 매수를 출력하시오.   1 2 3 4 5 6 7 8 예제 입력 1  복사 380 예제 출력 1  복사 4 예제 입력 2  복사 1 예제 출력 2  복사 15   1 2 3 4 5 6 7 8 9 10 11 12 price = int(input())  change = 1000 - price  a = change//500 b = change%500//100 c = change%500%100//50 d = change%500%100%50//10 e = change%500%100%50%10//5 f = change%500%100%50%10%5//1  print(sum([a,b,c,d,e,f]))   1 2 380 4   1   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EA%B1%B0%EC%8A%A4%EB%A6%84%EB%8F%88/",
        "teaser": null
      },{
        "title": "[BOJ] 2217 로프 (Python3)",
        "excerpt":"문제  N(1 ≤ N ≤ 100,000)개의 로프가 있다. 이 로프를 이용하여 이런 저런 물체를 들어올릴 수 있다. 각각의 로프는 그 굵기나 길이가 다르기 때문에 들 수 있는 물체의 중량이 서로 다를 수도 있다.   하지만 여러 개의 로프를 병렬로 연결하면 각각의 로프에 걸리는 중량을 나눌 수 있다. k개의 로프를 사용하여 중량이 w인 물체를 들어올릴 때, 각각의 로프에는 모두 고르게 w/k 만큼의 중량이 걸리게 된다.   각 로프들에 대한 정보가 주어졌을 때, 이 로프들을 이용하여 들어올릴 수 있는 물체의 최대 중량을 구해내는 프로그램을 작성하시오. 모든 로프를 사용해야 할 필요는 없으며, 임의로 몇 개의 로프를 골라서 사용해도 된다.   입력  첫째 줄에 정수 N이 주어진다. 다음 N개의 줄에는 각 로프가 버틸 수 있는 최대 중량이 주어진다. 이 값은 10,000을 넘지 않는 자연수이다.   출력  첫째 줄에 답을 출력한다.   1 2 3 4 5 6 예제 입력 1  복사 2 10 15 예제 출력 1  복사 20   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 N = int(input()) #로프의 개수 weight = [] for i in range(N):     weight.append(int(input())) #weight 리스트에 로프의 중량을 넣어준다.      weight.sort() #오름차순으로 정렬  time = N  for i in range(N):     weight.append(weight[i]*time) #리스트의 첫요소보다 큰 요소의 개수만큼 곱해     time-=1 print(max(weight))   1 2 3 4 5 6 4 20 30 40 50 90   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%A1%9C%ED%94%84/",
        "teaser": null
      },{
        "title": "[BOJ] 1449 수리공 항승 (Python3)",
        "excerpt":"문제  항승이는 품질이 심각하게 나쁜 수도 파이프 회사의 수리공이다. 항승이는 세준 지하철 공사에서 물이 샌다는 소식을 듣고 수리를 하러 갔다.   파이프에서 물이 새는 곳은 신기하게도 가장 왼쪽에서 정수만큼 떨어진 거리만 물이 샌다.   항승이는 길이가 L인 테이프를 무한개 가지고 있다.   항승이는 테이프를 이용해서 물을 막으려고 한다. 항승이는 항상 물을 막을 때, 적어도 그 위치의 좌우 0.5만큼 간격을 줘야 물이 다시는 안 샌다고 생각한다.   물이 새는 곳의 위치와, 항승이가 가지고 있는 테이프의 길이 L이 주어졌을 때, 항승이가 필요한 테이프의 최소 개수를 구하는 프로그램을 작성하시오. 테이프를 자를 수 없고, 테이프를 겹쳐서 붙이는 것도 가능하다.   입력  첫째 줄에 물이 새는 곳의 개수 N과 테이프의 길이 L이 주어진다. 둘째 줄에는 물이 새는 곳의 위치가 주어진다. N과 L은 1,000보다 작거나 같은 자연수이고, 물이 새는 곳의 위치는 1,000보다 작거나 같은 자연수이다.   출력  첫째 줄에 항승이가 필요한 테이프의 개수를 출력한다.   1 2 3 4 5 예제 입력 1  복사 4 2 1 2 100 101 예제 출력 1  복사 2   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 N, L = map(int, input().split()) # N: 물이새는 곳의 개수, L: 테이프의 길이  hole = list(map(int, input().split()))  hole.sort()  hole_strt = hole[0] tape = 1  for i in range(1, N):     if hole_strt + (L-1) &gt;= hole[i]:         continue      tape += 1     hole_strt = hole[i] print(tape)   1 2 3 4 2 1 2 3 4 2   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%88%98%EB%A6%AC%EA%B3%B5-%ED%95%AD%EC%8A%B9/",
        "teaser": null
      },{
        "title": "[BOJ] 14487 욱제는 도박쟁이야!! (Python3)",
        "excerpt":"문제  욱제는 라스베이거스에서 유명한 베팅꾼이다. 어찌나 게임을 잘 하는지 ‘제2의 홍진호’라는 별명이 붙었을 정도다. 어찌나 게임을 잘 하는지 ‘제2의 홍진호’라는 별명이 붙었을 정도다.   욱제가 주로 하는 게임은 아주 단순하고, 친숙한 게임이다. 바로 동전 뒤집기 게임이다. 이 게임에 쓰이는 동전의 양면에는 절댓값이 같고 부호가 다른 정수가 한 면에 하나씩 쓰여 있다. (단, 동전끼리는 쓰인 숫자의 절댓값이 다를 수 있다) 한 플레이어 당 두 번의 라운드가 주어진다. 모든 라운드는 같은 동전으로 진행되며, 딜러는 각 라운드마다 N개의 동전을 임의로 섞고 이를 일렬로 배열한다. 이때, 동전의 앞뒤 방향도 바뀔 수 있다. 첫 번째 라운드에서는 동전에 표시된 값들의 합이 최대가 되도록 뒤집어야 하고, 두 번째 라운드에서는 동전에 표시된 값들의 합이 최소가 되도록 뒤집어야 한다. (첫 번째 라운드 동전 값의 합) - (두 번째 라운드 동전 값의 합)이 해당 플레이어가 게임에서 획득한 점수이고, 이 점수가 최대가 되는 플레이어가 바로 게임의 승자가 된다.   욱제는 엄지, 검지, 중지를 이용해서 항상 연속한 3개의 동전을 뒤집는 최고의 동전 뒤집러이다. 욱제는 연속한 3개의 동전을 뒤집지 않으면 이길 수 없다고 생각하기 때문에 실패하는 경우 없이 항상 연속한 3개의 동전만 뒤집는다. 동전 배열의 양 끝에서 벗어나서 양 끝의 동전만 뒤집거나 양 끝의 두 개 동전만 뒤집는 것도 가능하다. 동전을 뒤집는 횟수에 제한은 없다.   (!) 너, 강해 보이는군. 나와 승부를 겨루자! 띠리링띠리링디리ㅣ리리ㅣ링~ 앗! 심술쟁이 해커 임준오(동탄 주민)이 승부를 걸어왔다!   욱제는 이번 게임에서 얼마의 점수를 획득하게 될까? 욱제는 최고의 베팅꾼이기 때문에 항상 게임에서 획득할 수 있는 최고의 점수를 얻는다는 사실은 자명하다.   입력  첫째 줄에 동전의 수 N이 주어진다. (1 &lt;= N &lt;= 10,000) 둘째 줄에 욱제의 첫 번째 라운드의 N개 동전의 배열이 주어진다. 셋째 줄에 욱제의 두 번째 라운드의 N개 동전의 배열이 주어진다. 동전에 적히는 숫자는 절댓값 10,000 이하의 정수이다.   출력  욱제가 이번 게임에서 획득할 점수를 출력한다.   1 2 3 4 5 6 예제 입력 1  복사 6 5 -2 -7 -8 9 1 -9 1 8 -7 5 2 예제 출력 1  복사 64  힌트  첫 번째 라운드에서 –2, -7, -8을 뒤집으면 동전 값의 합을 최대로 만들 수 있다.   두 번째 라운드에서 1, 8, -7을 뒤집고 7, 5, 2를 뒤집으면 동전 값의 합을 최소로 만들 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 N = int(input()) round_1 = list(map(int, input().split())) round_2 = list(map(int, input().split())) result = 0 for i in range(N):     result += abs(round_1[i])     result += abs(round_2[i]) print(result)     1 2 3 4 6 5 -2 -7 -8 9 1 -9 1 8 -7 5 2 64   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%9A%B1%EC%A0%9C%EB%8A%94-%EB%8F%84%EB%B0%95%EC%9F%81%EC%9D%B4%EC%95%BC!!/",
        "teaser": null
      },{
        "title": "[BOJ] 10162 전자레인지 (Python3)",
        "excerpt":"문제  3개의 시간조절용 버튼 A B C가 달린 전자레인지가 있다. 각 버튼마다 일정한 시간이 지정되어 있어 해당 버튼을 한번 누를 때마다 그 시간이 동작시간에 더해진다. 버튼 A, B, C에 지정된 시간은 각각 5분, 1분, 10초이다.   냉동음식마다 전자레인지로 요리해야할 시간 T가 초단위로 표시되어 있다. 우리는 A, B, C 3개의 버튼을 적절히 눌러서 그 시간의 합이 정확히 T초가 되도록 해야 한다. 단 버튼 A, B, C를 누른 횟수의 합은 항상 최소가 되어야 한다. 이것을 최소버튼 조작이라고 한다.   만일 요리시간이 100초라고 하면(T=100) B를 1번, C는 4번 누르면 된다. 이와 다르게 C를 10번 눌러도 100초가 되지만 이 경우 10번은 최소 횟수가 아니기 때문이 답이 될 수 없다. 이 경우 B 1번, C 4번, 총 5번이 최소버튼 조작이다. 그리고 T=234와 같이 3개의 버튼으로 시간을 정확히 맞출 수 없는 경우도 있다.   여러분은 주어진 요리시간 T초를 맞추기 위한 최소버튼 조작 방법을 구하는 프로그램을 작성해야 한다.   입력  첫 번째 줄에는 요리시간 T(초)가 정수로 주어져 있으며 그 범위는 1 ≤ T ≤ 10,000 이다.   출력  여러분은 T초를 위한 최소버튼 조작의 A B C 횟수를 첫 줄에 차례대로 출력해야 한다. 각각의 횟수 사이에는 빈 칸을 둔다. 해당 버튼을 누르지 않는 경우에는 숫자 0을 출력해야한다. 만일 제시된 3개의 버튼으로 T초를 맞출 수 없으면 음수 -1을 첫 줄에 출력해야 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 서브태스크 번호\t배점\t제한 1\t30\t T ≤ 60 2\t30\t T ≤ 300 3\t40\t T ≤ 10,000 예제 입력 1  복사 100 예제 출력 1  복사 0 1 4 예제 입력 2  복사 189 예제 출력 2  복사 -1   1 2 3 4 5 6 7 8 9 10 11 T = int(input())  if T%10 != 0:     print(-1) else:     A = T//300     B = T%300//60     C = T%300%60//10     print(A,B,C)     1 2 100 0 1 4   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%A0%84%EC%9E%90%EB%A0%88%EC%9D%B8%EC%A7%80/",
        "teaser": null
      },{
        "title": "[BOJ] 17208 카우버거 (Python3)",
        "excerpt":"문제  윤진이는 이번에 카우버거 알바생으로 뽑히게 되었다. 그녀는 카우버거를 평소에 이용하면서 들었던 의문점 한가지가 있었다.   “카우버거에는 왜 세트 메뉴에 대한 할인이 존재하지 않는가?”  따라서 윤진이의 아이디어로 카우버거에 세트 할인을 도입하고자 한다. 세트 메뉴는 버거 1개, 사이드 메뉴 1개, 음료 1개를 선택 할 경우 각각의 제품에 대해서 10%의 세트 할인을 적용하는 방식으로 진행된다.   하지만 카우버거 점주는 POS기의 소프트웨어가 오래되어 세트 할인에 대한 내용을 추가할 수가 없었다. 따라서 소프트웨어학부에 재학 중인 윤진이는 전공을 살려 직접 프로그램을 만들어보려고 한다. 윤진이를 도와 POS기에 들어갈 세트 할인에 대한 프로그램을 작성해보자.   입력  첫째 줄에는 주문한 버거의 개수 B, 사이드 메뉴의 개수 C, 음료의 개수 D가 공백을 사이에 두고 순서대로 주어진다. (1 ≤ B, C, D ≤ 1,000)   둘째 줄에는 각 버거의 가격이 공백을 사이에 두고 주어진다.   셋째 줄에는 각 사이드 메뉴의 가격이 공백을 사이에 두고 주어진다.   넷째 줄에는 각 음료의 가격이 공백을 사이에 두고 주어진다.   각 메뉴의 가격은 100의 배수이며, 10000원을 넘지 않는다.   출력  첫째 줄에는 세트 할인이 적용되기 전 가격을 출력한다.   둘째 줄에는 세트 할인이 적용된 후의 최소 가격을 출력한다.   예제 입력 1  복사  3 3 2  2000 3000 2500  800 1300 1000  500 1000  예제 출력 1  복사  12100  11170   힌트  입력 예에 나온 메뉴들의 가격을 모두 합하면 12100원이다.   첫 번째 세트는 3000원짜리 버거, 1300원짜리 사이드메뉴, 1000원짜리 음료로 구성하면 5300 * 0.9 = 4770원이다.   두 번째 세트는 2500원짜리 버거, 1000원짜리 사이드메뉴, 500원짜리 음료로 구성하면 4000 * 0.9 = 3600원이다.   남은 2000원짜리 버거와 800원짜리 사이드메뉴는 음료가 없으므로 세트 할인을 받을 수 없다. 따라서 세트 할인이 적용된 후의 최소 가격은 4770+3600+2800 = 11170원이 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 B, C, D = map(int, input().split())  #B: 버거의 개수, C : 사이드메뉴의 개수, D : 음료의 개수  B_list = list(map(int, input().split()))  C_list = list(map(int, input().split()))  D_list = list(map(int, input().split()))  B_list.sort(reverse= True) C_list.sort(reverse= True) D_list.sort(reverse= True)  set_num = min(B,C,D)       print(sum([sum(B_list), sum(C_list), sum(D_list)])) for i in range(set_num):     B_list[i] = B_list[i]*90/100     C_list[i] = C_list[i]*90/100     D_list[i] = D_list[i]*90/100      print(int(sum([sum(B_list), sum(C_list), sum(D_list)])))    1 2 3 4 5 6 3 3 3 2500 2000 2000 3000 3000 2500 800 200 300 16300 14670   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%B9%B4%EC%9A%B0%EB%B2%84%EA%B1%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 11034 캥거루 세마리2 (Python3)",
        "excerpt":"문제  캥거루 세 마리가 사막에서 놀고 있다. 사막에는 수직선이 하나 있고, 캥거루는 서로 다른 한 좌표 위에 있다.   한 번 움직일 때, 바깥쪽의 두 캥거루 중 한 마리가 다른 두 캥거루 사이의 정수 좌표로 점프한다. 한 좌표 위에 있는 캥거루가 두 마리 이상일 수는 없다.   캥거루는 최대 몇 번 움직일 수 있을까?   입력  여러개의 테스트 케이스로 이루어져 있으며, 세 캥거루의 초기 위치 A, B, C가 주어진다. (0 &lt; A &lt; B &lt; C &lt; 100)   출력  각 테스트에 대해 캥거루가 최대 몇 번 움직일 수 있는지 출력한다.  1 2 3 4 5 6 예제 입력 1   2 3 5 3 5 9 예제 출력 1   1 3   코드   1 2 3 4 5 6 while 1:     try:         A, B, C = map(int, input().split())#캥거루의 좌표 A,B,C를 입력받는다.  ##왼쪽캥거루가 뛰는 경우, 오른쪽 캥거루가 뛰는경우         print(max(C-B, B-A)-1)     except:         break   1 2 3 2 3 5 1 1 2   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%BA%A5%EA%B1%B0%EB%A3%A8-%EC%84%B8%EB%A7%88%EB%A6%AC-2/",
        "teaser": null
      },{
        "title": "[BOJ] 2810 컵홀더 (Python3)",
        "excerpt":"문제  십년이면 강산이 변한다.   강산이네 동네에 드디어 극장이 생겼고, 강산이는 극장에 놀러갔다. 매점에서 콜라를 산 뒤, 자리에 앉은 강산이는 큰 혼란에 빠졌다. 양쪽 컵홀더를 이미 옆 사람들이 차지했기 때문에 콜라를 꽂을 컵 홀더가 없었기 때문이다. 영화를 보는 내내 콜라를 손에 들고 있던 강산이는 극장에 다시 왔을 때는 꼭 콜라를 컵 홀더에 놓겠다는 다짐을 한 후 집에 돌아갔다.   극장의 한 줄에는 자리가 N개가 있다. 서로 인접한 좌석 사이에는 컵홀더가 하나씩 있고, 양 끝 좌석에는 컵홀더가 하나씩 더 있다. 또, 이 극장에는 커플석이 있다. 커플석 사이에는 컵홀더가 없다.   극장의 한 줄의 정보가 주어진다. 이때, 이 줄에 사람들이 모두 앉았을 때, 컵홀더에 컵을 꽂을 수 있는 최대 사람의 수를 구하는 프로그램을 작성하시오. 모든 사람은 컵을 한 개만 들고 있고, 자신의 좌석의 양 옆에 있는 컵홀더에만 컵을 꽂을 수 있다.   S는 일반 좌석, L은 커플석을 의미하며, L은 항상 두개씩 쌍으로 주어진다.   어떤 좌석의 배치가 SLLLLSSLL일때, 컵홀더를 *로 표시하면 아래와 같다.   SLLLLSSLL*  위의 예에서 적어도 두 명은 컵홀더를 사용할 수 없다.   입력  첫째 줄에 좌석의 수 N이 주어진다. (1 ≤ N ≤ 50) 둘째 줄에는 좌석의 정보가 주어진다.   출력  컵을 컵홀더에 놓을 수 있는 최대 사람의 수를 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 예제 입력 1  복사 3 SSS 예제 출력 1  복사 3 예제 입력 2  복사 4 SLLS 예제 출력 2  복사 4 예제 입력 3  복사 9 SLLLLSSLL 예제 출력 3  복사 7   코드   1 2 3 4 5 6 7 8 9 N = int(input()) #좌석의 수 N을 입력으로 받는다. S = input() #좌석의 정보 S를 입력으로 받는다. people = len(S) holder = len(S.replace('LL', 'S'))+1 if people &lt; holder:     print(people) else:     print(holder)    1 2 3 9 SLLLLSSLL 6   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%BB%B5%ED%99%80%EB%8D%94/",
        "teaser": null
      },{
        "title": "[BOJ] 14659 한조 서열 정리하고옴 ㅋㅋ(Python3)",
        "excerpt":"문제  “반갑다. 내 이름은 반고흐#31555! 조선 최고의 활잡이지. 오늘도 난 금강산 위에서 적들을 노리고 있지. 내 앞에 있는 적들이라면 누구도 놓치지 않아! 좋아, 이제 곧 월식이 시작되는군. 월식이 시작되면 용이 적들을 집어삼킬 것이다. 잘 봐두어라! 마장동 활잡이 반고흐#31555님의 실력을-!”   반고흐#31555는 자기 뒤쪽 봉우리에 덩기#3958이 있음을 전혀 모르고 있었다. 덩기#3958도 반고흐#31555와 마찬가지로 월식이 시작되면 용을 불러내어 눈앞에 있는 다른 활잡이들을 모두 처치할 생각이다. 사실, 반고흐#31555와 덩기#3958 뿐만 아니라 금강 산맥의 N개 봉우리에 있는 모든 활잡이들이 같은 생각을 가지고 있다.   반고흐#31555가 있는 금강 산맥에는 총 N개의 봉우리가 있고, 모든 봉우리마다 한 명의 활잡이가 서서 월식이 시작되기만을 기다리고 있다. 다만, 애석하게도, 천계에 맥도날드가 생겨 용들이 살이 찐 탓에 용들은 자신보다 낮은 봉우리에 서있는 적들만 처치할 수 있게 되었다. 또한 용들은 처음 출발한 봉우리보다 높은 봉우리를 만나면 그대로 공격을 포기하고 금강산자락에 드러누워 낮잠을 청한다고 한다. 봉우리의 높이는 모두 다르고 모든 용들은 오른쪽으로만 나아가며, 중간에 방향을 틀거나, 봉우리가 무너지거나 솟아나는 경우는 없다.   “달에 마구니가 끼었구나.”   드디어 월식이 시작됐다! 과연 이들 활잡이 중 최고의 활잡이는 누구일까? 최고의 활잡이가 최대 몇 명의 적을 처치할 수 있는지 알아보자.   입력  첫째 줄에 봉우리의 수 겸 활잡이의 수 N이 주어진다. (1 ≤ N ≤ 30,000) 둘째 줄에 N개 봉우리의 높이가 왼쪽 봉우리부터 순서대로 주어진다. (1 ≤ 높이 ≤ 100,000) 각각 봉우리의 높이는 중복 없이 유일하다.   출력  최고의 활잡이가 처치할 수 있는 적의 최대 숫자를 출력한다.   1 2 3 4 5 6 7 예제 입력 1   7 6 4 10 2 5 7 11 예제 출력 1   3 힌트 높이 10 봉우리에 있는 활잡이가 높이 2, 5, 7 봉우리에 있는 활잡이들을 처치할 수 있다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 N = int(input()) #봉우리, 활잡이의 수 N bow = list(map(int, input().split())) #봉우리의 높이를 받아 리스트로 저장한다.  max_num = bow[0] #최댓값에 첫번째 값을 넣음  kill = 0 result = []  for i in range(1, N): #반복하며 bow의 인자가 최댓값보다 작을때만 kill을 카운트하여               if max_num &gt; bow[i]:         kill+= 1         result.append(kill)               else:         result.append(kill)         kill = 0         max_num = bow[i]  print(max(result))                                       1 2 3 4 5 6 7 7 6 4 10 2 5 7 11 [1] [1, 1, 1] [1, 1, 1, 2] [1, 1, 1, 2, 3] 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%ED%95%9C%EC%A1%B0-%EC%84%9C%EC%97%B4%EC%A0%95%EB%A6%AC%ED%95%98%EA%B3%A0%EC%98%B4-%E1%84%8F%E1%84%8F/",
        "teaser": null
      },{
        "title": "[BOJ] 1339 단어 수학 (Python3)",
        "excerpt":"문제  민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.   단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.   예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.   N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.   입력  첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.   출력  첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 예제 입력 1  복사 2 AAA AAA 예제 출력 1  복사 1998 예제 입력 2  복사 2 GCF ACDEB 예제 출력 2  복사 99437 예제 입력 3  복사 10 A B C D E F G H I J 예제 출력 3  복사 45 예제 입력 4  복사 2 AB BA 예제 출력 4  복사 187   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from collections import defaultdict N = int(input()) #단어의 개수 N  word = []  for i in range(N):     word.append(input())  word.sort(reverse= True, key = lambda x: len(x))  num = [] result = [] dic = defaultdict() n = 9  # 알파벳을 키값으로 알파벳의 자릿수에 맞는 10의 배수를 딕셔너리에 저장해준다. for alpha in word:      k = len(alpha)-1          for i in range(len(alpha)):         #딕셔너리에 이미 있으면 밸류에 자릿수를 더해준다.         if alpha[i] in dic:             dic[alpha[i]]+= pow(10, k)         else:             dic[alpha[i]]= pow(10, k)         k-=1  #딕셔너리의 밸류만을 값으로 갖는 리스트 num을 만들어준다. for value in dic.values():     num.append(value)  # 내림차순 정렬 num.sort(reverse= True)  #큰수부터 9-0을 곱해준다. t = 9 for i in range(len(num)):     num[i] = num[i]*t     t-=1           print(sum(num))         1 2 3 4 2 AAA AAA 1998   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%8B%A8%EC%96%B4-%EC%88%98%ED%95%99/",
        "teaser": null
      },{
        "title": "[BOJ] 11047 동전 0 (Python3)",
        "excerpt":"문제  준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.      동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)   둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)   출력  첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 예제 입력 1  복사 10 4200 1 5 10 50 100 500 1000 5000 10000 50000 예제 출력 1  복사 6 예제 입력 2  복사 10 4790 1 5 10 50 100 500 1000 5000 10000 50000 예제 출력 2  복사 12   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 N, K = map(int, input().split())  coin = []  for i in range(N):     coin.append(int(input()))   ans = 0 money = K i = len(coin)-1 while money:     c = coin[i]      if c &lt;= money:         ans += money//c         money = money%c         i-=1     else:         i-=1  print(ans)                  1 2 3 4 5 6 7 8 9 10 11 12 10 4790 1 5 10 50 100 500 1000 5000 10000 50000 12   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%8F%99%EC%A0%84-0/",
        "teaser": null
      },{
        "title": "[BOJ] 1052 물병 (Python3)",
        "excerpt":"문제  지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, K개를 넘지 않는 비어있지 않은 물병을 만들려고 한다.   물은 다음과 같이 재분배 한다.   먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.  이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.   예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.   입력  첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.   출력  첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.   1 2 3 4 예제 입력 1  복사 3 1 예제 출력 1  복사 1   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 N, K = map(int, input().split()) #물병의 개수 N, 지민이가 한번에 옮길 수 있는 물병의 개수 K   def check(num): #최대로 합칠 수 있는 물병의 개수를 반환하는 함수     ans = 0     while (1):          a = num//2 #하나로 합친 물병의 수 a         b = num%2 # 합치지 못합 물병의 수 b         num = a          ans+=b         if num == 0:             break     return ans  if K &gt;= N:     print(0)      else:     i = N     while (1):         if check(i) &lt;= K:             print(i-N)             break         else:             i+=1                                        1 2 5 1 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EB%AC%BC%EB%B3%91/",
        "teaser": null
      },{
        "title": "[BOJ] 2473 되었을까? (Python3)",
        "excerpt":"문제  하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 한다. 이 저울의 양 팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있다.   무게가 양의 정수인 N개의 저울추가 주어질 때, 이 추들을 사용하여 측정할 수 없는 양의 정수 무게 중 최솟값을 구하는 프로그램을 작성하시오.   예를 들어, 무게가 각각 3, 1, 6, 2, 7, 30, 1인 7개의 저울추가 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21이다.   입력  첫 째 줄에는 저울추의 개수를 나타내는 양의 정수 N이 주어진다. N은 1 이상 1,000 이하이다. 둘째 줄에는 저울추의 무게를 나타내는 N개의 양의 정수가 빈칸을 사이에 두고 주어진다. 각 추의 무게는 1이상 1,000,000 이하이다.   출력  첫째 줄에 주어진 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 출력한다.   1 2 3 4 5 예제 입력 1  복사 7 3 1 6 2 7 30 1 예제 출력 1  복사 21   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #무게추의 개수 N N = int(input())  #무게추들의 값을 공백을 기준으로 나눈 값으로 받아 리스트로 저장한다. weights = list(map(int, input().split()))  #리스트 정렬 weights.sort()  target = 1  for i in weights:     if target &lt; i:         break     target+= i print(target)      1 2 3 4 5 6 7 8 7 3 1 6 2 7 30 1 2 3 5 8 14 21   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%A0%80%EC%9A%B8/",
        "teaser": null
      },{
        "title": "[BOJ] 1715 카드 정렬하기 (Python3)",
        "excerpt":"문제  정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.   매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.   N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.   출력  첫째 줄에 최소 비교 횟수를 출력한다.   1 2 3 4 5 6 7 예제 입력 1   3 10 20 40 예제 출력 1   100   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import heapq  #카드 묶음의 개수 N N = int(input())   queue = []  #큐에 인풋값들을 힙 푸쉬해준다. for i in range(N):     heapq.heappush(queue, int(input()))  result = 0 #큐의 값들을 앞에서부터 작은순으로 더해서 다시 힙큐에 푸쉬해준다. while len(queue) &gt; 1:     sum_value = 0     for _ in range(2):         sum_value += heapq.heappop(queue)     result+= sum_value     heapq.heappush(queue, sum_value) print(result)             1 2 3 4 5 3 10 20 40 100   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%B9%B4%EB%93%9C-%EC%A0%95%EB%A0%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 15903 카드 합체 놀이 (Python3)",
        "excerpt":"문제  석환이는 아기다. 아기 석환이는 자연수가 쓰여져있는 카드를 갖고 다양한 놀이를 하며 노는 것을 좋아한다. 오늘 아기 석환이는 무슨 놀이를 하고 있을까? 바로 카드 합체 놀이이다!   아기 석환이는 자연수가 쓰여진 카드를 n장 갖고 있다. 처음에 i번 카드엔 ai가 쓰여있다. 카드 합체 놀이는 이 카드들을 합체하며 노는 놀이이다. 카드 합체는 다음과 같은 과정으로 이루어진다.   x번 카드와 y번 카드를 골라 그 두 장에 쓰여진 수를 더한 값을 계산한다. (x ≠ y)  계산한 값을 x번 카드와 y번 카드 두 장 모두에 덮어 쓴다.  이 카드 합체를 총 m번 하면 놀이가 끝난다. m번의 합체를 모두 끝낸 뒤, n장의 카드에 쓰여있는 수를 모두 더한 값이 이 놀이의 점수가 된다. 이 점수를 가장 작게 만드는 것이 놀이의 목표이다.   아기 석환이는 수학을 좋아하긴 하지만, 아직 아기이기 때문에 점수를 얼마나 작게 만들 수 있는지를 알 수는 없었다(어른 석환이는 당연히 쉽게 알 수 있다). 그래서 문제 해결 능력이 뛰어난 여러분에게 도움을 요청했다. 만들 수 있는 가장 작은 점수를 계산하는 프로그램을 만들어보자.   입력  첫 번째 줄에 카드의 개수를 나타내는 수 n(2 ≤ n ≤ 1,000)과 카드 합체를 몇 번 하는지를 나타내는 수 m(0 ≤ m ≤ 15×n)이 주어진다.   두 번째 줄에 맨 처음 카드의 상태를 나타내는 n개의 자연수 a1, a2, …, an이 공백으로 구분되어 주어진다. (1 ≤ ai ≤ 1,000,000)   출력  첫 번째 줄에 만들 수 있는 가장 작은 점수를 출력한다.   1 2 3 4 5 6 7 8 9 10 예제 입력 1  복사 3 1 3 2 6 예제 출력 1  복사 16 예제 입력 2  복사 4 2 4 2 3 1 예제 출력 2  복사 19   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 n, m = map(int, input().split()) # n: 카드의 개수, m: 합체 수  a = list(map(int, input().split())) # 카드의 숫자를 리스트에 넣어준다.  a.sort()  for i in range(m):     a.sort()     a[0] = a[1] = a[0]+a[1] print(sum(a))       1 2 3 4 2 4 2 3 1 19   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%EC%B9%B4%EB%93%9C-%ED%95%A9%EC%B2%B4-%EB%86%80%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[BOJ] 16173 점프왕 쩰리(small) (Python3)",
        "excerpt":"문제  ‘쩰리’는 점프하는 것을 좋아하는 젤리다. 단순히 점프하는 것에 지루함을 느낀 ‘쩰리’는 새로운 점프 게임을 해보고 싶어 한다. 새로운 점프 게임의 조건은 다음과 같다.   ‘쩰리’는 가로와 세로의 칸 수가 같은 정사각형의 구역 내부에서만 움직일 수 있다. ‘쩰리’가 정사각형 구역의 외부로 나가는 경우엔 바닥으로 떨어져 즉시 게임에서 패배하게 된다.  ‘쩰리’의 출발점은 항상 정사각형의 가장 왼쪽, 가장 위의 칸이다. 다른 출발점에서는 출발하지 않는다.  ‘쩰리’가 이동 가능한 방향은 오른쪽과 아래 뿐이다. 위쪽과 왼쪽으로는 이동할 수 없다.  ‘쩰리’가 가장 오른쪽, 가장 아래 칸에 도달하는 순간, 그 즉시 ‘쩰리’의 승리로 게임은 종료된다.  ‘쩰리’가 한 번에 이동할 수 있는 칸의 수는, 현재 밟고 있는 칸에 쓰여 있는 수 만큼이다. 칸에 쓰여 있는 수 초과나 그 미만으로 이동할 수 없다.  새로운 게임이 맘에 든 ‘쩰리’는, 계속 게임을 진행해 마침내 최종 단계에 도달했다. 하지만, 게임을 진행하는 구역이 너무 넓어져버린 나머지, 이 게임에서 이길 수 있는지 없는지 가늠할 수 없어졌다. ‘쩰리’는 유능한 프로그래머인 당신에게 주어진 구역에서 승리할 수 있는 지 알아봐 달라고 부탁했다. ‘쩰리’를 도와 주어진 게임 구역에서 끝 점(오른쪽 맨 아래 칸)까지 도달할 수 있는지를 알아보자!   입력  입력의 첫 번째 줄에는 게임 구역의 크기 N (2 ≤ N ≤ 3)이 주어진다.   입력의 두 번째 줄부터 마지막 줄까지 게임판의 구역(맵)이 주어진다.   게임판의 승리 지점(오른쪽 맨 아래 칸)에는 -1이 쓰여있고, 나머지 칸에는 0 이상 100 이하의 정수가 쓰여있다.   출력  ‘쩰리’가 끝 점에 도달할 수 있으면 “HaruHaru”(인용부호 없이), 도달할 수 없으면 “Hing” (인용부호 없이)을 한 줄에 출력합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 예제 입력 1   3 1 1 10 1 5 1 2 2 -1  예제 출력 1   HaruHaru 쩰리는 맨 왼쪽 위의 칸에서 출발해 (행, 열)로 나타낸 좌표계로,  (1, 1) -&gt; (2, 1) -&gt; (3, 1) -&gt; (3, 3)으로 이동해 게임에서 승리할 수 있다.  예제 입력 2   3 2 2 1 2 2 2 1 2 -1  예제 출력 2   Hing 쩰리는 맨 왼쪽 위의 칸에서 출발하더라도 절대 게임의 승리 지점인 (3, 3)에 도달할 수 없다.   풀이   이 문제는 dfs를 사용하여 풀이하는 문제이다.  visited를 따로 만들어주어 방문을 확인하면서 큐에 넣어가며 탐색을 하고,  맵의 좌표에 적혀있는 숫자만큼 전진하여야 되므로 따로 step이라는 변수에 좌표의 숫자를 저장하여 그 숫자만큼 이동하여 탐색하도록 해주면 간단하게 풀 수 있다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from collections import deque  n = int(input())  maps = [list(map(int, input().split())) for _ in range(n)]    dx = [-1,1,0,0] dy = [0,0,-1,1]   def bfs(sx : int, sy : int)-&gt;bool:     q = deque()     q.append([sx,sy])          visited = [[False]*3 for _ in range(n)]          while q:         x,y = q.popleft()         step = maps[x][y]                  if maps[x][y] == -1:             return True         for dir in range(4):             nx, ny = x+dx[dir]*step, y+dy[dir]*step             if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n:                 if not visited[nx][ny]:                     visited[nx][ny] = True                     q.append([nx,ny])   if bfs(0,0):     print('HaruHaru') else:     print('Hing')          1 2 3 4 5 3  1 1 10 1 5 1 2 2 -1 Hing   ","categories": ["baekjoon"],
        "tags": ["코딩테스트","백준","파이썬"],
        "url": "/baekjoon/BOJ-16173-%EC%A0%90%ED%94%84%EC%99%95-%EC%A9%B0%EB%A6%AC(small)-Python-%EB%B3%B5%EC%82%AC%EB%B3%B8/",
        "teaser": null
      },{
        "title": "[Programmers] 회문 (Python3)",
        "excerpt":"문제  회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.   여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다.   입력   입력의 첫 줄에는 주어지는 문자열의 개수를 나타내는 정수 T(1 ≤ T ≤ 30)가 주어진다. 다음 줄부터 T개의 줄에 걸쳐 한 줄에 하나의 문자열이 입력으로 주어진다. 주어지는 문자열의 길이는 3 이상 100,000 이하이고, 영문 알파벳 소문자로만 이루어져 있다.   출력   각 문자열이 회문인지, 유사 회문인지, 둘 모두 해당되지 않는지를 판단하여 회문이면 0, 유사 회문이면 1, 둘 모두 아니면 2를 순서대로 한 줄에 하나씩 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 예제 입력 1   7 abba summuus xabba xabbay comcom comwwmoc comwwtmoc 예제 출력 1   0 1 1 2 2 0 1   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def inner_palindrome(word, left, right):     while left &lt; right:         if word[left] == word[right]:             left += 1             right -=1         else:             return False                  return True    def is_palindrome(word, left, right):     while left &lt; right:         if word[left] == word[right]:             left += 1             right -=1         else:             if inner_palindrome(word, left+1, right) or inner_palindrome(word, left, right-1):                 return 1             else:                 return 2                  return 0     #회문을 판별하다가 서로 다른 문자가 있으면 유사회문인지 회문이 아닌지 판별하는 함수를 재귀함수를 사용하여 정의  T = int(input()) #문자열의 개수 T  string = [] for i in range(T):     string.append(input()) # T의 개수만큼 받아 리스트로 저장  answer = [] for word in string:     left = 0     right = len(word)-1     answer.append(is_palindrome(word, left, right)) # is_palindrome 함수를 사용하여 순서대로 회문인지 판별  for i in range(len(answer)):     print(answer[i])   1 2 3 1 summuus 1   ","categories": ["programmers"],
        "tags": ["코딩테스트","Programmers","파이썬"],
        "url": "/programmers/Programmers-%ED%9A%8C%EB%AC%B8/",
        "teaser": null
      },{
        "title": " [BOJ] 1012 유기농배추 (Python3)",
        "excerpt":"문제  차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.   한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.  1 2 3 4 5 6 1\t1\t0\t0\t0\t0\t0\t0\t0\t0 0\t1\t0\t0\t0\t0\t0\t0\t0\t0 0\t0\t0\t0\t1\t0\t0\t0\t0\t0 0\t0\t0\t0\t1\t0\t0\t0\t0\t0 0\t0\t1\t1\t0\t0\t0\t1\t1\t1 0\t0\t0\t0\t1\t0\t0\t1\t1\t`   입력  입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.   출력  각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 예제 입력 1  복사 2 10 8 17 0 0 1 0 1 1 4 2 4 3 4 5 2 4 3 4 7 4 8 4 9 4 7 5 8 5 9 5 7 6 8 6 9 6 10 10 1 5 5 예제 출력 1  복사 5 1 예제 입력 2  복사 1 5 3 6 0 2 1 2 2 2 3 2 4 2 4 0 예제 출력 2  복사 2   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 import sys sys.setrecursionlimit(10**6) def dfs(x: int, y: int)-&gt; bool:      if x &lt; 0 or x &gt;= M or y &lt; 0 or y &gt;= N:         return False     if graph[y][x] == 1:         graph[y][x] = 2         dfs(x-1, y)         dfs(x+1, y)         dfs(x, y+1)         dfs(x, y-1)         return True     return False #테스트 케이스의 개수 T = int(input())  answer = [] for i in range(T):     #가로길이 M, 세로길이 N, 배추의 위치의 개수 K     M, N, K = map(int, input().split())     graph = [[0]*M for i in range(N)]     result = 0     for i in range(K):         x,y = map(int, input().split())         graph[y][x] = 1     for i in range(M):         for j in range(N):             if graph[j][i] == 1:                 if dfs(i,j) == True:                     result += 1     answer.append(result)      for i in answer:     print(i)   1 2 3 4 5 6 7 8 9 1 5 3 6 0 2 1 2 2 2 3 2 4 2 4 0 2   ","categories": ["baekjoon"],
        "tags": ["코딩테스트","백준","파이썬"],
        "url": "/baekjoon/BOJ-%EC%9C%A0%EA%B8%B0%EB%86%8D-%EB%B0%B0%EC%B6%94/",
        "teaser": null
      },{
        "title": "[BOJ] 2468 안전영역 (Python3)",
        "excerpt":"문제  재난방재청에서는 많은 비가 내리는 장마철에 대비해서 다음과 같은 일을 계획하고 있다. 먼저 어떤 지역의 높이 정보를 파악한다. 그 다음에 그 지역에 많은 비가 내렸을 때 물에 잠기지 않는 안전한 영역이 최대로 몇 개가 만들어 지는 지를 조사하려고 한다. 이때, 문제를 간단하게 하기 위하여, 장마철에 내리는 비의 양에 따라 일정한 높이 이하의 모든 지점은 물에 잠긴다고 가정한다.   어떤 지역의 높이 정보는 행과 열의 크기가 각각 N인 2차원 배열 형태로 주어지며 배열의 각 원소는 해당 지점의 높이를 표시하는 자연수이다. 예를 들어, 다음은 N=5인 지역의 높이 정보이다.  1 2 3 4 5 6\t8\t2\t6\t2 3\t2\t3\t4\t6 6\t7\t3\t3\t2 7\t2\t5\t3\t6 8\t9\t5\t2\t7  이제 위와 같은 지역에 많은 비가 내려서 높이가 4 이하인 모든 지점이 물에 잠겼다고 하자. 이 경우에 물에 잠기는 지점을 회색으로 표시하면 다음과 같다.  1 2 3 4 5 6\t8\t2\t6\t2 3\t2\t3\t4\t6 6\t7\t3\t3\t2 7\t2\t5\t3\t6 8\t9\t5\t2\t7  물에 잠기지 않는 안전한 영역이라 함은 물에 잠기지 않는 지점들이 위, 아래, 오른쪽 혹은 왼쪽으로 인접해 있으며 그 크기가 최대인 영역을 말한다. 위의 경우에서 물에 잠기지 않는 안전한 영역은 5개가 된다(꼭짓점으로만 붙어 있는 두 지점은 인접하지 않는다고 취급한다).   또한 위와 같은 지역에서 높이가 6이하인 지점을 모두 잠기게 만드는 많은 비가 내리면 물에 잠기지 않는 안전한 영역은 아래 그림에서와 같이 네 개가 됨을 확인할 수 있다.  1 2 3 4 5 6\t8\t2\t6\t2 3\t2\t3\t4\t6 6\t7\t3\t3\t2 7\t2\t5\t3\t6 8\t9\t5\t2\t7  이와 같이 장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다. 위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면 물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다.   어떤 지역의 높이 정보가 주어졌을 때, 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.   입력  첫째 줄에는 어떤 지역을 나타내는 2차원 배열의 행과 열의 개수를 나타내는 수 N이 입력된다. N은 2 이상 100 이하의 정수이다. 둘째 줄부터 N개의 각 줄에는 2차원 배열의 첫 번째 행부터 N번째 행까지 순서대로 한 행씩 높이 정보가 입력된다. 각 줄에는 각 행의 첫 번째 열부터 N번째 열까지 N개의 높이 정보를 나타내는 자연수가 빈 칸을 사이에 두고 입력된다. 높이는 1이상 100 이하의 정수이다.   출력  첫째 줄에 장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 예제 입력 1  복사 5 6 8 2 6 2 3 2 3 4 6 6 7 3 3 2 7 2 5 3 6 8 9 5 2 7 예제 출력 1  복사 5 예제 입력 2  복사 7 9 9 9 9 9 9 9 9 2 1 2 1 2 9 9 1 8 7 8 1 9 9 2 7 9 7 2 9 9 1 8 7 8 1 9 9 2 1 2 1 2 9 9 9 9 9 9 9 9 예제 출력 2  복사 6  노트  아무 지역도 물에 잠기지 않을 수도 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import sys sys.setrecursionlimit(10**6)  def dfs(x,y,water):     if x &lt; 0 or x &gt;=n or y &lt; 0 or y &gt;= n:         return False          if graph[y][x] &gt; water:         if not visited[y][x]:             visited[y][x] = True                      dfs(x+1, y, water)             dfs(x-1,y , water)             dfs(x, y+1, water)             dfs(x, y-1, water)             return True              return False      #n: 지역의 크기 N n = int(input())  #그래프 리스트 graph = [] for i in range(n):     graph.append(list(map(int, input().split())))  answer = []   max_num = max(map(max,graph))  for water in range(max_num+1):     result = 0     visited = [[False]*n for i in range(n)]     for i in range(n):         for j in range(n):             if graph[j][i]:                 if dfs(i,j,water):                     result+=1     answer.append(result)           print(max(answer))    1 2 3 4 5 3 2 2 2 2 2 2 2 2 2 1   ","categories": ["baekjoon"],
        "tags": ["코딩테스트","백준","파이썬"],
        "url": "/baekjoon/%EC%95%88%EC%A0%84%EC%98%81%EC%97%AD/",
        "teaser": null
      },{
        "title": "[BOJ] 12761 돌다리 (Pytyon3)",
        "excerpt":"문제  동규와 주미는 일직선 상의 돌 다리 위에있다. 돌의 번호는 0 부터 100,000 까지 존재하고 동규는   N번 돌 위에, 주미는 M번 돌 위에 위치하고 있다. 동규는 주미가 너무 보고싶기 때문에 최대한 빨리 주미에게 가기 위해 A,B만큼의 힘을 가진 스카이 콩콩을 가져왔다. 동규가 정한 다리를 건너는 규칙은 턴 방식인데, 한 턴에 이동할 수 있는 거리는 이러하다. 현 위치에서 +1칸, -1칸을 이동할 수 있고, 스카이 콩콩을 이용해 현 위치에서 A나 B만큼 좌우로 점프할 수 있으며, 순간적으로 힘을 모아 현 위치의 A배나 B배의 위치로 이동을 할 수 있다.   예를 들어 지금 동규가 7번 돌 위에 있고 스카이 콩콩의 힘이 8이면 그냥 점프를 해서 15번 돌에 갈 수도 있고, 순간적으로 힘을 모아 56번 돌에 갈 수도 있다는 것이다. 주어진 8가지의 방법 중 적절한 방법을 골라서 최대한 빨리 동규가 주미를 만날 수 있게 도와주자. 단, 이동 과정에서 100,000보다 크거나 0보다 작은 번호의 돌은 존재하지 않으므로 갈 수 없고, 같은 방법을 계속 사용해도 되며 항상 도달할 수 있는 케이스만 주어진다.   입력  입력의 첫 줄에 스카이 콩콩의 힘 A와 B, 그리고 동규의 현재위치 N,   주미의 현재 위치 M이 주어진다. (단, 2≤A,B≤30이고 0≤N,M≤100,000)   출력  동규가 주미에게 도달하기 위한 최소한의 이동 횟수를 출력하라.   1 2 3 4 5 6 7 8 9 10 예제 입력 1   2 3 1 20 예제 출력 1   4   예제 입력 2   3 7 2 98500 예제 출력 2   10  풀이  좌우좌표계로 연결된 노드로 생각하고 bfs를 사용하여 방문한적이 없다면 점프하기 전의 위치에서 1을 더한값을 현재위치에 저장해 주며 앞으로 끝까지 나아간다. 그 이후에 주미가 있는 곳의 숫자를 출력해주면, 그 숫자가 동규가 주미에게 도달하기위한 최소 이동 횟수가 된다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from collections import deque def bfs(x):     visited[x] = 1     q = deque()     q.append(x)     while q:         nx = q.popleft()         for i in range(8):             if i &lt; 6:                 sx = nx+dx[i]                 if 0 &lt;= sx &lt;= 100000 and visited[sx] == 0:                     q.append(sx)                     visited[sx] = 1                     stone[sx] = stone[nx]+1                              else:                 sx = nx*dx[i]                 if 0 &lt;= sx &lt;= 100000 and visited[sx] == 0:                     q.append(sx)                     visited[sx] = 1                     stone[sx] = stone[nx]+1                           A,B,N,M = map(int, input().split())  stone = [0 for i in range(100001)] visited = [0 for i in range(100001)]  dx =[1,-1,A,-A,B,-B,A,B]  bfs(N)  print(stone[M])   1 2 2 3 1 20 4   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/BOJ-12761-%EB%8F%8C%EB%8B%A4%EB%A6%AC-(Pytyon3)/",
        "teaser": null
      },{
        "title": "[BOJ] 16956 늑대와 양 (Python3)",
        "excerpt":"문제  크기가 R×C인 목장이 있고, 목장은 1×1 크기의 칸으로 나누어져 있다. 각각의 칸에는 비어있거나, 양 또는 늑대가 있다. 양은 이동하지 않고 위치를 지키고 있고, 늑대는 인접한 칸을 자유롭게 이동할 수 있다. 두 칸이 인접하다는 것은 두 칸이 변을 공유하는 경우이다.   목장에 울타리를 설치해 늑대가 양이 있는 칸으로 갈 수 없게 하려고 한다. 늑대는 울타리가 있는 칸으로는 이동할 수 없다. 울타리를 설치해보자.   입력  첫째 줄에 목장의 크기 R, C가 주어진다.   둘째 줄부터 R개의 줄에 목장의 상태가 주어진다. ‘.’는 빈 칸, ‘S’는 양, ‘W’는 늑대이다.   출력  늑대가 양이 있는 칸으로 갈 수 없게 할 수 있다면 첫째 줄에 1을 출력하고, 둘째 줄부터 R개의 줄에 목장의 상태를 출력한다. 울타리는 ‘D’로 출력한다. 울타리를 어떻게 설치해도 늑대가 양이 있는 칸으로 갈 수 있다면 첫째 줄에 0을 출력한다.   제한   1 ≤ R, C ≤ 500     예제 입력 1      6 6        ..S…      ..S.W.      .S….      ..W…      …W..      ……      예제 출력 1        1      ..SD..      ..SDW.        .SD…       .DW…       DD.W..       ……   예제 입력 2         1 2       SW       예제 출력 2         0   예제 입력 3         5 5       .S…       …S.       S….       …S.       .S…  예제 출력 3  복사       1       .S…       …S.       S.D..       …S.       .S…   노트  이 문제는 설치해야 하는 울타리의 최소 개수를 구하는 문제가 아니다.   문제풀이  이 예제에는 양과 늑대가 딱 분리될정도만 울타리를 쳐서 출력되게 되어있어서 이걸 어떻게 구현해야할지 아무리 고민해도 답이 안나와서 다른사람들은 어떻게 풀었나 하고 봤는데, 그냥 모든 평지를 울타리로 박아도 답으로 통과가 되서 허무했다.   어째 실버4 수준이라기엔 너무 복잡해서 어려웠는데, 양과 늑대를 제외하고 다 울타리로 막아버리게 되면 아주 단순한 기본적인 bfs풀이 문제이다.   모든 좌표를 방문하여,   1 2 3 4 5 * 좌표에 해당하는 문자가 W일 경우에는 bfs로 상하좌우를 확인 후, 양이 상하좌우에 있다면 반복문을 break하고 kill을 True로 바꾸고 0을 출력  * 좌표에 해당하는 문자가 S일 경우에는 continue  * 좌표에 해당하는 문자가 .일 경우에는 .을 D로 바꾸기   위 반복문이 끝나고 kill이 False라면 1과함께 리스트를 문자열로 다시 출력한다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #목장의 크기 r,c r,c = map(int,input().split()) #목장의 상태 pasture pasture = [] for i in range(r):     pasture.append(list(input())) dx = [-1,1,0,0] dy = [0,0,1,-1] kill = False for i in range(r):     for j in range(c):         if pasture[i][j] == 'W':             for k in range(4):                 nx = i+dx[k]                 ny = j+dy[k]                 if nx &lt;0 or nx&gt;=r or ny&lt;0 or ny&gt;=c:                     continue                              if pasture[nx][ny] == 'S':                     kill = True                     break         elif pasture[i][j] == 'S':             continue         elif pasture[i][j] == '.':             pasture[i][j] = 'D' if kill:     print(0) else:     print(1)     for i in range(len(pasture)):         print(\"\".join(pasture[i]))                   1 2 3 1 2 SW 0   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/BOJ-16956-%EB%8A%91%EB%8C%80%EC%99%80-%EC%96%91-(Python3)/",
        "teaser": null
      },{
        "title": "[BOJ] 17086 아기상어2 (Python3)",
        "excerpt":"문제  N×M 크기의 공간에 아기 상어 여러 마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 아기 상어가 최대 1마리 존재한다.   어떤 칸의 안전 거리는 그 칸과 가장 거리가 가까운 아기 상어와의 거리이다. 두 칸의 거리는 하나의 칸에서 다른 칸으로 가기 위해서 지나야 하는 칸의 수이고, 이동은 인접한 8방향(대각선 포함)이 가능하다.   안전 거리가 가장 큰 칸을 구해보자.   입력  첫째 줄에 공간의 크기 N과 M(2 ≤ N, M ≤ 50)이 주어진다. 둘째 줄부터 N개의 줄에 공간의 상태가 주어지며, 0은 빈 칸, 1은 아기 상어가 있는 칸이다. 빈 칸의 개수가 한 개 이상인 입력만 주어진다.   출력  첫째 줄에 안전 거리의 최댓값을 출력한다.   예제 입력 1           5 4     0 0 1 0     0 0 0 0     1 0 0 0     0 0 0 0     0 0 0 1     예제 출력 1          2   예제 입력 2       7 4     0 0 0 1     0 1 0 0     0 0 0 0     0 0 0 1     0 0 0 0     0 1 0 0     0 0 0 1     예제 출력 2      2   문제풀이  bfs 문제인데, 다른 문제들과 다르게 4방향이 아닌 대각선을 포함한 8방향으로 이동할 수 있다는게 특이한 문제이다. 다른 문제들과 마찬가지로 bfs로 풀이하면 되지만  dx와 dy를 8개의 요소를 갖는 리스트로 선언해주고 모든 좌표를 방문하다가 상어가 있는 좌표에 도달하면 bfs함수를 불러와 다름 1이 나올때까지 이동하며 그 이동거리를 누적하여 더해준 후, 가장 큰 안전거리 값을 출력한다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 from collections import deque def bfs():     while q:         x,y = q.popleft()         for k in range(8):             nx,ny = x + dx[k], y + dy[k]             if nx &lt; 0 or nx&gt;=n or ny &lt;0 or ny &gt;=m:                 continue             if space[nx][ny] == 0:                 q.append([nx,ny])                 space[nx][ny] = space[x][y] + 1          #공간의 크기 n,m n,m = map(int,input().split())  q = deque()  #공간의 모습  space = [] for i in range(n):     space.append(list(map(int, input().split())))     for j in range(m):         if space[i][j] == 1:             q.append([i,j])               #대각선 이동하기 위한 dx, dy dx = [1,-1,0,0,1,-1,1,-1] dy = [0,0,1,-1,1,-1,-1,1]   bfs() dist = 0 for i in range(n):     for j in range(m):         dist = max(space[i][j], dist)          print(dist-1)   1 2 3 4 5 6 7 8 9 7 4 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 3   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/BOJ-17086-%EC%95%84%EA%B8%B0%EC%83%81%EC%96%B42-(Python3)/",
        "teaser": null
      },{
        "title": "[BOJ] 1326 폴짝폴짝 (Python3)",
        "excerpt":"문제  개구리가 일렬로 놓여 있는 징검다리 사이를 폴짝폴짝 뛰어다니고 있다. 징검다리에는 숫자가 각각 쓰여 있는데, 이 개구리는 매우 특이한 개구리여서 어떤 징검다리에서 점프를 할 때는 그 징검다리에 쓰여 있는 수의 배수만큼 떨어져 있는 곳으로만 갈 수 있다.   이 개구리는 a번째 징검다리에서 b번째 징검다리까지 가려고 한다. 이 개구리가 a번째 징검다리에서 시작하여 최소 몇 번 점프를 하여 b번째 징검다리까지 갈 수 있는지를 알아보는 프로그램을 작성하시오.   입력  첫째 줄에 징검다리의 개수 N(1≤N≤10,000)이 주어지고, 이어서 각 징검다리에 쓰여 있는 N개의 정수가 주어진다. 그 다음 줄에는 N보다 작거나 같은 자연수 a, b가 주어지는 데, 이는 개구리가 a번 징검다리에서 시작하여 b번 징검다리에 가고 싶다는 뜻이다. 징검다리에 쓰여있는 정수는 10,000보다 작거나 같은 자연수이다.  출력  첫째 줄에 개구리가 a번 징검다리에서 b번 징검다리로 최소 몇 번 점프하여 갈 수 있는 지를 출력하시오. a에서 b로 갈 수 없는 경우에는 -1을 출력한다.   1 2 3 4 5 6 예제 입력 1  복사 5 1 2 2 1 2 1 5  예제 출력 1  복사 1 ## 힌트 1번 징검다리에 1이 쓰여 있으므로, 1의 배수인 4만큼을 한 번에 뛰어 5번 징검다리로 갈 수 있다. ## 풀이 bfs를 이용하여 징검다리에 인덱스 + 징검다리에 적혀있는 크기의 배수들에 모두 방문하여 방문하지 않은 징검다리라면 visited에 1을 더해주는 방식으로 몇번만에 b에 도달했는지가 visited에 1보다 큰 수로 저장되도록 한다.   간단한 bfs문제이지만 푸는데 한참걸렸는데, 징검다리가 왼쪽으로도 이동할 수 있다는 사실을 생각을 안하고 계속 풀어서 아무리 반례를 찾으려 해도 찾을 수 가 없어 시간을 너무 많이 잡아먹었다. 문제를 잘읽고 프로그램을 어떤 상황까지 구현해야 하는지 확실하게 풀어야겠다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from collections import deque  def bfs(x):     q = deque()     q.append(x)     visited[x] = 1     while q:         nx = q.popleft()         dx=[]         for i in range(b+1):             if abs(bridge[nx]*-i) &gt; n:                 break             dx.append(bridge[nx]*i)         for i in range(b+1):             if abs(bridge[nx]*-i) &gt; n:                 break             dx.append(bridge[nx]*-i)         for i in range(len(dx)):             sx = nx + dx[i]             if 0 &lt;= sx &lt; n and visited[sx]==0:                 visited[sx] = visited[nx]+1                 q.append(sx)                 #print('result:', result)  n = int(input()) bridge = list(map(int,input().split())) a,b = map(int,input().split()) visited = [0]*n result = [0]*n bfs(a-1) if bridge[a-1] == 1:         print(1) elif a == b:     print(0) else:     print(visited[b-1]-1)    1 2 3 4 5 6 5 2 3 1 2 3 5 2 [0, 3, 0, -3] [0, 3, 0, -3] 1   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/BOJ-1326-%ED%8F%B4%EC%A7%9D%ED%8F%B4%EC%A7%9D-(Python3)/",
        "teaser": null
      },{
        "title": "목표",
        "excerpt":"2021.07.18  요즘 어느정도 무엇을 하고싶고 그 무엇을 하기위해 어떻게 하고싶은지에 대한 가닥이 잡혀서  목표를 뚜렷하게 정하고 시작해야겠다는 생각이 들었다.   사실 요 몇달간 열심히 하기는 했지만 더 구체적인 목표와 방향성이 있어야 내가 원하는 바를 이뤄낼 수 있겠다는 생각이 들기도 해서, 아래 구체적인 내용을 연말까지 해내는 것을 우선적인 목표로 진행해보려한다.   1일 1커밋   사실 1일 1커밋에 대한 이야기를 많이 들어서 깃허브를 처음 시작했을때 할까 고민도 했었지만, 사실 바쁜날은  1일 1커밋을 지키기 위해서 글자하나만 바꾼다던가, 의미없는 커밋을 하는게 큰의미가 있나 싶어서 의미있는 커밋을 남기는게 더 중요하다는 생각에 시도하지 않았었다. 하지만 다른사람들의 1일 1커밋 챌린지 도전에 관한 글들을 보며 느낀건, 1일 1커밋 챌린지는 그저 잔디를 예쁘게 심는것만이 목적이 아닌, 진짜로 내 삶이 개발자의 라이프 스타일이 되어서 항상 어떤것을 오늘 커밋해야할까라는 생각을 하며 살게되는 것에 큰 의미가 있다는 걸 알게 되었다. 뿐만 아니라 채워지는 잔디를 보며 내가 하루하루 해냈다는 성취감이 내일의 나를 더 나아가게 한다는 느낌이 자칫 지치고 힘들 수 있는 공부에 큰 힘이 될 것 같았다.   1일 1알고리즘 문제 풀이   사실 이 1일 1알고리즘 문제풀이는 위의 1일 1 커밋과 같은 목표라고 볼 수 있는데,  1일 1커밋을 의미없이 글자만 바꾼다거나, 의미없는 변화를 추가하여 굳이 커밋하고 싶지 않았다.  내 깃허브에 박힌 잔디들이 가진 내용은 아무리 그래도 잔디 하나당 블로그 포스트 하나 정도는 되어야 내 자존심이 상하지 않을 것 같았다. 따라서 아무리 바쁜날이 와 커밋을 할 여력이 안될지라도, 아침이나 지하철 이동 시간을 이용해서라도 하루에 한 문제를 꼭 풀어 내어 커밋하겠다는 다짐을 했다.   연말까지 한개이상의 프로젝트 완성   기본적인 이론들이나 스킬에 대한 공부도 중요하지만, 역시 가장 중요한건 직접 하나의 프로젝트를 시작해보며  거기서 오는 돌발 상황들이나 실무적인 요령을 얻는것도 몹시 중요하다. 따라서 연말내로 하나의 프로젝트를 완성 시킬 생각인데, 중요한것은 내가 현재 능숙한 언어인 파이썬으로 제작하는것이 아니라 오늘부터 새로 공부할 언어인 자바를 사용하여 제작하는 것이다. 사실 코딩테스트만 통과하자는 목적으로 파이썬으로 알고리즘 테스트만 공부할 요령이었는데, 진정한 의미로써의 내 개발자체의 실력을 올리려면 여러가지 언어를 틈틈히 공부해야 하며, 그 중 자바는 절대 빼놓을 수 없는 언어이다.   따라서 위의 세가지 목표를 중심으로 남은 6개월을 보낼 생각이다. 물론, 휴학 반년 결산에서 한 목표도 함께!  사실 6개월에 모든것을 이루기에는 너무 어려운 일일 수 있지만, 한번쯤은 적은 목표를 쉽게 이루는 것보다 많은 목표를 힘들게 못이뤄보아야 내가 어느 정도 양의 목표를 이룰 수 있을지에 대한 감이 잡힐 것같아서,   올해의 목표는 살짝 벅차게 잡아보도록 했다.   요즘따라 의욕이 넘친다. 더 나은 삶을 위해서 더 열심히 살아야겠다는 생각이 드는 요즘이다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%AA%A9%ED%91%9C/",
        "teaser": null
      },{
        "title": "[Java] 생성자",
        "excerpt":"생성자란?  다음과 같이 Person과 PersonTest 클래스를 만들어보자  1 2 3 4 5 6 7 package constructor;  public class Person {     String name;     float height;     float weight; }  위와 같은 클래스를 만들었다면 PersonTest라는 클래스를 하나 더 만들어  personLee라는 인스턴스를 선언해보자  1 2 3 4 5 6 7 package constructor;  public class PersonTest {     public static void main(String[] args){         Person personLee = new Person()     } }  여기서 new Person() 의 Person()같은 함수를 생성자라고 한다.  클래스의 멤버 변수는 메서드에 의해 값이 변경될 수도 있지만, 처음 클래스를 생성할 때 값을  정해야 하는 경우도 있다. 생성자가 하는 일은 클래스를 처음 만들 때 멤버 변수나 상수를 초기화하는 것이다.   디폴트 생성자  생성자는 오직 클래스를 생성할때만 호출한다.      생성자 이름은 클래스 이름과 동일하고, 생성자는 반환값을 갖지 않는다.  하지만 우리가 처음 Person 클래스를 만든 코드를 보면 Person() 생성자가 따로 없다.  하지만 그럼에도 new Person()을 통해 객체를 만들어 줄 수 있었는데, 이는 컴파일러가  자동으로 생성자를 만들어주기 때문이다. 이렇게 자동으로 만들어주는 생성자를 디폴트 생성자(default constructor) 라고 하는데 이는 매개변수도 없고 구현코드가 없다.   생성자 만들기  필요한 경우 디폴트 생성자가 아닌 프로그래머가 임의로 만든 생성자를 사용할 수도 있는데, 이렇게 하면  인스턴스를 생성할때 반드시 특정 멤버변수의 값을 초기화하면서 하도록 할 경우에 직접 생성자를 구현하여     사용하게된다.  1 2 3 4 5 6 7 8 9 10 11 package constructor;  public class Person {     String name;     float height;     float weight;      public Person(String pname){         name = pname;     } }  이렇게 선언하게 되면 반드시 name을 매개변수로 넣어주어야만 인스턴스의 멤버 변수값을 초기화함과 동시에  인스턴스가 만들어진다. 따라서 우리가 아까 만들었던 PersonTest 클래스는 오류를 나타내게 되는데,  이는 우리가 직접 생성자를 만들어줌으로써 컴파일러가 이제는 자동으로 디폴트 생성자를 만들게 되지 않기 때문이다. 따라서 오류가 나지 않도록 하려면 아래의 코드와 같이 name을 매개변수에 지정을 해주어야 한다.  1 2 3 4 5 6 7 package constructor;  public class PersonTest {     public static void main(String[] args){         Person personLee = new Person(\"이민재\");     } }  만약 매개변수를 받아도 되고 안받아도 되도록 하고 싶다면, 우리가 직접 디폴트 생성자도 함께 있도록 추가해주면 된다. 이렇게 하면 생성자 두개중에서 하나를 선택하여 사용 할 수 있게된다.  1 2 3 4 5 6 7 8 9 10 11 12 package constructor;  public class Person {     String name;     float height;     float weight;      public Person(String pname){         name = pname;     }     public Person(){} }  생성자 오버로드  이렇게 위처럼 생성자가 두 개 이상 제공되는 경우를 생성자 오버로드(constructor overload) 라고 한다.  필요에 따라 매개변수가 다른 생성자를 여러 개 만들 수 있으며, 경우에 따라서는 아예 디폴트 생성자를 제공하지 않을 수 도 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%83%9D%EC%84%B1%EC%9E%90/",
        "teaser": null
      },{
        "title": "[Java] 객체 지향 프로그래밍과 클래스",
        "excerpt":"클래스란?  클래스는 객체와의 속성과 기능을 코드로 구현한 것으로, 객체를 클래스로 구현하는 것을      ‘클래스를 정의한다’라고 한다. 클래스를 정의하려면 우선 클래스 이름과 클래스가 가지는 속성,  또는 특성이 필요하다. 객체를 코드로 구현한다는 말이 모호할 수 있으니  ‘학생’이라는 객체를 클래스로 살펴보자.   학생이라는 객체가 있다면, 이 객체가 가지는 일반적인 속성들이 있을것이다.  예를들어 학번, 이름, 학년, 사는곳 정도가 될 수 있는데, 이런 클래스 속성은 특성이라고도 하고  클래스 내부에 변수로 선언한다.   이렇게 선언하는 클래스의 속성을 ‘멤버 변수’라고한다.   클래스를 정의하는 문법을 간단히 나타내면 다음과 같다.  1 2 3 4 (접근 제어자) class 클래스 이름 {     멤버 변수;     메서드; }  그럼 예를들어 학생이라는 객체의 클래스를 선언해보자.  1 2 3 4 5 6 7 8 9 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      }  위의 코드를 보면, 우리는 Student라는 클래스를 선언했다.     또, 위에서 말한 객체의 속성을 변수로써 클래스 안쪽에 선언했는데,    자바프로그램은 모든 요소가 반드시 클래스 내부에 존재하여야 한다.     클래스 외부에는 package 선언과 import 외에는 아무것도 선언하지 않는다.   클래스 기능을 구현하는 메서드  지금까지는 클래스의 속성인 멤버 변수를 선언했다면, 이번에는 클래스에 관련된 기능을 구현해볼 것이다. 예를 들어 앞서만든 학생의 클래스라면 이를 출력하는 메서드 showStudent를 만들어 보자  1 2 3 4 5 6 7 8 9 10 11 12 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     } }  위처럼 클래스 내부에 학생의 이름과 주소를 출력하는 메서드를 만든 것을 알 수 있다.  아직은 기능으로만 존재하기 때문에 이 메서드를 사용하려면 다른 방법이 추가되어야 한다.  그럼 그 전에 먼저 패키지에 대해서 알아 본 후 기능을 실제로 사용해보도록하다.   패키지란?  패키지는 간단히 말하면 클래스 파일의 묶음이라고 할 수 있다.     패키지를 말들게 되면 프로젝트 하위에 디렉토리가 하나 생기게 되는데, 이렇게 만든 패키지는  계층 구조를 가질 수 있다.  만약 학교와 관련된 프로젝트 파일이 있다면  강좌에 관련된 클래스, 학생에 관련된 패키지 등등 서로 관련이있는 클래스를 묶어주는 패키지 파일을 만들어줌으로써 계층구조를 갖도록 해주어 소스코드 관리와 유지보수를 편하게 해줄 수 있다.   패키지 선언은 맨위에 해줌으로써 이 클래스가 어떤 패키지에 소속되어있는지 알려준다.  클래스 이름이 같다고 해도 패키지 이름이 다르면 클래스 전체의 이름이 다른것이므로 다른 클래스가 된다. 다시 말해서 같은 이름의 클래스라도 다른 패키지에 속해있다면 그 두 클래스는 연관이 없다.   함수란?  함수는 하나의 기능을 수행하는 코드를 미리 만들어 놓은것으로,  예를들어 더하기 함수가 있다면 우리는 덧셈을 할때마다 덧셈에 대한 코드를 일일히 입력할 필요가   없이 더하기 함수를 불러옴으로써 간단하게 덧셈 연산을 수행할 수 있을 것이다.   함수 정의하기  더하기 함수를 실제 코드로 작성해보자.  함수의 반환형, 함수이름과 매개변수를 선언해주면, 우리는 함수를 선언할 수 있다.  1 2 3 4 5 int add(int num1, int num2){     int result;     result = num1+num2;     return result }  함수 호출하고 값 반환하기  아까 위에서 학생의 이름을 출력하는 함수를 구현만 하고 사용해보지 않았는데, 이번에는  어떻게 함수를 사용하는지에 대해 알아보도록 하자.     위에서 정의했던 add함수를 한번 구현하고 호출해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package classpart;  public class FunctionTest {     public static void main(String[] args){         int num1 = 10;         int num2 = 20;          int sum = add(num1, num2);         System.out.println(sum);      }      public static int add(int n1, int n2){          int result = n1 + n2;         return result;     } }  클래스 기능을 구현하는 메서드  자바는 함수와 별개로 클래스 내부에서 사용하는 멤버 함수를 따로 지원하는데,      이를 메서드라고 한다. 메서드는 멤버변수를 사용하여 클래스의 기능을 구현하는 것으로  함수에 객체지향이 포함된 용어로 이해하면 쉽다.   아까 만들었던 Student 클래스에 학생의 이름을 가져오는 메서드를 한번 만들어보자  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     }     public String getStudent(){         return studentName; } }  아까 만들었던 클래스에 이처럼 getStudent() 메서드를 추가해보았다.  그럼 이번에는 학생이름을 멤버 변수에 대입해주는       setStudentName()메서드를 동일하게 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     }     public String getStudent(){         return studentName; }     public void setStudentName(String name){         studentName = name; } }  그럼 이제 이 메서드를 어떻게 사용하는지에 대해 알아보자  클래스와 인스턴스  클래스를 사용하여 프로그램을 실행하려면, 먼저 main() 함수를 알아야 한다.  main() 함수는 자바의 가상머신이 프로그램을 시작하기 위해 호출하는 함수로,  클래스 내부에 만들지만, 클래스의 메서드는 아니다.   main() 함수에서 클래스를 사용하는 방법은 두가지가 있는데,     직접 만든 클래스 내부에 main()을 만드는 방법   외부에 테스트용 클래스를 만들어 사용하는 방법  두가지가 있다.   먼저 첫번째 방법으로 방금 만든 Student 클래스에 main() 함수를 작성해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package classpart;  public class Student {     int studentID;     String studentName;     int grade;     String address;      public void showStudent(){         System.out.println(studentName+\",\"+address);     }     public String getStudent(){         return studentName;     }     public void setStudentName(String name){         studentName = name;     }      public static void main(String[] args){         Student studentLee = new Student();         studentLee.studentName = \"이민재\";          System.out.println(studentLee.studentName);         System.out.println(studentLee.getStudent());     }      }   1 2 &gt;&gt;&gt; 이민재 &gt;&gt;&gt; 이민재  이렇게 클래스안에 main() 함수를 선언하여 클래스를 테스트 해보았다.  하지만 이런 방식이라면 거의 모든 클래스에 main() 함수가 존재해야 한다.   따라서 위에서 설명한 두번째 방법인, 테스트용 클래스를 만들어 메서드를 실행시켜보도록 하겠다.   1 2 3 4 5 6 7 8 9 10 11 package classpart;  public class StudentTest {     public static void main(String[] args){         Student studentLee = new Student();         studentLee.studentName = \"이민재\";          System.out.println(studentLee.studentName);         System.out.println(studentLee.getStudent());     } }  1 2 &gt;&gt;&gt; 이민재 &gt;&gt;&gt; 이민재  실행결과가 동일한 것을 알 수 있다.   new 예약어로 클래스 생성하기  클래스를 만들고 실행하는 과정을 살펴보자.     클래스를 사용하려면 먼저 클래스를 생성해야 하는데, 자바에서 클래스를 생성할때는  new 예약어를 사용하고 이어서 생성자를 써준다.   1 클래스형 변수 이름 = new 생성자  클래스 자료형 변수를 선언하고 new 예약어로 생성자를 호출하려 대입하면 새로운 클래스가 생성된다.  클래스가 생성된다는 것은 클래스를 실제 사용할 수 있도록 메모리 공간에 올린다는 뜻으로,  이렇게 실제로 사용할 수 있도록 생성된 클래스를 ‘인스턴스’라고 한다.   우리가 앞에서 사용했던 코드를 다시 한번 보면,  1 Student studentLee = new Student();  위 코드는 Student 클래스 자료형으로 StudentLee 변수를 선언하고  new Strudent(); 로 Student 클래스를 생성하여 studentLee에 대입한다는 뜻이다.  이때 studentLee를 참조변수라고 하고, 이 변수가 생성된 인스턴스를 가르키게된다.   이렇게 인스턴스를 생성하게 되면 이 인스턴스의 멤버 변수와 메서드를 참조하여 사용 할 수 있게된다.  예를들어 우리가 만든 studentLee를 이용하여 멤버변수와 메서드를 사용해보면,  1 2 studentLee.studentName =\"이민재\" System.out.println(studentLee.getStudentName)  인스턴스와 힙 메모리  인스턴스가 생성되는 과정을 조금 더 자세히 살펴보자.     new Student()를 선언하면 Student가 하나 생성되는데, 각 Student는     studentID, studentName 등의 멤버 변수를 갖고있다. 그런데 이 변수들을 저장할 공간이 있어야 한다. 이때 사용되는 메모리를 힙 메모리라고 하는데 클래스 생성자를 하나 호출하면, 인스턴스가  힙메모리에 생성되게 되는 것이다.  1 Student studentLee = new Student();  위와 같이 생성된 클래스 (new Student())를 studentLee 변수에 대입하면,      인스턴스가 저장된 메모리를 studentLee 변수가 가르키게 된다.     studentLee는 지역변수이므로 스택 메모리에 생성되게 되고, 인스턴스는 힙메모리에 생성된다.   따라서 지역변수 studentLee에 생성된 인스턴스를 대입하는 것은 studentLee에 인스턴스가      생성된 힙 메모리의 주소를 대입한다는것과 같은 의미이다.   정리  객체 지향을 배우다 보니 새로운 용어가 많아 혼란스러울 수 있는 내용들을 정리해 표로   정리해보았다. 개념들이 이름도 살짝 모호하고 서로 엮여있다보니 헷갈릴 수가 있어  확실하게 어떤 것을 가르키는 개념인지 잘 기억해 두어야겠다.                  용어       설명                       객체       객체 지향 프로그램의 대상, 생성된 인스턴스                 클래스       객체를 프로그래밍하기 위해 코드로 만든 상태                 인스턴스       클래스가 메모리에 생성된 상태                 멤버 변수       클래스이 속성, 특성                 메서드       멤버 변수를 이용하여 클래스의 기능을 구현                 참조 변수       메모리에 생성된 인스턴스를 가리키는 변수                 참조 값       생성된 인스턴스의 메모리 주소 값           ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EA%B3%BC-%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Java] 변수와 자료형",
        "excerpt":"변수 선언하여 사용하기  1 2 3 int level; level = 10; System.out.println(level)  변수 초기화하기  1 int level = 10;  자료형  자바는 기본자료형과 참조 자료형을 제공하는데, 기본 자료형은 자바 라이브러리에서 기본으로 제공하며, 얼마만큼의 메모리를 어떻게 사용할 것인지가 이미 정해져있다.                  바이트       정수형       문자형       실수형       논리형                       1바이트       byte       -               boolean                 2바이트       short       char       -       -                 4바이트       int       -       float       -                 8바이트       long       -       double       -           다른 자료형은 모두 다른 언어와 동일한데,  long을 사용할때의 한가지 주의 사항이 있다.   1 2 3 int num1 = 12345678900;  &gt;&gt;&gt; integer number too large   num1의 경우는 int가 표현가능한 범위를 넘어서서 오류가 난다고 하지만,      num2의 경우는 long 사용하였는데도 왜 오류가 나는 것일까?   이는 자바가 모든 정수를 기본적으로 int를 사용하여 처리하기 때문이다.     즉 숫자 12345678900이 들어오면 우선 int로 처리하기 때문에, 숫자뒤에 L을 붙여    long형으로 이 숫자를 처리하도록 컴파일러에게 알려주어야 한다.   1 long num = 12345678900L;   문자 자료형 선언하기   1 char mychar = 'A'   문자를 변수에 대입하면 문자 그대로 저장되는 것이 아니라      그 문자에 해당하는 정수 값(아스키코드 값)이 저장된다.   따라서 아래와 같이 아스키코드를 대입하여도 문자를 대입한 것과 동일하게 인식한다.   1 2 3 4 5 6 7 8 char ch1 = 'A'; char ch2 = 65;  System.out.println(ch1); System.out.println(ch2);  &gt;&gt;&gt; A &gt;&gt;&gt; A   반대로 출력할때 int를 표기해주면, 씌워주면 문자에 해당하는 아스키코드값을 출력한다.   1 2 3 System.out.println((int)ch1)  &gt;&gt;&gt; 65   자료형 없이 변수 선언하기  var를 사용하여 변수를 선언하면 자료형을 정확히 명시하지 않고도 변수에 대입되는  값에따라 컴파일러가 자료형을 추측한다.   1 2 3 var num = 10; var dNum = 10.0; var str = \"hello\"   상수와 리터럴  자바에서 상수를 선언하고 싶다면, final을 사용하여 선언한다.   1 2 final double PI = 3.14; final int MAX_NUM = 100;   상수는 변하지 않기 떄문에 선언과 동시에 초기화 하는 것이 좋다.   형 변환  정수와 실수는 컴퓨터 내부에서 표현되는 방식이 전혀 다르다.  따라서 정수와 실수를 더한다고 할 땐 그대로 연산을 수행 할 수 없고, 하나의 자료형으로  통일 후에 연산해야 한다. 이때 형 변환(type conversion)이 필요하다.   1 2 int n = 10; double dnum = n;   위 처럼 변수 n은 int형이고 dnum은 double형이다.     형 변환이란 이렇게 변수의 자료형을 같게 해주는 것을 말한다.   형 변환은 크게 묵시적 형변환(자동 형 변환)과 명시적 형 변환(강제 형 변환)   두가지가 있는데, 형 변환의 기본원칙은 다음과 같다.      바이트 크기가 작은 자료형에서 큰 자료형으로 형 변환은 자동으로 이루어진다   덜 정밀한 자료형에서 더 정밀한 자료형으로 형 변환은 자동으로 이루어진다   따라서 이 반대로 강제적 형 변환을 하게 되면, 자료 손실이 발생 할 수가 있다.   묵시적 형 변환   1 2 int iNum = 20; float fNum = iNum   명시적 형 변환  강제로 형 변환하려면 바꾸고자 하는 타입을 괄호로 명시해주어야 한다.   1 2 int iNum = 20; byte bNum = (byte)iNum  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%B3%80%EC%88%98%EC%99%80-%EC%9E%90%EB%A3%8C%ED%98%95/",
        "teaser": null
      },{
        "title": "[Java] 기본 클래스",
        "excerpt":"java.lang  지금까지 자바로 프로그램을 구현하면서 String, Integer와 같은 클래스를 사용했다. 이러한 클래스들은 어디에 있는 걸까? 이들은 모두 java.lang 패키지에 속해 있다. String 클래스의 전체 이름은 java.lang.String이고, Integer 클래스의 전체 이름은 java.lang.Integer이다. 이처럼 java.lang 패키지에는 기본적으로 많이 사용하는 클래스들이 포함되어 있다.   자바에서는 외부 패키지에서 선언한 클래스를 사용하고자 할 때는 import문으로 클래스가 어느 패키지에 속해 있는지 선언해야한다. 근데 우리는 지금까지 String 클래스를 쓰면서 import java.lang.String을 쓴 적이 없다. 그럼에도 우리는 String 클래스를 바로바로 사용할 수 있었다. 그 이유는 컴파일을 하게 되면 자동으로 컴파일러가 import java.lang.*; 을 추가 하기 때문에 직접 써주지 않아도 우리는 java.lang의 하위 클래스를 사용 할 수 있다.   우리가 여기서 다룰 기본 클래스들은 모두 java.lang 패키지에 속한 클래스들이다.      그러면 모든 자바 클래스의 최상위 클래스인 java.lang.Object에 대해서 알아보자.   최상위 클래스, Object  Object 클래스는 모든 자바 클래스의 최상위 클래스로, 모든 클래스는 Object 클래스를 상속받는다. 이 역시 컴파일러가 자동으로 extends Object를 추가해주기 때문에, 우리가 따로 추가할 필요는 없다.   우리가 직접 만드는 클래스 뿐만 아니라, JDK에서 제공하는 클래스도 모두 Object 클래스에서 상속을 받는다.   Object 클래스에 정의된 메서드 중 주로 사용하는 메서드는 다음과 같다.                  메서드       설명                       String toString()       객체를 문자열로 표현하여 반환한다. 재정의하여 객체에 대한 설명이나 특정 멤버 변수 값을 반환한다.                 boolean equals(Object obj)       두 인스턴스가 동일한지 여부를 반환한다. 재정의하여 논리적으로 동일한 인스턴스임을 정의할 수 있다.                 int hashCode()       객체의 해시 코드 값을 반환한다.                 class getClass()       객체의 클래스를 반환한다.                 void finalize()       인스턴스가 힙 메모리에서 제거될 때 가비지 컬렉터(GC)에 의해 호출되는 메서드이다. 네트워크 연결 해제, 열려있는 파일 스트림 해제 등을 구현한다.                 void wait()       멀티스레드 프로그램에서 사용하는 메서드이다. 스레드를 ‘기다리는 상태’ (non runnable)로 만든다.                 void notify()       wait() 메서드에 의해 기다리고 있는 스레드(non runnable)를 실행가능한 상태 (runnable)로 바꾼다.           Object 메서드 중에는 재정의할 수 있는 메서드가 있고, 그렇지 않은 메서드가 있다. 여기서는 자주 재정의하여 사용하는 메서드 위주로 알아보자.   toString() 메서드  toString()은 객체 정보를 문자열로 바꾸어 준다. Object 클래스를 상속받은 모든 클래스는 toString()을 재정의할 수 있는데, String 이나 Integer등의 여러 JDK 클래스에는 toString() 클래스가 이미 재정의 되어있다.   toString의 원형은 인스턴스 클래스의 이름과 주소 값을 보여준다.     예제로 책 번호와 제목을 담고 있는 Book 클래스의 인스턴스를 생성하여 참조변수를 출력해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package objectclass;  public class ToStringEx {     public static void main(String[] args){         Book book1 = new Book(200,\"개미\");          System.out.println(book1);         System.out.println(book1.toString());     }  } class Book{     int bookNumber;     String bookTile;      Book(int bookNumber, String bookTile){         this.bookNumber = bookNumber;         this.bookTile = bookTile;     } }  &gt;&gt;&gt; objectclass.Book@3fb6a447 &gt;&gt;&gt; objectclass.Book@3fb6a447  System.out.println()에 참조 변수를 넣으면 인스턴스의 정보가 호출되는데, 이는 자동으로 toString()을 호출하는 것이다.   toString() 메서드의 원형은 다음과 같다.  1 getClass().getName()+'@'+Integer.toHexString(hashCode())  위의 정의를 살펴보면,  ‘클래스 이름@해시코드 값’을 출력하라는 뜻인걸 알 수 있다.      따라서 위처럼 objectclass.Book@해시코드값이 출력된다.   equals 메서드  equals() 의 원래 기능은 두 인스턴스의 주소값을 비교하여 boolean 값으로 반환해 주는 것이다. 주소 값이 같다면 당연히 같은 인스턴스이다. 그런데 서로 다른 주소 값을 가짐에도 같은 인스턴스라고 정의해줄 수 있는 경우가 있다. 따라서 물리적 동일성(인스턴스의 메모리 주소가 같음) 뿐 아니라 논리적 동일성(논리적으로 두 인스턴스가 같음)을 구현할 때도 equals() 메서드를 재정의하여 사용한다.   생성된 두 인스턴스가 ‘같다’는건 어떤 의미일까?   먼저 물리적 동일성의 경우, 당연히 메모리 주소값이 같은 경우 일 것이다.  1 2 Student studentLee = new Student(100, \"이민재\"); Student studentLee2 = studentLee;  예를 들어 위처럼 동일한 인스턴스를 두 변수가 가르키게 한다면, studentLee와 studentLee2의 힙메모리 주소는 같으므로 물리적으로 동일하다 할 수 있다.   하지만 이 경우를 보자.  1 2 3 Student studentLee = new Student(100, \"이민재\"); Student studentLee2 = studentLee; Student studentMin = new Student(100,\"이민재\");  이러한 경우는 studentLee와 studentMin이 다른 메모리 주소를 가르키지만, 논리적으로는 같은 학생으로 처리해주어야 할 것이다. 이 상황을 구현할 에제를 만들어 살펴보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package objectclass;  class Student{     String studentName;     int studentID;      public Student(String studentName, int studentID){         this.studentName = studentName;         this.studentID = studentID;     } } public class EqualsTest {     public static void main(String[] args){         Student studentLee = new Student(\"이민재\", 100);         Student studentLee2 = studentLee;         Student studentMin = new Student(\"이민재\",100);          if (studentLee.equals(studentLee2)){             System.out.println(\"두 주소값이 같습니다.\");         }         else{             System.out.println(\"두 주소값이 다릅니다..\");         }         if (studentLee.equals(studentMin)){             System.out.println(\"두 주소값이 같습니다.\");         }         else{             System.out.println(\"두 주소값이 다릅니다.\");         }     }   }  &gt;&gt;&gt; 두 주소값이 같습니다. &gt;&gt;&gt; 두 주소값이 다릅니다.  위는 equals()의 원래 기능으로 두 변수의 논리적 동일성이 어떻든간에, 두 인스턴스의 주소가 다르다면 false를 반환한다.  만약 논리적으로 같은 인스턴스인지 확인하고싶다면, 재정의 하여 그렇게 확인하도록 구현해주어야 한다.   따라서 앞서 말한것 처럼 String 클래스와 Integer 클래스에서는 이미 equals()가 재정의 되어있기 때문에, 주소값과 관계없이 두 인스턴스가 논리적으로 같다면 true를 반환한다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/%EA%B8%B0%EB%B3%B8-%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[BOJ] 1325 효율적인 해킹 (Python3)",
        "excerpt":"문제  해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.   이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.   이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.   입력  첫째 줄에, N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에 신뢰하는 관계가 A B와 같은 형식으로 들어오며, “A가 B를 신뢰한다”를 의미한다. 컴퓨터는 1번부터 N번까지 번호가 하나씩 매겨져 있다.   출력  첫째 줄에, 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   5 4 3 1 3 2 4 3 5 3  예제 출력 1   1    풀이  간단한 탐색문제로 bfs로 풀 수 있는데, 컴퓨터의 신뢰관계를 노드 형식으로 리스트에 넣어주고, 노드가 많이 연결되어있는 컴퓨터순으로 출력하면 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from collections import deque #컴퓨터의 개수 n, 신뢰관계의 개수 m n,m = map(int, input().split())  #노드의 형태 graph graph = [[] for _ in range(n+1)]  #자신을 신뢰하는 컴퓨터를 자신의 리스트에 넣는다 for i in range(m):     a,b = map(int, input().split())     graph[b].append(a)  #bfs를 사용하여 1-5의 컴퓨터를 순서대로 방문하며, 자신을 신뢰하는 컴퓨터에 모두 방문한다. #방문한 횟수를 hack 변수에 넣는다. def bfs(x):     q = deque()     q.append(x)     hack = 1     visited = [0 for _ in range(n+1)]     visited[x] = 1     while q:         nx = q.popleft()         for i in graph[nx]:             if visited[i] == 0:                 q.append(i)                 hack+=1                 visited[i] = 1     return hack #자신을 신뢰하는 컴퓨터의 개수를 저장하는 리스트 answer answer = [] #bfs함수에 넣어 얻은 result를 answer 리스트에 넣어준다. for i in range(1,n+1):         answer.append(bfs(i))           #resutl 순차 출력 for i in range(len(answer)):     if max(answer)== answer[i]:         print(i+1, end = ' ')      1 2 3 4 5 6 5 4 3 1 3 2 4 3 5 3 1 2    Feedback  방문을 체크하는 visited 리스트를 만들지 않아서 계속 메모리 초과가 떴다.  예제는 서로 상호신뢰관계가 없어서 잘되길래 문제가 없다고 생각했는데, 테스트셋의 상호신뢰관계 때문에 반복이 끝나지를 않아서 메모리가 초과 된것 같다.  bfs, dfs를 풀때는 항상 방문을 잘 체크하자.   1   ","categories": ["baekjoon"],
        "tags": ["백준 알고리즘 BFS"],
        "url": "/baekjoon/BOJ-1325-%ED%9A%A8%EC%9C%A8%EC%A0%81%EC%9D%B8-%ED%95%B4%ED%82%B9-(Python3)/",
        "teaser": null
      },{
        "title": "[BOJ] 1325 효율적인 해킹 (Python3)",
        "excerpt":"문제  꽉꽉나라에 사는 주예와 방주는 점 S에서 만나 저녁을 먹기로 했다. 주예는 점 S에 도착했지만 길치인 방주가 약속시간이 30분이 지나도 나타나지 않자 방주에게 연락을 하여 방주가 점 E에 있다는 사실을 알아냈다. 주예는 방주에게 그 위치에 가만히 있으라고 했고, 직접 점 E로 가려고 한다.   꽉꽉나라에는 1부터 N까지의 각 점에 하나의 텔레포트 정거장이 위치해 있고 텔레포트를 통하여 연결되어 있는 다른 텔레포트의 정거장으로 이동할 수 있다. 주예는 현재 위치가 점 X라면 X+1이나 X-1로 이동하거나 X에 위치한 텔레포트와 연결된 지점으로 이동할 수 있으며 각 행동에는 1초가 소요된다. 배가 고픈 주예는 최대한 빨리 방주와 만나고 싶어 한다.   N과 텔레포트 연결 정보가 주어질 때 점 S에 있는 주예가 점 E까지 가는 최소 시간을 구해보자.   입력  첫 번째 줄에 정수 N, M이 공백으로 구분되어 주어진다. (2 ≤ N ≤ 300,000, 0 ≤ M ≤ min(N×(N-1)/2, 300,000))   두 번째 줄에 정수 S, E가 공백으로 구분되어 주어진다. (1 ≤ S, E ≤ N, S ≠ E)   그 다음 줄부터 M개의 줄에 걸쳐 텔레포트 연결 정보를 의미하는 정수 x, y가 주어진다. (1 ≤ x, y ≤ N, x ≠ y)   x y는 점 x의 텔레포트와 점 y의 텔레포트가 연결되어 있다는 뜻이다. M개의 연결정보는 중복되는 x y쌍이 없도록 주어진다.   출력  첫 번째 줄에 주예와 방주가 만날 수 있는 최소 시간을 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 예제 입력 1   5 1 1 5 1 4 예제 출력 1   2   예제 입력 2   10 3 2 5 1 6 1 3 2 8 예제 출력 2   3  풀이  단순 bfs 문제이다. 항상 이런 x좌표만 있는 문제는 단방향이 아닌 양방향으로 풀어야 한다는걸 기억하고 풀어야한다.   코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from collections import deque n,m = map(int, input().split())  s,e = map(int, input().split())  graph = [[] for _ in range(n+1)] visited = [-1 for _ in range(n+1)]  for i in range(m):     x,y = map(int, input().split())     graph[x].append(y)     graph[y].append(x)    def bfs(x):     q = deque()     q.append(x)     visited[x] = 0     while q:         nx = q.popleft()         dx = [nx-1, nx+1]         if graph[nx]:             dx += (graph[nx])         #print('dx :', dx)         for sx in dx:             #print('nx:',nx,'sx :', sx)             if 0 &lt; sx &lt;= n and visited[sx] == -1:                 q.append(sx)                 #print('q:', q)                 visited[sx] = visited[nx]+1                 #print(visited)             if sx == e:                 return visited[sx]          print(bfs(s))   1 2 3 4 5 1 1 5 1 3 3   ","categories": ["baekjoon"],
        "tags": ["백준 알고리즘 BFS"],
        "url": "/baekjoon/BOJ-18232-%ED%85%94%EB%A0%88%ED%8F%AC%ED%8A%B8-%EC%A0%95%EA%B1%B0%EC%9E%A5/",
        "teaser": null
      },{
        "title": "[Java] static 변수",
        "excerpt":"변수를 여러 클래스에서 공통으로 사용하기  우리가 앞서만든 학생클래스에서, 만약 학번을 만들고 싶다면 어떻게 해야할까?      이 학번은 새로운 인스턴스가 생성될때마다 자동으로 생성되어 그 인스턴스에 할당되게 하고싶다.     이렇게 하려면 인스턴스마다 따로 변수가 생성되는게 아니라, 클래스 전체가 함께 사용하는 기준 변수가 하나 있어야한다. 이러한 변수가 있다면, 우리는 학번을 1씩 증가시켜가며 새로운 인스턴스가 생길때마다 할당 해주면 학번이 자동으로 정해지도록 할 수 있을 것이다.   이때, 클래스에서 사용하는 공통 변수를 static 변수로 선언한다.   static 변수의 정의와 사용 방법  static 변수는 다른 용어로 ‘정적 변수’라고도 한다. static 변수는 자바뿐만 아니라 다른 언어에서도 비슷한 개념으로 사용하는 변수로, 다른 멤버 변수와 동일하게 내부에 선언한다.     자료형앞에 static 예약어를 선언해주면 사용 할 수 있다.  1 static int seralNum;  static 변수는 클래스 내부에 선언하지만, 다른 멤버 변수처럼 인스턴스가 생성될 때마다 새로 생성되는 변수가 아니라, 프로그램이 실행되어 메모리에 올라가면 딱 한 번 메모리 공간이 할당되고, 그 값을 모든 인스턴스가 공유하는 변수이다.   그럼 이러한 static변수를 갖고 학번을 가지는 학생 클래스를 만들어 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package staticex;  public class Student {     static int serialNum = 1000;     String studentName;     int studentID;          public Stirng getStudentName(){         return studentName     }     public void setStudentName(String name){         studentName = name;              }  }  학생 클래스는 serialNum이라는 static 변수를 갖는데, 이 값은 1000이다.  이제 테스트 코드에서 이 static 변수를 증가시키면, 이 값을 다른 인스턴스들이 공유하는지 한번 확인해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package staticex;  public class StudentTest {     public static void main(String[] args){         Student Lee = new Student();         Lee.setStudentName(\"Lee\");         System.out.println(Lee.serialNum);         Lee.serialNum++;          Student Kim = new Student();         Kim.setStudentName(\"Kim\");         System.out.println(Kim.serialNum);          System.out.println(Lee.serialNum);         System.out.println(Kim.serialNum);     } }  &gt;&gt;&gt; 1000 &gt;&gt;&gt; 1001 &gt;&gt;&gt; 1001 &gt;&gt;&gt; 1001  Lee 학생의 serialNum을 증가시켰는데, Kim학생의 serialNum도 동일하게 증가된 것을 확인 할 수 있다.     이처럼 static변수의 값은 모든 인스턴스가 공유한다는 것을 알게되었다. 그럼 이제 인스턴스가 생성되면 자동으로 증가한 학번을 할당하도록 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package staticex;  public class Student {     static int serialNum = 1000;     String studentName;     int studentID;      public Student(){         serialNum++;         studentID = serialNum;     }     public String getStudentName(){         return studentName;     }     public void setStudentName(String name){         studentName = name;       }  }  public Student를 만들어 새로운 인스턴스가 생성되면 serialNum을 1증가시키고, 그 값을 학번에다 할당하도록 했다. 그럼 다시 테스트 코드로 가서 학번이 올바르게 증가하며 할당되는지 확인 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package staticex;  public class StudentTest {     public static void main(String[] args){         Student Lee = new Student();         Lee.setStudentName(\"Lee\");         System.out.println(\"이름: \"+Lee.studentName+\" 학번: \"+Lee.serialNum);          Student Kim = new Student();         Kim.setStudentName(\"Kim\");         System.out.println(\"이름: \"+Kim.studentName+\" 학번: \"+Kim.serialNum);     } }  &gt;&gt;&gt; 이름: Lee 학번: 1001 &gt;&gt;&gt; 이름: Kim 학번: 1002  인스턴스를 생성해줄때마다 자동으로 학번이 증가하는 것을 확인 할 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-static-%EB%B3%80%EC%88%98/",
        "teaser": null
      },{
        "title": "[Java] 객체 간 협력",
        "excerpt":"객체 지향 프로그램은 객체를 정의하고 객체 간 협력으로 만들어진다.      그러면 실제로 객체간의 협력이 어떻게 이루어지는지 한번 예제를 만들어 확인해보자.   학생 클래스 구현하기  계속 예제로 들었던 학생 클래스를 또 한번 만들어보자. 학생클래스는 ‘이름’,’ 학년’, ‘가진 돈’ 이렇게 세가지 멤버 변수를 갖는다고 가정해보겠다. 그리고 메서드로는, ‘버스 타기’, ‘지하철 타기’, ‘학생의 현재 정보 보여주기’ 세가지 행동을 갖는다고 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package cooperation;  public class Student {     public String studentName;     public int grade;     public int money;      public Student(String studentName, int money){         this.studentName = studentName;         this.money = money;     }      public takeBus(Bus bus){         bus.take(1000);         this.money-= 1000;     }      public takeSubway(Subway subway){         subway.take(1500);         this.money -= 1500;     }     public void showInfo(){         System.out.println(studentName+\"님의 남은 돈은\"+money+\"입니다.\");     } }  Student 클래스는 버스를 타면 1000원을 money에서 빼주고, 지하철을 타면 1500원을 money 에서 뺀다.   그럼 위에서 Student에서 사용한 클래스들인 Bus와 Subway 클래스를 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 package cooperation;  public class Bus {     int money;     int person;     int busNumber;      public Bus(int busNumber){         this.busNumber = busNumber;     }     public void take(int money){         this.money += money;         person++;     }      public void showInfo(){         System.out.println(busNumber+\"번의 승객은\"+person+\"명이고, 수입은\"+money+\"입니다\");      } }  동일하게 이름만 바꿔서 Subway를 만들어준다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package cooperation;  public class Subway {     int money;     int person;     int subwayNumber;      public Subway(int subwayNumber){         this.subwayNumber = subwayNumber;     }     public void take(int money){         this.money += money;         person++;     }      public void showInfo(){         System.out.println(subwayNumber+\"번의 승객은\"+person+\"명이고, 수입은\"+money+\"입니다\");      }  }  이렇게 Student, Bus, Subway 클래스를 만들어 주었으니 이들이 어떤 식으로 협력하여 main에서 작동하는지 TakeTrans 클래스를 만들어주어 객체간의 협력을 시켜보자.     학생은 James와 Tomas 두명으로 하고, James는 버스, Tomas는 지하철을 타도록 한뒤, 각각 탑승 후 학생의 현재 상태와 대중교통의 현재 상태가 나오도록 해주자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package cooperation;  public class TakeTrans {     public static void main(String[] args){         Student James = new Student(\"James\", 5000);         Student Tomas = new Student(\"Tomas\", 10000);          Bus bus100 = new Bus(100);         James.takeBus(bus100);         James.showInfo();         bus100.showInfo();          Subway subway9 = new Subway(9);         Tomas.takeSubway(subway9);         Tomas.showInfo();         subway9.showInfo();     } }  James와 Tomas라는 두개의 인스턴스를 만들어 준뒤, 이름과 가진돈을 추가해준다.       버스와 지하철도 동일하게 각각 하나씩 bus100과 subway9이라는 인스턴스를 추가 해준다.  James는 takeBus 메서드가 호출되어 버스를 탔고, Tomas는 takeSubway 메서드가 호출되어 지하철을 탔다.   이처럼 우리가 각각 만든 객체들을 인스턴스로 만들어 각 객체끼리 협력하도록 해줄 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EA%B0%9D%EC%B2%B4-%EA%B0%84-%ED%98%91%EB%A0%A5/",
        "teaser": null
      },{
        "title": "[Java] 싱글톤 패턴",
        "excerpt":"싱글톤 패턴이란?  프로그램을 구현하다 보면 여러 개의 인스턴스가 필요한 경우도 있고, 단 하나의 인스턴스만 필요한 경우도 있다. 객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴을 싱글톤 패턴(singleton pattern) 이라고 한다. 우리가 여기서 살펴볼 싱글톤 패턴은 static을 응용하여 프로그램 전반에서 사용하는 인스턴스를 하나만 구현하는 방식이다.   어떤 회사의 직원들을 객체지향으로 구현한다고 가정해보자. 직원은 여러명이겠지만, 회사는 하나다.  이런 경우에 직원 인스턴스는 여러 개를 생성하는 것이 당연하지만, 회사 객체는 하나여야 할 것 이다.  그럼 싱글톤 패턴으로 company 클래스를 단계적으로 만들어 보자.   싱글톤 패턴으로 회사 클래스 구현하기  단계 1 : 생성자를 private로 만들기  생성자가 하나도 없는 클래스는 컴파일러가 자동으로 디폴트 생성자를 만들어 주는데, 이 생성자는 항상 public이다. 생성자가 public이면 외부에서 접근이 가능하기 때문에 인스턴스를 여러 개 생성 할 수 있다. 따라서 싱글톤 패턴에서는 생성자를 반드시 명시적으로 만들고, 그 접근 제어자를 private로 설정해야한다.  1 2 3 4 5 6 7 package singleton;  public class Company {     private Company(){              } }  단계 2 : 클래스 내부에 static으로 유일한 인스턴스 생성하기  단계 1에서 접근제어자를 private로 함으로써 외부 인스턴스를 생성할 수 없도록 만들었다. 하지만 우리가 프로그램에서 사용할 인스턴스 하나는 필요하기 때문에, Compony 클래스 내부에서 하나의 인스턴스를 생성한다. 이 인스턴스가 프로그램 전체에서 사용가능한 유일한 인스턴스가 된다.  이 또한 private으로 선언해야만 외부에서 이 인스턴스에 접근 할 수 없어, 인스턴스 오류가 방지된다.  1 2 3 4 5 6 package singleton;  public class Company {     private static Company instance = new Company();     private Company(){ } }  단계 3 : 외부에서 참조 할 수 있는 public 메서드 만들기  이제 private으로 선언한 유일한 인스턴스인 instance를 외부에서도 사용가능 하게 설정해야한다.  이를 위해 public 메서드를 사용해 유일한 인스턴스를 반환하게 한다. 이때 인스턴스를 반환하는 메서드는 반드시 static으로 선언해주어야 인스턴스 생성과 상관없이 호출이 가능하다.  1 2 3 4 5 6 7 8 9 10 11 12 13 package singleton;  public class Company {     private static Company instance = new Company();     private Company(){ }      public static Company getInstance(){         if(instance== null){             instance = new Company();         }         return instance;     } }   단계 4 : 실제로 사용하는 코드 만들기  외부 클래스에서는 Company를 생성할 수 없으므로 getInstance() 메서드를 호출한다.     Company.getInstance(); 와 같이 호출하면 유일한 인스턴스를 받아온다.      두 인스턴스를 만들어 주소 값이 같은지 확인해보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 package singleton;  public class CompanyTest {     public static void main(String[] args){         Company myCompany1 = Company.getInstance();         Company myCompany2 = Company.getInstance();         System.out.println(myCompany1 == myCompany2);     } }  &gt;&gt;&gt; true  두개의 인스턴스를 만들었지만, 받아온 인스턴스는 동일한 주소 값을 가지는, 아까 만들었던 유일한 인스턴스를 받아왔음을 알 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%8B%B1%EA%B8%80%ED%86%A4-%ED%8C%A8%ED%84%B4/",
        "teaser": null
      },{
        "title": "[Java] 참조 자료형, 정보은닉",
        "excerpt":"참조 자료형  크기가 정해진 기본 자료형 ( int, char, float, double등)으로 선언하는 변수가 있고, 클래스 자료형으로 선언하는 참조 자료형 변수가 있다. 참조 자료형 변수의 특징에 대해 좀 더 자세히 살펴보고, 클래스를 선언하여 참조형을 이용한 프로그램을 구현해보자.   어떤 학생이 있다고 가정하자. 이 학생이 국어와 수학 과목을 수강하는데, 이 시험의 수학과 국어 점수를 저장하는 프로그램을 만든다고 생각해보면,  1 2 3 4 5 6 7 8 package reference;  public class Student1 {     int studendID;     String studentName;     int koreaScore;     int mathScore; }  이렇게 Student1이라는 클래스를 만들어보았다. 근데 만약 이 클래스에 성적뿐만 아니라 이 학생이 수강하고 있는 과목의 이름도 함께 저장하고 싶다면 어떻게 해야할까? 아주 간단한 방법으로는   String을 사용해서 클래스 안에 과목이름 변수를 추가해주는 것이다.     Student2라는 과목이름 변수도 함께있는 클래스를 만들어보자   1 2 3 4 5 6 7 8 9 package reference;  public class Student1 {     int studentID;     String studentName;     int koreaScore;     int mathScore;  }  이렇게 구현하고보니, 이 클래스는 학생에 관한 클래스인데 과목에 대한 변수가 늘어나 Student라는 이름의 클래스하나로 구현하게 되면 나중에 참조 할때 헷갈리거나 문제가 생길 수 있다.   따라서 과목에 대한 변수는 Subject라는 클래스를 따로 만들어 분리해보도록 하자.  1 2 3 4 5 6 package reference;  public class Subject {     String SubjectName;     int scorePoint; }  이렇게 Subject로 따로 클래스를 만들어 주면, 우리는 기본 자료형이 아닌 우리가 만들어준 참조 자료형으로 변수를 선언 할 수 있게된다. Subject에 과목의 이름과 과목의 점수를 저장할 수 있는 변수가 있으니, 우리는 다른 클래스에서 이 참조 자료형을 사용하여 변수를 선언 할 수가 있게 된다.   Student3 클래스를 만들어 참조자료형 선언을 해보자.  1 2 3 4 5 6 7 8 package reference;  public class Student3 {     int studentID;     String studentName;     Subject korean;     Subject math; }  이렇게 구현하게 되면 기존에는 Student2 클래스의 경우처럼 과목이름을 koreanSubjectName, mathSubjectName 이런식으로 두개의 변수를 추가 해주어야 한다. 그러나 Subject와 같이 클래스를 분리해주면 subjectName은 Subject클래스에 선언한뒤 korean.subjectName과 같이 사용해줄 수 있어 매우 편리하다.   정보 은닉  지금까지 클래스를 선언할때 public이라는 예약어를 사용하였다. 이제 이 예약어가 어떤 의미를 갖는지에 대해 알아보자.   객체 지향 프로그램에서는 예약어를 사용하여 클래스 내부의 변수나 메서드, 생성자에 대한 접근 권한을 지정한다. 이러한 예약어들을 접근 제어자(acces modifier) 라고 하는데, 우리가 사용하던 public이라고 선언했던 예약어는 외부클래스에서 접근이 가능하게 설정되었다는 뜻이다. 반대로 외부클래스에서 사용하게 하고 싶지 않은 클래스는 private으로 선언해주면 된다.  1 2 3 4 5 6 7 8 package hiding;  public class Student {     int studentID;     private String studentName;     int grade;     String address; }  위 코드는 Student라는 클래스를 만들어주어 안에 변수를 만들어주었는데, studentName 변수를 private를 사용하여 선언해주었다.  이렇게 private 예약어를 사용한 변수를 한번 다른 클래스에서 접근해보면,  1 2 3 4 5 6 7 8 9 10 package hiding;  public class StudentTest {     public static void main(String[] args){         Student studentLee = new Student();         studentLee.studentName = \"이민재\";          System.out.println(studentLee.getStudentName());     } }  위의 코드는 private로 선언한 studentName 변수에 접근했으므로, 프로그램에서 오류를 출력한다.   그렇다면 private으로 선언한 studentName에 접근하고 싶다면 어떻게 해야 할까? 이 때 사용 할 수 있는것이 바로 내부클래스에서 접근을 할수 있도록 해주는 메서드를 만들어 주는 것이다.     다시 Student 파일을 열어 메서드 두개를 추가해주도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package hiding;  public class Student {     int studentID;     private String studentName;     int grade;     String address;          public String getStudentName(){         return studentName     }          public void setStudentName(String studentName){         this.studentName = studentName;     } }  getStudentName() 클래스는 public으로 선언되어 있으며, 이 메서드는 studentName과 같은 클래스에 있으므로 접근도 가능하다. 그럼 직접 저 변수에 접근하는게 아니라 우리가 만들어준 메서드를 사용하여 우리가 private로 선언한 studentName에 접근해보자.  1 2 3 4 5 6 7 8 9 10 package hiding;  public class StudentTest {     public static void main(String[] args){         Student studentLee = new Student();         studentLee.setStudentName(\"이민재\");          System.out.println(studentLee.getStudentName());     } }  이렇게 우리가 만들어준 메서드로 접근을 할 수 있도록 코드를 작성해주니, 올바르게 프로그램에 동작하는 것을 볼 수 있다.   굳이 이렇게 직접 변수에대한 접근을 막는 private 예약어를 제공해주는 이유는 무엇일까??  만약 우리가 날짜를 받는 기능을 구현한다고 생각해보자.   각 달은 30일, 31일을 가지며, 2월의 경우에는 28일의 날짜를 갖는데, 만약 public으로 변수를 선언하고 변수를 직접 대입해주면 2월에도 30일이 들어갈 수 있는 오류가 생길 것이다.  따라서 이럴때는 변수를 private로 선언해 준뒤, set() 메서드를 만들어주어, 직접 set() 메서드가 이 월에 따른 일수가 맞는지를 판별하여 일수가 일치하는 경우에만 해당 변수에 날짜를 대입하도록 만들 수 가 있다.   이처럼 클래스 내부에서 사용할 변수는 private로 선언해주어 외부의 접근을 막아주면, 우리가 예상치 못한 오류들을 막아내는데 유용하게 사용할 수 있다.                  접근 제어자       설명                       public       외부클래스 어디에서나 접근 가능                 protected       같은 패키지 내부와 상속관계의 클래스에서만 접근가능                 아무것도 없는 경우       default이며, 같은 패키지 내부에서만 접근 가능                 private       같은 클래스 내부에서만 접근가능          ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%B0%B8%EC%A1%B0%EC%9E%90%EB%A3%8C%ED%98%95,-%EC%A0%95%EB%B3%B4%EC%9D%80%EB%8B%89/",
        "teaser": null
      },{
        "title": "[Programmers] 쿼드 압축 후 개수 세기 (Python3)",
        "excerpt":"문제  0과 1로 이루어진 2n x 2n 크기의 2차원 정수 배열 arr이 있습니다. 당신은 이 arr을 쿼드 트리와 같은 방식으로 압축하고자 합니다. 구체적인 방식은 다음과 같습니다.  당신이 압축하고자 하는 특정 영역을 S라고 정의합니다.   만약 S 내부에 있는 모든 수가 같은 값이라면, S를 해당 수 하나로 압축시킵니다.  그렇지 않다면, S를 정확히 4개의 균일한 정사각형 영역(입출력 예를 참고해주시기 바랍니다.)으로 쪼갠 뒤, 각 정사각형 영역에 대해 같은 방식의 압축을 시도합니다.   arr이 매개변수로 주어집니다. 위와 같은 방식으로 arr을 압축했을 때, 배열에 최종적으로 남는 0의 개수와 1의 개수를 배열에 담아서 return 하도록 solution 함수를 완성해주세요.   제한사항  arr의 행의 개수는 1 이상 1024 이하이며, 2의 거듭 제곱수 형태를 하고 있습니다. 즉, arr의 행의 개수는 1, 2, 4, 8, …, 1024 중 하나입니다.   arr의 각 행의 길이는 arr의 행의 개수와 같습니다. 즉, arr은 정사각형 배열입니다.  arr의 각 행에 있는 모든 값은 0 또는 1 입니다.   입출력 예  1 2 3 4 5 6 7 arr                                          result [[1,1,0,0],[1,0,0,0],[1,0,0,1],[1,1,1,1]]    [4,9]  [[1,1,1,1,1,1,1,1],[0,1,1,1,1,1,1,1], [0,0,0,0,1,1,1,1],[0,1,0,0,1,1,1,1], [0,0,0,0,0,0,1,1],[0,0,0,0,0,0,0,1], [0,0,0,0,1,0,0,1],[0,0,0,0,1,1,1,1]]        [10,15]  입출력 예 설명  입출력 예 #1  다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.    최종 압축 결과에 0이 4개, 1이 9개 있으므로, [4,9]를 return 해야 합니다.   입출력 예 #2  다음 그림은 주어진 arr을 압축하는 과정을 나타낸 것입니다.    최종 압축 결과에 0이 10개, 1이 15개 있으므로, [10,15]를 return 해야 합니다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def solution(arr):     answer = [0,0]     N = len(arr)     def quad(x,y,n):         start = arr[x][y]         for i in range(x,x+n):             for j in range(y,y+n):                 if start != arr[i][j]:                     end = n//2                     quad(x,y,end)                     quad(x+end,y, end)                     quad(x,y+end,end)                     quad(x+end,y+end,end)                     return         answer[start] += 1       quad(0,0,N)     return answer      1 2 3 4 arr = [[1,1,0,0],        [1,0,0,0],        [1,0,0,1],        [1,1,1,1]]   1 solution(arr)   1 [4, 9]   ","categories": ["programmers"],
        "tags": ["코딩테스트","Programmers","파이썬"],
        "url": "/programmers/Programmers-%EC%BF%BC%EB%93%9C-%EC%95%95%EC%B6%95-%ED%9B%84-%EA%B0%9C%EC%88%98-%EC%84%B8%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 캐시 (Python3)",
        "excerpt":"문제  지도개발팀에서 근무하는 제이지는 지도에서 도시 이름을 검색하면 해당 도시와 관련된 맛집 게시물들을 데이터베이스에서 읽어 보여주는 서비스를 개발하고 있다.  이 프로그램의 테스팅 업무를 담당하고 있는 어피치는 서비스를 오픈하기 전 각 로직에 대한 성능 측정을 수행하였는데, 제이지가 작성한 부분 중 데이터베이스에서 게시물을 가져오는 부분의 실행시간이 너무 오래 걸린다는 것을 알게 되었다.   어피치는 제이지에게 해당 로직을 개선하라고 닦달하기 시작하였고, 제이지는 DB 캐시를 적용하여 성능 개선을 시도하고 있지만 캐시 크기를 얼마로 해야 효율적인지 몰라 난감한 상황이다.   어피치에게 시달리는 제이지를 도와, DB 캐시를 적용할 때 캐시 크기에 따른 실행시간 측정 프로그램을 작성하시오.   입력 형식  캐시 크기(cacheSize)와 도시이름 배열(cities)을 입력받는다.  cacheSize는 정수이며, 범위는 0 ≦ cacheSize ≦ 30 이다.  cities는 도시 이름으로 이뤄진 문자열 배열로, 최대 도시 수는 100,000개이다.  각 도시 이름은 공백, 숫자, 특수문자 등이 없는 영문자로 구성되며, 대소문자 구분을 하지 않는다. 도시 이름은 최대 20자로 이루어져 있다.   출력 형식  입력된 도시이름 배열을 순서대로 처리할 때, “총 실행시간”을 출력한다.   조건  캐시 교체 알고리즘은 LRU(Least Recently Used)를 사용한다.  cache hit일 경우 실행시간은 1이다.  cache miss일 경우 실행시간은 5이다.  입출력 예제  |캐시크기(cacheSize)|도시이름(cities)|실행시간|  |:—:|:—:|:—:|  3|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]|50  3|[“Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”, “Jeju”, “Pangyo”, “Seoul”]\t|21  2|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]|60  5|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”, “SanFrancisco”, “Seoul”, “Rome”, “Paris”, “Jeju”, “NewYork”, “Rome”]|52  2|[“Jeju”, “Pangyo”, “NewYork”, “newyork”]|16  0|[“Jeju”, “Pangyo”, “Seoul”, “NewYork”, “LA”]|25   문제 풀이  이 문제는 캐시메모리를 파이썬으로 간단하게 구현해보는 것인데, 카카오 문제라 그런지 한번도 풀어본 적이 없는 신유형 느낌이라 당황스러웠다. 우선 이 문제는 캐시와 LRU를 알지 못하면 아예 풀수가 없어서 이에 대해 알아야 풀 수 있다.   캐시는 메인 메모리와 CPU간의 데이터 속도 향상을 위한 중간 버퍼 역할을 하는 메모리로써, 잠시 저장해둔다는 의미를 갖고, 실제로 이 기능을 한다. 이 문제는 캐시DB를 간단하게 구현해보는 방식인데, 위 문제에서 나온 Cache Hit은 캐시에 이미 값이 저장 되어있는 값을 참조할때를 말하고, Cache Miss는 캐시메모리에 저장이 되어있지 않아서 메인 메모리로 가서 값을 캐시메모리로 저장해야 할 때를 말한다.   LRU는 캐시교체 알고리즘으로, 가장 오래전에 참조된 값을 삭제하고 새로운 데이터를 그 자리에 삽입하는 알고리즘이다. LRU를 검색하다가 캐시 교체 알고리즘에 대해 알게 되었는데, 내가 이미 큐에서 배웠던 FIFO 방식도 캐시메모리에서 비롯된 알고리즘이란걸 알게되었다.  간단하게 캐시 알고리즘을 정리 해보면 아래의 표와 같다.                  캐시 알고리즘       특징       단점                       Random       교체될 페이지를 임의 선정함       오버헤드가 적음                 FIFO(First in First Out)       캐시 내에 가장 오래있었던 페이지를 교체       자주사용되는 페이지가 교체될 우려가 있음                 LFU(Least Frequently Used)       사용 횟수가 가장 적은 페이지부터 교체       최근 적재된 페이지가 교체될 우려가 있음                 LRU(Least Recently Used)       가장 오랫동안 사용되지 않은 페이지부터 교체       time stamping에 의한 오버헤드 존재                 Optimal       향후 가장 참조되지 않을 페이지부터 교체       참조될 것을 미리 알 수 없기 떄문에 실현 불가능                 NUR(Not Used Recently)       참조 비트와 수정 비트로 미사용 페이지 교체, 최근 사용되지 않은 페이지 교체                         SCR(Second Chance Replacement)       최초 참조 비트 1로 셋팅, 1인 경우 0으로 세팅하고, 0인 경우 교체, 기회를 한번 더 준다.                   따라서 LRU 방식으로 캐시 교체를 하려면, 캐시라는 리스트를 하나 만들어주고 만약 이미 캐시 리스트 안에 있는 값이라면 참조 후 가장 최근위치로 변경해주고 실행시간 1추가, 만약 캐시 리스트 안에 없는 값이라면, 가장 앞에있는 값을 삭제 후 새로운 값을 넣어준 뒤 실행시간 5를 추가 해주면 된다.   주의할점은, 대소문자를 구분하지 않는다고 했기 때문에 반드시 .lower로 소문자로 통일해주어야 하며, 캐시사이즈가 0인 경우는 모두다 Cache Miss이기 때문에 예외처리를 해주어야한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def solution(cacheSize, cities):     #캐시리스트     cache = []     #실행시간     time = 0     #만약 캐시사이즈가 0인경우는 모두 miss처리한다.     if cacheSize == 0:         return len(cities)*5     #캐시 메모리에 리스트 요소 하나씩 추가     for city in cities:         #캐시메모리가 꽉찼을 경우에만 미스와 hit처리         if len(cache) == cacheSize:             #hit의 경우             if city.lower() in cache:                 cache.remove(city.lower())                 cache.append(city.lower())                 time += 1                 #print('hit:',cache)             #miss의 경우             else:                 cache.remove(cache[0])                 cache.append(city.lower())                 time+=5                 #print('miss:',cache)         #캐시메모리의 자리가 있다면 miss인 경우에도 삭제는 필요없음         else:             #hit의 경우             if city.lower() in cache:                 cache.remove(city.lower())                 cache.append(city.lower())                 time += 1                 #print('hit:',cache)             #miss의 경우             else:                 cache.append(city.lower())                 time+=5                 #print('miss:',cache)     return time   1 solution(3,[\"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\", \"Jeju\", \"Pangyo\", \"Seoul\"])   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 firstmiss: ['jeju'] firstmiss: ['jeju', 'pangyo'] firstmiss: ['jeju', 'pangyo', 'seoul'] hit: ['pangyo', 'seoul', 'jeju'] hit: ['seoul', 'jeju', 'pangyo'] hit: ['jeju', 'pangyo', 'seoul'] hit: ['pangyo', 'seoul', 'jeju'] hit: ['seoul', 'jeju', 'pangyo'] hit: ['jeju', 'pangyo', 'seoul']      21   노트  프로그래머스에서 다른 풀이를 보니 너무 예쁘게 잘 푼 풀이가 있어서 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(cacheSize, cities):     import collections     cache = collections.deque(maxlen=cacheSize)     time = 0     for i in cities:         s = i.lower()         if s in cache:             cache.remove(s)             cache.append(s)             time += 1         else:             cache.append(s)             time += 5     return time   위 풀이는 deque의 maxlen을 이용했는데, maxlen은 deque의 크기를 제한해주는 메서드로, 그 크기를 넘어서는 값이 들어오면 알아서 가장 앞에있는 값을 삭제하고 새로운 값을 채운다. 이를 사용하면 훨씬 더 파이써닉 하게 풀 수 있을 것 같다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%EC%BA%90%EC%8B%9C/",
        "teaser": null
      },{
        "title": "[Programmers] 점프와 순간 이동 (Python3)",
        "excerpt":"문제  OO 연구소는 한 번에 K 칸을 앞으로 점프하거나, (현재까지 온 거리) x 2 에 해당하는 위치로 순간이동을 할 수 있는 특수한 기능을 가진 아이언 슈트를 개발하여 판매하고 있습니다. 이 아이언 슈트는 건전지로 작동되는데, 순간이동을 하면 건전지 사용량이 줄지 않지만, 앞으로 K 칸을 점프하면 K 만큼의 건전지 사용량이 듭니다. 그러므로 아이언 슈트를 착용하고 이동할 때는 순간 이동을 하는 것이 더 효율적입니다. 아이언 슈트 구매자는 아이언 슈트를 착용하고 거리가 N 만큼 떨어져 있는 장소로 가려고 합니다. 단, 건전지 사용량을 줄이기 위해 점프로 이동하는 것은 최소로 하려고 합니다. 아이언 슈트 구매자가 이동하려는 거리 N이 주어졌을 때, 사용해야 하는 건전지 사용량의 최솟값을 return하는 solution 함수를 만들어 주세요.  예를 들어 거리가 5만큼 떨어져 있는 장소로 가려고 합니다.   아이언 슈트를 입고 거리가 5만큼 떨어져 있는 장소로 갈 수 있는 경우의 수는 여러 가지입니다.   처음 위치 0 에서 5 칸을 앞으로 점프하면 바로 도착하지만, 건전지 사용량이 5 만큼 듭니다.     처음 위치 0 에서 2 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 2) x 2에 해당하는 위치로 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 3 만큼 듭니다.      처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동됩니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 2) x 2 만큼 이동할 수 있으므로 위치 4로 이동합니다. 이때 1 칸을 앞으로 점프하면 도착하므로 건전지 사용량이 2 만큼 듭니다.      위의 3가지 경우 거리가 5만큼 떨어져 있는 장소로 가기 위해서 3번째 경우가 건전지 사용량이 가장 적으므로 답은 2가 됩니다.   제한 사항  숫자 N: 1 이상 10억 이하의 자연수     숫자 K: 1 이상의 자연수   입출력 예  |N|result|  |:—:|:—:|  |5\t|2|  |6\t|2|  |5000\t|5|   입출력 예 설명  입출력 예 #1  위의 예시와 같습니다.   입출력 예 #2  처음 위치 0 에서 1 칸을 앞으로 점프한 다음 순간이동 하면 (현재까지 온 거리 : 1) x 2에 해당하는 위치로 이동할 수 있으므로 위치 2로 이동합니다. 이때 1 칸을 앞으로 점프하면 위치3으로 이동합니다. 이때 다시 순간이동 하면 (현재까지 온 거리 : 3) x 2 이동할 수 있으므로 위치 6에 도착합니다. 이 경우가 건전지 사용량이 가장 적으므로 2를 반환해주면 됩니다.   입출력 예 #3  위와 같은 방식으로 합니다.   문제풀이  대략 읽고 당연히 bfs로 풀어야하는 문제라고 생각해서 bfs로 풀다가 도저히 안풀렸는데, 생각해보니 숫자 N의 제한사항이 1이상 10억이하라 애초에 bfs로 풀 수가 없는 문제였다.굳이 bfs로 생각하지 않아도 되는 쉬운 문제였다. 배터리를 가장 적게 사용하기 위해서는 최대한 순간이동으로 이동해야 하므로, 2씩 나눠가며 나머지가 1이 나오면 한칸 점프해야 하므로 배터리사용량을 1증가시키고, 계속 순간이동 하며 가면된다.  사실 코드난이도로 보면 이게 왜 레벨2인지 잘 모르겠지만, 아마 bfs를 함정으로 낸 문제가 아닐까 싶다.   코드  1 2 3 4 5 6 7 8 9 10 def solution(n):     battery = 0     while n!=1:         if n%2 == 0:             n = n//2         else:             n= n//2             battery += 1              return battery+1   1 solution(6)   1 2   노트  문제를 풀고 다른 사람 풀이를 보니 기가막히게 푼게 있어서 첨부한다. 이런 생각을 하는사람들 보면 진짜 똑똑한것 같다… 다음에 이렇게 2로나눠서 나머지를 사용하는 문제가 있으면 이렇게도 사용할 수 있다는 것을 알고 있어야겠다.   1 2 def solution(n):     return bin(n).count('1')   2진법으로 변환할때 나머지가 있으면 1 아니면 0으로 변환하는걸 이용해서 나머지 1의 개수를 셌다.  ","categories": [],
        "tags": [],
        "url": "/%EC%A0%90%ED%94%84%EC%99%80-%EC%88%9C%EA%B0%84-%EC%9D%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "[Java] 배열과 ArrayList",
        "excerpt":"배열 선언과 초기화  배열을 사용하려면 먼저 배열을 선언해야한다.     배열도 변수와 마찬가지로 자료형을 함께 선언하는데, 배열을 선언하는 문법은 다음과 같다.  1 2 자료형[] 배열 이름 = new 자료형[개수]; 자료형 배열 이름[] = new 자료형[개수];  예를들어 학생의 학번을 만약 배열로 선언한다고 하면,  1 int[] studentIDs = new int[10];  이렇게 선언하면 studentIDs라는 이름을 가진 int형 10자리 배열이 생성된다.   만약 선언과 동시에 배열의 값을 초기화하고 싶다면,     중괄호를 사용하면 배열의 값을 초기화하면서 선언할 수 있다.  1 int[] studentIDs = new int[]{101,102,103}  이때, 알아서 초기화 되는 갯수 만큼 배열이 생성되므로, []안의 개수는 생략해야한다.  또 다음과 같이 new int[] 부분을 아예 생략할 수도 있다.  1 int[] studentIDs = {102,102,103}  배열 사용하기  선언한 배열의 요소에 접근하려면 [ ]를 사용한다.     만약 배열의 첫번째 요소에 10을 저장한다면 아래처럼 코드를 작성하면된다.  1 studentIDs[0] = 10;  배열의 순서는 항상 0부터 시작한다.   그럼 위의 코드를 하나의 프로그램으로 해서 배열을 출력해보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package array;  public class ArrayTest {     public static void main(String[] args){         int[] num = new int[] {1,2,3,4,5,6,7,8,9,10};          for (int i = 0;i&lt;num.length;i++){             System.out.println(num[i]);         }     } } &gt;&gt;&gt; 1 &gt;&gt;&gt; 2 &gt;&gt;&gt; 3 &gt;&gt;&gt; 4 &gt;&gt;&gt; 5 &gt;&gt;&gt; 6 &gt;&gt;&gt; 7 &gt;&gt;&gt; 8 &gt;&gt;&gt; 9 &gt;&gt;&gt; 10  위처럼 배열에 담긴 1부터 10까지의 수가 차례로 출력된것을 볼 수 있다.   자바의 배열은 배열길이를 가지는 legth 속성을 가지는데, 자바에서 배열길이는 처음에 선언한 배열의 전체 요소 개수를 의미한다. 전체 길이를 알고 싶은 배열 이름뒤에 도트 연산자를 붙이고 length 속성을 쓰면 배열 길이를 반환해준다. for문으로 배열의 모든 요소를 출력하고 싶다면, 조건식에 .length를 사용해줌으로써 배열의 길이만큼 출력하도록 할 수 있다.   그럼 빈 값이 들어가있는 배열에서 값이 있는 요소만 출력하고 싶다면 어떻게 해야 할까?  아래의 코드와 같이 size라는 변수를 하나 더 만들어 사용해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package array;  public class ArrayTest {     public static void main(String[] args){         int[] num = new int[5];         int size = 0;        num[0] = 10; size++;        num[1] = 20; size++;        num[2] = 30; size++;         for(int i = 0;i&lt;size;i++){            System.out.println(num[i]);        }     } }   객체 배열 사용하기  이번에는 참조 자료형으로 선언하는 객체 배열에 대해 알아보자.     동일한 기본 자료형 변수 여러개를 사용할 수 있듯이 참조자료형 변수도 여러 개를 배열로 사용 가능하다. 책과 책 저자를 저장하는 클래스 Book을 만들어 객체 배열을 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package array;  public class Book {     private  String bookName;     private String author;      public Book(){}          public Book(String bookName, String author){         this.bookName = bookName;         this.author = author;     }     public String getBookName(){         return bookName;     }     public void setBookName(String bookName){         this.bookName = bookName;     }     public String getAuthor(){         return author;     }     public void setAuthor(String author){         this.author =author;     }     public  void showBookInfo(){         System.out.println(bookName+\",\"+author);     } }  Book 클래스를 만들어 책이름과 저자를 저장하는 변수 bookName, author를 만들어주고, 각각을 받아오는 get 함수와 각각을 저장하는 set함수를 만들고, 마지막으로 책이름과 저자를 출력하는 showBookInfo 함수를 만들어주었다.   이제 도서관에 책이 5권있다고 가정하고 Book클래스를 사용하여 책 5권을 객체 배열로 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package array;  public class BookArray {     public static void main(String[] args){         Book[] library = new Book[5];          for(int i = 0; i&lt;library.length;i++){             System.out.println(library[i]);         }     } }  &gt;&gt;&gt; null &gt;&gt;&gt; null &gt;&gt;&gt; null &gt;&gt;&gt; null  library = new Book[5]; 를 보면 마치 5개의 인스턴스가 생성된 것처럼 보이지만, 실제로는 인스턴스를 가리키는 주소값을  담을 공간 5개를 생성하는 문장이다. 따라서 이 코드를 실행하게 되면 Book의 주소를 담을 공간 5개가 만들어지고 자동으로 공간이 null로 초기화 된다.   그럼 이제 만들어준 빈공간에 인스턴스를 만들어 저장해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package array;  public class BookArray2 {     public static void main(String[] args){         Book[] library = new Book[5];                  library[0] = new Book(\"태백산맥\", \"조정래\");         library[1] = new Book(\"데미안\", \"헤르만 헤세\");         library[2] = new Book(\"1q84\", \"무라카미 하루키\");         library[3] = new Book(\"토지\", \"박경리\");         library[4] = new Book(\"어린왕자\", \"생택쥐페리\");              for(int i = 0;i&lt;library.length;i++){             library[i].showBookInfo();         }              } }  &gt;&gt;&gt; 태백산맥,조정래 &gt;&gt;&gt; 데미안,헤르만 헤세 &gt;&gt;&gt; 1q84,무라카미 하루키 &gt;&gt;&gt; 토지,박경리 &gt;&gt;&gt; 어린왕자,생택쥐페리  출력값을 보면 각 인스턴스가 모두 잘 생성되었음을 알 수 있다.   배열 복사하기  기존 배열과 자료형 및 크기가 똑같은 배열을 새로 만들거나 배열의 모든 요소에 자료가 꽉 차서 더 큰 배열을 만들어   기존 배열에 저장된 자료를 가져오려고 할 때, 배열을 복사한다.     배열을 복사하는 방법은 두 가지가 있는데, 첫 번째는 기존 배열과 배열 길이가 같거나 더 긴 배열을 만들고 for문을 사용하여 각 요소 값을 반복해서 복사하는 법이고, 두 번째는 System.arraycopy() 메서드를 사용하는 방법이다.   Sysyem.arraycopy(src,srcPos,dest,destPos,length)   각 매개변수의 의미는 다음과 같다.                  매개변수       설명                       src       복사할 배열 이름                 srcPos       복사할 배열의 첫 번째 위치                 dest       복사해서 붙여 넣을 대상 배열 이름                 destPos       복사해서 대상 배열에 붙여 넣기를 시작할 첫 번째 위치                 length       src에서 dest로 자료를 복사할 요소 개수           그럼 예제를 통해 실제로 배열을 한번 복사해보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 package array;  public class ArrayCopy {     public static void main(String[] args){         int[] array1 = {10,20,30,40,50};         int[] array2 = {1,2,3,4,5};          System.arraycopy(array1,0,array2,1,4);         for(int i = 0;i&lt;array2.length;i++){             System.out.println(array2[i]);         }     } }  src = array1, dest = array2 이므로 array1에 있는 값을 array2에 복사한다.     srcPos = 0, destPos = 1 이므로, array1의 값은 0부터 array2의 1부터의 공간에 length인 4만큼의 길이로 복사된다.  이때, 복사할 대상 배열의 길이가 복사할 요소 개수보다 작다면 오류가 난다.   이번에는 객체 배열을 복사해보자.     객체 배열도 마찬가지로 동일한 방식으로 복사해서 사용 할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package array;  public class ObjectCopy1 {     public static void main(String[] args){         Book[] library1 = new Book[3];         Book[] library2 = new Book[3];           library1[0] = new Book(\"태백산맥\", \"조정래\");         library1[1] = new Book(\"데미안\", \"헤르만 헤세\");         library1[2] = new Book(\"1q84\", \"무라카미 하루키\");          System.arraycopy(library1,0,library2,0,3);          for(int i=0;i&lt; library2.length;i++){             library2[i].showBookInfo();         }     } } &gt;&gt;&gt; 태백산맥,조정래 &gt;&gt;&gt; 데미안,헤르만 헤세 &gt;&gt;&gt; 1q84,무라카미 하루키   다음과 같이 library1의 인스턴스가 library2로 복사된 것을 확인 할 수 있다.     이 상태에서 만약 library1의 값을 변경하게 되면 어떻게 될까??     예제를 통해 확인해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package array;  public class ObjectCopy2 {         public static void main(String[] args){             Book[] library1 = new Book[3];             Book[] library2 = new Book[3];               library1[0] = new Book(\"태백산맥\", \"조정래\");             library1[1] = new Book(\"데미안\", \"헤르만 헤세\");             library1[2] = new Book(\"1q84\", \"무라카미 하루키\");              System.arraycopy(library1,0,library2,0,3);              library1[0].setBookName(\"나목\");             library1[0].setAuthor(\"박완서\");                          for(int i=0;i&lt; library2.length;i++){                 library2[i].showBookInfo();                      }     }  }  &gt;&gt;&gt; 나목,박완서 &gt;&gt;&gt; 데미안,헤르만 헤세 &gt;&gt;&gt; 1q84,무라카미 하루키  library1[0]의 값을 변경해주었는데, library2[0]의 값도 변경되었다.     이는 객체 배열의 요소에 저장된 값은 인스턴스 자체가 아니고, 인스턴스의 주소 값이기 때문이다. 따라서 객체 배열을 복사하게되면 인스턴스를 따로 생성하는게 아닌, 기존 인스턴스의 주소값만을 복사하게된다. 결국 두 배열의 서로 다른 요소가 같은 인스턴스를 가리키고 있으므로, 복사되는 배열의 인스턴스 값이 변경되면 두 배열 모두 영향을 받게되는 것이다. 이런 복사를 얕은 복사(shallow copy) 라고 한다.   그렇다면 실제로 두 배열의 요소가 각각 다른 주소값의 인스턴스를 가르키도록 복사하려면 어떻게 해야할까?   이렇게 하고 싶다면, 직접 인스턴스를 만들어 요소 값을 복사해야 한다.      아래의 코드를 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package array;  public class ObjectCopy3 {     public static void main(String[] args){         Book[] library1 = new Book[3];         Book[] library2 = new Book[3];          library1[0] = new Book(\"태백산맥\",\"조정래\");         library1[1] = new Book(\"데미안\", \"헤르만 헤세\");         library1[2] = new Book(\"1q84\", \"무라카미 하루키\");          library2[0] = new Book();         library2[1] = new Book();         library2[2] = new Book();                  for(int i = 0;i&lt; library2.length;i++){             library2[i].setBookName(library1[i].getBookName());             library2[i].setAuthor(library1[i].getAuthor());         }          library1[0].setBookName(\"나목\");         library1[0].setAuthor(\"박완서\");          for(int i =0;i&lt; library2.length;i++){             library2[i].showBookInfo();         }      } }  위의 코드는 library2의 인스턴스를 직접 만들어 준뒤, setBookName과 setAuthor를 사용하여 하나 하나의 값에 요소값을 복사 해주었다.     이렇게 하면 복사한 배열 요소는 기존 배열 요소와 서로 다른 인스턴스를 가르키므로 기존 배열의 요소값이 변경되어도 영향을 받지 않는다는 것을 알 수 있다.   향상된 for문과 배열  자바 5부터 제공되는 향상된 for문(enhanced for loop) 은 배열의 처음에서 끝까지 모든 요소를 참조할 때 사용하면 편리한 반복문으로, 향상된 for문은 배열 요소 값을 하나씩 가져와 변수에 대입한다. 따로 초기화와 종료조건을 명시하지 않아도 알아서 모든 배열의 시작요소부터 끝 요소까지를 실행해준다.  1 2 3 4 5 6 7 8 9 10 11 package array;  public class EnhancedFor {     public static void main(String[] args){         String[] srtArray = {\"Java\", \"Android\", \"C\", \"JavaScript\", \"Python\"};          for(String lang : srtArray){             System.out.println(lang);         }     } }  이처럼 for문의 매개변수에 (String 변수 : 배열 )을 넣어주면 배열의 첫 요소부터 끝까지를 참조해준다.   ArrayList  우리가 앞서 배운 배열은 기본 프로그램에서 사용하기 위해서는 항상 배열의 길이를 정하고 시작해야 한다.     하지만 만약 예를 들어 100명의 학생을 위한 프로그램을 개발했는데, 어느 순간 학생 수가 100명이 넘은 경우를 생각해보자. 배열을 사용하는 중에는 배열의 길이를 변경 할 수 없기 때문에 코드를 수정해야한다.  또, 만약 한명이 중간에 전학을 가게되었다면 배열은 중간의 요소를 비워 둘 수 없으므로 배열 요소의 위치를 변경해야한다. 이 두 경우 모두 배열을 하나 하나 수정하려 한다면 매우 힘들고 복잡할 것이다.   그래서 자바는 객체 배열을 더 쉽게 사용 할 수 있도록 객체 배열클래스 ArrayList를 제공한다.      ArrayList 클래스는 객체 배열을 관리하는 멤버변수와 메서드를 따로 제공하기 때문에, 사용방법만 알아 둔다면 편리하게 사용가능하다.   ArrayList 클래스는 이미 만들어져 있는 메서드가 있는데, 가장 주로 사용하는 메서드를 정리해보자면 다음과 같다.                  메서드       설명                       boolean add(E e)       요소 하나를 배열에 추가한다. E는 요소의 자료형을 의미한다.                 int size()       배열에 추가된 요소 전체 개수를 반환한다.                 E get(int index)       배열의 index 위치에 있는 요소 값을 반환한다.                 E remove(int index)       배열의 index 위치에 있는 요소 값을 제거하고 그 값을 반환한다.                 boolean isEmpty()       배열이 비어있는지 확인한다.           add( ) 메서드를 사용하면 배열 길이와 상관없이 객체를 추가 할 수 있다. 만약 배열 요소 개수가 부족하다면  배열 크기를 더 키울 수 있도록 구현되어 있으며, 또 배열 중간의 어떤 요소가 제거되면 그 다음 요소 값을 하나씩 앞으로 이동하는 코드도 이미 구현되어 있기때문에, 훨씬 편리하게 프로그래밍 할 수 있다.   ArrayList 활용하기  ArrayList를 사용하는 방법은 다음과 같다.  1 ArrayList&lt;E&gt; 배열 이름 = new ArrayList&lt;E&gt;();  선언하는 부분 &lt;&gt;안에 사용할 객체의 자료형을 쓰면 된다.     예를들어 앞에서 살펴본 Book 클래스형을 자료형으로 사용해서 ArrayList 배열을 생성한다면 다음과 같다.  1 ArrayList&lt;Book&gt; library = new ArrayList&lt;Book&gt;();  ArrayList는 java.util 패키지에 구현되어 있는 클래스로, 현재 만든 프로그램에는 이 패키지가 포함되어 있지 않기 때문에 컴파일러에게 ArrayList를 사용하기 위해서는 컴파일러에게 ArrayList가 어디에 구현되어 있다고 알려주기 위해 코드 맨 위에 선언하는 것을 임포트(import) 한다고 한다. 즉 ArrayList를 사용하려면 ArrayList를 import해주어야 사용할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package array; import java.util.ArrayList;  public class ArrayListTest {     public static void main(String[] args){         ArrayList&lt;Book&gt; library = new ArrayList&lt;Book&gt;();          library.add(new Book(\"태백산맥\", \"조정래\"));         library.add(new Book(\"데미안\", \"헤르만 헤세\"));         library.add(new Book(\"1q84\", \"무라카미 하루키\"));         library.add(new Book(\"토지\", \"방경리\"));         library.add(new Book(\"어린왕자\", \"생택쥐페리\"));          for(int i = 0; i&lt;library.size();i++){             Book book = library.get(i);             book.showBookInfo();         }         System.out.println();          System.out.println(\"=== 향상된 for문 사용 ===\");         for(Book book : library){             book.showBookInfo();         }      } }  기본 배열에서는 [ ] 안에 배열 전체 길이를 미리 지정해야 했습니다. 하지만 ArrayList를 생성할 때는 미리 지정할 필요 없이 add( ) 메서드를 사용해 생성자만 호출하면 된다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%B0%B0%EC%97%B4%EA%B3%BC-ArrayList/",
        "teaser": null
      },{
        "title": "[Programmers] 이진 변환 반복하기 (Python3)",
        "excerpt":"문제  0과 1로 이루어진 어떤 문자열 x에 대한 이진 변환을 다음과 같이 정의합니다.  x의 모든 0을 제거합니다.  x의 길이를 c라고 하면, x를 “c를 2진법으로 표현한 문자열”로 바꿉니다.  예를 들어, x = “0111010”이라면, x에 이진 변환을 가하면 x = “0111010” -&gt; “1111” -&gt; “100” 이 됩니다.  0과 1로 이루어진 문자열 s가 매개변수로 주어집니다. s가 “1”이 될 때까지 계속해서 s에 이진 변환을 가했을 때, 이진 변환의 횟수와 변환 과정에서 제거된 모든 0의 개수를 각각 배열에 담아 return 하도록 solution 함수를 완성해주세요.   제한사항  s의 길이는 1 이상 150,000 이하입니다.  s에는 ‘1’이 최소 하나 이상 포함되어 있습니다.   입출력 예  |s\t|result|  |:—:|:—:|  |”110010101001”\t|[3,8]|  |”01110”\t|[3,3]|  |”1111111”|\t[4,1]|   입출력 예 설명  입출력 예 #1  “110010101001”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.                  회차       이진 변환 이전       제거할 0의 개수       0 제거 후 길이       이진 변환 결과                       1       “110010101001”       6       6       “110”                 2       “110”       1       2       “10”                 3       “10”       1       1       “1”           3번의 이진 변환을 하는 동안 8개의 0을 제거했으므로, [3,8]을 return 해야 합니다.   입출력 예 #2  “01110”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.                  회차       이진 변환 이전       제거할 0의 개수       0 제거 후 길이       이진 변환 결과                       1       “01110”       2       3       “11”                 2       “11”       0       2       “10”                 3       “10”       1       1       “1”           3번의 이진 변환을 하는 동안 3개의 0을 제거했으므로, [3,3]을 return 해야 합니다.   입출력 예 #3  “1111111”이 “1”이 될 때까지 이진 변환을 가하는 과정은 다음과 같습니다.                  회차       이진 변환 이전       제거할 0의 개수       0 제거 후 길이       이진 변환 결과                       1       “1111111”       0       7       “111”                 2       “111”       0       3       “11”                 3       “11”       0       2       “10”                 4       “10”       1       1       “1”           4번의 이진 변환을 하는 동안 1개의 0을 제거했으므로, [4,1]을 return 해야 합니다.   문제풀이  간단한 문제였다. 그냥 문제가 시키는대로 천천히 코드를 짜주면 풀 수 있다.  중간에 0을 제거한 숫자의 길이를 이진변환 하는것을 문제를 제대로 안읽어서 자꾸 숫자자체를 이진변환하려다가 자꾸 무한루프가 떠서 좀 걸렸는데, 제대로 풀고나서도 테스트 케이스에서 하나 시간초과가 떠서 중간에 변환과정을 줄였다.  앞으로는 문제를 잘 읽자…   코드   1 2 3 4 5 6 7 8 9 10 11 def solution(string):     string = list(string)     change = 0     zero = 0     while len(string) != 1:         zero+=string.count('0')         string = ['1']*string.count('1')         change+=1         string = list(bin(len(string))[2:])         #print(string)     return [change,zero]   1 solution(\"110010101001\")   1 [3, 8]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%9D%B4%EC%A7%84-%EB%B3%80%ED%99%98-%EB%B0%98%EB%B3%B5%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 오픈채팅방 (Python3)",
        "excerpt":"문제  카카오톡 오픈채팅방에서는 친구가 아닌 사람들과 대화를 할 수 있는데,       본래 닉네임이 아닌 가상의 닉네임을 사용하여 채팅방에 들어갈 수 있다.      신입사원인 김크루는 카카오톡 오픈 채팅방을 개설한 사람을 위해, 다양한 사람들이 들어오고, 나가는 것을 지켜볼 수 있는 관리자창을 만들기로 했다. 채팅방에 누군가 들어오면 다음 메시지가 출력된다.   “[닉네임]님이 들어왔습니다.”   채팅방에서 누군가 나가면 다음 메시지가 출력된다.   “[닉네임]님이 나갔습니다.”   채팅방에서 닉네임을 변경하는 방법은 다음과 같이 두 가지이다.     채팅방을 나간 후, 새로운 닉네임으로 다시 들어간다.   채팅방에서 닉네임을 변경한다.  닉네임을 변경할 때는 기존에 채팅방에 출력되어 있던 메시지의 닉네임도 전부 변경된다.     예를 들어, 채팅방에 “Muzi”와 “Prodo”라는 닉네임을 사용하는 사람이 순서대로 들어오면 채팅방에는 다음과 같이 메시지가 출력된다.   “Muzi님이 들어왔습니다.”      “Prodo님이 들어왔습니다.”   채팅방에 있던 사람이 나가면 채팅방에는 다음과 같이 메시지가 남는다.   “Muzi님이 들어왔습니다.”      “Prodo님이 들어왔습니다.”     “Muzi님이 나갔습니다.”   Muzi가 나간후 다시 들어올 때, Prodo 라는 닉네임으로 들어올 경우 기존에 채팅방에 남아있던 Muzi도 Prodo로 다음과 같이 변경된다.   “Prodo님이 들어왔습니다.”      “Prodo님이 들어왔습니다.”      “Prodo님이 나갔습니다.”      “Prodo님이 들어왔습니다.”   채팅방은 중복 닉네임을 허용하기 때문에, 현재 채팅방에는 Prodo라는 닉네임을 사용하는 사람이 두 명이 있다. 이제, 채팅방에 두 번째로 들어왔던 Prodo가 Ryan으로 닉네임을 변경하면 채팅방 메시지는 다음과 같이 변경된다.   “Prodo님이 들어왔습니다.”      “Ryan님이 들어왔습니다.”      “Prodo님이 나갔습니다.”       “Prodo님이 들어왔습니다.”   채팅방에 들어오고 나가거나, 닉네임을 변경한 기록이 담긴 문자열 배열 record가 매개변수로 주어질 때, 모든 기록이 처리된 후, 최종적으로 방을 개설한 사람이 보게 되는 메시지를 문자열 배열 형태로 return 하도록 solution 함수를 완성하라.   제한사항  record는 다음과 같은 문자열이 담긴 배열이며, 길이는 1 이상 100,000 이하이다.     다음은 record에 담긴 문자열에 대한 설명이다.     모든 유저는 [유저 아이디]로 구분한다.   [유저 아이디] 사용자가 [닉네임]으로 채팅방에 입장 - “Enter [유저 아이디] [닉네임]” (ex. “Enter uid1234 Muzi”)   [유저 아이디] 사용자가 채팅방에서 퇴장 - “Leave [유저 아이디]” (ex. “Leave uid1234”)   [유저 아이디] 사용자가 닉네임을 [닉네임]으로 변경 - “Change [유저 아이디] [닉네임]” (ex. “Change uid1234 Muzi”)  첫 단어는 Enter, Leave, Change 중 하나이다.  각 단어는 공백으로 구분되어 있으며, 알파벳 대문자, 소문자, 숫자로만 이루어져있다.   유저 아이디와 닉네임은 알파벳 대문자, 소문자를 구별한다.   유저 아이디와 닉네임의 길이는 1 이상 10 이하이다.   채팅방에서 나간 유저가 닉네임을 변경하는 등 잘못 된 입력은 주어지지 않는다.     입출력 예      |record\t|result|  |:—:|:—:|  |[“Enter uid1234 Muzi”, “Enter uid4567 Prodo”,”Leave uid1234”,”Enter uid1234 Prodo”,”Change uid4567 Ryan”]|\t[“Prodo님이 들어왔습니다.”, “Ryan님이 들어왔습니다.”, “Prodo님이 나갔습니다.”, “Prodo님이 들어왔습니다.”]|       문제풀이  이 문제는 유저아이디와 닉네임이 있으므로 딕셔너리에 유저아이디를 키로 넣고 닉네임을 밸류값으로 넣어서 호출하면 풀 수 있는 문제이다.   다만 닉네임 변경이라는 부분이 까다로워서 생각을 좀 더 하게 만들었는데, 레코드를 나눠 바로 닉네임값만 받아 메세지를 결과리스트에 추가하면 나중에 딕셔너리에서 바뀐값을 또 결과리스트에서 참조하기가 불가능해, 닉네임 변경이 어려웠다.   그래서 따로 process라는 리스트를 하나만들어준 뒤, Enter인경우는 앞에 ‘i’를 유저아이디 앞에 붙여서 저장하고, Leave인경우에는 ‘o’를 유저아이디 앞에 붙여 저장하도록 했으며, Change인 경우에는 딕셔너리에 있는 유저아이디 키값에 해당하는 밸류를 바꾸도록 했다.      그렇게 모든 레코드를 받아 process에 저장한 뒤에 process의 요소를 하나씩 받아 맨앞 글자로 Enter와 Leave를 판단한 뒤, 그 뒤에 붙어있는 유저아이디를 딕셔너리에서 호출해서 텍스트를 결과리스트에 저장하도록 했다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def solution(record):     process = []     msgdic  = dict()     result = []     for user in record:         msg = user.split()         if msg[0] == \"Enter\":             msgdic[msg[1]] = msg[2]             process.append('i'+msg[1])         if msg[0] == \"Leave\":             process.append('o'+msg[1])         else:             msgdic[msg[1]] = msg[2]     for i in process:         if i[0] == 'i':             result.append(msgdic[i[1:]]+\"님이 들어왔습니다.\")         if i[0] == 'o':              result.append(msgdic[i[1:]]+\"님이 나갔습니다.\")              return result   1 solution([\"Enter uid1234 Muzi\", \"Enter uid4567 Prodo\",\"Leave uid1234\",\"Enter uid1234 Prodo\",\"Change uid4567 Ryan\"])   1 ['Prodo님이 들어왔습니다.', 'Ryan님이 들어왔습니다.', 'Prodo님이 나갔습니다.', 'Prodo님이 들어왔습니다.']   노트  풀고나니 역시 나보다 똑똑한 사람이 푼 훨씬 깔끔한 코드가 있어 첨부한다.     이 사람은 printer라는 딕셔너리를 하나 더 만들어주어 닉네임 뒤에 붙는 메시지도 호출 할 수 있게해서 훨씬 깔끔하다. 나도 따로 process를 만들지 않고 record를 두번 참조하는 편이 메모리도 아끼고 훨씬 간단했을텐데 왜 이 생각을 못했는지 아쉽다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 def solution(record):     answer = []     namespace = {}     printer = {'Enter':'님이 들어왔습니다.', 'Leave':'님이 나갔습니다.'}     for r in record:         rr = r.split(' ')         if rr[0] in ['Enter', 'Change']:             namespace[rr[1]] = rr[2]      for r in record:         if r.split(' ')[0] != 'Change':             answer.append(namespace[r.split(' ')[1]] + printer[r.split(' ')[0]])      return answer  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9/",
        "teaser": null
      },{
        "title": "[Java] 배열 응용 프로그램",
        "excerpt":"예제 시나리오  1001학번 Lee와 1002 학번 Kim, 두 학생이 있다. Lee 학생은  2과목을 수강한다. 국어 점수가 100점, 수학 점수는 50점이다.  Kim 학생은 3과목을 수강한다. 국어 점수가 70점, 수학 점수가 85점, 영어 점수가 100점이다. Student 클래스와 Subject 클래스를 생성한 후 두 학생의 과목 성적과 총점을 각각 출력해 보자.   먼저 Student 클래스를 구현해보자.     Student 클래스는 이름과 학번, 그리고 수강과목을 멤버변수로 갖는데, 이중 수강과목은 ArrayList로 선언하여 구현한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package arraylist; import java.util.ArrayList;  public class Student {     String name;     int studentId;     ArrayList&lt;Subject&gt; subjectList;      public Student(int studentId, String name){         this.studentId = studentId;         this.name = name;         subjectList = new ArrayList&lt;Subject&gt;();     }     //생성자     public void addSubject(String name, int score){         Subject subject = new Subject();         subject.setScore(score);         subject.setName(name);         subjectList.add(subject);     }     public void showInfo(){         int total = 0;         for(Subject s: subjectList){             total += s.getScore();             System.out.println(\"학생\" + name + \"의\" + s.getName()+\"과목 성적은\"+s.getScore()+\"입니다.\");         }         System.out.println(\"총점은\"+total);     } }  Student 클래스는 과목을 추가하는 addSubject와 정보를 출력하는 showInfo 메서드를 갖는다.  여기서 ArrayList의 자료형으로 Subject 클래스를  선언했으므로 Subject 클래스를 만들어주자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package arraylist;  public class Subject {     private String name;     private int score;      public Subject(){         this.name = name;         this.score = score;     }     public void setName(String name){         this.name = name;     }     public String getName(){         return name;     }     public void setScore(int score) {         this.score =  score;     }     public int getScore() {         return score;     }  }  Student 인스턴스의 addSubject 메서드안에 있는 Subject의 메서드를 만들어주어야 하므로, 점수와 이름을 private 멤버변수로 선언해주고, 각각의 변수에 값을 할당하는 함수 setName과 setScore를 만들어준다.   이제 ArrayListTest 클래스를 만들어 main함수로써 우리가 위에 만들었던 클래스들이 동작하도록, Lee와 Kim의 인스턴스를 선언해 주고 과목과 점수를 입력후, 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package arraylist;  public class ArrayListTest {     public static void main(String[] args){         Student Lee = new Student(1001, \"Lee\");         Lee.addSubject(\"국어\",100);         Lee.addSubject(\"수학\",50);          Student Kim = new Student(1002, \"Kim\");         Kim.addSubject(\"국어\", 70);         Kim.addSubject(\"수학\", 85);         Kim.addSubject(\"영어\", 100);          Lee.showInfo();         System.out.println(\"---------------------------\");         Kim.showInfo();     }  }  &gt;&gt;&gt; 학생Lee의국어과목 성적은100입니다. &gt;&gt;&gt; 학생Lee의수학과목 성적은50입니다. &gt;&gt;&gt; 총점은150 &gt;&gt;&gt; --------------------------- &gt;&gt;&gt; 학생Kim의국어과목 성적은70입니다. &gt;&gt;&gt; 학생Kim의수학과목 성적은85입니다. &gt;&gt;&gt; 학생Kim의영어과목 성적은100입니다. &gt;&gt;&gt; 총점은255  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%B0%B0%EC%97%B4-%EC%9D%91%EC%9A%A9-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8/",
        "teaser": null
      },{
        "title": "[Programmers] 배달 (Python3)",
        "excerpt":"문제  N개의 마을로 이루어진 나라가 있습니다. 이 나라의 각 마을에는 1부터 N까지의 번호가 각각 하나씩 부여되어 있습니다. 각 마을은 양방향으로 통행할 수 있는 도로로 연결되어 있는데, 서로 다른 마을 간에 이동할 때는 이 도로를 지나야 합니다. 도로를 지날 때 걸리는 시간은 도로별로 다릅니다. 현재 1번 마을에 있는 음식점에서 각 마을로 음식 배달을 하려고 합니다. 각 마을로부터 음식 주문을 받으려고 하는데, N개의 마을 중에서 K 시간 이하로 배달이 가능한 마을에서만 주문을 받으려고 합니다. 다음은 N = 5, K = 3인 경우의 예시입니다.     위 그림에서 1번 마을에 있는 음식점은 [1, 2, 4, 5] 번 마을까지는 3 이하의 시간에 배달할 수 있습니다. 그러나 3번 마을까지는 3시간 이내로 배달할 수 있는 경로가 없으므로 3번 마을에서는 주문을 받지 않습니다. 따라서 1번 마을에 있는 음식점이 배달 주문을 받을 수 있는 마을은 4개가 됩니다.   마을의 개수 N, 각 마을을 연결하는 도로의 정보 road, 음식 배달이 가능한 시간 K가 매개변수로 주어질 때, 음식 주문을 받을 수 있는 마을의 개수를 return 하도록 solution 함수를 완성해주세요.   제한사항     마을의 개수 N은 1 이상 50 이하의 자연수입니다.   road의 길이(도로 정보의 개수)는 1 이상 2,000 이하입니다.   road의 각 원소는 마을을 연결하고 있는 각 도로의 정보를 나타냅니다.   road는 길이가 3인 배열이며, 순서대로 (a, b, c)를 나타냅니다.   a, b(1 ≤ a, b ≤ N, a != b)는 도로가 연결하는 두 마을의 번호이며, c(1 ≤ c ≤ 10,000, c는 자연수)는 도로를 지나는데 걸리는 시간입니다.   두 마을 a, b를 연결하는 도로는 여러 개가 있을 수 있습니다.   한 도로의 정보가 여러 번 중복해서 주어지지 않습니다.   K는 음식 배달이 가능한 시간을 나타내며, 1 이상 500,000 이하입니다.   임의의 두 마을간에 항상 이동 가능한 경로가 존재합니다.   1번 마을에 있는 음식점이 K 이하의 시간에 배달이 가능한 마을의 개수를 return 하면 됩니다.     입출력 예      |N\t|road\t|K\t|result|  |:—:|:—:|:—:|:—:|  |5\t|[[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]]\t|3\t|4|  |6\t|[[1,2,1],[1,3,2],[2,3,2],[3,4,3],[3,5,2],[3,5,3],[5,6,1]]|4|\t4       입출력 예 설명  입출력 예 #1      문제의 예시와 같습니다.   입출력 예 #2      주어진 마을과 도로의 모양은 아래 그림과 같습니다.         1번 마을에서 배달에 4시간 이하가 걸리는 마을은 [1, 2, 3, 5] 4개이므로 4를 return 합니다.   문제풀이  맨 처음에는 bfs나 dfs로 풀려고 했는데, 아무리 풀어봐도 거리를 저장하는게 어려워서 해답을 찾아봤다. 이 문제는 다익스트라 알고리즘(dijkstra algorithm) 으로 푸는 문제로, 다익스트라 알고리즘은 최단거리를 구할 때 사용하는 알고리즘이다. 보통 노드와 노드, 그리고 노드 사이의 거리 or 시간의 세가지가 주어질 때 사용하는 알고리즘으로, 힙큐와 bfs를 일정 부분 섞어서 사용하는 알고리즘이다.   다익스트라 알고리즘은 그리디 알고리즘의 한 종류로, 매 상황에서 가장 비용이 적은 노드를 선택해 과정을 반복함으로써 얻은 최단 경로가 실제로 가장 비용이 적은 노드가 해답이라는 가정하에 사용한다.   알고리즘의 동작 과정은 다음과 같다.     출발 노드를 설정한다.   최단 거리 테이블을 초기화한다.   방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.   해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.   3번과 4번을 반복한다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque import heapq import sys INF = sys.maxsize  def solution(N, road, K):     distance = [INF]*(N+1)     graph = [[] for _ in range(N+1)]     for i in road:         graph[i[0]].append((i[1],i[2]))         graph[i[1]].append((i[0],i[2]))          def dijkstra(start):         q = []         heapq.heappush(q,(0,start))         distance[start] = 0         while q:             dist, now = heapq.heappop(q)             if distance[now] &lt; dist:                 continue             for i in graph[now]:                 cost = dist+i[1]                 if cost &lt; distance[i[0]]:                     distance[i[0]] = cost                     heapq.heappush(q,(cost,i[0]))     dijkstra(1)     result = 0     for i in range(1, N+1):         if distance[i] &lt;= K:             result += 1              return result   1 solution(5,[[1,2,1],[2,3,3],[5,2,2],[1,4,2],[5,3,1],[5,4,2]],3)   1 2 3 4 5 6 7 [[], [(2, 1), (4, 2)], [(1, 1), (3, 3), (5, 2)], [(2, 3), (5, 1)], [(1, 2), (5, 2)], [(2, 2), (3, 1), (4, 2)]]      4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B0%B0%EB%8B%AC/",
        "teaser": null
      },{
        "title": "[Programmers] 주식가격 (Python3)",
        "excerpt":"문제  초 단위로 기록된 주식가격이 담긴 배열 prices가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 return 하도록 solution 함수를 완성하세요.   제한사항  prices의 각 가격은 1 이상 10,000 이하인 자연수입니다.      prices의 길이는 2 이상 100,000 이하입니다.   입출력 예  |prices|\treturn|  |:—:|:—:|  |[1, 2, 3, 2, 3]|\t[4, 3, 1, 1, 0]|   입출력 예 설명  1초 시점의 ₩1은 끝까지 가격이 떨어지지 않았습니다.     2초 시점의 ₩2은 끝까지 가격이 떨어지지 않았습니다.     3초 시점의 ₩3은 1초뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.     4초 시점의 ₩2은 1초간 가격이 떨어지지 않았습니다.     5초 시점의 ₩3은 0초간 가격이 떨어지지 않았습니다.     ※ 공지 - 2019년 2월 28일 지문이 리뉴얼되었습니다.   문제 풀이  이 문제는 브루트포스로 풀어도 통과가 뜨긴 하지만, 그래도 더 빠른 동작을 위해서는 스택을 사용해서 풀어야 한다. 결국 가격이 떨어지지 않은 기간은 가격이 떨어지게되는 가격의 인덱스에서 해당 인덱스를 뺀 값이기 때문에, 가격을 스택에 쌓아주다가 다음 가격이 더 크면 스택에 쌓고, 다음 가격이 더 작으면 pop해준다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(prices):     answer = [0]*len(prices)     stack = []     for i,price in enumerate(prices):         while stack and price &lt; prices[stack[-1]]:             j = stack.pop()             answer[j] = i - j             #print(stack)         stack.append(i)         #print(stack)     while stack:         j = stack.pop()         answer[j] = len(prices)-1-j                       return answer   1 solution([1, 2, 3, 2, 3])   1 2 3 4 5 6 7 8 9 10 11 12 [0] [0, 1] [0, 1, 2] [0, 1] [0, 1, 3] [0, 1, 3, 4]      [4, 3, 1, 1, 0]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%A3%BC%EC%8B%9D%EA%B0%80%EA%B2%A9/",
        "teaser": null
      },{
        "title": "[Java] 상속",
        "excerpt":"상속이란?  객체 지향 프로그래밍의 중요한 특징 중 하나가 바로 상속(inheritance) 이다. 상속은 우리가 아는 의미인 무엇인가를 물려받는다는 의미 동일하게 사용되며, 부모가 자식에게 상속을 해주면 자녀가 그 재산을 사용할 수 있듯이, 객체 지향 프로그램에서도 마찬가지로 B클래스가 A클래스를 상속받으면 B클래스는 A클래스의 멤버 변수와 메서드를 사용할 수 있게 된다. 객체 지향 프로그램은 유지 보수하기가 간편하고 프로그램을 수정하거나 새로운 내용을 추가하는 것이 유연한데, 그 기반이 되는 기술이 바로 상속이다.   클래스의 상속  우리가 일반적으로 생각할 때는 상속을 하는 클래스에서 받는 클래스로 화살표가 갈 것 같지만, 클래스 간 상속을 표현할 때는 상속받는 클래스에서 상속 해주는 클래스로 화살표가 간다.   클래스를 상속하려면 extends 예약어를 사용한다. extends는 연장, 확장한다는 의미로, A가 갖고있는 속성이나 기능을 추가로 확장하여 B클래스를 구현한다는 뜻이다. 아래와 같이 선언해주면, B클래스는 A클래스를 상속한다.  1 class B extends A{}  예를들어, 포유류와 사람의 관계를 생각해보자. 포유류는 사람보다 일반적인 개념으로써, 사람은 포유류의 특징과 기능을 기본으로 더 많거나 다른 특징과 기능을 가지고 있다. 따라서 포유류 클래스를 사람클래스에 상속해주면, 우리는 포유류의 특징과 기능은 그대로 사용하고, 이를 간단하게 변형하거나 추가하여 사용할 수 있는 것이다.   상속을 사용하여 고객 관리 프로그램 구현하기  회사에서 고객 정보를 갖고 맞춤 서비스를 제공하기 위해 고객관리 프로그램을 구현하려고 한다고 가정해보자.     그렇다면 먼저, 고객 클래스를 만들어주어야 할 것 이다. 앞서 배웠듯이 고객 클래스의 속성을 멤버 변수로 선언 해주면 된다.      이 예제에서는 고객 아이디, 이름, 고객 등급, 보너스 포인트, 보너스 포인트 적립 비율을 속성으로 선언한다고 해보겠다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package inheritance;  public class Customer {     private int customerID;     private String customerName;     private String customerGrade;     int bonusPoint;     double bonusRatio;      public Customer(){         customerGrade = \"SILVER\";         bonusRatio = 0.01;     }     public int calcPrice(int price) {         bonusPoint += price * bonusRatio;         return price;     }     public String getCustomerInfo(){         return customerName+\" 님의 등급은 \"+ customerGrade+\"이며, 보너스 포인트는\"+bonusPoint+\"입니다.\";     } }  위의 클래스는 인스턴스가 생성될 경우 기본적으로 customerGrade가 SILVER 등급으로 설정되고, bonusRatio가 0.01로 설정된다.  또, 보너스 포인트를 적립하고 지불 가격을 계산하는 calcPrice() 메서드와 고객 정보를 가져오는 getCustomerInfo() 메서드를 갖고있다.   그럼 이제 이러한 상황에서 새로운 고객등급이 필요한 경우를 생각해보자.      만약 고객이 점점 늘어나고 판매가 늘어나 단골 고객이 생긴 경우에는, 단골 고객은 회사 매출에 많은 기여를 하는 우수 고객이기 때문에, 이들에게 더 우수한 혜택을 주어야 할 것이다. 우수 고객 등급은 VIP 등급이며, 다음과 같은 혜택을 제공한다고 가정해보자.      제품을 살때는 항상 10% 할인   보너스 포인트를 5% 적립   담당 전문 상담원 배정   이러한 혜택을 추가하고 싶다면 어떻게 해야 할까? 가장 간단하게 생각한다면, Customer 클래스에 VIP고객 등급에 필요한 변수와 메서드를 추가하여 구현하는 것이다. 하지만 그렇게 하면 Customer 클래스의 코드가 복잡해 진다. 게다가 일반 고객의 인스턴스를 생성할 때에는 VIP 고객과 관련된 기능은 필요가 없는데, VIP 고객의 내용이 계속 생성되기 때문에 메모리 낭비가 발생할 수 있다.  따라서 이러한 경우에 상속을 사용하여 VIPCustomer 클래스를 따로 만들어주는 것이 좋다.   VIP 클래스의 경우는 Customer의 속성과 메서드를 모두 포함한 상태로 추가적인 혜택이 제공 되는 것이기 때문에, Customer를 상속하여 만들어주면 추가적인 멤버변수와 메서드만 작성해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package inheritance;  public class VIPCustomer extends Customer {     private  int agentID;     double saleRatio;          public VIPCustomer(){         customerGrade = \"VIP\";//오류 발생         bonusRatio = 0.05;         saleRatio = 0.1;              }     public  int getAgentID(){         return agentID;     } }  이렇게 위 처럼 Customer를 상속한 VIPCustomer 클래스를 만들어 보았다.     하지만, 상속을 해주었음에도 customerGrade의 변수를 사용하려고 하니, 오류가 발생한다.      우리는 아까 Customer 변수를 선언할 때 private으로 customerGrade를 선언해주었기 때문에, 이 변수를 외부 클래스에서 사용할 수 없어 오류가 발생한 것이다. 이럴 때 사용하는 것이 protected 예약어이다.   protected는 private와 동일하게 다른 외부클래스에서 접근하지 못하도록 해주지만, 하위클래스에서는 사용할 수 있도록 해준다.     따라서 상속받은 클래스에서는 public과 동일하게 작동하게 되는것이기 때문에, 외부클래스에서의 접근은 막고싶지만, 상속받은 클래스에서는 사용할 수 있도록 해주려면, protected 예약어를 사용해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package inheritance;  public class Customer {     protected int customerID;     protected String customerName;     protected String customerGrade;     int bonusPoint;     double bonusRatio;      public Customer(){         customerGrade = \"SILVER\";         bonusRatio = 0.01;     }     public int calcPrice(int price) {         bonusPoint += price * bonusRatio;         return price;     }     public String getCustomerInfo(){         return customerName+\" 님의 등급은 \"+ customerGrade+\"이며, 보너스 포인트는\"+bonusPoint+\"입니다.\";     }     public void setCustomerID(int customerID){         this.customerID = customerID;     }     public void setCustomerName(String customerName){         this.customerName = customerName;     } }   다시 Customer 클래스의 private를 protected로 변경 해줌으로써, VIPCustomer에서도 멤버 변수를 사용 할 수 있게 되었다.      추가로, 외부 클래스에서 접근 할 수 있도록, set() 메서드를 추가해주었다.   그러면 간단하게 테스트 프로그램을 만들어 다음의 예제를 구현해보자.   일반 고객 1명과 VIP 고객 1명이 있다. 일반 고객의 이름은 이순신, 아이디는 100010이고, 이 고객은 현재 보너스 포인트를 1000점 갖고있다. VIP 고객의 이름은 김유신, 아이디는 10020이며, 이 고객은 보너스 포인트를 10000점 가지고 있다고 가정해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package inheritance;  public class Test {     public static void main(String[] args){         Customer customerLee = new Customer();         customerLee.setCustomerID(10010);         customerLee.bonusPoint = 1000;         customerLee.setCustomerName(\"이순신\");         System.out.println(customerLee.getCustomerInfo());          VIPCustomer customerKim = new VIPCustomer();         customerKim.setCustomerID(10020);         customerKim.bonusPoint = 10000;         customerKim.setCustomerName(\"김유신\");         System.out.println(customerKim.getCustomerInfo());     } }  위처럼 고객들의 인스턴스를 생성하여 메서드를 사용해 이름과 고객번호, 보너스포인트를 저장해 준 뒤, 고객의 정보를 출력해보았다.   상속에서 클래스 생성과 형 변환  하위 클래스가 생성될 때는 상위 클래스의 생성자가 먼저 호출된다. 상속관계에서 클래스의 생성 과정을 살펴보면 하위 클래스가 상위 클래스의 변수와 메서드를 사용할 수 있는 이유와 하위클래스가 상위클래스의 자료형으로 형 변환이 가능한 이유를 이해하기 쉽다.   하위 클래스가 생성되는 과정  상속을 받은 하위 클래스는 상위 클래스의 변수와 메서드를 사용할 수 있다고 했었다. 즉 Test 예제를 보면, VIPCustomer 클래스로 선언한 customerKim 인스턴스는 상속받은 상위 클래스의 변수를 자기 것처럼 사용할 수 있다. 변수를 사용할 수 있다는 것은 그 변수를 저장하고 있는 메모리가 존재한다는 뜻이다. 그런데 VIPCousomer 클래스 코드에는 해당 변수가 존재하지 않는다. Custmer 클래스를 상속받았을 뿐이다. 여기서 우리는 상속된 하위 클래스가 생성되는 과정을 생각해볼 필요가 있다.   테스트 해보기 위해 Customer  클래스와 VIPCustomer 클래스 생성자에 출력문을 추가해 보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  package inheritance;   public class Customer {      protected int customerID;      protected String customerName;      protected String customerGrade;      int bonusPoint;      double bonusRatio;       public Customer(){          customerGrade = \"SILVER\";          bonusRatio = 0.01;          System.out.println(\"Customer() 생성자 호출\");      }      public int calcPrice(int price) {          bonusPoint += price * bonusRatio;          return price;      }      public String getCustomerInfo(){          return customerName+\" 님의 등급은 \"+ customerGrade+\"이며, 보너스 포인트는\"+bonusPoint+\"입니다.\";      }      public void setCustomerID(int customerID){          this.customerID = customerID;      }      public void setCustomerName(String customerName){          this.customerName = customerName;      }  }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package inheritance;  public class VIPCustomer extends Customer {     private  int agentID;     double saleRatio;          public VIPCustomer(){         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         System.out.println(\"VIPCustomer() 생성자 호출\");      }     public  int getAgentID(){         return agentID;     } }  두 클래스 모두 생성자 안에 “(생성자이름) 생성자 호출” 이라는 문자열을 출력하도록 했다.      따라서 생성자가 호출되면 위 문자열이 출력될 것이므로, 한번 생성자가 호출될때 어떻게 되는지 확인해 보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package inheritance;  public class Test2 {     public static void main(String[] args){         VIPCustomer customerKim = new VIPCustomer();         customerKim.setCustomerID(10020);         customerKim.setCustomerName(\"김유신\");         customerKim.bonusPoint = 10000;         System.out.println(customerKim.getCustomerInfo());     } }  &gt;&gt;&gt; Customer() 생성자 호출 &gt;&gt;&gt; VIPCustomer() 생성자 호출 &gt;&gt;&gt; 김유신 님의 등급은 VIP이며, 보너스 포인트는10000입니다.  Test2 클래스를 만들어 VIPCustomer의 인스턴스인 customerKim을 만들어 생성자가 어떻게 호출되는지 확인해 보았다.     출력 내용을 보면, 먼저 Customer() 생성자가 호출된 뒤, 그 다음에 VIPCustomer()가 호출되는 것을 알 수 있다.   정리해보면, 상위클래스를 상속받은 하위 클래스가 생성될 때는 반드시 상위클래스의 생성자가 먼저 호출된다.     그 이후 상위 클래스 생성자가 호출될 때 상위 클래스의 멤버 변수가 메모리에 생성되는 것이다.   따라서 상위클래스의 변수가 메모리에 먼저 생성되기 때문에 하위 클래스에서도 이 값들을 모두 사용할 수 있는 것이다.   부모를 부르는 예약어, super  super 예약어는 하위 클래스에서 상위 클래스로 접근할 때 사용한다. 하위 클래스는 상위 클래스의 주소, 즉 참조 값을 알고 있다.  이 참조 값을 갖고 있는 예약어가 바로 super로, this가 자기 자신의 참조 값을 가지고 있는 것과 같다고 생각하면 된다. 또한 supers는 상위 클래스의 생성자를 호출할 때도 사용된다.      이러한 super()는 상속된 하위 클래스를 호출하면 하위 클래스 생성자가 자동으로 호출한다.  1 2 3 4 5 6 public VIPCustomer(){     super();     customerGrade = \"VIP\";     bonusRatio = 0.05;     saleRatio = 0.1; }  위와 같이 디폴트 코드로 변환되기전에 super();를 자동으로 호출한다.   이런 경우를 생각해 보자. Customer 클래스를 생성할 때 고객 ID와 이름을 반드시 지정하도록 할때를 생각해보자. 이런 경우에 set() 메서드로 값을 지정하는게 아니고, 새로운 생성자를 만들어 매개변수로 값을 전달 받아야 할 것 이다. 즉 자동으로 생성되는 디폴트 생성자가 아닌 매개변수가 있는 생성자를 직접 구현해야 한다.  1 2 3 4 5 6 7 8 public Customer(){        this.customerID = customerID;        this.customerName = customerName;        customerGrade = \"SILVER\";        bonusRatio = 0.01;        System.out.println(\"Customer() 생성자 호출\");            }  위의 Customer 클래스의 생성자는 반드시 customerID와 customerName을 지정해야하는 생성자이다. 이렇게 디폴트 생성자가 아닌 새로운 생성자를 작성하면, Customer를 상속받은 VIPCustomer 클래스에서 오류가 발생한다.  Customer 클래스를 새로 생성할 때 반드시 멤버변수를 지정하도록 했으므로, VIPCustomer 클래스를 생성할 때도 당연히 이 멤버변수를 지정해주어야 할 것 이다. 따라서 super()를 사용하여 상위클래스의 생성자를 호출해 주어야 한다.   1 2 3 4 5 6 7 8 9 public VIPCustomer(int customerID, String customerName, int agentID){         super(customerID, customerName);         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         System.out.println(\"VIPCustomer() 생성자 호출\");         this.agentID = agentID;      }  위처럼 상위 생성자를 super()로 호출후 매개변수를 지정 해주어야 정상적으로 코드가 작동하는 것을 볼 수 있다.   상위 클래스로 묵시적 클래스 형 변환  상속을 공부하면서 우리가 이해해야 하는 중요한 관계가 클래스 간의 형 변환이다. 일단 Customer와 VIPCustomer의 관계를 생각해보자. 개념 면에서 보면 상위클래스인 Customer가 VIPCustomer보다 일반적 개념이지만, 기능 면에서 보면 VIPCustomer가 Customer보다 상위에 있다.   따라서 VIPCustomer는 VIPCustomer형이면서 동시에 Customer형이기도 하다. 즉 VIPCustomer 클래스로 인스턴스를 생성할 때 이 인스턴스의 자료형을 Customer형으로 클래스 형 변환하여 선언할 수 있다.   형 변환을 선언하는 방법은 다음과 같다.  1 Cutomer vc = new VIPCustomers();  이렇게 선언하면 VIPCustomer의 생성자가 호출되지만, 그 클래스의 자료형이 Customer로 한정된다. 따라서 선언해준 vc는 Customer 클래스의 멤버 변수와 메서드만 사용가능하게 된다.   메서드 오버라이딩  위에서 새로운 등급을 만들면서 VIP 고객에게 제공하는 할인율과 세일 가격을 어떻게 적용 할지는 구현하지 않았다. 이번에는 그 기능을 구현해보도록 하자.   상위클래스 Customer에는 제품 가격을 계산하는 calcPrice() 메서드가 이미 정의 되어있는데, 이 메서드는 포인트를 적립 후 정가를 그대로 지불한다. 그런데 VIP 고객은 정가에서 10%의 할인을 받을 수 있어야 하므로, 상위클래스인 Customer의 메서드를 그대로 사용해서는 할인이 적용되지 않는다.   이렇게 상위클래스에서 정의한 메서드가 하위 클래스에서 구현할 내용과 맞지 않는 경우에는 이 메서드를 재정의 할 수 있는데, 이를 메서드 오버라이딩(method overiding) 이라고 한다.   오버라이딩을 하려면 반환형, 메서드 이름, 매개변수 개수, 매개변수 자료형이 반드시 같아야한다. 그렇지 않으면 자바 컴파일러는 재정의한 메서드를 기존 메서드와 다른 메서드로 인식한다.   한번 VIPCustomer 에서 calPrice() 메서드를 오버라이딩 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 package inheritance;  public class VIPCustomer extends Customer {     private  int agentID;     double saleRatio;          public VIPCustomer(int customerID, String customerName){         super(customerID, customerName);         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         System.out.println(\"VIPCustomer() 생성자 호출\");       }     public int getAgentID(){         return agentID;     }     public int calcPrice(int price){         bonusPoint +=price * bonusRatio;         return price - (int)(price * saleRatio);     } }  위와 같이 calcPrice를 매개변수의 자료형 및 개수가 같고, 반환형도 int형으로 같다.      이렇게 하면 자바 컴파일러는 이 메서드를 오버라이딩한다. 이런 오버라이딩은 이클립스의 기능을 사용해서 오버라이딩 할 수도 있다.   이렇게 메서드를 오버라이딩한 결과를 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package inheritance;  public class Test {     public static void main(String[] args){         Customer customerLee = new Customer(10010, \"이순신\");         customerLee.bonusPoint = 1000;          VIPCustomer customerKim = new VIPCustomer(10020,\"김유신\");         customerKim.bonusPoint = 10000;         int price = 10000;         System.out.println(customerLee.getCustomerInfo()+\"님이 지불해야 하는 금액은\"+customerLee.calcPrice(price)+\"원입니다.\");         System.out.println(customerKim.getCustomerInfo()+\"님이 지불해야 하는 금액은\"+customerKim.calcPrice(price)+\"원입니다.\");     } }  &gt;&gt;&gt; 이순신 님의 등급은 SILVER이며, 보너스 포인트는1000입니다.님이 지불해야 하는 금액은10000원입니다. &gt;&gt;&gt; 김유신 님의 등급은 VIP이며, 보너스 포인트는10000입니다.님이 지불해야 하는 금액은9000원입니다.  VIP회원인 김유신은 올바르게 지불 금액이 할인된것을 볼 수 있다.   묵시적 클래스 형 변환과 메서드 재정의  다음과 같은 경우에는 어떻게 실행될지 생각해 보자.  1 2 Customer vc = new VIPCustomer(\"10030\", \"나몰라, 2000); vc.calcPrice(10000);  VIPCustomer 가 Customer형으로 변환되었다.  calcPrice()는 Customer 클래스와 VIPCustomer 클래스에 모두 존재한다. 그렇다면, vc.calcPrice(10000)은 어떤 클래스의 메서드를 호출할까??   고객이 지불해야 하는 금액은 얼마일지 다음 코드로 테스트해 보겠습니다.  1 2 3 4 5 6 7 8 9 10 11 12 package inheritance;  public class OveridngTest {     public static void main(String[] args){         Customer vc = new VIPCustomer(10030,\"나몰라\", 2000);         vc.bonusPoint = 1000;          System.out.println(vc.getCustomerName()+\"님이 지불해야 하는 금액은\"+vc.calcPrice(10000)+\" 원 입니다.\");     } }  &gt;&gt;&gt; 나몰라님이 지불해야 하는 금액은9000원 입니다.  호출한 결과 분명 묵시적 형변환으로 Customer() 클래스로 형변환을 해주었음에도 VIPCustomer 클래스의 calcPrice() 메서드가 호출된것을 볼 수 있다. 왜일까?   상속에서 상위 클래스와 하위 클래스에 같은 이름의 메서드가 존재할 때 호출되는 메서드는 인스턴스에 따라 결정된다. 다시 말해 선언한 클래스형이 아니라 생성된 인스턴스의 메서드를 호출하는 것이다. 이렇게 인스턴스의 메서드가 호출되는 것을 가상 메서드(virtual mehod) 라고 한다. 가상메서드가 실행되는 원리를 이해하면 왜 위의 예제가 Customer() 클래스의 메서드가 아닌 VIPCustomer의 메서드를 호출하는지 이해할 수 있다.   가상 메서드  자바의 클래스는 멤버 변수와 메서드로 이루어져 있다. 클래스를 생성하여 인스턴스가 생성되면 멤버 변수는 힙 메모리에 위치한다. 그렇다면 메서드는 어디에 위치할까? 변수가 사용하는 메모리와 메서드가 사용하는 메모리는 다르다. 변수는 인스턴스가 생성될 때마다 새로 생성되지만, 메서드는 실행해야 할 명령 집합이기 때문에 인스턴스가 달라도 같은 로직을 수행하게 된다. 즉 같은 객체의 인스턴스를 여러 개 생성해도 메서드는 여러 개 생성되지 않는다.   따라서 인스턴스가 달라도 동일한 메서드가 실행된다.   calcPrice() 메서드는 두 클래스에서 서로 다른 메서드 주소를 가지고 있다. 이렇게 재정의된 메서드는 실제 인스턴스에 해당하는 메서드가 호출되는데, getCustomInfo()와 같이 재정의되지 않은 메서드인 경우는 메서드 주소가 같으며, 상위클래스의 메서드가 호출된다.   이렇게 변수를 선언할 때 사용한 자료형의 메서드가 호출되는 것이 아니라 생성된 인스턴스의 메서드가 호출되는것을 가상 메서드라한다. 자바의 모든 메서드는 가상 메서드이다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%83%81%EC%86%8D/",
        "teaser": null
      },{
        "title": "[BOJ] 녹색 옷 입은 애가 젤다지? (Python3)",
        "excerpt":"문제  젤다의 전설 게임에서 화폐의 단위는 루피(rupee)다. 그런데 간혹 ‘도둑루피’라 불리는 검정색 루피도 존재하는데, 이걸 획득하면 오히려 소지한 루피가 감소하게 된다!   젤다의 전설 시리즈의 주인공, 링크는 지금 도둑루피만 가득한 N x N 크기의 동굴의 제일 왼쪽 위에 있다. [0][0]번 칸이기도 하다. 왜 이런 곳에 들어왔냐고 묻는다면 밖에서 사람들이 자꾸 “젤다의 전설에 나오는 녹색 애가 젤다지?”라고 물어봤기 때문이다. 링크가 녹색 옷을 입은 주인공이고 젤다는 그냥 잡혀있는 공주인데, 게임 타이틀에 젤다가 나와있다고 자꾸 사람들이 이렇게 착각하니까 정신병에 걸릴 위기에 놓인 것이다.   하여튼 젤다…아니 링크는 이 동굴의 반대편 출구, 제일 오른쪽 아래 칸인 [N-1][N-1]까지 이동해야 한다. 동굴의 각 칸마다 도둑루피가 있는데, 이 칸을 지나면 해당 도둑루피의 크기만큼 소지금을 잃게 된다. 링크는 잃는 금액을 최소로 하여 동굴 건너편까지 이동해야 하며, 한 번에 상하좌우 인접한 곳으로 1칸씩 이동할 수 있다.   링크가 잃을 수밖에 없는 최소 금액은 얼마일까?   입력  입력은 여러 개의 테스트 케이스로 이루어져 있다.   각 테스트 케이스의 첫째 줄에는 동굴의 크기를 나타내는 정수 N이 주어진다. (2 ≤ N ≤ 125) N = 0인 입력이 주어지면 전체 입력이 종료된다.   이어서 N개의 줄에 걸쳐 동굴의 각 칸에 있는 도둑루피의 크기가 공백으로 구분되어 차례대로 주어진다. 도둑루피의 크기가 k면 이 칸을 지나면 k루피를 잃는다는 뜻이다. 여기서 주어지는 모든 정수는 0 이상 9 이하인 한 자리 수다.   출력  각 테스트 케이스마다 한 줄에 걸쳐 정답을 형식에 맞춰서 출력한다. 형식은 예제 출력을 참고하시오.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 예제 입력 1   3 5 5 4 3 9 1 3 2 7 5 3 7 2 0 1 2 8 0 9 1 1 2 1 8 1 9 8 9 2 0 3 6 5 1 5 7 9 0 5 1 1 5 3 4 1 2 1 6 5 3 0 7 6 1 6 8 5 1 1 7 8 3 2 3 9 4 0 7 6 4 1 5 8 3 2 4 8 3 7 4 8 4 8 3 4 0  예제 출력 1   Problem 1: 20 Problem 2: 19 Problem 3: 36  문제 풀이  좌표 형식인 맵을 받아서 좌표에 적힌 도둑루피의 값을 노드 형식으로 바꿔서 다익스트라 알고리즘을 적용해서 풀었다. 좌표를 각각 왼쪽에서 오른쪽으로 1,2,3,4…로 값을 매긴 뒤  각 숫자에 있는 값들을 소모값으로 해서 (노드번호,소모값)의 형태로 해서 다익스트라 알고리즘을 적용해 주었다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import sys import heapq #input = sys.stdin.readline INF = sys.maxsize  n = 1 result = [] while n:     dx = [-1,1,0,0]     dy = [0,0,-1,1]     #동굴의 지도 graph     graph = []     #동굴의 크기를 n으로 받는다.     n = int(input())     #동구의 지도를 받아 graph에 이차원 배열로 넣는다.     if n == 0:         break     for i in range(n):         graph.append(list(map(int, input().split())))     #노드를 담을 리스트 node     node = [[] for _ in range(n*n+1)]     #지도를 노드화 시켜준다. 노드는 좌에서 우로 순서대로 1,2,3... 순이다.     # x+n+1+y를 하면 노드화가 가능하다.     for i in range(n):         for j in range(n):             for k in range(4):                 nx = i +dx[k]                 ny = j+ dy[k]                 num = i*n+1+j                 if nx &gt;= 0 and ny &gt;= 0 and nx &lt; n and ny &lt; n:                     index = nx*n+1+ny                     node[num].append((index,graph[nx][ny]))     #print(node)           distance = [ INF for _ in range(n*n+1)]          def djikstra(start):         q = []         heapq.heappush(q,(start,0))         distance[start]          while q:             now, dist = heapq.heappop(q)             if dist &gt; distance[now]:                 continue             for i in node[now]:                 cost = dist+i[1]                 if distance[i[0]] &gt; cost:                     distance[i[0]] = cost                     heapq.heappush(q,(i[0], cost))     djikstra(1)     result.append(distance[-1]+graph[0][0]) problem = 1 for i in result:     print(\"Problem\",str(problem)+\":\",i)     problem+=1   1 2 3 4 5 6 7 8 9 10 11 12 13 3 5 5 4 3 9 1 3 2 7 5 3 7 2 0 1 2 8 0 9 1 1 2 1 8 1 9 8 9 2 0 3 6 5 1 5 0 Problem 1: 20 Problem 2: 19   노트  풀고나니까 굳이 노드화 하지않고도 이차원 배열형식을 바로 다익스트라 알고리즘으로 풀 수가 있었다… 생각해보니까 이차원 배열형식 자체가 전후좌우로 연결된 노드기 때문에 당연한건데, 너무 복잡하게 문제를 생각했던것 같다. 바로 다익스트라를 적용한 코드를 아래 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import heapq  # direction arr dx = [-1, 1, 0, 0] dy = [0, 0, -1, 1]  # while input != 0 n, problem = int(input()), 1 while n != 0:   # input   data = list(list(map(int, input().split())) for _ in range(n))    # init distance array   distance = [[int(1e9) for i in range(n)] for j in range(n)]   distance[0][0] = data[0][0]   # dijkstra   heap = []   heapq.heappush(heap, [distance[0][0], 0, 0])   while heap:     dist, x, y = heapq.heappop(heap)     if dist &gt; distance[x][y]:       continue     for i in range(4):       nx, ny = x + dx[i], y + dy[i]       if not(0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n):         continue       cost = dist + data[nx][ny]       if cost &lt; distance[nx][ny]:         distance[nx][ny] = cost         heapq.heappush(heap, [cost, nx, ny])    # print ans   print('Problem ' + str(problem) + ': ' + str(distance[n-1][n-1]))   # next input   n = int(input())   problem += 1   1 2 3 4 5 6 3 5 5 4 3 9 1 3 2 7 Problem 1: 20 0   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EB%85%B9%EC%83%89-%EC%98%B7-%EC%9E%85%EC%9D%80-%EC%95%A0%EA%B0%80-%EC%A0%A4%EB%8B%A4%EC%A7%80/",
        "teaser": null
      },{
        "title": "[BOJ] 최소비용 구하기 (Python3)",
        "excerpt":"문제  N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.   입력  첫째 줄에 도시의 개수 N(1 ≤ N ≤ 1,000)이 주어지고 둘째 줄에는 버스의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 M+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.   그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다. 출발점에서 도착점을 갈 수 있는 경우만 입력으로 주어진다.   출력  첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 예제 입력 1   5 8 1 2 2 1 3 3 1 4 1 1 5 10 2 4 2 3 4 1 3 5 1 4 5 3 1 5 예제 출력 1   4   문제풀이  다익스트라 알고리즘을 사용하면 간단하게 풀 수 있다.     양방향으로 노드를 그려서 자꾸 다른 값이 나와서 오래걸려버렸다…      그래도 오류를 찾는다고 다익스트라 알고리즘을 처음부터 끝까지 하나하나 단계를 그려봐서 조금 더 다익스트라 알고리즘에 동작방식에 대한 이해가 늘었으니 만족한다.     이런 경로 문제를 풀때는 항상 단방향인지 양방향인지 잘 살펴보고 문제를 풀자.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 import sys import heapq INF = sys.maxsize #input = sys.stdin.readline #도시의 개수 n = int(input()) #버스의 개수 m = int(input()) #도시의 노드 graph graph = [[]for _ in range (n+1)] #거리 테이블 dist distance = [INF]*(n+1)  visited = [False]*(n+1) #입력을 받아 graph를 채워준다. for i in range(m):     g = list(map(int,input().split()))     graph[g[0]].append((g[1],g[2])) #출발 도시와 도착도시의 번호 start,end = list(map(int,input().split()))  #다익스트라 알고리즘 def dijkstra(start):     q = []     heapq.heappush(q,(0, start))      while q:         dist, now = heapq.heappop(q)            if distance[now] &lt; dist:             continue                 for i in graph[now]:             cost = dist + i[1]             if cost &lt; distance[i[0]]:                 distance[i[0]] = cost                                  heapq.heappush(q,(cost,i[0]))  dijkstra(start) print(distance[end])    1 2 3 4 5 6 7 8 9 10 11 12 5 8 1 2 2 1 3 3 1 4 1 1 5 10 2 4 2 3 4 1 3 5 1 4 5 3 1 5 4   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EC%B5%9C%EC%86%8C%EB%B9%84%EC%9A%A9-%EA%B5%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "여름",
        "excerpt":"2021.07.30  요즘 날씨가 진짜 너무 덥다….      지구온난화 솔직히 어느정도 과장했다고 생각하고 있었는데, 과장이 아닐지도…?       에어컨을 하루종일 틀어도 잘 시원해지지가 않을정도로 덥다. 이렇게 더운 여름이 있었나 싶을정도로 요즘 더운 것 같다.      밖에 그냥 나가기가 싫을 정도로 너무 더운데, 괜히 더우니까 사람까지 늘어지고 나태해지는 기분이라고 해야하나…       아홉시에는 스터디카페 출근하기로 약속했는데, 최근에 아홉시에 출근한적이 없다. 물론 저번주, 이번주 월화 생동성을 다녀와서  좀 일정이 꼬인것도 있는데, 그래도 너무 늘어진다 이건…   운동도 좀 하고 해야하는데, 진짜 운동 운동 운동!!!!!       에너지가 잘 없으니까 운동할 의욕이 생기지가 않는다. 뭐던간에 한번 어느정도 해놔야 그걸 잃기 싫어서 계속 열심히 하는법인데,  쌓아놨던 운동의 경험을 한번에 싹 날려버리니 이제 될대로 되라… 하기 싫다 식이다…   나는 좀 기록을 만들고 뭔가 남겨야 더 열심히 하는 스타일인데, 운동이라는게 어디다 뭐를 남길만한 그게 좀없다.  엑셀 파일이라도 하나 만들어서 기록이라도 할까….   어쨌든 나태해진 나를 또, 몇번째 반성하는지 모르겠는데, 반성하며 다시 공부하러 가야겠다…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%97%AC%EB%A6%84/",
        "teaser": null
      },{
        "title": "[Java] 다형성",
        "excerpt":"다형성이란?  지금까지 설명한 묵시적 클래스 형 변환과 가상 메서드를 바탕으로 객체 지향의 중요한 특성인 다형성(polymorphism) 을 알아보자. 다형성이란, 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 말한다. 쉽게 말해 같은 코드에서 여러 실행결과가 나오는 것으로, 예제를 통해 살펴보자.   만약 Animal 클래스가 있고 이를 상속받아 Human, Tiger, Eagle 클래스를 만들어본다고 가정해보자.       Animal 클래스에 메서드를 하나 정의하고 이를 상속받은 클래스에서 재정의 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package polymorphism;  class Animal{     public void move(){         System.out.println(\"동물이 움직입니다.\");     } } class Human extends Animal{     public void move(){         System.out.println(\"사람이 두 발로 걷습니다.\");     } }  class Eagle extends Animal{     public void move(){         System.out.println(\"독수리가 하늘을 납니다.\");     }  } class Tiger extends Animal{     public void move(){         System.out.println(\"호랑이가 네발로 뜁니다.\");     }  } public class AnimalTest{     public static void main(String[] args){         AnimalTest aTest = new AnimalTest();         aTest.moveAnimal(new Human());         aTest.moveAnimal(new Eagle());         aTest.moveAnimal(new Tiger());      }     public void moveAnimal(Animal animal){         animal.move();     } }  위 코드는 Animal 클래스를 하나 만들고, 이를 상속하는 클래스 Human, Tiger, Eagle 을 만들어준 뒤 Animal의 메서드인 move를 오버라이딩하여 이를 main 함수에서 moveAnimal 메서드를 통해 사용되도록 했다.   여기서 moveAnimal 메서드는 어떤 인스턴스가 매개변수로 넘어와도 모두 Animal 형으로 변환한다. 예를 들어 매개변수 부분에 Human 인스턴스가 전달되었다면, 다음코드처럼 형 변환된다.  1 Animal ani = new Human();  Animal에서 상속받은 클래스가 매개변수로 넘어오면 모두 Animal형으로 변환되므로 animal.move() 메서드를 호출할 수 있다. 가상 메서드 원리에 따라 animal.move() 메서드가 호출하는 메서드는 Animal의 move가 아닌 매개변수로 넘어온 실제 인스턴스의 메서드이다. 따라서 animal.move() 메서드는 변함이 없지만 어떤 메서드가 넘어왔느냐에 따라 출력문이 달라지는데,  이를 다향성이라 한다.   다향성의 장점  다른 동물이 새로 추가되는 경우를 생각해보자. 새로운 동물도 Animal 클래스를 상속받아서 구현하면 모든 클래스를 Animal 자료형 하나로 쉽게 관리할 수 있을것이다. 이것이 바로 다형성을 활용한 프로그램의 확장성이다. 각 자료형에 따라 코드를 다르게 구현하면 코드는 훨씬 복잡해지고 내용도 길어지겠지만, 상위클래스에서 공통 부분의 메서드를 제공하고, 하위 클래스에서는 그에 기반한 추가요소만 덧붙여 구현하면 코드 양도 줄어들며, 유지보수도 편리하다.   그럼 다형성을 이용해서 상속에서 다뤘던 VIP 클래스를 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 package polymorphism;  public class Customer {     protected int customerID;     protected String customerName;     protected String customerGrade;     int bonusPoint;     double bonusRatio;      public Customer(){         initCustomer();     }     public Customer(int customerID, String customerName){         this.customerID = customerID;         this.customerName = customerName;         initCustomer();     }     private void initCustomer(){         customerGrade = \"SILVER\";         bonusRatio = 0.01;     }      public int calcPrice(int price){         bonusPoint += price * bonusRatio;         return price;     }     public String showCustomerInfo(){         return customerName+\"님 의 등급은 \" + customerGrade+\"이며, 보너스 포인트는 \"+bonusPoint+\"입니다.\";     } }  먼저 Customer 클래스를 만들어 주었는데, 등급과 보너스 비율을 기본으로 설정하는 메서드를 생성자 두곳에서 모두 사용할 수 있도록 initCustomer() 메서드로 만들어주었다. 그럼 이를 상속하여 VIPCustomer 클래스를 만들어보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 package polymorphism;  public class VIPCustomer extends Customer {     private int agentID;     double saleRatio;          public VIPCustomer(int customerID, String customerName, int agentID){         super(customerID, customerName);         customerGrade = \"VIP\";         bonusRatio = 0.05;         saleRatio = 0.1;         this.agentID = agentID;     }     public int calcPrice(int price){         bonusPoint += price * bonusRatio;         return price - (int)(price * saleRatio);     }     public String showCustomerInfo(){         return super.showCustomerInfo()+ \"담당 상담원 번호는\" + agentID+\"입니다.\";     }     public int getAgentID(){         return agentID;     }      }  Customer 클래스를 상속하여 VIPCustomer 클래스를 만들어 주었다. VIPCustomer 클래스만의 멤버변수를 선언해 준뒤, calcPrice()와 showCustomerInfo() 메서드도 오버라이딩 해주었다.   이제 이렇게 생성해준 Customer 클래스와 VIPCustomer 클래스를 사용해서 각각의 인스턴스를 선언해 돈을 지불하고 계산해보면서 다형성에 대해 알아보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 package polymorphism;  public class CustomerTest {     public static void main(String[] args){         Customer customerLee = new Customer(10010, \"이순신\");         customerLee.bonusPoint = 1000;          System.out.println(customerLee.showCustomerInfo());          Customer customerKim = new VIPCustomer(10020,\"김유신\",12345);         customerKim.bonusPoint = 1000;          System.out.println(customerKim.showCustomerInfo());         System.out.println(\"====================\");          int price = 10000;         int leePrice = customerLee.calcPrice(price);         int kimPrice = customerKim.calcPrice(price);          System.out.println(customerLee.customerName + \"님이\" + leePrice+\"원 을 지불했습니다.\");         System.out.println(customerLee.showCustomerInfo());         System.out.println(customerKim.customerName+ \"님이\" + kimPrice+\"원을 지불 하셨습니다.\");         System.out.println(customerKim.showCustomerInfo());     } }  &gt;&gt;&gt; 이순신님 의 등급은 SILVER이며, 보너스 포인트는 1000입니다. &gt;&gt;&gt; 김유신님 의 등급은 VIP이며, 보너스 포인트는 1000입니다.담당 상담원 번호는12345입니다. &gt;&gt;&gt; ==================== &gt;&gt;&gt; 이순신님이10000원 을 지불했습니다. &gt;&gt;&gt; 이순신님 의 등급은 SILVER이며, 보너스 포인트는 1100입니다. &gt;&gt;&gt; 김유신님이9000원을 지불 하셨습니다. 김유신님 의 등급은 VIP이며, 보너스 포인트는 1500입니다.담당 상담원 번호는12345입니다.   위에는 인스턴스로 customerLee와 customerKim 두개를 생성해주었는데, customerKim 은 형변환을 하여 Customer형으로 선언해주었다. 고객의 자료형은 Customer형으로 동일하지만, 할인율과 보너스 포인트는 각 인스턴스에 맞게 계산된 것을 알 수 있다.   이처럼 상속관계에 있는 상위 클래스와 하위 클래스는 같은 상위 클래스 자료형으로 선언되어 생성 할 수 있지만, 재정의된 메서드는 각각 호출될뿐만 아니라 이름만 같을 뿐, 서로 다른 역할을 구현하고 있음을 알 수 있다.   다형성 활용하기  앞에서 배운 상속과 다형성을 이용하여 어떻게 이 둘을 활용하여 프로그램을 간편하게 만들 수 있는지 알아보자.  다음과 같은 요구 사항이 발생했다고 하자.   고객이 늘어 VIP 고객만큼 물건을 많이 구매하지는 않지만, 그래도 단골인 분들에게 혜택을 주고싶다. 그래서 고객등급에 GOLD 고객등급을 하나 추가 하려한다. GOLD 회원의 혜택은 다음과같다.     제품을 살 때는 항상 10% 할인해준다.   보너스 포인트를 2% 적립해준다.   담당 전문 상담원은 없다.   이것을 기반으로 Customer 클래스를 상속받아 GOLDCustomer 클래스를 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package polymorphism;  public class GOLDCustomer extends Customer{     double saleRatio;      public GOLDCustomer(int customerID, String customerName){         super(customerID, customerName);         customerGrade = \"GOLD\";         bonusRatio = 0.02;         saleRatio = 0.1;     }     @Override     public int calcPrice(int price){         bonusPoint += price * bonusRatio;         return price - (int)(price * saleRatio);     } }  그럼 다시 CustomerTest 클래스에  main 함수를 구현하여 고객관리 프로그램을 구현해보자.   다음과 같은 상황을 구현해보도록 할 것 이다.   이 회사의 고객은 현재 5명이다. 5명 중 VIP 1명, GOLD 2명, SILVER 2명이다. 이 고객들이 각각 10000원 짜리 상품을 구매했을 때의 결과를 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package polymorphism; import java.util.ArrayList; import java.util.concurrent.atomic.AtomicReferenceArray;  public class CustomerTest {     public static void main(String[] args){         ArrayList&lt;Customer&gt; customerList = new ArrayList&lt;Customer&gt;();          Customer customerLee = new Customer(10010, \"이순신\");         Customer customerShin = new Customer(10020, \"신사임당\");         Customer customerHong= new GOLDCustomer(10030, \"홍길동\");         Customer customerYoul = new GOLDCustomer(10040, \"이율곡\");         Customer customerKim = new VIPCustomer(10050, \"김유신\",12345);          customerList.add(customerLee);         customerList.add(customerShin);         customerList.add(customerHong);         customerList.add(customerYoul);         customerList.add(customerKim);          System.out.println(\"==== 고객 정보 출력 ====\");         for(Customer c : customerList){             System.out.println(c.showCustomerInfo());         }          System.out.println(\"==== 할인율과 보너스 포인트 계산 ====\");         int price = 10000;         for (Customer c : customerList){             int cost = c.calcPrice(price);             System.out.println(c.customerName+ \"남이 \"+cost+\"원 지불하셨습니다.\");             System.out.println(\"현재 남아있는 포인트는\"+c.bonusPoint+ \"입니다.\");         }     } }  &gt;&gt;&gt; 이순신님 의 등급은 SILVER이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 신사임당님 의 등급은 SILVER이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 홍길동님 의 등급은 GOLD이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 이율곡님 의 등급은 GOLD이며, 보너스 포인트는 0입니다. &gt;&gt;&gt; 김유신님 의 등급은 VIP이며, 보너스 포인트는 0입니다.담당 상담원 번호는12345입니다. &gt;&gt;&gt; ==== 할인율과 보너스 포인트 계산 ==== &gt;&gt;&gt; 이순신님이 10000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는100입니다. &gt;&gt;&gt; 신사임당님이 10000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는100입니다. &gt;&gt;&gt; 홍길동남이 9000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는200입니다. &gt;&gt;&gt; 이율곡님이 9000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는200입니다. &gt;&gt;&gt; 김유신님이 9000원 지불하셨습니다. &gt;&gt;&gt; 현재 남아있는 포인트는500입니다.  5명의 고객의 정보를 담기 위해 객체 배열 ArrayList를 선언해주었다. 그리고 Customer 클래스로 5개의 인스턴스를 선언했는데, 이순신, 신사임당은 SILVERCustomer 객체로, 홍길동, 이율곡은 GOLDCustomer, 김유신은 VIPCustomer 객체로 선언하였다. 그리고 for 문을 사용하여 ArrayList에 있는 요소를 하나씩 가져와 c변수에 넣게되어 메서드를 실행하게된다. 그리고 각 인스턴스가 메서드를 호출하면 현재 이 변수의 실제 인스턴스가 무엇이냐에 따라 재정의한 메서드를 각각 호출하여 계산한다. 이것이 다형성이다.   만약 재정의한 메서드가 가상 메서드 방식에 의해 자동으로 호출되지 않는다면 if-else if문을 사용하여 각 자료형에 적합한 코드를 따로 구현해야 할 것이다. 게다가 새로운 등급의 고객이 필요할 때 마다 또 다른 조건을 구현해야 하므로 코드의 유지보수가 어려워진다. 이련경우에 상속과 다형성을 활용하면 복잡한 코드를 간결하게 하고 확장성있는 프로그램을 구현할 수 있게된다.   상속의 사용 조건  이렇게 상속에 대해 알아봤는데, 상속은 코드의 재사용 개념이 아니라는 것을 알아야한다.     예를 들어 과목을 나타내는 Subject 클래스가 있다고 하자. 과목 아이디, 이름을 멤버변수로 가지고 get(), set() 메서드도 제공한다. 이제 Student 클래스를 만들고자 하는데, 모든 학생은 전공 과목을 가지고 있기 때문에, Subject 클래스에서 제공하는 여러 메서드를 활용할 수 있도록 상속 해주면 좋을 것 같다는 생각이 든다.   하지만 이런 경우에는 상속을 사용하지 않는게 좋다. Subject가 Student를 포괄하는 개념의 클래스가 아니기 때문이다. 또한 Student 클래스를 상속받는 다른 클래스가 있을 수도 있기 때문에 상속을 사용하지 않는 것이 좋다. 이런경우를 HAS-A 관계(has a relationship; association) 라고 한다.   이 관계는 한 클래스가 다른 클래스를 소유한 관계로 상속이 아닌 멤버변수로 사용하는 것이 좋다.  1 2 3 class Student(){     Subject majorSubject; }  그렇다면 어떤 경우에 상속을 사용해주어야 좋을까?   바로 두 개념이 상위와 하위에 위치한, 일반적인 개념과 구체적인 개념의 관계를 갖고있는 상황에서 사용해주어야 한다. 즉 ‘사람은 포유류이다’ 와 같은 관계이다. 이러한 관계를 IS-A 관계(is a relationship; inheritance) 라고 한다.  상속은 이러한 관계를 갖고있는 개념에서 사용해주어야 올바르고 효율적인 코드를 작성할 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%8B%A4%ED%98%95%EC%84%B1/",
        "teaser": null
      },{
        "title": "[Programmers] 메뉴 리뉴얼 (Python3)",
        "excerpt":"문제  레스토랑을 운영하던 스카피는 코로나19로 인한 불경기를 극복하고자 메뉴를 새로 구성하려고 고민하고 있습니다.       기존에는 단품으로만 제공하던 메뉴를 조합해서 코스요리 형태로 재구성해서 새로운 메뉴를 제공하기로 결정했습니다. 어떤 단품메뉴들을 조합해서 코스요리 메뉴로 구성하면 좋을 지 고민하던 “스카피”는 이전에 각 손님들이 주문할 때 가장 많이 함께 주문한 단품메뉴들을 코스요리 메뉴로 구성하기로 했습니다.        단, 코스요리 메뉴는 최소 2가지 이상의 단품메뉴로 구성하려고 합니다. 또한, 최소 2명 이상의 손님으로부터 주문된 단품메뉴 조합에 대해서만 코스요리 메뉴 후보에 포함하기로 했습니다.        예를 들어, 손님 6명이 주문한 단품메뉴들의 조합이 다음과 같다면,      (각 손님은 단품메뉴를 2개 이상 주문해야 하며, 각 단품메뉴는 A ~ Z의 알파벳 대문자로 표기합니다.)                  손님 번호       주문한 단품메뉴 조합                       1번 손님       A, B, C, F, G                 2번 손님       A, C                 3번 손님       C, D, E                 4번 손님       A, C, D, E                 5번 손님       B, C, F, G                 6번 손님       A, C, D, E, H           가장 많이 함께 주문된 단품메뉴 조합에 따라 “스카피”가 만들게 될 코스요리 메뉴 구성 후보는 다음과 같습니다.                  코스 종류       메뉴 구성       설명                       요리 2개 코스       A, C       1번, 2번, 4번, 6번 손님으로부터 총 4번 주문됐습니다.                 요리 3개 코스       C, D, E       3번, 4번, 6번 손님으로부터 총 3번 주문됐습니다.                 요리 4개 코스       B, C, F, G       1번, 5번 손님으로부터 총 2번 주문됐습니다.                 요리 4개 코스       A, C, D, E       4번, 6번 손님으로부터 총 2번 주문됐습니다.           각 손님들이 주문한 단품메뉴들이 문자열 형식으로 담긴 배열 orders, “스카피”가 추가하고 싶어하는 코스요리를 구성하는 단품메뉴들의 갯수가 담긴 배열 course가 매개변수로 주어질 때, “스카피”가 새로 추가하게 될 코스요리의 메뉴 구성을 문자열 형태로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.   제한사항     orders 배열의 크기는 2 이상 20 이하입니다.   orders 배열의 각 원소는 크기가 2 이상 10 이하인 문자열입니다.   각 문자열은 알파벳 대문자로만 이루어져 있습니다.   각 문자열에는 같은 알파벳이 중복해서 들어있지 않습니다.   course 배열의 크기는 1 이상 10 이하입니다.   course 배열의 각 원소는 2 이상 10 이하인 자연수가 오름차순으로 정렬되어 있습니다.   course 배열에는 같은 값이 중복해서 들어있지 않습니다.   정답은 각 코스요리 메뉴의 구성을 문자열 형식으로 배열에 담아 사전 순으로 오름차순 정렬해서 return 해주세요.   배열의 각 원소에 저장된 문자열 또한 알파벳 오름차순으로 정렬되어야 합니다.   만약 가장 많이 함께 주문된 메뉴 구성이 여러 개라면, 모두 배열에 담아 return 하면 됩니다.   orders와 course 매개변수는 return 하는 배열의 길이가 1 이상이 되도록 주어집니다.   입출력 예  |orders|\tcourse|\tresult|  |:—:|:—:|:—:|  |[“ABCFG”, “AC”, “CDE”, “ACDE”, “BCFG”, “ACDEH”]\t|[2,3,4]\t|[“AC”, “ACDE”, “BCFG”, “CDE”]|  |[“ABCDE”, “AB”, “CD”, “ADE”, “XYZ”, “XYZ”, “ACD”]|\t[2,3,5]\t|[“ACD”, “AD”, “ADE”, “CD”, “XYZ”]|  |[“XYZ”, “XWY”, “WXA”]|\t[2,3,4]\t|[“WX”, “XY”]|   입출력 예에 대한 설명  입출력 예 #1  문제의 예시와 같습니다.   입출력 예 #2  AD가 세 번, CD가 세 번, ACD가 두 번, ADE가 두 번, XYZ 가 두 번 주문됐습니다.  요리 5개를 주문한 손님이 1명 있지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 5개로 구성된 코스요리는 새로 추가하지 않습니다.   입출력 예 #3  WX가 두 번, XY가 두 번 주문됐습니다.  3명의 손님 모두 단품메뉴를 3개씩 주문했지만, 최소 2명 이상의 손님에게서 주문된 구성만 코스요리 후보에 들어가므로, 요리 3개로 구성된 코스요리는 새로 추가하지 않습니다.  또, 단품메뉴를 4개 이상 주문한 손님은 없으므로, 요리 4개로 구성된 코스요리 또한 새로 추가하지 않습니다.   문제풀이  카카오 문제들은 다 다른 문제들에서 풀어보지못한 유형으로 문제가 출제되는 것 같다. 문제를 정말 열심히 만드시는 듯 하다… 근데 이 문제는 솔직히 이해하기 너무 어렵게 써놔서 문제를 세번씩 풀었다. 내가 이해력이 떨어지는건가??   이 문제는 메뉴 자체들을 주문한 수를 세는게 아니라 각각의 손님들이 주문한 음식들을 하나의 코스를 시킨것으로 간주하고 거기서 조합을 모두 출력하여 각 course변수에 있는 숫자들의 조합별로 최대로 많이 나온 조합자체를 코스로 세야한다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import defaultdict import operator from itertools import combinations  def solution(orders, course):     result = []     menudic = defaultdict()     for num in course:         for order in orders:             menus = list(order)             combis = combinations(menus, num)                          for combi in combis:                 combi = sorted(list(combi))                 if \"\".join(combi) in menudic:                     menudic[\"\".join(combi)]+=1                 else:                     menudic[\"\".join(combi)]=1     menu_candidate = []     print(menudic)     for num in course:         count = []         for i in menudic.items():             if len(i[0]) == num and i[1]&gt;=2:                 count.append(i)          for i in count:             if i[1] == max(count, key = lambda x: x[1])[1]:                 result.append(i[0])                                                    return sorted(result)   1 solution([\"XYZ\", \"XWY\", \"WXA\"], [2, 3, 4])   1 2 3 4 5 6 7 defaultdict(None, {'XY': 2, 'XZ': 1, 'YZ': 1, 'WX': 2, 'WY': 1, 'AW': 1, 'AX': 1, 'XYZ': 1, 'WXY': 1, 'AWX': 1})      ['WX', 'XY']   노트  역시나 나보다 훨씬 간단하게 푼 코드가 있어서 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import collections import itertools  def solution(orders, course):     result = []      for course_size in course:         order_combinations = []         for order in orders:             order_combinations += itertools.combinations(sorted(order), course_size)          most_ordered = collections.Counter(order_combinations).most_common()         result += [ k for k, v in most_ordered if v &gt; 1 and v == most_ordered[0][1] ]      return [ ''.join(v) for v in sorted(result) ]   1 solution([\"XYZ\", \"XWY\", \"WXA\"], [2, 3, 4])   1 ['WX', 'XY']   이 코드는 Counter()와 most_common() 메서드를 통해서 더 간단하게 풀었다.  두 메서드다 사용해본 적이 있는 메서드인데, 까먹어서 사용을 못했다. 파이썬 딕셔너리 사용하는 문제를 좀 더 많이 풀어봐야겠다.   Counter() 메서드는 리스트 요소의 개수를 세어 딕셔너리로 반환해주는 메서드이고, Counter().most_common()은 이렇게 반환한 딕셔너리를 개수가 많은 요소순으로 정렬하여 튜플리스트 값으로 반환해주는 메서드이다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%A9%94%EB%89%B4-%EB%A6%AC%EB%89%B4%EC%96%BC/",
        "teaser": null
      },{
        "title": "[Programmers] 후보키 (Python3)",
        "excerpt":"문제  프렌즈대학교 컴퓨터공학과 조교인 제이지는 네오 학과장님의 지시로, 학생들의 인적사항을 정리하는 업무를 담당하게 되었다.       그의 학부 시절 프로그래밍 경험을 되살려, 모든 인적사항을 데이터베이스에 넣기로 하였고, 이를 위해 정리를 하던 중에 후보키(Candidate Key)에 대한 고민이 필요하게 되었다.  후보키에 대한 내용이 잘 기억나지 않던 제이지는, 정확한 내용을 파악하기 위해 데이터베이스 관련 서적을 확인하여 아래와 같은 내용을 확인하였다.      관계 데이터베이스에서 릴레이션(Relation)의 튜플(Tuple)을 유일하게 식별할 수 있는 속성(Attribute) 또는 속성의 집합 중, 다음 두 성질을 만족하는 것을 후보 키(Candidate Key)라고 한다.   유일성(uniqueness) : 릴레이션에 있는 모든 튜플에 대해 유일하게 식별되어야 한다.   최소성(minimality) : 유일성을 가진 키를 구성하는 속성(Attribute) 중 하나라도 제외하는 경우 유일성이 깨지는 것을 의미한다. 즉, 릴레이션의 모든 튜플을 유일하게 식별하는 데 꼭 필요한 속성들로만 구성되어야 한다.     제이지를 위해, 아래와 같은 학생들의 인적사항이 주어졌을 때, 후보 키의 최대 개수를 구하라.                  학번       이름       전공       학년                       100       ryan       music       2                 200       apeach       math       2                 300       tube       computer       3                 400       con       computer       1                 500       muzi       music       3                 600       apeach       music       2           위의 예를 설명하면, 학생의 인적사항 릴레이션에서 모든 학생은 각자 유일한 “학번”을 가지고 있다. 따라서 “학번”은 릴레이션의 후보 키가 될 수 있다.       그다음 “이름”에 대해서는 같은 이름(“apeach”)을 사용하는 학생이 있기 때문에, “이름”은 후보 키가 될 수 없다. 그러나, 만약 [“이름”, “전공”]을 함께 사용한다면 릴레이션의 모든 튜플을 유일하게 식별 가능하므로 후보 키가 될 수 있게 된다.     물론 [“이름”, “전공”, “학년”]을 함께 사용해도 릴레이션의 모든 튜플을 유일하게 식별할 수 있지만, 최소성을 만족하지 못하기 때문에 후보 키가 될 수 없다.     따라서, 위의 학생 인적사항의 후보키는 “학번”, [“이름”, “전공”] 두 개가 된다.  릴레이션을 나타내는 문자열 배열 relation이 매개변수로 주어질 때, 이 릴레이션에서 후보 키의 개수를 return 하도록 solution 함수를 완성하라.  제한사항     relation은 2차원 문자열 배열이다.   relation의 컬럼(column)의 길이는 1 이상 8 이하이며, 각각의 컬럼은 릴레이션의 속성을 나타낸다.   relation의 로우(row)의 길이는 1 이상 20 이하이며, 각각의 로우는 릴레이션의 튜플을 나타낸다.   relation의 모든 문자열의 길이는 1 이상 8 이하이며, 알파벳 소문자와 숫자로만 이루어져 있다.   relation의 모든 튜플은 유일하게 식별 가능하다.(즉, 중복되는 튜플은 없다.)   입출력 예  |relation|\tresult|  |:—:|:—:|  |[[“100”,”ryan”,”music”,”2”],[“200”,”apeach”,”math”,”2”],[“300”,”tube”,”computer”,”3”],[“400”,”con”,”computer”,”4”],[“500”,”muzi”,”music”,”3”],[“600”,”apeach”,”music”,”2”]]|\t2|   입출력 예 설명  입출력 예 #1  문제에 주어진 릴레이션과 같으며, 후보 키는 2개이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from collections import defaultdict from itertools import combinations  def solution(relation):     N = len(relation[0])     key_idx = list(range(N))     candidate_key = []          for i in range(1,N+1):         for comb in combinations(key_idx,i):             hist = []             for rel in relation:                 current_key = [rel[c] for c in comb]                 if current_key in hist:                     break                 else:                     hist.append(current_key)             else:                 for ck in candidate_key:                     if set(ck).issubset(set(comb)):                         break                 else:                     candidate_key.append(comb)             return len(candidate_key)    1 solution([[\"100\",\"ryan\",\"music\",\"2\"],[\"200\",\"apeach\",\"math\",\"2\"],[\"300\",\"tube\",\"computer\",\"3\"],[\"400\",\"con\",\"computer\",\"4\"],[\"500\",\"muzi\",\"music\",\"3\"],[\"600\",\"apeach\",\"music\",\"2\"]])   1 2   노트  이 문제는 집합형 자료형 set에 대해 알아야 효율적으로 풀이가 가능한 문제다. 사실 중복을 처리할때 뺴고는 set 자료형의 교집합이나 합집합 기능을 사용할일 이 적은데, 미리 알아두면 다른 문제를 풀때도 응용이 가능할 것 같아 정리해두려 한다.   set 자료형  set 자료형은 집합에 관련된 것을 처리 하기 위해 만들어진 자료형으로 set 키워드를 사용하거나 중괄호를 이용하여 표현 할 수 있다. 선언 방식은 아래와 같다.   1 2 3 s1 = set({1,2,3}) s2 = set([1,2,3]) s3 = {1,2,3}   세 방법 모두 같은 집합을 만들며 빈 집합을 선언하기 위해서는 아래와 같이 사용한다.   1 s4 = set()   집합의 특징은 다음과 같다.     set() 키워드 혹은 중괄호를 이용한다.   순서가 없다   고유한 값을 가진다.   mutable(=값이 변하는) 객체이다.   순서가 없기 때문에 리스트나 튜플에서 사용했던 인덱싱은 불가능하다.   교집합   1 2 3 4 5 6 7 8 s1 = set([1,2,3,4,5]) s2 = set([4,5,6,7,8])  #교집합 메서드 print(s1.intersection(s2))  #교집합 연산자 print(s1 &amp; s2)   1 2 {4, 5} {4, 5}   위의 두 메서드와 연산자 모두 교집합을 구할 수 있도록 한다.   합집합   1 2 3 4 5 6 7 8 s1 = set([1,2,3,4,5]) s2 = set([4,5,6,7,8])  #합집합 메서드 union print(s1.union(s2))  #합집합 연산자 | print(s1 | s2)   1 2 {1, 2, 3, 4, 5, 6, 7, 8} {1, 2, 3, 4, 5, 6, 7, 8}                  합집합은 union 메서드나       연산자를 이용하여 구할 수 있다.           차집합   1 2 3 4 5 6 7 8 9 10 11 s1 = set([1,2,3,4,5]) s2 = set([4,5,6,7,8])  #차집합 메서드 difference print(s1.difference(s2)) print(s2.difference(s1))  #차집합 연산자 - print(s1 - s2) print(s2 - s1)    1 2 3 4 {1, 2, 3} {8, 6, 7} {1, 2, 3} {8, 6, 7}   순서가 상관이 없는 교집합, 합집합과는 다르게 차집합은 순서가 상관이 있다.     차집합을 구할떄는 difference 메서드를 이용하거나 - 연산자를 이용하여 구할 수 있다.   집합이 아예 다른지를 확인하는 경우   1 2 3 4 5 6 s1 = {1,2,3,4} s2 = {5,6,7,8} s3 = (1,5,6,7)  print(s1.isdisjoint(s2)) print(s1.isdisjoint(s3))   1 2 True False   isdisjoint 메서드는 두 집합의 요소가 한개도 동일하지 않은지를 확인하는 메서드이다. 만약 요소가 한개라도 같다면 False를 출력하고, 요소가 모두 다를 경우 True를 출력한다.   집합이 부분집합인지를 확인하는 경우   1 2 3 4 5 6 s1 = {1,2,3,4} s2 = {1,2}  print(s1.issubset(s2)) print(s2.issubset(s1))    1 2 False True   해당 집합이 메서드 배개변수의 집합의 부분집합인지를 판별하여 bool 자료형으로 출력해준다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%ED%9B%84%EB%B3%B4%ED%82%A4-(Python3)/",
        "teaser": null
      },{
        "title": "[Java] 다운 캐스팅과 instanceof",
        "excerpt":"하위 클래스로 형 변환, 다운캐스팅  앞에서 상위 클래스로 형 변환이 묵시적으로 이루어지는 과정을 알아보왔다. 여기서는 다시 하위 클래스로 형 변환이 되는 과정을 살펴보자.   Animal 이라는 클래스가 있고, 하위 클래스로  Human, Tiger, Eagle 세가지 클래스가 있다면     우리는 상위클래스를 자료형으로 선언하는 Animal ani = new Human(); 코드를 사용할 수 있다.  이때 생성된 인스턴스 Human은 Ainimal 형이다. 이렇게 Animal형으로 형 변환이 이루어진 경우에는 Animal 클래스에서 선언한 메서드와 멤버변수만 사용할 수 있다. 따라서 Human 클래스에 더 많은 메서드가 구현되어 있고 다양한 멤버 변수가 있다고 하더라도 자료형이 Animal 이라면 사용할 수가 없을 것 이다. 따라서 다시 원래의 인스턴스 자료형으로 되돌아가야 하는 경우가 있다. 이렇게 상위클래스로 형 변환된 하위 클래스를 원래 자료형으로 형 변환하는 것을 다운캐스팅(down casting) 이라고 한다.   instanceof  상속관계를 생각해보면 모든 인간은 동물이지만, 모든 동물이 인간은 아니다. 따라서 다운캐스팅을 하기 전에 상위 클래스로 형 변환된 인스턴스의 원래 자료형을 확인해야 변환할 때 오류를 막을 수 있다. 이를 확인하는 예약어가 바로 instanceof 인데, instanceof의 사용 방법은 다음과 같다.  1 2 3 4 Animal hAnimal = new Human(); if(hAnimal instanceof Human){     Human human = (Human)hAnimal }  위에서 사용한 hAnimal은 원래 Human형으로 생성되었는데, Animal형으로 형 변환된다. instanceof 예약어는 왼쪽에 있는 변수의 원래 인스턴스형이 오른쪽 클래스 자료형인가를 확인한다. 코드를 보면 hAnimal이 Animal 형으로 되어있지만, 원래는 Human형으로 생성된 인스턴스인지 확인하는 것이다. instanceof의 반환값이 true이면 다운 캐스팅을 하는데, 이때는 Human human = (Human)hAnimal; 문장과 같이 명시적으로 자료형을 써주어야 한다.  상위 클래스 형변환은 묵시적으로 가능하지만, 하위클래스로 형변환은 명시적으로 해야하기 때문이다.   다음처럼 원래 자료형이 Human이 아닌 경우를 보자.  1 2 Animal ani = new Tiger(); Human h = (Human)ani;  위와 같이 코딩해도 컴파일 오류는 나지 않는다. 왜일까? 일단 Tiger 인스턴스는 상위클래스로의 형 변환이기 때문에 자동으로 형 변환이 된다. 변수 h의 자료형 Human과 강제 형 변환되는 ani(Human)의 자료형이 동일하므로 컴파일 오류는 일어나지 않는다. 그 대신 이 코드를 실행하면 오류가 발생한다.   따라서 참조 변수의 원래 인스턴스형을 정확히 확인하고 다운 캐스팅을 해야 안전하며, 이때 instanceof를 사용하는 것이다. 그럼 원래 인스턴스 형으로 가운 캐스팅하는 예를 살펴보도록 하자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 package downcasting; import java.util.ArrayList;  class Animal {     public void move(){         System.out.println(\"동물이 움직입니다.\");     }  }  class Human extends Animal{     @Override     public void move() {     System.out.println(\"사람이 걷습니다.\");     }     public void readBook(){         System.out.println(\"사람이 책을 읽습니다.\");     } }  class Tiger extends Animal{     @Override     public void move(){         System.out.println(\"호랑이가 네발로 깁니다.\");     }     public void hunting(){         System.out.println(\"호랑이가 사냥을 합니다.\");     } }  class Eagle extends Animal{     @Override     public void move(){         System.out.println(\"독수리가 날아갑니다..\");     }     public void flying(){         System.out.println(\"독수리가 멀리 납니다.\");     } }  public class AnimalTest {     ArrayList&lt;Animal&gt; aniList = new ArrayList&lt;Animal&gt;();      public static void main(String[] args){         AnimalTest aTest = new AnimalTest();         aTest.addAnimal();         System.out.println(\"===다운 캐스팅===\");         aTest.testCasting();     }     public void addAnimal(){         aniList.add(new Human());         aniList.add(new Tiger());         aniList.add(new Eagle());          for(Animal ani : aniList){             ani.move();         }     }     public void testCasting(){         for(int i = 0; i &lt; aniList.size();i++){             Animal ani = aniList.get(i);             if(ani instanceof Human){                 Human h = (Human)ani;                 h.readBook();              }             else if(ani instanceof Tiger){                 Tiger t = (Tiger) ani;                 t.hunting();             }             else if(ani instanceof Eagle){                 Eagle e = (Eagle) ani;                 e.flying();             }             else{                 System.out.println(\"지원되지 않는 자료형입니다.\");             }         }      } }   &gt;&gt;&gt; 사람이 걷습니다. &gt;&gt;&gt; 호랑이가 네발로 깁니다. &gt;&gt;&gt; 독수리가 날아갑니다.. &gt;&gt;&gt; ===다운 캐스팅=== &gt;&gt;&gt; 사람이 책을 읽습니다. &gt;&gt;&gt; 호랑이가 사냥을 합니다. &gt;&gt;&gt; 독수리가 멀리 납니다.   위의 코드를 보면 각 동물 클래스를 인스턴스로 생성하여 Animal 형으로 선언한 배열에 추가한다. 이렇게 되면 배열에 추가되는 요소의 자료형은 모두 Animal 형으로 변환되는데, 이때 호출할 수 있는 메서드는 Animal 클래스에 선언된 메서드 뿐이다. 이렇게 선언된 배열에서 요소를 하나씩 꺼내 move() 메서드를 호출 하면 제정의한 메서드가 호출된다.  하지만 배열요소가 Animal 형이므로, 각각에 있는 메서드인 readBook(), hunting(), flying() 메서드는 사용할 수 없기 때문에, for 문을 사용하여 각각을 if문으로 다운캐스팅 해주어야만 각각의 메서드를 실행 시킬 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%EB%8B%A4%EC%9A%B4%EC%BA%90%EC%8A%A4%ED%8C%85%EA%B3%BC-instanceof/",
        "teaser": null
      },{
        "title": "[Java] 추상 클래스",
        "excerpt":"추상클래스란?  ‘추상적이다’라는 말의 뜻을 생각해 보자. 추상적이라는 것은 구체적이지 않고 막연한 것을 뜻한다.  그렇다면 어떤 클래스가 추상적이다 라는 말은 무슨 뜻일까? 앞의 용어풀이를 대입해 보면 ‘구체적이지 않은 클래스’ 라는 뜻일 것이다. 추상 클래스를 영어로 하면 abstract class이고, 추상 클래스가 아닌 클래스는 concrete class 라고 한다. 우리가 지금까지 만든 클래스는 모두 concrete class이다. 추상 클래스 활용방법을 살펴보기 전에 추상 클래스 문법부터 배워보자.   추상 클래스는 항상 추상메서드 를 포함한다. 추상메서드는 구현코드가 없다. 함수의 구현 코드가 없다는 것은 함수 몸체가 없다는 뜻이다.  1 2 3 int add(int x, int y){     return x + y; }  중괄호 {}로 감싼 부분을 함수의 구현부(implementation)라고 하며, 이 부분이 없는 함수는 추상 함수(abstract function)이고 자바에서는 추상 메서드(abstract method) 라고 한다. 추상메서드는 다음과 같이 선언만 하며 abstract 예약어를 사용한다. 또한 {}대신 ;를 사용한다.  1 abstract int add(int x int y)  참고로 아래와 같은 메서드는 추상 메서드가 아니다.  중괄호를 사용한 것 만으로 메서드를 구현한 셈이기 때문이다.  1 int add(int x, int y){}  정리하자면, 자바에서 추상 메서드는 abstract 예약어를 사용하여 선언만 하는 메서드이다.   이러한 추상 클래스를 이해하려면 먼저 메서드 선언의 의미에 대해서 생각해보아야한다.     아래의 코드를 보자.  1 int add(int num1, int num2);  위 코드처럼 선언한 메서드를 보면 두 개의 정수를 입력받은 후 더해서 그 결과 값을 반환한다는 것을 유추할 수 있다. 즉 이 메서드의 선언부(declaration)만 봐도 어떤일을 하는 메서드인지 알수 있는 것이다. 함수의 선언부 즉 반환 값, 함수 이름, 매개변수를 정의 한다는것은 곧 함수의 역할이 무엇인지, 어떻게 구현해야 하는지를 정의한다는 뜻이다. 우리가 자바에서 사용하는 메서드 역시 마찬가지이다. 메서드를 선언한다는 것은 해야 할 일을 명시해 두는 것이다.   추상클래스 구현하기  아래의 코드를 보고, 추상클래스에 대해 알아보자  1 2 3 4 5 6 7 8 9 10 11 12 package abstractex;  public class Computer {     public void display();     public void typing();     public void turnOn(){         System.out.println(\"전원을 켭니다\");     }     public void turnOff(){         System.out.println(\"전원을 끕니다.\");     } }  컴퓨터라는 클래스를 만들어주고 display와 typing, turnOn,turnOff 메서드를 선언해주었는데, 함수구현부를 써주지않은 display와 typing에서는 오류가 발생하고 있다. 이 부분이 오류가 나지 않으려면 몸체 부분을 작성하거나, 이 메서드를 추상 메서드로 선언해주어야 한다. 그럼 display와 typing 앞에 abstract 예약어를 사용해보자.  1 2 3 4 5 6 7 8 9 10 11 12 package abstractex;  public class Computer {     public abstract void display();     public abstract void typing();     public void turnOn(){         System.out.println(\"전원을 켭니다\");     }     public void turnOff(){         System.out.println(\"전원을 끕니다.\");     } }  그러면 이제 오류가 없어졌지만, 이제는 class Computer에 오류가 뜬다. 왜냐하면 추상 메서드가 속한 클래스를 추상 클래스로 선언하지 않았기 때문이다. 그러니 이번에는 Computer 클래스를 추상 클래스로 바꿔서 선언해보자.  1 2 3 4 5 6 7 8 9 10 11 12 package abstractex;  public abstract class Computer {     public abstract void display();     public abstract void typing();     public void turnOn(){         System.out.println(\"전원을 켭니다\");     }     public void turnOff(){         System.out.println(\"전원을 끕니다.\");     } }  이제 모든 오류가 제거되었다. Computer 클래스에 이렇게 구현한 이유는   Computer를 상속받는 클래스를 이와 같이 구현한것은 ‘Computer를 상속받는 클래스 중 turnOn과 turnOff( ) 구현 코드는 공통이다. 하지만 display()와 typing()은 하위 클래스에 따라 구현이 달라질 수 있다. 그래서 Computer에서는 구현하지 않고, 이 두 메서드 구현에 대한 책임을 상속받는 클래스에 위임한다’ 라는 의미이다.   따라서 Computer 클래스의 추상 메서드는 추상 클래스를 상속받은 DeskTop과 NoteBook에서 실제로 구현하게 된다. 이 클래스의 상위 클래스에서는 하위 클래스도 공통으로 사용할 메서드를 구현하고, 하위 클래스마다 다르게 구현할 메서드는 추상 메서드로 선언해 두는 것이다.   그러면 DeskTop 클래스를 만들어보자. 다음과 같이 DeskTop 클래스를 선언하고 Computer 클래스를 상속받는다.  1 2 3 4 package abstractex;  public class DeskTop extends Computer{ }  이렇게 Computer를 상속한 DeskTop을 만들어주면 오류가 발생한다.   추상 클래스를 상속했으므로, 위에서 추상메서드로 선언했던 display() 와 typing() 메서드의 몸체 부분을 상속받은 클래스에서 구현해주던가, 상속한 DeskTop도 추상 클래스로 선언해주던가 둘중에 하나를 해주어야 오류가 발생하지 않는다. display()와 typing() 메서드의 몸체 부분을 작성해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 package abstractex;  public class DeskTop extends Computer{      @Override     public void display() {         System.out.println(\"DeskTop display()\");     }      @Override     public void typing() {         System.out.println(\"Desktop typing()\");     } }  마찬가지로 NoteBook 클래스도 구현한다.  1 2 3 4 5 6 7 8 9 10 11 package abstractex;  public abstract class NoteBook extends Computer {       @Override     public void display() {         System.out.println(\"Notebook display\");     }  }  NoteBook 클래스는 추상 클래스로 선언해주기 위해 abstract 예약어를 사용했다.  그럼 NoteBook 클래스를 또 상속하는 MyNoteBook 클래스를 만들어보자.  1 2 3 4 5 6 7 8 package abstractex;  public class MyNoteBook extends NoteBook{     @Override     public void typing(){         System.out.println(\"MyNoteBook typing()\");     } }  이렇게 하면, 가장 상위클래스이자 추상클래스인 Computer에서 추상 메서드인 display와 typing이 선언되고, 그 아래의 DeskTop 클래스는 두가지 메서드를 모두 재정의 하여 추상클래스가 아닌 클래스가 되었고, NoteBook은 display 하나만 재정의 함으로써 추상클래스로 선언된걸 확인 할 수 있다. 마지막으로 MyNoteBook은 NoteBook을 상속받은 뒤, NoteBook에서 선언하지 않은 typing을 재정의 해줌으로써 구체적 클래스가 된다.   추상 클래스를 만드는 이유  추상 클래스를 어떻게 정의하고 구현하는지를 이야기 했다. 그렇다면 이런 추상 클래스는 어디에 사용하기 위해 사용하는 것일까? 앞서 만든 추상클래스를 사용하여 알아보자.  1 2 3 4 5 6 7 8 9 10 package abstractex;  public class ComputerTest {     public static void main(String[] args){         Computer c1 = new Computer();         Computer c2 = new DeskTop();         Computer c3 = new NoteBook();         Computer c4 = new MyNoteBook();     } }  ComputerTest 클래스를 만들어 메인함수를 통해 인스턴스를 각각의 자료형으로 4개 선언해주었다.      추상 클래스인 Computer 와 NoteBook이 오류가 나는것을 확인 할 수 있다.   이러한 오류가 발생하는 이유는 바로 추상클래스는 인스턴스로 생성 할 수 없기 떄문이다.   추상 클래스는 상속을 하기 위해 만든 클래스로, 하위클래스에서 각각 다르게 구현해야 할 메서드가 있다면, 구현 내용 제목만 상위클래스에 남겨두고 이러한 내용을 하위클래스에서 재정의하여 사용하도록 한 것이 바로 추상 클래스이다.   추상클래스는 이러한 특징때문에 많은 프레임워크에서 사용되고 있는 구현방식인데, 앱마다 어떻게 만드는지에 따라 다르게 구현해야할 클래스인 경우, 이런식으로 추상클래스로 선언하여 사용하게되는 것이다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Programmers] 거리두기 확인하기 (Python3)",
        "excerpt":"문제  개발자를 희망하는 죠르디가 카카오에 면접을 보러 왔습니다.  코로나 바이러스 감염 예방을 위해 응시자들은 거리를 둬서 대기를 해야하는데,   개발 직군 면접인 만큼      아래와 같은 규칙으로 대기실에 거리를 두고 앉도록 안내하고 있습니다.          대기실은 5개이며, 각 대기실은 5x5 크기입니다.     거리두기를 위하여 응시자들 끼리는 맨해튼 거리1가 2 이하로 앉지 말아 주세요.     단 응시자가 앉아있는 자리 사이가 파티션으로 막혀 있을 경우에는 허용합니다.      응시자가 앉아있는 자리(P)를 의미합니다.\t빈 테이블(O)을 의미합니다.\t파티션(X)을 의미합니다.   예를들어,   PXP     위 그림처럼 자리 사이에 파티션이 존재한다면 맨해튼 거리가 2여도 거리두기를 지킨 것입니다.   PX     XP     위 그림처럼 파티션을 사이에 두고 앉은 경우도 거리두기를 지킨 것입니다.   PX     OP     위 그림처럼 자리 사이가 맨해튼 거리 2이고 사이에 빈 테이블이 있는 경우는 거리두기를 지키지 않은 것입니다.   5개의 대기실을 본 죠르디는 각 대기실에서 응시자들이 거리두기를 잘 기키고 있는지 알고 싶어졌습니다. 자리에 앉아있는 응시자들의 정보와 대기실 구조를 대기실별로 담은 2차원 문자열 배열 places가 매개변수로 주어집니다. 각 대기실별로 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 배열에 담아 return 하도록 solution 함수를 완성해 주세요.   제한사항     places의 행 길이(대기실 개수) = 5   places의 각 행은 하나의 대기실 구조를 나타냅니다.   places의 열 길이(대기실 세로 길이) = 5   places의 원소는 P,O,X로 이루어진 문자열입니다.   places 원소의 길이(대기실 가로 길이) = 5   P는 응시자가 앉아있는 자리를 의미합니다.   O는 빈 테이블을 의미합니다.   X는 파티션을 의미합니다.   입력으로 주어지는 5개 대기실의 크기는 모두 5x5 입니다.   return 값 형식   1차원 정수 배열에 5개의 원소를 담아서 return 합니다.   places에 담겨 있는 5개 대기실의 순서대로, 거리두기 준수 여부를 차례대로 배열에 담습니다.   각 대기실 별로 모든 응시자가 거리두기를 지키고 있으면 1을, 한 명이라도 지키지 않고 있으면 0을 담습니다.   입출력 예  |places|\tresult|  |:—:|:—:|  |[[“POOOP”, “OXXOX”, “OPXPX”, “OOXOX”, “POXXP”], [“POOPX”, “OXPXP”, “PXXXO”, “OXXXO”, “OOOPP”], [“PXOPX”, “OXOXP”, “OXPOX”, “OXXOP”, “PXPOX”], [“OOOXX”, “XOOOX”, “OOOXX”, “OXOOX”, “OOOOO”], [“PXPXP”, “XPXPX”, “PXPXP”, “XPXPX”, “PXPXP”]]|\t[1, 0, 1, 1, 1]|   문제풀이  이 문제는 bfs를 이용해서 푸는 문제인데, 뭔가 너무 복잡하게 생각해서 오래 걸린 문제였다. 거리두기 문제가 아닌 바이러스를 퍼뜨리는 문제라고 생각하니, 쉽게 풀수 있었는데, p가 바이러스를 놓는위치라고 생각하고 거리가 2보다 커지거나, 파티션을 만나면 바이러스가 더 이상 못퍼진다고 생각하면 동일한 결과로 문제를 풀 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from collections import deque  def solution(places):     def bfs(x,y):         dx = [-1,1,0,0]         dy = [0,0,-1,1]         q = deque()             q.append([x,y])         while q:             nx,ny = q.popleft()             if visited[nx][ny] == 0:                 visited[nx][ny] +=1             for i in range(4):                 sx = nx+dx[i]                 sy = ny+dy[i]                 if 0 &lt;= sx &lt; 5 and 0 &lt;= sy &lt; 5 and visited[sx][sy] ==0:                     if room[sx][sy] ==  'X':                         continue                     if room[sx][sy] == 'P':                         visited[sx][sy] = 1                         distance.append(visited[nx][ny])                         q.append([sx,sy])                     else:                         visited[sx][sy] = visited[nx][ny] + 1                         q.append([sx,sy])         return visited     answer = []     for place in places:                  room = []         for pl in place:             room.append(list(pl))              distance = []                            visited = [[0 for i in range(5)]for i in range(5)]         for i in range(5):             for j in range(5):                 if room[i][j] == \"P\":                     bfs(i,j)         #print(visited)                  if 1 in distance or 2 in distance:             answer.append(0)         else:             answer.append(1)                                                    return answer   1 solution([[\"POOOP\", \"OXXOX\", \"OPXPX\", \"OOXOX\", \"POXXP\"], [\"POOPX\", \"OXPXP\", \"PXXXO\", \"OXXXO\", \"OOOPP\"], [\"PXOPX\", \"OXOXP\", \"OXPOX\", \"OXXOP\", \"PXPOX\"], [\"OOOXX\", \"XOOOX\", \"OOOXX\", \"OXOOX\", \"OOOOO\"], [\"PXPXP\", \"XPXPX\", \"PXPXP\", \"XPXPX\", \"PXPXP\"]])   1 [1, 0, 1, 1, 1]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B1%B0%EB%A6%AC%EB%91%90%EA%B8%B0-%ED%99%95%EC%9D%B8%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Java] 인터페이스",
        "excerpt":"인터페이스란?  인터페이스(Interface)는 클래스 혹은 프로그램이 제공하는 기능을 명시적으로 선언하는 역할을 한다. 인터페이스는 추상 메서드와 상수로만 이루어져 있다. 구현된 코드가 없기 때문에 당연히 인터페이스로는 인스턴스도 생성 할 수 없다. 그렇다면 구현코드도 없는 인터페이스는 어떻게 사용하는 걸까? 인터페이스를 직접 만들어 보면서 살펴보자.   인터페이스를 사용해 간단한 계산기 프로그램을 만들어보자.  내가 사용하고 있는 책에서는 이클립스를 사용하고 있는데, 패키지에서 오른쪽 버튼 클릭 후 New -&gt; Interface를 클릭하면된다. 나는 IntelliJ를 사용하고 있기 때문에 방법이 다른데, 클래스를 추가하면 클래스 이름을 설정하라고 나올때, 형식을 클래스가 아닌 Interface로 설정하면 된다.  1 2 3 4 package interfaceex;  public interface Calc { }  이렇게 하면 인터페이스를 사용할 준비가 끝났다.   그럼 인터페이스의 구현부를 추상 클래스와 상수로 채워보자.  1 2 3 4 5 6 7 8 9 10 11 package interfaceex;  public interface Calc {     double PI = 3.14;     int ERROR = -99999999;          int add(int num1,int num2);     int substract(int num1, int num2);     int times(int num1, int num2);     int divide(int num1,int num2); }  인터페이스의 메서드와 멤버변수는 추상메서드와 상수로만 이루어져야 한다고 했다. 근데 위 인터페이스는 파이와 에러가 변수로 선언되어있으며 메서드도 추상메서드로 선언하는 예약어인 abstract로 선언하지 않았다.   인터페이스의 메서드와 변수는 예약어를 명시하지않아도 컴파일 과정에서 자동으로 추상메서드로 변환되고, 변수는 상수가 된다. 따라서 public abstract나 public static final 예약어를 선언하지 않아도 된다.   클래스에서 인터페이스 구현하기  그럼 이제 선언한 인터페이스를 클래스에서 사용해보자. 상속을 할때는 기능을 확장한다는 의미로 extends를 썼었다. 인터페이스에서는 인터페이스에서 선언한 기능을 클래스가 구현한다는 의미로 implements 예약어를 사용한다. calc 인터페이스를 Calculator에서 구현하는 방법은 다음과 같다.  1 2 3 4 package interfaceex;  public class Calculator implements Calc{ }  이렇게 implements로 선언해주면 추상 메서드 4개를 포함하는 Calculator 클래스가 선언된다. 이 추상메서드 4개를 구현하지 않으면, Calcultor 클래스도 추상클래스가 된다. 그럼 추상메서드의 개념까지 한번 더 생각해 볼겸, add()와 substract() 메서드만 구현한 추상메서드로 한번 더 추상클래스를 선언해보고, CompleteCalc에서 모든 기능을 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 package interfaceex;  public abstract class Calculator implements Calc{     @Override     public int add(int num1, int num2) {         return num1 + num2;     }      @Override     public int substract(int num1, int num2) {         return num1 - num2;     } }  2개의 메서드만 구현했으므로 이 클래스 또한 추상 클래스이다. 따라서 abstract 예약어를 사용해서 선언한다.   그럼 이제 모든 메서드를 구현한 클래스를 만들어보자. 위에서 만든 추상클래스 Calculator를 상속받아 CompleteCalc에 아직 구현되지 않은 times()와 divide() 추상 메서드를 이 클래스에 구현해주면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 package interfaceex;  public class CompleteCalc extends Calculator{       @Override     public int times(int num1, int num2) {         return num1 * num2;     }      @Override     public int divide(int num1, int num2) {         if(num2 != 0)             return num1 / num2;         else             return Calc.ERROR;     }        public void showInfo(){         System.out.println(\"Calc 인터페이스 구현 완료\");     } }   이제 이렇게 만든 클래스를 Test 파일에서 메인함수를 만들어 출력해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 package interfaceex;  public class Test {     public static void main(String[] args){         int num1 = 10;         int num2 = 5;                  CompleteCalc cal = new CompleteCalc();         System.out.println(cal.add(num1,num2));         System.out.println(cal.substract(num1,num2));         System.out.println(cal.divide(num1,num2));         System.out.println(cal.times(num1,num2));         cal.showInfo();     } }   &gt;&gt;&gt; 15 &gt;&gt;&gt; 5 &gt;&gt;&gt; 2 &gt;&gt;&gt; 50 &gt;&gt;&gt; Calc 인터페이스 구현 완료  덧셈, 뺄셈, 나눗셈, 곱셈 연산을 실행하고 그 값을 출력해보았다. 이처럼 인터페이스는 선언부를 모아놓았기 때문에, 해당 메서드의 구현부를 재정의하여 사용 할 수 있게 해준다.   인터페이스 구현과 형 변환  Calculator 클래스는 인터페이스에서 선언한 추상 메서드 중 일부 메서드만 구현했으므로 추상 클래스이다.  그리고 이를 상속받은 CompleteCalc 클래스는 Calc에서 구현하지 않은 나머지 추상 메서드를 모두 구현하고 showInfo() 메서드를 추가로 구현했다. 이러한 관계에서 하위 클래스의 형 변환은 어떻게 이루어지는지 알아보자.   상속관계에서는 하위클래스는 상위클래스로 묵시적 형변환이 언제든 가능하다고 했다. 인터페이스도 마찬가지로 CompleteCalc 클래스는 상위클래스인 Calculator 형이면서 Calc형이다. 따라서 다음과 같은 코드 선언이 가능하다.  1 Calc calc = new CompleteCalc();  이렇게 하면 calc 변수에 대입한 newCalc는 인터페이스에서 선언한 메서드만 사용할 수 있고, CompleteCalc 에서 구현한 showInfo() 메서드는 사용할 수 없다. 이것이 바로 인터페이스의 중요한 역할이다.   인터페이스의 역할  지금까지 인터페이스를 정의하고 클래스에서 구현해보았는데, 그러면 이러한 인스턴스는 어디에 쓰는 코드일까?   인터페이스는 클라이언트 프로그램에 어떤 메서드를 제공하는지 미리 알려주는 명제 또는 약속의 역할로, 만약 Abc 클래스를 구현한 A클래스가 있다고 가정하자. 이 클래스를 사용하는 Z라는 프로그램이 있다면, Abc인터페이스에는 구현해야할 추상메서드가 모두 선언되어있고, 어떤 매개변수가 사용되는지, 어떤 자료형 값이 반환되는지 선언되어 있을 것이다. 즉 Z프로그램에서는 A클래스의 구현부를 살펴보지 않고 Abc 인터페이스의 선언 부분만 보고도 A클래스의 사용방법을 알게되는 것이다.   만약 Z프로그램에서 Abc 인터페이스를 구현한 다른 클래스 B를 사용하고 싶다면, 인터페이스 명을 B클래스로 교체하여 사용가능하다.  1 2 3 4 Abc abc; abc = new A(); abc = new B(); abc = new C();  이렇게 Z프로그램에서 각 클래스를 사용하려고 할 떄, 클래스에서 구현한 내용을 몰라도 Abc 인터페이스에서 선언한 메서드의 매개변수 자료형과 반환값을 알면 인터페이스를 구현한 어떤 클래스든 사용가능하다.   인터페이스와 다형성  인터페이스를 사용하면 다형성을 구현하여 확장성 있는 프로그램을 만들 수 있다.     즉, 클라이언트 프로그램을 많이 수정하지 않고 기능을 추가하고 다른 기능을 사용할 수 있게된다.   다음 예제를 보자.   고객센터에는 전화 상담을 하는 상담원이 있다. 고객센터로 전화가 오면 대기열에 저장되고, 상담원이 지정되기 전까지 대기 상태가 된다. 전화를 상담원에게 분배하는 방법은 세가지가 있는데,      순서대로 배분하기: 모든 상담원에게 순서대로 전화를 준다.   짧은 대디열 찾아 헤메기 : 가장 적은 대기명을 보유하지않은 상담원에게 전화를 준다.   우선순위에 따라 배분하기 : 고객 등급에 따라 등급이 높을 수록 업무능력이 높은 상담원에게 우선 배분한다.   이 전화를 배분하기 위해 Scheduler 인터페이스를 만들어보자.  1 2 3 4 5 6 package interfaceex;  public interface Scheduler {     public void getNextCall();     public void sendCallToAgent(); }  그럼 순서대로 배분하는 경우 부터 인터페이스의 구현부를 채워보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 package interfaceex;  public class RoundRobin implements Scheduler {     @Override     public void getNextCall(){         System.out.println(\"전화를 순서대로 대기열에서 가져온다.\");     }      @Override     public void sendCall() {         System.out.println(\"다음 순서 상담원에게 배분\");     }  }  먼저 순서대로 배정하는 경우 (RoundRobin)를 구현해보았다.  마찬가지로implements를 사용하여 Scheduler 인터페이스를 기반으로 클래스를 선언헀다.   다음은 짧은 대기열 먼저 분배하는 LeastJob 클래스, 우선순위에 따라 배분하는 PriorityAllocation 클래스를 구현해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package interfaceex;  public class LeastJob implements Scheduler{      @Override     public void getNextCall() {         System.out.println(\"상담 전화를 순서대로 대기열에서 가져옵니다.\");     }      @Override     public void sendCall() {         System.out.println(\"대기가 적은 순으로 상담원에게 할당합니다.\");      } }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package interfaceex;  public class PriorityAllocation implements Scheduler{      @Override     public void getNextCall() {         System.out.println(\"고객등급이 높은 순서대로 대기열에서 가져온다.\");     }      @Override     public void sendCall() {         System.out.println(\"업무 역량이 높은 상담원 우선 배정한다.\");      } }  이제 해당 클래스들을 main 함수에서 구동해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package interfaceex;  import java.io.IOException;  public class SchedulerTest {     public static void main(String[] args)throws IOException {         System.out.println(\"전화 상담 할당 방식을 선택하세요\");         System.out.println(\"R : 한명씩 차례로 할당\");         System.out.println(\"L : 대기가 적은 상담원에게 할당\");         System.out.println(\"P : 우선순위가 높은 고객 먼저 할당\");          int ch = System.in.read();         Scheduler scheduler = null;          if(ch == 'R' || ch == 'r'){             scheduler = new RoundRobin();         }         else if(ch == 'L' || ch == 'l'){             scheduler = new LeastJob();         }         else if(ch == 'P' || ch == 'p'){             scheduler = new PriorityAllocation();         }         else{             System.out.println(\"지원하지 않는 기능입니다.\");             return;         }         scheduler.getNextCall();         scheduler.sendCall();     } }   위 함수를 실행하면, 입력받은 전화 할당 방식에 따라서 각 기능에 따른 메서드가 실행된다.   만약 새로운 정책을 추가해야 한다면, 앞에서와 마찬가지로 Scheduler 인터페이스를 구현하는 새 클래스로 만들면된다. 어떤 클래스를 구현하던간에 클라이언트가 인터페이스를 구현한 클래스를 사용하는 방식은 다음과 같다.  1 2 scheduler.getNextCall() scheduler.sendCall();  이렇게 클라이언트 프로그램은 각 클래스의 구현 방법을 몰라도 인터페이스에서 선언된 매개변수, 반환값을 보고 클래스를 사용할 수 있다.   인터페이스 상수  인터페이스는 추상 메서드로 이루어지므로 인스를 생성할 수 없으며 멤버 변수도 사용할 수 없다.  1 2 3 4 public interface Calc{     double PI = 3.14;     int ERROR = -9999999999; }  그런데, 위의 코드와 같이 변수를 선언해도 오류가 발생하지 않는다. 그 이유는 인터페이스에서 선언한 변수를 컴파일하면 상수로 변환 되기 떄문이다.   디폴트 메서드와 정적 메서드  원래 자바는 인터페이스를 구현한 여러 클래스에서 사용할 메서드가 클래스마다 같은 기능을 제공하는 경우에도 인터페이스에 메서드를 구현할 수 없기 때문에 클래스마다 똑같이 그 기능을 반복해 구현해야 했다. 하지만 자바 8부터는 인터페이스 활용성을 높이기 위해 디폴트 메서드와 정적 메서드를 지원한다.   정적 메서드는 인스턴스 생성과 관계없이 사용할 수 있는 메서드이다. 하지만 디폴트 메서드나 정적 메서드를 추가 했다고 해서 인터페이스가 인스턴스를 생성할 수 있는건 아니다. 그럼 인터페이스에 구현하는 디폴트 메서드와 정적 메서드가 무엇인지 살펴보자.   디폴트 메서드  디폹트 메서드란 말 그대로 기본으로 제공되는 메서드로, 인터페이스에서 구현하지만 이후 인터페이스를 구현한 클래스가 생성되면 그 클래스에서 사용할 기본 기능이다. 디폴트 메서드는 default를 사용해 선언한다.  1 2 3 4 5 6 7 public interface Calc {     ...          default void description(){         System.out.println(\"정수 계산기를 구한다.\");     } }  디폴트는 일반 메서드와 동일하게 구현하고 자료형 앞에 default만 붙여주면 된다.  그럼 디폴트 메서드를 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package interfaceex;  public class Test {     public static void main(String[] args){         int num1 = 10;         int num2 = 5;          CompleteCalc cal = new CompleteCalc();         System.out.println(cal.add(num1,num2));         System.out.println(cal.substract(num1,num2));         System.out.println(cal.divide(num1,num2));         System.out.println(cal.times(num1,num2));         cal.showInfo();         cal.description();     } }   다음과 같이 인스턴스 cal을 생성하면 디폴트 메서드를 호출 할 수 있다.      이러한 디폴트 메서드도 마찬가지로 하위클래스에서 기능을 다르게 구현하고 싶다면, 재정의가 가능하다.   정적 메서드  정적 메서드는 static 예약어를 사용하여 선언하며 클래스 생성과 무관하게 사용할 수 있다.     정적 메서드를 사용할 때는 인터페이스 이름으로 직접 참조하여 사용한다. 그러면 Calc 인터페이스에 매개변수로 전달된 배열의 모든 요소 값을 더하는 정적 메서드 total()을 추가해 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package interfaceex;  public interface Calc {     double PI = 3.14;     int ERROR = -9999999;       int add(int num1,int num2);     int substract(int num1, int num2);     int times(int num1, int num2);     int divide(int num1,int num2);      default void description(){         System.out.println(\"정수 계산기를 구한다.\");     }          static int total(int[] arr){         int total = 0;                  for(int i : arr){             total+=i;         }         return total     } }   위 처럼 static을 사용하여 정적 메서드인 total을 선언해보았다.      마찬가지로 main함수에서 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package interfaceex;  public class Test {     public static void main(String[] args){         int num1 = 10;         int num2 = 5;          CompleteCalc cal = new CompleteCalc();         System.out.println(cal.add(num1,num2));         System.out.println(cal.substract(num1,num2));         System.out.println(cal.divide(num1,num2));         System.out.println(cal.times(num1,num2));         cal.showInfo();         cal.description();          int[] arr = {1,2,3,4,5}         System.out.println(\"총합 :\"+ Calc.total(arr));     } }  마지막줄에 정적메서드인 total을 호출하였다. 특이한점은 인스턴스로 참조한게 아니라 직접 인터페이스 이름으로 정적메서드를 호출하였다.   private 메서드  자바 9부터는 인터페이스에 private 메서드를 구현할 수 있다. private 메서드는 인터페이스를 구현한 클래스에서 사용하거나 재정의할 수 없다. 따라서 기존에 구현된 코드를 변경하지 않고 인터페이스를 구현한 클래스에서 공통으로 사용하는 경우에 private 메서드로 구현하면 코드 재사용성을 높일 수 있다.   private 메서드는 코드를 모두 구현해야 하므로 추상 메서드에 private을 사용할 순 없지만, static은 함께 사용할 수 있다. 그럼 Calc인터페이스에 private와 private static을 구현하고 이를 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package interfaceex;  public interface Calc {     double PI = 3.14;     int ERROR = -9999999;       int add(int num1,int num2);     int substract(int num1, int num2);     int times(int num1, int num2);     int divide(int num1,int num2);      default void description(){         System.out.println(\"정수 계산기를 구한다.\");         myMethod();     }      static int total(int[] arr){         int total = 0;          for(int i : arr){             total+=i;         }         myStaticMethod();         return total;     }      private void myMethod() {         System.out.println(\"private 메서드입니다.\");     }     private static void myStaticMethod(){         System.out.println(\"private static 메서드 입니다.\");     } }   private와 static private로 선언한 메서드를 각각 디폴트 메서드와 정적메서드에서 호출시켜주면 올바르게 호출 된 것을 확인 할 수 있다.   인터페이스 활용하기  한 클래스가 여러 클래스를 상속받으면 메서드 호출이 모호해지는 문제가 발생하곤 한다. 하지만 인터페이스는 한 클래스가 여러 인터페이스를 구현할 수 있다. 만약 Customer 클래스가 추상 메서드 buy()와 sell() 두 인터페이스를 구현하고 있다고 하자.  1 2 3 public interface Buy{     void buy(); }  1 2 3 public interfce Sell{     void sell(); }  이렇게 선언해준 추상메서드 두개를 구현해보면,  1 2 3 4 5 6 7 8 9 public class Customer implemeent Buy,Sell{     @override     public void buy(){     System.out.println(\"구매하기)     }     public void sell(){     System.out.println(\"구매하기)     }    }  인터페이스는 구현 코드나 멤버 변수를 갖지 않기 떄문에 여러 개를 동시에 구현 가능하다. 두 인터페이스에 이름이 같은 메서드가 선언되어도 구현은 클래스에서 이루어지므로, 어떤 메서드를 호출해야 하는지 모호하지 않은것이다.   이제, 테스트 프로그램에서 두가지 인터페이스를 구현가능한 Customer를 호출해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package interfaceex;  public class Test2 {     public static void main(String[] args){         Customer customer = new Customer();         Buy buyer = customer;         buyer.buy();          Sell seller = customer;         seller.sell();          if(seller instanceof Customer){             Customer customer2 = (Customer) seller;             customer2.buy();             customer2.sell();         }      } }  Customer 클래스형인 customer를 Buy 인터페이스 형인 buyer에 대입하여 형 변환한 뒤 buy()를 호출해주고, 다음은 customer를 Sell 인터페이스형은 seller에 대입하여 sell() 메서드를 호출 해보았다. 이처럼 우리가 구현한 Customer 클래스는 두가지를 다중 상속받은 것처럼 Buy와 Sell로 형변환이 가능한 것을 알 수 있다. 상속과 마찬가지로 instanceof로 하위클래스로의 형변환도 당연히 가능하다.   두 인터페이스의 디폴트 메서드가 중복되는 경우  정적 메서드는 인스턴스 생성과 상관없이 사용이 가능하다. 만약 Customer 클래스가 Buy,Sell 두 인터페이스를 구현하고   두 인터페이스에 pay()라는 정적메서드가 있다고 생각해보자. 이 경우 Buy.pay()와 Sell.pay()로 특정하여 호출할 수 있기 떄문에 문제가 되지 않는다. 그런데 디폴트 메서드는 어떻게 될까? 디폴트 메서드는 인스턴스를 생성해야 호출 가능한 메서드이기 때문에, 다음처럼 이름이같은 디폴트 메서드가 두 인터페이스에 있으면 문제가 된다.   다음 코드를 보자.  1 2 3 4 5 6 7 public interface Buy{     void buy();          default void order(){         System.out.println(\"구매 주문\");         } }  1 2 3 4 5 6 7 public interface Sell{     void buy();          default void order(){         System.out.println(\"판매 주문\");         } }  이렇게 정의 하고 두 인터페이스를 모두 구현하면 Customer 클래스에서는 오류가 발생한다.  두 디폴트 메서드가 중복되었으므로, Customer 클래스에서 재정의 해주어야 동일한 이름이어도 오류가 발생하지 않는다.  1 2 3 4 5 6 7 8 9 public class Customer implements Buy, Sell{          ...          @Overide     public void order(){         System.out.println(\"고객 판매 주문\") } }  위 와같이 재정의 해주면 오류가 발생하지않고, 재정의된 메서드가 호출된다.   인터페이스 상속  인터페이스 간에도 상속이 가능합니다. 인터페이스 간 상속을 구현 코드를 통해 기능을 상속하는 것이 아니므로 형 상속(type inheritance) 라고 부른다. 클래스의 경우에는 하나의 클래스만 상속받을 수 있지만, 인터페이스는 여러 개를 동시에 상속 받을 수 있다. 한 인터페이스가 여러 인터페이스를 상속받으면, 상속받은 인터페이스는 상위 인터페이스에 선언한 추상 메서드를 모두 가지게 된다.   만약 X와 Y라는 인터페이스를 선언해주고 이를 상속받는 인터페이스 MyInterface를 선언해준다면 이 인터페이스는 3개의 추상 메서드를 가진 인터페이스가 되는것이다. 따라서 MyInterface를 구현하려면 3개의 메서드를 구현해주어야 한다.   인터페이스 구현과 클래스 상속 함께 쓰기  한 클래스에서 클래스 상속과 인터페이스 구현을 모두 할 수도 있다. 다음은 Queue 인터페이스를 구현하고 Shelf 클래스를 상속받는 BookShelf 클래스를 나타낸 그림입니다.   BookShelf 클래스는 책을 넣은 순서대로 꺼내어 볼 수 있도록 만들려고 한다. BookShelf 클래스를 구현하기 전에 더 큰 개념인 Shelf 클래스를 먼저 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package bookshelf;  import java.util.ArrayList;  public class Shelf {     protected ArrayList&lt;String&gt; shelf;          public Shelf(){         shelf = new ArrayList&lt;String&gt;();     }          public ArrayList&lt;String&gt; getShelf(){         return shelf;     }     public int getCount(){         return shelf.size();     } }   Shelf 클래스에는 자료를 순서대로 저장할 배열 객체를 선언했다. 이름을 저장 할 수 있도록 자료형은 String을 사용한다. getShelf() 메서드는 저장되어있는 배열 shelf를 반환하고, getCount() 메서드는 배열 shelf에 저장된 요소 개수를 반환한다.   그럼 Queue 인터페이스를 정의해보자. Queue 인터페이스는 먼저 들어온 자료를 먼저 꺼내는 기능을 정의한다.  1 2 3 4 5 6 7 package bookshelf;  public interface Queue {     void enQueue(String title); //배열의 맨 마지막에 추가     String deQueue(); //배열의 맨 처음 항목 반환     int getSize(); //현재 Queue에 있는 개수 반환 }   이제 Shelf 클래스와 Queue 인터페이스를 사용하여 BookShelf 클래스를 다음과 같이 구현 할 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package bookshelf;  public class BookShelf extends Shelf implements Queue{      @Override     public void enQueue(String title) {         shelf.add(title);     }      @Override     public String deQueue() {         return shelf.remove(0)     }      @Override     public int getSize() {         return getCount();     } }  위의 코드를 보면 Shelf를 상속받고 Queue도 구현하는 BookShelf의 코드이다.     상속받은 shelf 멤버 변수를 사용해서 Queue 인터페이스에서 선언한 메서드를 구현한 것을 볼 수있다.   이제 책의 이름을 배열에 추가해주고, 순서대로 앞에서부터 출력해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package bookshelf;  public class BookShelfTest {     public static void main(String[] args){         Queue shelfQueue = new BookShelf();          shelfQueue.enQueue(\"태백산맥 1\");         shelfQueue.enQueue(\"태백산맥 2\");         shelfQueue.enQueue(\"태백산맥 3\");          System.out.println(shelfQueue.deQueue());         System.out.println(shelfQueue.deQueue());         System.out.println(shelfQueue.deQueue());     } }  &gt;&gt;&gt; 태백산맥 1 &gt;&gt;&gt; 태백산맥 2 &gt;&gt;&gt; 태백산맥 3  올바르게 배열의 앞에서부터 반환되어 큐의 역할을 잘 수행하는 것을 볼 수 있다.   실무에서 인터페이스를 사용하는 경우  인터페이스는 클래스가 제공할 기능을 선언하고 설계하는 것이다. 만약 여러 클래스가 같은 메서드를 서로 다르게 구현한다면 어떻게 해야할까? 우선 인터페이스에 메서드를 선언한 다음 인터페이스를 구현한 각 클래스에서 같은 메서드에 대해 다양한 기능을 구현하면 된다. 이것이 바로 인터페이스를 이용한 다형성의 구현이다.   이런 경우를 생각해보자. 어느회사에서 자료를 저장하기 위해 데이터베이스를 사용한다고 하면, 처음에는 MySQL 데이터 베이스를 사용했는데, 이 시스템을 다른 회사에 가서 설치하려고 하니 오라클 데이터 베이스를 사용하여 해달라고 하고, 또 다른 회사는 MS-SQL을 사용한다고 한다. 프로그램은 하나인데 사용하는 데이터 베이스가 제각각 인 것이다. 하지만 이프로그램의 웹페이지나 모바일 페이지는 데이터베이스의 종류와 관계없이 동일하게 수행된다.   데이터베이스와 연관되는 코드는 프로그램의 특정 부분인 것이지,나머지는 동일한것이다.     이런경우에 데이터베이스 기능을 인터페이스로 정의해주면 된다. 그리고 인터페이스 정의에 맞게 여러 데이터베이스 관련 모듈을 개발하면 되는것이다.   인터페이스를 잘 정의하는 것이 확장성 있는 프로그램을 만드는 시작이라고 할 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Programmers] 프렌즈4블록 (Python3)",
        "excerpt":"문제  프렌즈4블록  블라인드 공채를 통과한 신입 사원 라이언은 신규 게임 개발 업무를 맡게 되었다. 이번에 출시할 게임 제목은 “프렌즈4블록”.  같은 모양의 카카오프렌즈 블록이 2\u0014×2 형태로 4개가 붙어있을 경우 사라지면서 점수를 얻는 게임이다.      만약 판이 위와 같이 주어질 경우, 라이언이 2×2로 배치된 7개 블록과 콘이 2×2로 배치된 4개 블록이 지워진다. 같은 블록은 여러 2×2에 포함될 수 있으며, 지워지는 조건에 만족하는 2×2 모양이 여러 개 있다면 한꺼번에 지워진다.      블록이 지워진 후에 위에 있는 블록이 아래로 떨어져 빈 공간을 채우게 된다.      만약 빈 공간을 채운 후에 다시 2×2 형태로 같은 모양의 블록이 모이면 다시 지워지고 떨어지고를 반복하게 된다.      위 초기 배치를 문자로 표시하면 아래와 같다.  TTTANT     RRFACC     RRRFCC     TRRRAA     TTMMMF     TMMTTJ     각 문자는 라이언(R), 무지(M), 어피치(A), 프로도(F), 네오(N), 튜브(T), 제이지(J), 콘(C)을 의미한다  입력으로 블록의 첫 배치가 주어졌을 때, 지워지는 블록은 모두 몇 개인지 판단하는 프로그램을 제작하라.   입력 형식  입력으로 판의 높이 m, 폭 n과 판의 배치 정보 board가 들어온다.  2 ≦ n, m ≦ 30  board는 길이 n인 문자열 m개의 배열로 주어진다. 블록을 나타내는 문자는 대문자 A에서 Z가 사용된다.   출력 형식  입력으로 주어진 판 정보를 가지고 몇 개의 블록이 지워질지 출력하라.   입출력 예제  |m\t|n\t|board|\tanswer|  |:—:|:—:|:—:|:—:|  |4\t|5\t|[“CCBDE”, “AAADE”, “AAABF”, “CCBBF”]|\t14|  |6\t|6\t|[“TTTANT”, “RRFACC”, “RRRFCC”, “TRRRAA”, “TTMMMF”, “TMMTTJ”]|\t15|   문제풀이  카카오 문제들은 풀 때마다 까다로운 것 같다. 이 문제도 푸는데 너무 오랜시간이 걸렸다.  근데 논리 구조가 조금 까다로워서 그렇지, 사실 어려운 발상을 하거나 특정 알고리즘을 적용할 필요는 없는 문제였는데 자꾸 브루트포스말고 신박한 풀이를 생각해내려다 더욱 오래 걸렸다. 항상 시간복잡도를 생각해보고, 시간복잡도 신경 안써도 되겠다 싶은 문제면 그냥 브루트포스로 풀어버리는게 결국 더 문제를 빨리 푸는 방법인것 같다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def solution(m, n, boards):     #board를 이차원 배열로 받는 리스트 board     board_list = []          #board를 이차원 배열로 받는다.     for board in boards:         board_list.append(list(board))                    #오른쪽, 아래, 오른쪽 아래 대각을 확인할 dx,dy     dx = [1,0,1]     dy = [1,1,0]          count = 0               while 1:         #삭제여부를 0과 1로 나타낼 리스트 remove         remove = [[0 for i in range(n)]for i in range(m)]                  for i in range(m):             for j in range(n):                 if board_list[i][j] == '-':                     continue                 for k in range(3):                     nx = i+dx[k]                     ny = j+dy[k]                     if 0&lt;= nx &lt; m and 0&lt;= ny &lt; n:                         if board_list[i][j] != board_list[nx][ny]:                             break                     else:                         break                 else:                     remove[i][j] = 1                     for k in range(3):                         nx = i+dx[k]                         ny = j+dy[k]                         remove[nx][ny] = 1                              if max(map(max,remove))== 0:             break                      for i in range(m):             for j in range(n):                 if remove[i][j] == 1:                     board_list[i][j] = '-'                     count+=1         while 1:                   check = []             for i in range(m):                 for j in range(n):                     if board_list[i][j] == '-':                         if i-1 &gt;= 0 and board_list[i-1][j] != '-' :                             board_list[i][j] = board_list[i-1][j]                             board_list[i-1][j] = '-'                             check.append(1)             if len(check) == 0:                 break                  return count   1 2 3 4 5 6 7 8 solution(8, 5, ['HGNHU',                  'CRSHV',                  'UKHVL',                  'MJHQB',                  'GSHOT',                  'MQMJJ',                  'AGJKK',                  'QULKK'])   1 8   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%94%84%EB%A0%8C%EC%A6%884%EB%B8%94%EB%A1%9D/",
        "teaser": null
      },{
        "title": "[Programmers] 2개 이하로 다른 비트 (Python3)",
        "excerpt":"문제  양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.     x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수  예를 들어,   f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.                  수       비트       다른 비트의 개수                       2       000…0010                         3       000…0011       1              f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.                  수       비트       다른 비트의 개수                       7       000…0111                         8       000…1000       4                 9       000…1001       3                 10       000…1010       3                 11       000…1011       2           정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.   제한사항     1 ≤ numbers의 길이 ≤ 100,000   0 ≤ numbers의 모든 수 ≤ 1015   입출력 예  |numbers|\tresult|  |:—|:—|  |[2,7]|\t[3,11]|   입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.   문제 풀이  처음 문제를 보자마자 당연히 xor 비트연산자로 푸는 문제라고 생각해 풀었는데 테스트케이스 10,11에서 시간초과가 떴다. 테스트 케이스의 값의 크기들이 커서 시간초과가 중요한 문제 인줄은 알았지만, 비트 연산자가 내 생각보다 시간복잡도를 많이 잡아 먹는다는걸 알게되었다.   어쨌든 그래서 문제를 풀기위해 숫자를 하나하나 증가시켜가면서 어떻게 해야 비트가 2개이하인 가장 작은수를 찾을 수 있는지 노트에 써보았는데,  이렇게 구현방식을 정확하게 했음에도 풀리지 않는 문제는, 특이한 패턴이 있어 그 패턴을 찾아 구현하면 통과 된다는 것을 깨달았다.   이 문제는 비트가 2개 이하로 다르면서 가장 작은 수를 구하는 패턴을 찾아야 하는데, 짝수일 경우는 끝이 0이기 때문에 1하나만 바꿔주면 바로 다음 작은수가 된다. 따라서 짝수일때는 해당 숫자 +1을 답으로 저장해주면되고, 혹수일 경우는 오른쪽에서부터 0을 찾아서 그 값을 1로 바꾼뒤 그 다음인덱스를 0으로 바꿔주면 답이나온다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 def solution(numbers):     answer = []     for number in numbers:         if number%2 == 0:             answer.append(number+1)         else:             bin_num = list('0' + bin(number)[2:])             idx = ''.join(bin_num).rfind('0')             bin_num[idx] = '1'             bin_num[idx+1] = '0'             answer.append(int(''.join(bin_num),2))              return answer   1 solution([2,7])   1 [3, 11]   노트  역시 풀이를 보니까 너무나 간단한 풀이가 있었는데, 이번거는 좀 놀랐다…  너무 간단하게 풀었기 때문인데, 사실 저 패턴을 짧은시간에 직관적으로 찾아내는건 말이 안되는 것 같다.   아래에 코드 첨부한다.   1 2 3 4 5 6 7 def solution(numbers):     answer = []     for idx, val in enumerate(numbers):         answer.append(((val ^ (val+1)) &gt;&gt; 2) +val +1)      return answer   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/2%EA%B0%9C-%EC%9D%B4%ED%95%98%EB%A1%9C-%EB%8B%A4%EB%A5%B8-%EB%B9%84%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[Programmers] Weekly Challenge 1주차 (Python3)",
        "excerpt":"문제 설명  새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.   놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.   단, 금액이 부족하지 않으면 0을 return 하세요.   제한사항  놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수      처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수   놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수   입출력 예  |price|\tmoney|\tcount|\tresult|  |:—:|:—:|:—:|:—:|  |3\t|20|\t4|\t10|   입출력 예 설명  입출력 예 #1   이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.   참고 사항  미션 언어는 Java, JavaScript, Python3, C++ 만 해당 됩니다.  같은 코드를 제출한 사람이 여럿이라면 코드를 가장 먼저 제출한 분께 상품을 드립니다.  좋아요 수가 동일할 경우 코드를 가장 먼저 제출한 분께 상품을 드립니다.   문제 풀이  문제자체는 난이도 하중에 하인데, 중요한건 문제를 푸는것 보다 어떻게 하면 코드를 간결화하거나 신박하게 풀 수 있는지에 의의를 두고 진행하는 챌린지다 보니까 이 쉬운 문제를 보고 생각을 많이 했다. 파이썬인 만큼 한줄로 풀고 싶어서 lambda를 사용하여 나름 파이써닉 하게 풀이를 냈다. 근데 자꾸 테스트 케이스 하나가 오류가 떠서 극단적인 케이스 값을 넣으면서 시간을 더 썼는데, 다시보니까 금액이 안부족하면 0을 return 하라고 되어있었다… 너무 쉽다고 무시해서 문제를 제대로 안 읽었나…   코드   1 2 def solution(price, money, count):     return max(0,sum(list(map(lambda x: x*price,range(1,count+1))))-money)   1 solution(3,20,4)   1 10   노트  나름 한줄로 간결하게 풀었다고 생각했는데 역시나 더 간결하게 푼사람이 있었다.  역시 이런거 보면 알고리즘은 수학이 중요한지도…     1부터 n까지의 총합은 어차피 시작이 무조건 1이고 n이 더해야할 숫자의 개수이므로 n*(n+1)/2라고 할 수 있다. 그러면 이 총합에다가 price를 곱해서 money를 빼주면 바로 이 문제를 풀이할 수 있다. 아마 이 사람이 상품 타갈 것 같긴한데, 다음주에 빠르게 문제 풀면 상품 받기 크게 어렵지 않을지도…?   1 2 3 def solution(price, money, count):     return max(0,price*(count+1)*count//2-money)   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B6%80%EC%A1%B1%ED%95%9C-%EA%B8%88%EC%95%A1-%EA%B3%84%EC%82%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Java] Swing (1)",
        "excerpt":"Swing  자바에서 GUI를 개발하기 위해서는 AWT, SwIng등이 있는데, 이번 프로젝트는 Swing을 이용하여 만들어 보도록 할 것이다. 둘이 사용할 때의 차이는 예로 버튼 Button을 만든다면 AWT는 Button, Swing은 JButton을 사용한다. 앞의 J로 이 프로그램이 어떤 GUI 라이브러리로 만들어졌는지 알 수 있다.   컨테이너  GUI의 각각의 요소를 컴포넌트라고 한다. 버튼이나 텍스트등의 GUI의 요소들을 말하는데, 이러한 컴포넌트들이 자리를 잡을 화면, 창이 필요할 것이다. 이러한 창은 컨테이너 라고 한다. 컨테이너 조차도 하나의 컴포넌트라고 할 수 있는데, 이러한 컨테이너는 JFrame을 상속하여 만들어준다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package swing;   import javax.swing.*;  public class MyFrame{     public static void main(String[] args){         JFrame frame = new JFrame;                  frame.setSize(300,400);         frame.setTitle(\"첫 번째 프레임\");         frame.setResizable(false);         frame.setLocationRelativeTo(null);         frame.setVisible(true);     } }  JFrame을 상속한 MyFrame() 클래스를 만들어 주었다.      setTitle()은 창의 제목을 설정한다.   setSize()는 창의 크기를 설정한다.   setVisible은 창을 보이게 설정할 것인지, 안보이게 할 것인지를 정한다.   setResizeable은 창의 크기조절을 가능하게 할것인지를 정한다.   setLocationReativeTo는 매개변수를 null값으로 넣으면 창을 화면 정 가운데에 띄운다.   이제 main을 만들어 MyFrame의 생성자를 불러오면,      위와 같이 컨테이너를 생성했음을 알 수 있다.   이 창을 x를 눌러 닫으면 창은 닫혔지만, 다시 프로그램을 실행시키려 하면 이미 프로그램이 실행중이라고 종료 후 실행하겠다는 창이 뜬다. 따라서 창만 닫히고 프로그램은 종료되지 않고 있는 것이다. 따라서 창을 닫으면 프로그램이 종료 되는 기능을 추가해주어야 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package swing;   import javax.swing.*;  public class MyFrame{     public static void main(String[] args){         JFrame frame = new JFrame;                  frame.setSize(300,400);         frame.setTitle(\"첫 번째 프레임\");         frame.setResizable(false);         frame.setLocationRelativeTo(null);         frame.setVisible(true);         frame.serDefaultCloseOperation();     }  MyFrame생성자 안에 setDefaultCloseOperation() 메서드를 추가해주었다. 매개변수로 JFram.EXIT_ON_CLOSE를 넣어주면 시스템의 exit 메소드를 사용해서 프로그램을 같이 종료해준다.   여기까지는 GUI를 적용한 프로그램을 만들 때 반드시 추가해주어야 하는 부분이라고 할 수 있다.   버튼  그럼 이제 만들어준 컨테이너에 버튼을 한번 추가해보자.  1 2 3 4 5 6 7 MyFrame(){         setTitle(\"첫번째 프레임\");         setSize(300,400);         setVisible(true);         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         Container c = getContentPane();     }  먼저 컨탠트팬을 만들어준다. 창 자체위에 버튼들이 올라올 수 있는 공간으로 보통 우리가 보는 창에서 위의 상태창을 제외한 공간을 말한다.  getContentPane(); 을 추가하여 만들어주었다.   다음은 JButton 클래스를 사용해서 버튼의 인스턴스를 만들어 준 뒤, 컨테이너 자료형으로 선언한 c의 add() 메소드를 사용해서 버튼을 추가해주자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package swing;   import javax.swing.*; import java.awt.*;  public class MyFrame extends JFrame {     MyFrame(){         setTitle(\"첫번째 프레임\");         setSize(300,400);         setVisible(true);         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         Container c = getContentPane();         c.setLayout(new FlowLayout());          JButton j = new JButton(\"확인\");         JButton j2 = new JButton(\"취소\");          c.add(j);         c.add(j2);         setVisible(true);     }     public static void main(String[] args){         new MyFrame();     } }          setLayout : 컨테이너의 배치를 결정하는 배치관리자 메서드 이다. 매개변수로 배치관리자를 넣어 주면 되는데, 컨테이너마다 하나의 배치관리자가 존재하며, 컨테이너에 부착되는 컴포넌트의 위치와 크기를 결정해준다. 배치관리자의 대표유형은 4가지인데, 아래와 같다.              FlowLayout - 컴포넌트가 삽입되는 순서대로 왼쪽에서 오른쪽으로 배치, 배치할 공간이 없으면 아래로 내려와서 반복한다.       BorderLayout - 컨테이너의 공간을 동,서,남,북,중앙의 5개영역으로 나누어 응용 프로그램에서 지정한 영역에 컴포넌트를 배치한다.       GridLayout - 컨테이너를 프로그램에서 설정한 동일한 크기의 2차원 격자로 나눈다. 컴포넌트는 삽입 순서대로 좌에서우, 위에서 아래로 배치된다.       CardLayout - 컨테이너의 공간에 카드를 쌓아놓은 듯이 컴포넌트를 포개어 배치           우리는 FlowLayout을 사용하여 버튼을 추가했다.      JButton 자료형의 버튼 인스턴스를 만들어 준뒤, 매개변수로는 버튼에 사용하고 싶은 텍스트를 써준다. 그리고 해당 인스턴스에 있는 메서드인 add()를 사용하면 간단하게 버튼을 만들 수 있다.      또, JLabel을 자료형으로 만든 변수를 add를 통해 추가하면 그냥 텍스트가 출력이 된다.      또, 리스트를 통해서 버튼을 추가할 수도 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 package swing;  import javax.swing.*; import java.awt.*;  public class MyFrameEx extends JFrame {     Container c;     JButton buttonList[] = new JButton[4];     String strList[] ={\"확인\", \"취소\", \"뒤로가기\",\"앞으로가기\"};     MyFrameEx(){         setVisible(true);         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         setSize(300,400);         setTitle(\"나의 두 번째 창\");          c = getContentPane();         c.setLayout(new FlowLayout());          for(int i=0;i&lt;buttonList.length;i++){             buttonList[i] = new JButton(strList[i]);             c.add(buttonList[i]);         }         setVisible(true);      }     public static void main(String[] args){         new MyFrameEx();     } }  버튼과 버튼에 들어갈 문자열을 각각 리스트로 선언하여 버튼을 일일히 선언하지않고 한번에 처리하였다.      패널  패널은 프레임을 세부적으로 나누어주는 컴포넌트로, 패널을 나누어 놓으면 패널마다의 각각의 컴포넌트를 추가해놓고 패널단위로 가리거나 패널 단위로 편집할 수 있게 되어 유지보수에 편리하다. 패널은 패널안에도 추가할 수 있다.   패널은 JPanel로 선언하여, 배경색을 지정하고 안에 버튼을 넣어보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 package swing;  import javax.swing.*; import java.awt.*;    class MyFrame2 extends JFrame {     Container c;     JPanel jPanel = new JPanel();     JButton btn = new JButton();     JButton buttonList[] = new JButton[4];     String strList[] = {\"확인\", \"취소\", \"뒤로가기\",\"앞으로 가기\"};      MyFrame2(){         setTitle(\"나의 두번째 창\");         setSize(300,400);         setDefaultCloseOperation(EXIT_ON_CLOSE);         setButton();         setVisible(true);     }     void setButton(){         c = getContentPane();         jPanel.setBackground(Color.magenta);         jPanel.setLayout(new FlowLayout());          for(int i = 0; i&lt;4; i++){             buttonList[i] = new JButton(strList[i]);             jPanel.add(buttonList[i]);         }         c.add(jPanel);      }  }  public class MyFrame3 {      public static void main(String[] args){         new MyFrame2();     } }  깔끔하게 패널의 부분은 setButton() 메서드로 따로 정리 해주었다.     setBackground() : 패널의 배경색을 설정하도록 해준다.   setLayout() : 마찬가지로 패널을 어떻게 프레임에 넣을지 정해준다.   이렇게 실행한 창의 결과는 다음과 같다.     ","categories": ["java"],
        "tags": [],
        "url": "/java/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%EC%82%B0%EA%B8%B0-(1)/",
        "teaser": null
      },{
        "title": "[Programmers] 구명 보트(Python3)",
        "excerpt":"문제  무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.   예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.   구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.   사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.   제한사항     무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.   각 사람의 몸무게는 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.   입출력 예                  people       limit       return                       [70, 50, 80, 50]       100       3                 [70, 80, 50]       100       3           문제풀이  아무리 봐도 어려운 문제도 아니고 알고리즘이 이렇게 복잡할리가 없다 싶다 했더니… 2명이 최대라는 걸 안보고 자꾸 3명 4명타는 케이스를 생각하고 풀려고 하니까 문제가 풀리지를 않았다. 앞으로 문제를 밑줄쳐가면서 읽는 습관을 들여야겠다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def solution(peoples, limit):     boat = 0     peoples.sort()     left = 0     right = len(peoples)-1     while left &lt;= right:                 if peoples[left]+peoples[right] &gt; limit:             right-=1             boat+=1         else:             left+=1             right-=1             boat+=1                       return boat   1 solution([20,30,40,50,80,90], 100)   1 2 3 4 5 6 7 8 9 10 5 0 4 0 3 1 2 2      4   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[Programmers] 영어 끝말잇기 (Python3)",
        "excerpt":"문제  1부터 n까지 번호가 붙어있는 n명의 사람이 영어 끝말잇기를 하고 있습니다. 영어 끝말잇기는 다음과 같은 규칙으로 진행됩니다.     1번부터 번호 순서대로 한 사람씩 차례대로 단어를 말합니다.   마지막 사람이 단어를 말한 다음에는 다시 1번부터 시작합니다.   앞사람이 말한 단어의 마지막 문자로 시작하는 단어를 말해야 합니다.   이전에 등장했던 단어는 사용할 수 없습니다.   한 글자인 단어는 인정되지 않습니다.   다음은 3명이 끝말잇기를 하는 상황을 나타냅니다.   tank → kick → know → wheel → land → dream → mother → robot → tank   위 끝말잇기는 다음과 같이 진행됩니다.      1번 사람이 자신의 첫 번째 차례에 tank를 말합니다.   2번 사람이 자신의 첫 번째 차례에 kick을 말합니다.   3번 사람이 자신의 첫 번째 차례에 know를 말합니다.   1번 사람이 자신의 두 번째 차례에 wheel을 말합니다.   (계속 진행)   끝말잇기를 계속 진행해 나가다 보면, 3번 사람이 자신의 세 번째 차례에 말한 tank 라는   단어는 이전에 등장했던 단어이므로 탈락하게 됩니다.   사람의 수 n과 사람들이 순서대로 말한 단어 words 가 매개변수로 주어질 때, 가장 먼저 탈락하는 사람의 번호와 그 사람이 자신의 몇 번째 차례에 탈락하는지를 구해서 return 하도록 solution 함수를 완성해주세요.   제한 사항     끝말잇기에 참여하는 사람의 수 n은 2 이상 10 이하의 자연수입니다.   words는 끝말잇기에 사용한 단어들이 순서대로 들어있는 배열이며, 길이는 n 이상 100 이하입니다.   단어의 길이는 2 이상 50 이하입니다.   모든 단어는 알파벳 소문자로만 이루어져 있습니다.   끝말잇기에 사용되는 단어의 뜻(의미)은 신경 쓰지 않으셔도 됩니다.   정답은 [ 번호, 차례 ] 형태로 return 해주세요.   만약 주어진 단어들로 탈락자가 생기지 않는다면, [0, 0]을 return 해주세요.   입출력 예  |n|\twords|\tresult|  |:—:|:—:|:—:|  |3|\t[“tank”, “kick”, “know”, “wheel”, “land”, “dream”, “mother”, “robot”, “tank”]|\t[3,3]|  |5\t|[“hello”, “observe”, “effect”, “take”, “either”, “recognize”, “encourage”, “ensure”, “establish”, “hang”, “gather”, “refer”, “reference”, “estimate”, “executive”]\t|[0,0]|  |2\t|[“hello”, “one”, “even”, “never”, “now”, “world”, “draw”]\t|[1,3]|   입출력 예 설명  입출력 예 #1  3명의 사람이 끝말잇기에 참여하고 있습니다.      1번 사람 : tank, wheel, mother   2번 사람 : kick, land, robot   3번 사람 : know, dream, tank   와 같은 순서로 말을 하게 되며, 3번 사람이 자신의 세 번째 차례에 말한 tank라는 단어가 1번 사람이 자신의 첫 번째 차례에 말한 tank와 같으므로 3번 사람이 자신의 세 번째 차례로 말을 할 때 처음 탈락자가 나오게 됩니다.   입출력 예 #2  5명의 사람이 끝말잇기에 참여하고 있습니다.      1번 사람 : hello, recognize, gather   2번 사람 : observe, encourage, refer   3번 사람 : effect, ensure, reference   4번 사람 : take, establish, estimate   5번 사람 : either, hang, executive   와 같은 순서로 말을 하게 되며, 이 경우는 주어진 단어로만으로는 탈락자가 발생하지 않습니다. 따라서 [0, 0]을 return하면 됩니다.   입출력 예 #3  2명의 사람이 끝말잇기에 참여하고 있습니다.      1번 사람 : hello, even, now, draw   2번 사람 : one, never, world   와 같은 순서로 말을 하게 되며, 1번 사람이 자신의 세 번째 차례에 ‘r’로 시작하는 단어 대신, n으로 시작하는 now를 말했기 때문에 이때 처음 탈락자가 나오게 됩니다.   문제풀이  난이도가 2단계중에서 낮은 수준에 속하는 문제였다. 단순하게 이전 문자의 마지막과 다음문자의 첫 문자가 일치하는지 확인해주고, used리스트를 만들어서 이전에 사용된적 있는 단어인지 확인해주면 된다.   코드   1 2 3 4 5 6 7 8 9 10 def solution(n, words):     used = []     last = words[0][0]     for i,word in enumerate(words):         if last != word[0] or word in used:             return [(i%n)+1,(i//n)+1]         used.append(word)            last = word[-1]     return [0,0]        1 solution(5,[\"hello\", \"observe\", \"effect\", \"take\", \"either\", \"recognize\", \"encourage\", \"ensure\", \"establish\", \"hang\", \"gather\", \"refer\", \"reference\", \"estimate\", \"executive\"])   1 [0, 0]   노트  좋은 풀이가있어서 하나 더 첨부한다.      나는 따로 used 리스트와 last라는 변수를 만들어서 사용된 문자를 담고, 문자의 끝문자를 저장했는데, 그렇게 하지않고 words[:p]로 지금 순서 이전의 리스트를 used로 사용하고, 이전문자의 끝말도 따로 변수에 저장하지 않고 words[p-1][-1]로 인덱싱을 사용하여 메모리 공간을 내가 푼 풀이보다 훨씬 아낀 좋은 풀이인 것 같다. 나도 어떻게 하면 더 코드와 메모리를 줄일 수 있을지 더 신중하게 생각하며 문제를 풀어야겠다.   1 2 3 4 5 def solution(n, words):     for p in range(1, len(words)):         if words[p][0] != words[p-1][-1] or words[p] in words[:p]: return [(p%n)+1, (p//n)+1]     else:         return [0,0]  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%98%81%EC%96%B4-%EB%81%9D%EB%A7%90%EC%9E%87%EA%B8%B0/",
        "teaser": null
      },{
        "title": "모가디슈",
        "excerpt":"2021.08.06  원래는 좀 글쓰고 싶은거 있을때만 종종 좀 글빨있게(?) 쓰려고 했었다가,      얼마전에 여자친구가 블로그 시작해서 맨날 그냥 일상을 올리는 걸 보니 그게 너무 보기 좋아서.     나도 뭐 하루에 한개씩 되도록 그냥 일상글이라도 끄적여보려고 한다.   어제는 오랜만에 친구랑 영화관가서 영화를 봤다.      오랜만이라기엔 최근에도 종종 여자친구랑 가서 보긴했는데,     그냥 동네에서 친구랑 본게 오랜만이었다. 원래는 밑에서 버거킹 할인하는거 하나 사서.     먹으면서 보는게 국룰인데, 코로나 때문에 영화관내에서 음료 말고는 취식이 안되기도 하고…     무엇보다 영화가 재밌는게 안나왔었다. 그래도 이제 좀 코로나가 어쩔 수 없다는 걸 아는 건지 괜찮은게 하나씩     개봉하는 것 같은데, 오랜만에 재밌는 한국영화가 나온 것 같아서 영화관에 가서 봤다.   아니 근데 우선 영화관 욕좀 하고 시작해야겠다. 얘네는 코로나 때문에 잘안되면 영화비 내려서 관객 모을 생각을 해야지     왜이렇게 가격을 올리는지 모르겠다. 아니 한번 보는데 13000원은 좀 선넘지… 물론 어떻게 할인 받아서 9500원에 보긴했지만  진짜 가격좀 그만올렸으면 좋겠다. 그리고 skt는 언제 멤버십에서 영화 무료를 롯데시네마 빼고 없애 버렸는지 다음에 핸드폰 바꾸면 진짜 통신사 무조건 kt나 lg로 바꾼다 진짜. 솔직히 멤버십 쓰는거 영화관 밖에 없는데 그걸 없애?   어쨌든 영화 자체는 뭐 기대보다는 재미가 덜했지만 그럭저럭 재밌었다.     류승완 감독 영화는 군함도 빼고 다 본 것 같은데 이번에도 류승완 냄새나게 액션나름 찰지게 섞어서     실화 각색것 치고 재밌게 뽑은 것 같다. 우선 소말리아 저 위험한 나라 한가운데 서있는것 자체가 서스펜스라서,  보는 내내 긴장되고 재밌긴 했다. 마지막에 차에다가 책이랑 모래주머니 휘감고 달리는 장면도 멋졌고…      아니 근데 총을 저렇게 쏘는데 한명만 죽는건 조금 오바가 아닌가…   어쨌든 신파도 하나도 안섞고 나름 남한과 북한이 서로를 이해하고 잠깐의 목표를 위해서 화합하는건 인상깊긴했다.     그렇게 점점 두 단체가 쟤들도 우리랑 다를거 없는 그냥 사람이구나… 싶어지고 관객들이 더 이상 저 사람들을 북한사람과 남한 사람이   아닌 모두 살았으면 좋겠다는 마음을 갖게 될 때 즈음에 딱 우리는 남한이고 저들은 북한인걸 뼈저리게 인식시켜주므로써      아 맞다 쟤네들 북한이었지… 하며 체제의 다름에서 오는 섞일 수 없는 벽을 체감하게 해준다.   사실 극찬하는 리뷰를 보고 가서 너무 기대를 했는데, 영화자체는 오랜만에 나름 재밌게 봤고,     조인성 연기 잘해서 놀랐다. 특히 그 경찰서에서 총 이마에 들이밀고 소리지르는 장면은 카리스마 있고 멋지게 잘 담아낸것 같아서  영화 끝나고도 그 장면이 생각났다.   다음은 수어사이드 스쿼드가 보고싶은데… 이건 또 누구랑 봐야할지…     다음주까지 꼭 볼 생각이다. 영화보는걸 이렇게 좋아했었는데 코로나가 다 뺏어간게 애석하다.     그래도 이제 재밌는게 슬슬 나오는것 같으니 종종 가서 봐야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%AA%A8%EA%B0%80%EB%94%94%EC%8A%88/",
        "teaser": null
      },{
        "title": "[Java] Class 클래스",
        "excerpt":"Class 클래스란?  지금까지 변수를 선언할 때 자료형을 미리 파악하고 그 자료형에 따라 변수를 선언했다.     그리고 클래스를 사용할 때도 이미 그 클래스 정보(변수, 메서드)를 알고 있는 상황에서 프로그램을 만들었다. 하지만 어떤 경우에는 여러 클래스 중에 상황에 따라 다른 클래스를 사용해야 할 때도 있고, 반환받는 클래스가 정확히 어떤 자료형인지 모를 때도 있다. 이렇게 모르는 클래스의 정보를 사용할 경우에는 우리가 클래스 정보를 직접 찾아야한다. 이때 Class 클래스를 사용한다.   Class 클래스를 선언하고 클래스 정보를 가져오는 방법은 다음과 같다.      Object 클래스의 getClass() 메서드 사용하기     1 2 String s = new String(); Class c = s.getClass           클래스 파일 이름을 Class 변수에 직접 대입하기     1 Class c = String.Class;           Class.forName(“클래스 이름”) 메서드 사용하기     1 Class c = Class.forName(\"java.lang.String\")           1번의 경우는 모든 클래스가 사용할 수 있는 메서드이다. 이 메서드를 사용하려면 이미 생성된 인스턴스가 있어야한다. 2,3번의 경우는 컴파일된 클래스 파일이 있으면 클래스 이름만으로도 Class 클래스를 반화놘다.   다음 예제로 Class 클래스를 반환받아 사용해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package objectclass;  public class Person {     private String name;     private int age;      public Person(){}      public Person(String name){         this.name = name;     }      public Person(String name, int age){         this.name = name;         this.age = age;     }      public String getName(){         return name;     }      public void setName(String name){         this.name = name;     }      public int getAge(){         return age;     }      public void setAge(int age){         this.age = age     } }  이 예제 클래스는 사람의 이름과 나이를 변수로 갖고, 생성자 매개변수가 없는경우, 이름만 있는경우, 이름과 나이가 있는경우를 만들었고, get 과 set 함수를 만들어 이름과 나이를 불러오고, 접근할 수 있도록 만들었다.   이제 Person의 Class 클래스를 가져와보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package objectclass;  public class PersonTest {     public static void main(String[] args) throws ClassNotFoundException{         Person person = new Person();         Class pClass1 = person.getClass();         System.out.println(pClass1.getName());          Class pClass2 = Person.class;         System.out.println(pClass2.getName());          Class pClass3 = Class.forName(\"objectclass.Person\");         System.out.println(pClass3.getName());     } }  &gt;&gt;&gt; objectclass.Person &gt;&gt;&gt; objectclass.Person &gt;&gt;&gt; objectclass.Person  Person의 클래스를 가져온것을 확인할 수 있다.   Class를 활용해 클래스 정보 알아보기  프로그래밍을 하다 보면 내가 사용할 클래스의 자료형을 모르는 경우가 왕왕 생기곤한다. 예를 들어 내 컴퓨터에 저장되어 있지 않은 객체를 메모리에 로드하고 생성하는 경우에는 그 객체의 정보를 알기가 쉽지 않을 것 이다. 이때 Class 클래스를 가져올 수 있다면 해당 클래스의 생성자, 메서드, 멤버변수 정보를 찾을 수 있다. 이렇게 사용하려는 클래스의 자료형을 모르는 상태에서 Class 클래스를 활용하여 그 클래스의 정보를 가져오고, 이 정보를 활용하여 인스턴스를 생성하거나 메서드를 호출하는 방식을 리플렉션 (reflection) 이라고 한다.   그럼 클래스의 Constructor, Method, Field 클래스를 사용하여 리플렉션 프로그래밍을 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 package objectclass;  import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.Method;  public class StringClassTest {     public static void main(String[] args) throws ClassNotFoundException{         Class strClass = Class.forName(\"java.lang.String\");          Constructor[] cons = strClass.getConstructors();         for(Constructor c : cons) {             System.out.println(c);         }          System.out.println();         Field[] fields = strClass.getFields();         for(Field f : fields){             System.out.println(f);         }         System.out.println();         Method[] methods = strClass.getMethods();         for(Method m : methods){             System.out.println(m);         }     } }  Class 클래스를 가져오기위해 forName() 메서드를 사용한다. 이 메서드는 정적 메서드이므로 클래스를 생성하지 않아도 사용할 수 있으며, java.lang.String을 사용하여 Class를 가져왔다. 이제 String 클래스의 정보를 알 수 있는데, 출력결과를 보면 String 클래스의 여러 생성자를 볼 수 있다. 이렇게 Class 클래스와 java.lang.reflect 패키지에 있는 클래스를 활용하면 클래스 이름만 알아도 클래스의 생성자, 메서드등의 정보를 얻을 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Class-%ED%81%B4%EB%9E%98%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Java] Swing (2)",
        "excerpt":"간단한 로그인 프로그램  스윙의 기초나 대략 어떻게 사용하는지를 알아봤는데, 그냥 기초만 무작정 공부하기보다는  간단한 에제프로그램을 만들어보면서 익히는 것이 가장 어떤 툴이나 언어를 빨리 습득하는 방법이 아닐까 싶다  애초에 계산기 자체도 작은 프로젝트지만, 스윙은 또 처음 배우는 라이브러리기 때문에 숙달을 위해  느낌으로 아주 간단한 예제를 통해 스윙을 배워보도록 하려고 한다.   로그인프로그램은 간단하게 아이디와 비밀번호를 입력할 수 있는 패널을 만들어   아이디와 비밀번호가 서버에 있는 내용과 일치하면 로그인을 허락하는 방식이다.  계산기를 만들기 위해서는 특정한 버튼을 누르면 텍스트에리어에 숫자가 나오게 되고 이를 연산자로  처리해야하는데, 이러한 기능들을 숙달하기 위해서 간단하게 만들어 보도록하자   먼저 클래스의 이름을 LogIn으로 선언하고 이 프로그램의 뼈대를 만들어준다.  1 2 3 4 5 6 7 8 9 10 11 12 package swing;  import javax.swing.JFrame;  public class LogIn extends JFrame {     public LogIn(){              }     public static void main(String[] args){         new LogIn();     } }  LogIn 이라는 JFrame을 상속받는 클래스를 만들고, main함수에서 LogIn클래스를 실행하도록 해주었다.   그 다음 컨테이너의 대략적인 속성들을 지정하여 창을 띄울 수 있도록 해준다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package swing;  import javax.swing.JFrame;  public class LogIn extends JFrame {     public LogIn(){         setVisible(true);         setTitle(\"LogIn\");         setResizable(false);         setSize(600, 400);         setLocationRelativeTo(null);         setDefaultCloseOperation(EXIT_ON_CLOSE);     }     public static void main(String[] args){         new LogIn();     } }     setVisible() : rue로 함으로써 창이 보이도록 해주었다.   setTitle() :  창의 제목이 “LogIn”으로 뜨게 해주었다.   setResizable() : false로 설정하여 사이즈 조절이 불가능하게 설정하였다.   setSize() : 사이즈를 600 * 400 으로 설정했다.   setLocationRelativeTo() : 창을 정가운데에 띄우도록 한다.   setDefaultCloseOperation() : EXIT_ON_CLOSE를 매개변수로 입력해주면,   창을 닫으면 프로그램이 알아서 종료된다.      다음은 아이디의 컴포넌트가 들어갈 패널을 만들어 컨테이너에 넣어주도록 하자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package swing;  import javax.swing.*;  public class LogIn extends JFrame {     public LogIn(){         JPanel panel = new JPanel();         JLabel label = new JLabel(\"ID : \");         JTextField txtID = new JTextField(10);          panel.add(label);         panel.add(txtID);          add(panel);          setVisible(true);         setTitle(\"LogIn\");         setResizable(false);         setSize(600, 400);         setLocationRelativeTo(null);         setDefaultCloseOperation(EXIT_ON_CLOSE);     }     public static void main(String[] args){         new LogIn();     } }     panel 이라는 JPanel 인스턴스와 JLabel 의 새로운 인스턴스를 만들고,     이렇게 선언한 컴포넌트를 패널에 추가해준뒤, 이 패널을 컨테이너에 추가해준다.   그럼 이제 패스워드를 만들어 줄건데, JPasswordField()를 사용할 것이다.     우리가 인터넷에서 패스워드를 입력할 때, 패스워드는 입력은 가능하지만 *** 처럼 암호화되어 화면에 표시되는데,     이러한 입력을 도와주는 메서드이다.      아래 처럼 입력을 하면 화면에 암호화 되어 출력되는 것을 볼 수 있다.      다음은 JButton을 사용해 로그인 버튼을 만들어 준다.      이렇게 우리가 만들어 볼 프로그램의 UI가 대략 만들어졌다.     이제 이 UI에 기능을 추가해보자.   실제로 웹페이지에서의 로그인은 보안을 중요시 해야하기 때문에 복잡할 수 있겠지만,     지금 우리가 만드는 것은 단순하게 우리가 입력한 값이 저장된 아이디, 패스워드 값과 일치하면 로그인,     아니면 실패만 뜨면 되므로, 간단하게 구현할 수 있다.   addActionListener() 통해서 버튼에 로그인 기능을 구현해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package swing;  import javax.swing.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener;  public class LogIn extends JFrame {     ...              loginBtn.addActionListener(new ActionListener() {             @Override             public void actionPerformed(ActionEvent e) {                 String id = \"LMJ\";                 String pass = \"1234\";                  if(id.equals(txtID.getText()) &amp;&amp; pass.equals(txtPass.getText())){                     JOptionPane.showMessageDialog(null,\"로그인에 성공하였습니다.\",\"로그인 성공\",JOptionPane.INFORMATION_MESSAGE);                 }                 else{                     JOptionPane.showMessageDialog(null,\"로그인에 실패하였습니다.\",\"오류\",JOptionPane.ERROR_MESSAGE);                 }             }         });              ... }  간단하게 ID를 LMJ, Password를 1234로 설정해 주었는데, JOptionpane.showMessageDialog()를 사용하였다.       showMessageDialog()는 우리가 프로그램에서 보는 알림창을 띄워주는 메서드인데, 매개변수는 다음과 같다.      Component parentComponent : 메시지창이 어떤 Frame 에서 보이지게 될 것인지 지정해준다. 보통 null 을 사용한다.   Object message : 출력할 문자열을 써준다.   String title : 제목표시줄에 나타날 제목을 써준다.   int messageType : 메시지 종류를 지정해준다. ERROR_MESSAGE, INFORMATION_MESSAGE, WARNING_MESSAGE, QUESTION_MESSAGE, or PLAIN_MESSAGE 가 있다.   Icon icon : Icon 이미지를 설정한다.   이렇게 알림창을 간단히 설정 할 수 있게 해주는 메서드이다.       그럼 적용된 화면을 보도록 하면,      실패 알림창      성공 알림창   이렇게, 아주 간단한 로그인 프로그램을 Swing을 이용해 만들어 보았다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B3%84%EC%82%B0%EA%B8%B0-(2)/",
        "teaser": null
      },{
        "title": "[Programmers] 다리를 지나는 트럭 (Python3)",
        "excerpt":"문제  트럭 여러 대가 강을 가로지르는 일차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 다리에는 트럭이 최대 bridge_length대 올라갈 수 있으며, 다리는 weight 이하까지의 무게를 견딜 수 있습니다. 단, 다리에 완전히 오르지 않은 트럭의 무게는 무시합니다.   예를 들어, 트럭 2대가 올라갈 수 있고 무게를 10kg까지 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다.                  경과 시간       다리를 지난 트럭       다리를 건너는 트럭       대기 트럭                       0       []       []       [7,4,5,6]                 1~2       []       [7]       [4,5,6]                 3       [7]       [4]       [5,6]                 4       [7]       [4,5]       [6]                 5       [7,4]       [5]       [6]                 6~7       [7,4,5]       [6]       []                 8       [7,4,5,6]       []       []           따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다.   solution 함수의 매개변수로 다리에 올라갈 수 있는 트럭 수 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭 별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요.   제한 조건     bridge_length는 1 이상 10,000 이하입니다.   weight는 1 이상 10,000 이하입니다.   truck_weights의 길이는 1 이상 10,000 이하입니다.   모든 트럭의 무게는 1 이상 weight 이하입니다.   입출력 예  |bridge_length    |weight|    truck_weights|    return|  |:—:|:—:|:—:|:—:|  |2|    10    |[7,4,5,6]    |8|  |100|    100    |[10]|    101|  |100|    100    |[10,10,10,10,10,10,10,10,10,10]|    110|  문제 풀이  처음에는 아예 실제 다리랑 똑같이 움직이는 큐를 만드려고 아예 0을 biridge_length만큼 데크로 만든 뒤 새로 들어오면 0이 popleft()되고 다음 차의 무게가 들어와 하나씩 밀리는 식으로 해서 그때마다 시간을 1초씩 추가해서 만들려고 했다. 사실 내심 시간초과가 뜰거라고 생각했는데, 진짜 시간 초과가 떠서 더 간단한 코드를 생각하게 되었다.   처음에는 모든 경우의 수를 다 제각각 코딩했었는데, 다시 간단하게 생각해보니 그냥 계속 time을 1씩 더하면서 큐를 밀어내주면 훨씬 간단하게 시간을 측정할 수가 있었다.   근데 이렇게 풀어도 자꾸 테스트 케이스 하나에서 시간초과가 떴다!     진짜 아무리봐도 더 줄일 수가 없다고 생각했는데 문제는 sum()이었다.   다리위의 차량들의 무게의 총합을 구하려고 sum(queue)를 사용하고 있었는데, 이게 시간복잡도를 꽤 잡아 먹고 있었다.   sum()을 사용하지말고 따로 다리위의 차량들의 무게를 따로 저장하는 변수를 만들어 차가 올라갈때나 내려올때 변수가 달라지게 만들었다. 앞으로 시간초과가 이유없이 뜬다면 sum() 함수를 없애줌으로써 시간을 절약할 수 있다는걸 알게 되었다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from collections import deque def solution(bridge_length, weight, truck_weights):     time = 0     queue = deque([0]* bridge_length)     bridge_weight = 0     while queue:         time+=1         out_truck = queue.popleft()                  if out_truck != 0:             bridge_weight-=out_truck                      if truck_weights:             if bridge_weight + truck_weights[0] &lt;= weight:                 in_truck = truck_weights.pop(0)                 queue.append(in_truck)                 bridge_weight+=in_truck                              else:                 queue.append(0)     return time   1 solution(2, 10, [7, 4, 5, 6])   1 8   잘못 풀었던 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import deque def solution(bridge_length, weight, truck_weights):          queue = deque(0 for _ in range(bridge_length))     time = 0          for i in range(len(truck_weights)):                  if sum(queue)+ truck_weights[i] &lt;= weight and 0 &lt; queue.count(0):             queue.popleft()             queue.append(truck_weights[i])             time+=1         else:             while 1:                 queue.popleft()                 queue.append(0)                 time+=1                 if queue.count(0) == bridge_length or sum(queue)+ truck_weights[i]&lt;= weight:                     queue.popleft()                     queue.append(truck_weights[i])                     break          while queue:         queue.popleft()         time+=1     return time  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8B%A4%EB%A6%AC%EB%A5%BC-%EC%A7%80%EB%82%98%EB%8A%94-%ED%8A%B8%EB%9F%AD/",
        "teaser": null
      },{
        "title": "[Programmers] 큰 수 만들기 (Python3)",
        "excerpt":"문제  어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는가장 큰 숫자를 구하려 합니다.   예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.   문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.   제한 조건     number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.   k는 1 이상 number의 자릿수 미만인 자연수입니다.   입출력 예  |number\t|k\t|return|  |:—:|:—:|:—:|  |”1924”|\t2\t|”94”|  |”1231234”\t|3|\t“3234”|  |”4177252841”|\t4|\t“775841”|   문제 풀이  풀고나니까 별로 안어려웠는데도 왜인지 발상이 너무 안 떠올라서 오래걸렸다. 생각하는걸 코드로 구현못하는건 그만큼 더 열심히 해야겠다고 생각하고 다음 문제를 풀게 되는데, 이렇게 발상 조차 안되서 코드 한줄도 못적고 노트에만 쓰고 있다보면 진짜 답답하고 나 자신한테 화가난다. 이번 문제도 그다지 어려운 알고리즘도 아닌데 도대체 왜 못떠올렸는지… 좀 패턴을 찾는 문제에 약한 것같다.   이 문제는 가장 큰 수를 만드는 문제이므로, 앞에서부터 리스트에 저장해가면서 만약 리스트의 가장 마지막 숫자가 다음 숫자보다 크다면 그 숫자를 바로 리스트에 추가하고, 다음 숫자보다 작다면 그 숫자보다 큰수가 나올때까지 리스트의 맨 마지막 값을 없애주고 다음 숫자를 추가하는 방식으로 가장 큰 수를 만들 수 있다.   또, 반드시 예외 처리를 해주어야하는데, 54321 처럼 내림차순의 모양을 띄는 숫자는 계속 리스트의 마지막 숫자가 다음숫자보다 크므로 삭제가 일어나지않기때문에, 가장 큰 수를 만드는 것은 뒤에서 부터 k만큼 삭제하는 것이므로, 따로 예외를 처리해주어 출력하도록 한다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  def solution(number, k):     result = []     number = list(number)     remove=0     for num in number:         if not result:             result.append(num)             continue         while result and result[-1] &lt; num:             if remove == k:                 result.append(num)                 break             result.pop()             remove+=1                      else:             result.append(num)                  if len(result) &gt; len(number)-k:         return \"\".join(result[:len(number)-k])          return \"\".join(result)                                 1 solution(\"54321\",2)   1 '543'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 카펫 (Python3)",
        "excerpt":"문제  Leo는 카펫을 사러 갔다가 아래 그림과 같이 중앙에는 노란색으로 칠해져 있고 테두리 1줄은 갈색으로 칠해져 있는 격자 모양 카펫을 봤습니다.      Leo는 집으로 돌아와서 아까 본 카펫의 노란색과 갈색으로 색칠된 격자의 개수는 기억했지만, 전체 카펫의 크기는 기억하지 못했습니다.   Leo가 본 카펫에서 갈색 격자의 수 brown, 노란색 격자의 수 yellow가 매개변수로 주어질 때 카펫의 가로, 세로 크기를 순서대로 배열에 담아 return 하도록 solution 함수를 작성해주세요.   제한사항     갈색 격자의 수 brown은 8 이상 5,000 이하인 자연수입니다.   노란색 격자의 수 yellow는 1 이상 2,000,000 이하인 자연수입니다.   카펫의 가로 길이는 세로 길이와 같거나, 세로 길이보다 깁니다.   입출력 예  |brown|\tyellow\t|return|  |:—:|:—:|:—:|  |10|\t2\t|[4, 3]|  |8|\t1|\t[3, 3]|  |24\t|24\t|[8, 6]|   문제풀이  맨처음에는 좌표를 하나씩 늘려가면서 갈색과 노란색의 모든 경우의 수를 찾다가 같은 값이 나오면 그 좌표를 리턴하는 형식으로 코드를 짰는데 역시나 시간초과가 떴다.   그래서 조금 더 생각을 간단히 해서 굳이 모든 사각형의 크기가 아니라 안쪽의 노란색 사각형의 크기만 생각해보기로 했는데, 노란색 사각형은 결국 3,3인 사각형일 때 1이므로 여기서 가로로 사각형이 커지면 노란색 사각형도 같이 1증가하고 세로로 커지면 같이 세로로 1증가한다. 따라서 yellow에 주어진 넓이를 구성할 수 있는 사각형의 가로와 세로를 모두 구해준 후, 그 가로와 세로가 구성하는 큰 사각형이 brown의 넓이와 일치한다면 그때의 가로와 세로를 리턴해주면 된다.   코드   1 2 3 4 5 6 7 8 def solution(brown, yellow):     i = 1     while 1:         if yellow % i == 0:             if (i+2)*(yellow/i+2)-yellow == brown:                     return[max(i+2,yellow//i+2),min(i+2,yellow//i+2)]             i+=1   1 solution(10,2)   1 [4, 3]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%B9%B4%ED%8E%AB/",
        "teaser": null
      },{
        "title": "[Programmers] 타겟 넘버 (Python3)",
        "excerpt":"문제  n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.   -1+1+1+1+1 = 3     +1-1+1+1+1 = 3     +1+1-1+1+1 = 3     +1+1+1-1+1 = 3     +1+1+1+1-1 = 3   사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.   제한사항     주어지는 숫자의 개수는 2개 이상 20개 이하입니다.   각 숫자는 1 이상 50 이하인 자연수입니다.   타겟 넘버는 1 이상 1000 이하인 자연수입니다.   입출력 예  |numbers|\ttarget|\treturn|  |:—:|:—:|:—:|  |[1, 1, 1, 1, 1]\t|3\t|5|   입출력 예 설명  문제에 나온 예와 같습니다.   문제풀이  제한사항에 주어진 개수와 경우의 수가 매우 적어서 그냥 브루트포스로 combinations를 이용하여 모든 조합을 찾아서 답을 찾았다. 브루트포스로 푼다는 가정하에 combinations 메서드만 알면 난이도가 낮은 문제인 것 같다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 from itertools import combinations  def solution(numbers, target):     result = 0     for i in range(len(numbers)):             combi = list(combinations([i for i in range(len(numbers))],i))             for com in combi:                 change_num = numbers.copy()                                  for idx in com:                     change_num[idx] = -change_num[idx]                 if sum(change_num) == target:                     result+=1                return result   1 solution([1,1,1,1,1], 3)   1 5   노트  사실 브루트포스로 그냥 풀겠다고 마음먹을 때부터 100명중에 50등 정도하는 코드라고 생각하긴 했는데, 100명중에 1등 급인 코드가 진짜 말도안되게 아름답게 코드를 짜서 첨부한다. 난 언제 저렇게 될까…   1 2 3 4 5 6 7 def solution(numbers, target):     if not numbers and target == 0 :         return 1     elif not numbers:         return 0     else:         return solution(numbers[1:], target-numbers[0]) + solution(numbers[1:], target+numbers[0])   그러고보니까 이 문제의 분류가 dfs/bfs로 되어있었다.     그래서 나도 처음에는 dfs/bfs로 생각하다가 잘 안풀리길래, 제한사항 경우의 수를 보니 시간적합도 남아 돌겠다 싶어서 브루트포스로 풀어버렸다.   타겟넘버가 dfs/bfs 문제인 이유는 다음인덱스에 해당하는 numbers 원소를 더하거나 뺀값을 새로운 노드로 모두 생성해주고, 그 값로 만든 새로운 그래프에 하나씩 방문하면서 numbers의 합이 같을때마다 count해주면 되기 때문이다.   그래서 저 위 코드는 numbers에 존재하는 값을 target에다가 더하거나 빼서 target이 0이 나오면 1을 리턴하고 0이 아니면 0을 리턴한 후, numbers를 그 다음요소부터 [1:]로 인덱싱하여 재귀함수로 다시 solution을 호출하는 방식으로 numbers의 요소를 각각 +,-로 바꿔가며 계산하여 풀었다.   사실 보다보니까 음수가 난 여러개인 경우의 수도 있다고 생각했는데, 사실 답은 음수는 무조건 하나여서 문제 설명이 좀 부족한게 아닌가 하는 생각이 들었다. 예제를 더 주던지, 제한사항을 추가해야할듯…  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%83%80%EA%B2%9F%EB%84%98%EB%B2%84/",
        "teaser": null
      },{
        "title": "[Programmers] Weekly Challenge 2주차 (Python3)",
        "excerpt":"문제  대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.                  No.       0       1       2       3       4                       0       100       90       98       88       65                 1       50       45       99       85       77                 2       47       88       95       80       67                 3       61       57       100       80       65                 4       24       90       94       75       65                 평균       45.5       81.25       97.2       81.6       67.8                 학점       F       B       A       B       D           위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.      0번 학생이 평가한 점수는 0번 행에담긴 [100, 90, 98, 88, 65]입니다.   0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.   2번 학생이 평가한 점수는 2번 행에담긴 [47, 88, 95, 80, 67]입니다.        2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.  당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.     만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.       0번 학생이 받은 점수는 0번 열에 담긴 [100, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.   0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.   4번 학생이 받은 점수는 4번 열에 담긴 [65, 77, 67, 65, 65]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다.   4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.   제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.                  평균       학점                       90점 이상       A                 80점 이상 90점 미만       B                 70점 이상 80점 미만       C                 50점 이상 70점 미만       D                 50점 미만       F           학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.   제한사항     2 ≤ scores의 행의 길이(학생 수) ≤ 10   scores의 열의 길이 = scores의 행의 길이   즉, scores는 행과 열의 길이가 같은 2차원 배열입니다.   0 ≤ scores의 원소 ≤ 100   return 값 형식   0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.   입출력 예  |scores|\tresult|  |:—:|:—:|  |[[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]|\t“FBABD”|  |[[50,90],[50,87]]|\t“DA”|  |[[70,49,90],[68,50,38],[73,31,100]]|\t“CFD”|   입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.   입출력 예 #2     No.\t0\t1     0\t50\t90     1\t50\t87     평균\t50\t90     학점\tD\tA   1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.   입출력 예 #3  No.\t0\t1\t2     0\t70\t49\t90     1\t68\t50\t38     2\t73\t31\t100     평균\t70.33…\t40\t64     학점\tC\tF\tD   1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.      2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.   문제풀이  역시나 코드를 줄이는게 관건인 위클리 챌린지라 문제를 그저 풀고자 하면 푸는 것은 난이도가 쉽다. 근데 이 문제는 오히려 코드를 줄이는게 굉장히 마땅한 방법이 없어서, 고민하다 그냥 제출했는데 다른사람 풀이를 봐도, ‘이건 획기적으로 줄였다.’ ‘나는 왜 이 생각을 못했지?’ 싶은 풀이는 없고 그냥 한줄풀이를 한 사람의 좋아요 수가 가장 많았다. 저런 한줄코드는 오히려 가독성만 떨어지고 별로라 굳이 분석하고 싶지도 않았다. 다음 위클리 챌린지 때는 더 멋진 코드를 뽐낼 수 있을만한 문제로 나오면 좋겠다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 def solution(scores):     result = []     student = [[]for _ in range(len(scores))]     for score in scores:         #print(score[i])         for k,j in enumerate(score):             student[k].append(j)     for i,stu in enumerate(student):         if stu[i] == max(stu) or stu[i] == min(stu):             if stu.count(stu[i])&lt;2:                 stu.remove(stu[i])                   for i in student:         aver = sum(i)/len(i)         print(aver)         if 90&lt;=aver:             result.append('A')         elif 80 &lt;= aver &lt;90:             result.append('B')         elif 70 &lt;= aver &lt;80:             result.append('C')             elif 50 &lt;= aver &lt;70:             result.append('D')         else:             result.append('F')     return \"\".join(result)   1 solution([[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]])   1 2 3 4 5 6 7 8 9 10 11 12 [[50, 47, 61, 24], [90, 88, 57, 90], [98, 99, 95, 100, 94], [88, 85, 80, 80, 75], [65, 77, 67, 65, 65]] 45.5 81.25 97.2 81.6 67.8      'FBABD'   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Weekly-Challenge-2%EC%A3%BC%EC%B0%A8/",
        "teaser": null
      },{
        "title": "[Programmers] 위장 (Python3)",
        "excerpt":"문제  스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.  예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다.                  종류       이름                       얼굴       동그란 안경, 검정 선글라스                 상의       파란색 티셔츠                 하의       청바지                 겉옷       긴 코트           스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요.   제한사항     clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다.   스파이가 가진 의상의 수는 1개 이상 30개 이하입니다.   같은 이름을 가진 의상은 존재하지 않습니다.   clothes의 모든 원소는 문자열로 이루어져 있습니다.   모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 ‘_’ 로만 이루어져 있습니다.   스파이는 하루에 최소 한 개의 의상은 입습니다.   입출력 예  |clothes|\treturn|  |:—:|:—:|  |[[“yellowhat”, “headgear”], [“bluesunglasses”, “eyewear”], [“green_turban”, “headgear”]]\t|5|  |[[“crowmask”, “face”], [“bluesunglasses”, “face”], [“smoky_makeup”, “face”]]|\t3|   입출력 예 설명  예제 #1  headgear에 해당하는 의상이 yellow_hat, green_turban이고 eyewear에 해당하는 의상이 blue_sunglasses이므로 아래와 같이 5개의 조합이 가능합니다.     yellow_hat   blue_sunglasses   green_turban   yellow_hat + blue_sunglasses   green_turban + blue_sunglasses   예제 #2  face에 해당하는 의상이 crow_mask, blue_sunglasses, smoky_makeup이므로 아래와 같이 3개의 조합이 가능합니다.     crow_mask   blue_sunglasses   smoky_makeup   문제 풀이  처음에는 딕셔너리에 리스트로 종류에 따른 옷을 넣어서 그걸 또 조합으로 빼서 모든 경우의 수를 하나씩 더해가며 답을 구했는데, 모두 통과되는듯 싶더니 테스트 케이스 1번에서 계속 시간초과가 떴다. 다시 문제를 놓고 간단한 조합문제로 생각해보니까, 각각의 옷종류에 안입은 경우를 하나씩 추가해서 위의 예제 1로 예를 들면 headgear = [안입음, yellow_hat, grren_turban], eyewear = [안입음, blue_sunglasses] 으로 두면 두 종류이니까 3*2 = 6으로 모든 경우의 수를 구할 수 가 있었다. 여기서 아무것도 안입은 경우의 수 1을 빼주면 답이된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 def solution(clothes):     dic = {}     answer = 1          for cloth in clothes:         if cloth[1] in dic:             dic[cloth[1]]+=1         else:             dic[cloth[1]]= 1     for i in dic.values():         answer *= (i+1)     return answer-1   1 solution([[\"yellowhat\", \"headgear\"], [\"bluesunglasses\", \"eyewear\"], [\"green_turban\", \"headgear\"]]\t)   1 5   노트  라이브러리를 이용해 예쁘게 푼 코드가 있어서 첨부한다.     reduce라는 처음 써보는 메서드도 있었다.   1 2 3 4 5 6 def solution(clothes):     from collections import Counter     from functools import reduce     cnt = Counter([kind for name, kind in clothes])     answer = reduce(lambda x, y: x*(y+1), cnt.values(), 1) - 1     return answer   개수를 세려면 무조건 Counter를 써주는게 편하다. Counter를 잘쓰자   reduce 함수는 functools 라이브러리를 통해서 import한다.   1 from functools import reduce   reduce() 함수는 여러개의 데이터를 대상으로 주로 누적 집계를 내기 위해서 사용한다.     reduce(집계 함수, 순회 가능한 데이터 [, 초기값])   예를들어 유저 5명의 데이터를 임의로 생성해보자.   1 2 3 4 5 users = [{'mail': 'gregorythomas@gmail.com', 'name': 'Brett Holland', 'sex': 'M', 'age': 73}, {'mail': 'hintoncynthia@hotmail.com', 'name': 'Madison Martinez', 'sex': 'F', 'age': 29}, {'mail': 'wwagner@gmail.com', 'name': 'Michael Jenkins', 'sex': 'M', 'age': 51}, {'mail': 'daniel79@gmail.com', 'name': 'Karen Rodriguez', 'sex': 'F', 'age': 32}, {'mail': 'ujackson@gmail.com', 'name': 'Amber Rhodes', 'sex': 'F', 'age': 42}]   이 데이터에서 reduce 함수를 사용해 유저들의 나이 합을 구해보자.   1 reduce(lambda acc, cur : acc+cur[\"age\"], users,0)   1 227   reduce의 첫번째 파라미터는 함수가 들어가게 된다. 람다식이 들어올수도 있고, 정의 해놓은 함수일 수도 있다. 두번째 파라미터는 집계할 리스트, 세번재는 초기값을 받는다.   이번에는 유저 이메일만을 모아 목록으로 만들어보자.   1 reduce(lambda acc, cur: acc +[cur[\"mail\"]],users,[])   1 2 3 4 5 ['gregorythomas@gmail.com',  'hintoncynthia@hotmail.com',  'wwagner@gmail.com',  'daniel79@gmail.com',  'ujackson@gmail.com']   마찬가지로 첫번째 파라미터에 함수를 받고, acc의 초깃값을 []로 해준뒤, [cur[“mail”]]을 순차적으로 더해준다.   이렇게 reduce를 사용하면 간편하게 딕셔너리나 리스트의 값을 집계할 수 있다. 정말 유용한 라이브러리인 것 같으니 꼭 생각해주자.   딕셔너리하면 Counter, reduce 생각하기  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%9C%84%EC%9E%A5/",
        "teaser": null
      },{
        "title": "[Programmers] 순위 검색 (Python3)",
        "excerpt":"문제 설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]  카카오는 하반기 경력 개발자 공개채용을 진행 중에 있으며 현재 지원서 접수와 코딩테스트가 종료되었습니다. 이번 채용에서 지원자는 지원서 작성 시 아래와 같이 4가지 항목을 반드시 선택하도록 하였습니다.      코딩테스트 참여 개발언어 항목에 cpp, java, python 중 하나를 선택해야 합니다.   지원 직군 항목에 backend와 frontend 중 하나를 선택해야 합니다.   지원 경력구분 항목에 junior와 senior 중 하나를 선택해야 합니다.   선호하는 소울푸드로 chicken과 pizza 중 하나를 선택해야 합니다.   인재영입팀에 근무하고 있는 니니즈는 코딩테스트 결과를 분석하여 채용에 참여한 개발팀들에 제공하기 위해 지원자들의 지원 조건을 선택하면 해당 조건에 맞는 지원자가 몇 명인 지 쉽게 알 수 있는 도구를 만들고 있습니다.   예를 들어, 개발팀에서 궁금해하는 문의사항은 다음과 같은 형태가 될 수 있습니다.      코딩테스트에 java로 참여했으며, backend 직군을 선택했고, junior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 50점 이상 받은 지원자는 몇 명인가?    물론 이 외에도 각 개발팀의 상황에 따라 아래와 같이 다양한 형태의 문의가 있을 수 있습니다.      코딩테스트에 python으로 참여했으며, frontend 직군을 선택했고, senior 경력이면서, 소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?   코딩테스트에 cpp로 참여했으며, senior 경력이면서, 소울푸드로 pizza를 선택한 사람 중 코딩테스트 점수를 100점 이상 받은 사람은 모두 몇 명인가?   backend 직군을 선택했고, senior 경력이면서 코딩테스트 점수를 200점 이상 받은 사람은 모두 몇 명인가?   소울푸드로 chicken을 선택한 사람 중 코딩테스트 점수를 250점 이상 받은 사람은 모두 몇 명인가?   코딩테스트 점수를 150점 이상 받은 사람은 모두 몇 명인가?   즉, 개발팀에서 궁금해하는 내용은 다음과 같은 형태를 갖습니다.      [조건]을 만족하는 사람 중 코딩테스트 점수를 X점 이상 받은 사람은 모두 몇 명인가?   문제  지원자가 지원서에 입력한 4가지의 정보와 획득한 코딩테스트 점수를 하나의 문자열로 구성한 값의 배열 info, 개발팀이 궁금해하는 문의조건이 문자열 형태로 담긴 배열 query가 매개변수로 주어질 때,  각 문의조건에 해당하는 사람들의 숫자를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해 주세요.   제한사항     info 배열의 크기는 1 이상 50,000 이하입니다.   info 배열 각 원소의 값은 지원자가 지원서에 입력한 4가지 값과 코딩테스트 점수를 합친 “개발언어 직군 경력 소울푸드 점수” 형식입니다.   개발언어는 cpp, java, python 중 하나입니다.   직군은 backend, frontend 중 하나입니다.   경력은 junior, senior 중 하나입니다.   소울푸드는 chicken, pizza 중 하나입니다.   점수는 코딩테스트 점수를 의미하며, 1 이상 100,000 이하인 자연수입니다.   각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.   query 배열의 크기는 1 이상 100,000 이하입니다.   query의 각 문자열은 “[조건] X” 형식입니다.   [조건]은 “개발언어 and 직군 and 경력 and 소울푸드” 형식의 문자열입니다.   언어는 cpp, java, python, - 중 하나입니다.   직군은 backend, frontend, - 중 하나입니다.   경력은 junior, senior, - 중 하나입니다.   소울푸드는 chicken, pizza, - 중 하나입니다.   ’-‘ 표시는 해당 조건을 고려하지 않겠다는 의미입니다.   X는 코딩테스트 점수를 의미하며 조건을 만족하는 사람 중 X점 이상 받은 사람은 모두 몇 명인 지를 의미합니다.   각 단어는 공백문자(스페이스 바) 하나로 구분되어 있습니다.   예를 들면, “cpp and - and senior and pizza 500”은 “cpp로 코딩테스트를 봤으며, 경력은 senior 이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 500점 이상 받은 사람은 모두 몇 명인가?”를 의미합니다.  [입출력 예]  |info|\tquery|\tresult|  |:—:|:—:|:—:|  |[“java backend junior pizza 150”,”python frontend senior chicken 210”,”python frontend senior chicken 150”,”cpp backend senior pizza 260”,”java backend junior chicken 80”,”python backend senior chicken 50”]\t|[“java and backend and junior and pizza 100”,”python and frontend and senior and chicken 200”,”cpp and - and senior and pizza 250”,”- and backend and senior and - 150”,”- and - and - and chicken 100”,”- and - and - and - 150”]\t|[1,1,1,1,2,4]|   입출력 예에 대한 설명  지원자 정보를 표로 나타내면 다음과 같습니다.                  언어       직군       경력       소울 푸드       점수                               java       backend       junior       pizza       150                         python       frontend       senior       chicken       210                         python       frontend       senior       chicken       150                         cpp       backend       senior       pizza       260                         java       backend       junior       chicken       80                         python       backend       senior       chicken\t50                              “java and backend and junior and pizza 100” : java로 코딩테스트를 봤으며, backend 직군을 선택했고 junior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 100점 이상 받은 지원자는 1명 입니다.   “python and frontend and senior and chicken 200” : python으로 코딩테스트를 봤으며, frontend 직군을 선택했고, senior 경력이면서 소울 푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 200점 이상 받은 지원자는 1명 입니다.   “cpp and - and senior and pizza 250” : cpp로 코딩테스트를 봤으며, senior 경력이면서 소울푸드로 pizza를 선택한 지원자 중 코딩테스트 점수를 250점 이상 받은 지원자는 1명 입니다.   ”- and backend and senior and - 150” : backend 직군을 선택했고, senior 경력인 지원자 중 코딩테스트 점수를 150점 이상 받은 지원자는 1명 입니다.   ”- and - and - and chicken 100” : 소울푸드로 chicken을 선택한 지원자 중 코딩테스트 점수를 100점 이상을 받은 지원자는 2명 입니다.   ”- and - and - and - 150” : 코딩테스트 점수를 150점 이상 받은 지원자는 4명 입니다.   문제풀이  이 문제만 잡고 거의 두시간을 풀었다…카카오 문제는 항상 풀때마다 유형도 새롭고 풀기도 까다로워서 공부하기 아주 좋은 문제들인 것 같다. 특히나 꼭 한가지의 개념을 정확히 알고 있어야 풀도록 나와서 그 개념을 모르면 시간초과가 계속 뜨거나 아예 풀 수가 없다.   이 문제는 일단 딕셔너리에 넣어서 푼다는 발상까지는 떠올릴 수 있지만, 중요한 것은 이진탐색을 알고 있느냐에 대한 문제였다. 이진탐색을 사용하지 않고 리스트에 접근해서 크기를 비교하면 무조건 시간초과가 뜬다.   어떤 리스트에서 특정 수보다 작거나 큰 수의 개수나 인덱스를 찾는 가장 빠른 방법은 이진탐색이다. 예를들어 a = [1,2,4,5] 에서 정렬된 순서를 유지하면서 3이 들어갈 수 있는 자리를 찾는경우, bisect 이진탐색을 사용하면 빠르게 찾을 수 있다.   1 2 3 a = [1,2,4,5]  print(bisect.bisect_left(a,3),bisect.bisect_right(a,3))   1 2 2   위처럼 3과 a를 매개변수로 넣어주면 a에서 3이 들어갈 인덱스인 2를 출력해준다.   이처럼 이진탐색은 순서에 맞는 위치를 찾는 방법이므로, 꼭 탐색전에 크기대로 정렬을 해주어야 메서드가 올바르게 동작한다.   만약 3보다 큰 숫자들의 개수를 알고 싶다면 다음과 같이 하면 된다.   1 len(a)-bisect.bisect_left(a,3)   1 2   그러므로 리스트에서 특정 요소가 들어갈 위치나, 특정요소보다 작은수, 큰수의 개수를 구할 때는 무조건 이진탐색을 이용하는 것이 시간복잡도가 가장 적게 문제를 풀 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from collections import defaultdict from itertools import combinations import bisect def solution(info, query):     info_table = []     dic = defaultdict(list)     for i in info:         people = i.split()[:4]         score = int(i.split()[4])         for num in range(5):             for combi in combinations(people,num):                 dic[''.join(combi)].append(score)                       query_table = []     answer = []          for value in dic.values():         value.sort()     for q in query:         key = q.split()         score = int(key.pop())         key = ''.join(key)         key = key.replace('and', '').replace(' ', '').replace('-', '')         answer.append(len(dic[key])-bisect.bisect_left(dic[key],score))     return answer   1 solution([\"java backend junior pizza 150\",\"python frontend senior chicken 210\",\"python frontend senior chicken 150\",\"cpp backend senior pizza 260\",\"java backend junior chicken 80\",\"python backend senior chicken 50\"],[\"java and backend and junior and pizza 100\",\"python and frontend and senior and chicken 200\",\"cpp and - and senior and pizza 250\",\"- and backend and senior and - 150\",\"- and - and - and chicken 100\",\"- and - and - and - 150\"])   1 [1, 1, 1, 1, 2, 4]   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%88%9C%EC%9C%84-%EA%B2%80%EC%83%89/",
        "teaser": null
      },{
        "title": "[Programmers] 괄호 회전하기 (Python3)",
        "excerpt":"문제 설명  다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.     (), [], {} 는 모두 올바른 괄호 문자열입니다.   만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다.   만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다.   대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x &lt; (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.   제한사항     s의 길이는 1 이상 1,000 이하입니다.   입출력 예  |s\t|result|  |:—:|:—:|  |”{}”|\t3|  |”}]()[{“|\t2|  |”[)(]”|\t0|  |”}}}”|\t0|   입출력 예 설명  입출력 예 #1          다음 표는 “{}” 를 회전시킨 모습을 나타낸 것입니다.  |x\t|s를 왼쪽으로 x칸만큼 회전\t|올바른 괄호 문자열?|  |:—:|:—:|:—:|  |0\t|”{}”|\tO|  |1|\t“](){}[”|\tX|  |2\t|”(){}[]”|\tO|  |3\t|”){}[](“|\tX|  |4\t|”{}”|\tO|  |5\t|”}{“|\tX|            올바른 괄호 문자열이 되는 x가 3개이므로, 3을 return 해야 합니다.       입출력 예 #2     다음 표는 “}]()[{“ 를 회전시킨 모습을 나타낸 것입니다.                  x       s를 왼쪽으로 x칸만큼 회전\t올바른 괄호 문자열?                         0       ”}]()[{“       X                 1       ”]()[{}”       X                 2       ”()[{}]”       O                 3       ”)[{}](“       X                 4       ”{}”       O                 5       ”{}]()[”       X              올바른 괄호 문자열이 되는 x가 2개이므로, 2를 return 해야 합니다.   입출력 예 #3     s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.   입출력 예 #4     s를 어떻게 회전하더라도 올바른 괄호 문자열을 만들 수 없으므로, 0을 return 해야 합니다.   문제풀이  괄호문제는 스택으로 풀었던 적이 있는데 또 까먹어서 괄호별로 딕셔너리를 만들어 숫자로 괄호가 닫혔는지 안닫혔는지 확인하다가 시간이 오래걸렸다.   자꾸 풀었던 알고리즘을 까먹는 것 같아서, 내일부터는 순차적으로 돌아가며 매일 다른 유형을 풀도록 해야겠다.   괄호가 만약 오른쪽으로 열린 괄호라면 스택에 넣어주고, 왼쪽으로 열린 괄호면 스택의 -1인덱스와 같은 지 확인해준뒤 같으면 stack.pop(), 다르면 append() 해주면 된다.  모든 반복문이 끝난 후 스택이 비어있으면 올바른 괄호이므로 answer+=1을 해준다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from collections import deque def solution(s):     q = deque(s)     answer = 0     if len(s) == 1:         return 0          left = ['[','{','(']     asci = {']':2,'}':2, ')':1}     for i in range(len(s)):         stack = []         for j in q:             if j in left:                 stack.append(j)             else:                 if stack and stack[-1] == chr(ord(j)-asci[j]):                     stack.pop()                 else:                     stack.append(j)         q.append(q.popleft())         if not stack:             answer+=1                      return answer   1 solution(\"[](){}\")   1 3   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B4%84%ED%98%B8-%ED%9A%8C%EC%A0%84%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] H-index (Python3)",
        "excerpt":"문제 설명  H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다.   어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다.   어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.   제한사항     과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.   논문별 인용 횟수는 0회 이상 10,000회 이하입니다.   입출력 예  |citations|\treturn|  |[3, 0, 6, 1, 5]|\t3|   입출력 예 설명  이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.  ※ 공지 - 2019년 2월 28일 테스트 케이스가 추가되었습니다.   문제 풀이  이게 왜 2단계…?      근데 문제를 좀 헷갈리게 설명해놨다. 그래서 푸는시간보다 이해하는게 더 오래걸렸다.  코드   1 2 3 4 5 6 7 def solution(citations):     citations.sort()     l = len(citations)     for i in range(l):         if citations[i] &gt;= l-i:             return l-i     return 0   1 solution([3,0,6,1,5])   1 2   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/H-Index-2/",
        "teaser": null
      },{
        "title": "[Programmers] 더 맵게 (Python3)",
        "excerpt":"문제  매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.   섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)   Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.   Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.   #제한 사항     scoville의 길이는 2 이상 1,000,000 이하입니다.   K는 0 이상 1,000,000,000 이하입니다.   scoville의 원소는 각각 0 이상 1,000,000 이하입니다.   모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.   입출력 예  |scoville|\tK|\treturn|  |:—:|:—:|:—:|  |[1, 2, 3, 9, 10, 12]|\t7|\t2|   입출력 예 설명     스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.   새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5   가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]      스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.  새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13   가진 음식의 스코빌 지수 = [13, 9, 10, 12]   모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.   문제풀이  힙큐의 아주 기본이라고 할 수 있는 문제이다.     자꾸 몇개 틀려서 왜그런가 했는데, 힙큐를 사용하기 전에 정렬을 해주는 것을 까먹어서 계속 실패가 떴다. 예제가 정렬되어있는 문제는 항상 제한사항에 테스트 케이스가 정렬되는지 안되는지 꼭 확인 하도록 하자.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import heapq def solution(scoville, K):     new = 0     answer = 0     scoville.sort()     for i in range(len(scoville)-1):         new = 0         first = heapq.heappop(scoville)         second = heapq.heappop(scoville)          new = first + second*2         heapq.heappush(scoville, new)          answer +=1         if scoville[0] &gt;= K:             return answer             else:         return -1        1 solution([1, 2],7)   1 -1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%8D%94-%EB%A7%B5%EA%B2%8C/",
        "teaser": null
      },{
        "title": "[Programmers] 프린터 (Python3)",
        "excerpt":"문제 설명  일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다.      인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다.   나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다.   그렇지 않으면 J를 인쇄합니다.   예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.   내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다.   현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요.   제한사항  현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다.  인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다.  location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.   입출력 예  |priorities|\tlocation|\treturn|  |:—:|:—:|:—:|  |[2, 1, 3, 2]\t|2\t|1|  |[1, 1, 9, 1, 1, 1]|\t0|\t5|   입출력 예 설명  예제 #1     문제에 나온 예와 같습니다.   예제 #2     6개의 문서(A, B, C, D, E, F)가 인쇄 대기목록에 있고 중요도가 1 1 9 1 1 1 이므로 C D E F A B 순으로 인쇄합니다.   문제 풀이  아주 기초적은 스택/큐 문제이다. 이것도 2단계라기엔 난이도가…  문제 그대로 만들어주면 풀 수 있다.   살짝 까다로운것은 숫자가 중복될 수 있어서 내가 원하는 location의 숫자가 출력됐을때 그 숫자가 원래 내가 원하던 자료인지인데, -로 마킹해주어서 풀었다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from collections import deque  def solution(priorities, location):     priorities[location] = -priorities[location]     pri = deque(priorities)      count =0     while 1:         p = pri.popleft()         for i in pri:                         if abs(i) &gt; abs(p):                 pri.append(p)                 break         else:             if p &lt; 0:                 count+=1                 return count                  break             count+=1          return answer   1 solution([2,1,3,2],2)   1 1   노트  처음 본 라이브러리로 푼 코드가 있어서 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 def solution(priorities, location):     queue =  [(i,p) for i,p in enumerate(priorities)]     answer = 0     while True:         cur = queue.pop(0)         if any(cur[1] &lt; q[1] for q in queue):             queue.append(cur)         else:             answer += 1             if cur[0] == location:                 return answer   any는 요소중에 단 하나라도 참이면 True를 반환하는 함수이다. 여기서는 queue 안에 있는 요소를 하나씩 빼가면서 하나라도 출력예정 프린트보다 중요도가 큰게 있으면 True를 리턴하는데에 사용했다.   반대되는 함수로는 all이 있는데, all은 모두 참이어야만 True를 반환한다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%94%84%EB%A6%B0%ED%84%B0/",
        "teaser": null
      },{
        "title": "토스 NEXT 코딩 테스트 후기",
        "excerpt":"2021.08.12  방금 두시간 반여에 걸친 토스 채용 코딩테스트를 보고 왔다.      문제들 난이도는 그렇게 어렵지 않았는데, 신경써서 만든 문제들이다 보니까 유형도 새롭기도 하고, 무엇보다 잘 푼것 같은데 한 두개 테스트 케이스가 통과가 안되서 그거 붙잡다가 시간도 날리고 결국 풀지도 못해서 전체 문제의 반밖에 못풀었다…   사실 마저 풀어서 블로그에 올리려고 했는데.  문제 외부에 유출하면 안된다고 해서 오답노트는 개인적으로 해보려고 한다.   오늘 풀면서 느낀게 문제 푸는 방식을 조금 바꿔야겠다.     시간을 재고 시간안에 못풀면 틀리는 식으로 해서 많이 풀어야지, 하나 붙잡고 하다 버릇하니까 시간관리가 안된다.  그리고 문제 풀때 항상 노트를 갖고 필기를 하면서 풀도록 해야겠다. 막상 코딩테스트를 실제로 보니까 생각보다 머릿속에서 코드정리가 안되서 시간을 많이 낭비한 것 같다.   솔직히 뭐 될거라고 생각도 하나도 안했고, 문제도 잘풀거라 생각도 안하고 그냥 본 테스트인데.      생각보다 느낀점이 많은 것 같다. 앞으로도 코딩테스트 있으면 왠만하면 다 참가해보고 해야겠다는 생각이 들었는데,     솔직히 1년정도의 시간이면 자신 있을 것 같다는 생각이 들었다. 물론 뒤에 과제전형까지 다 포함해서…   다음 코딩테스트때는 더 나아진 실력으로 임하게 되도록 더 바짝 노력해야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%86%A0%EC%8A%A4-NEXT-%EC%BD%94%EB%94%A9-%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1080 행렬 (Python3)",
        "excerpt":"문제  0과 1로만 이루어진 행렬 A와 행렬 B가 있다. 이때, 행렬 A를 행렬 B로 바꾸는데 필요한 연산의 횟수의 최솟값을 구하는 프로그램을 작성하시오.   행렬을 변환하는 연산은 어떤 3×3크기의 부분 행렬에 있는 모든 원소를 뒤집는 것이다. (0 → 1, 1 → 0)   입력  첫째 줄에 행렬의 크기 N M이 주어진다. N과 M은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 행렬 A가 주어지고, 그 다음줄부터 N개의 줄에는 행렬 B가 주어진다.   출력  첫째 줄에 문제의 정답을 출력한다. 만약 A를 B로 바꿀 수 없다면 -1을 출력한다.   예제  예제 출력 2     3 4     0000     0010     0000     1001     1011     1001   예제 출력 1      2   문제 풀이  그리디 알고리즘 문제이다. 근데 문제가 너무 그리디 써서 풀면 풀겠지~ 하고 풀면 풀려서 조금 그랬다… 무조건 3*3을 뒤집는다는것 부터 그냥 처음부터 순서대로 계속 뒤집으면 풀릴 것 같아서 그렇게 풀었더니 쉽게 풀렸다.   근데 다 풀어놓고 for문 중첩을 많이해서 i,j를 두번 써버리는 바람에 뭐가 잘못된지도 모르고 한참을 헤맸다. for문 너무 중첩하지 말고 항상 함수로 분리해서 쓰는 습관을 들이자.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import sys   M,N = map(int,input().rstrip().split()) A = [list(map(int,input())) for i in range(M)] B = [list(map(int,input())) for i in range(M)]  result = 0 check = False      for i in range(M-2):     for j in range(N-2):          if A[i][j] != B[i][j]:                         for a in range(i,i+3):                 for b in range(j,j+3):                                         A[a][b] = 1-A[a][b]             result+=1  for i in range(M):     for j in range(N):         if A[i][j] != B[i][j]:             check = True  if check:     print(-1) else:     print(result)          1 2 3 4 5 6 7 8 3 4 0000 0010 0000 1001 1011 1001 2   1   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%ED%96%89%EB%A0%AC/",
        "teaser": null
      },{
        "title": "[BOJ] 10870 피보나치 수 5 (Python3)",
        "excerpt":"문제  피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.   이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.   n=17일때 까지 피보나치 수를 써보면 다음과 같다.   0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597   n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 n이 주어진다. n은 20보다 작거나 같은 자연수 또는 0이다.   출력  첫째 줄에 n번째 피보나치 수를 출력한다.   예제 입력 1       10   예제 출력 1      55   문제 풀이  다이나믹 프로그래밍의 가장 기초인 피보나치 수열 구하기 문제이다.     다이나믹 프로그래밍이 어려워서 한번 다시 풀어보았다.  코드   1 2 3 4 5 6 7 8 n = int(input())      fibo = [0,1,1]  for i in range(3, n+1):     fibo.append(fibo[i-2] + fibo[i-1])      print(fibo[n])   1 2 10 55   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%EC%88%98-5/",
        "teaser": null
      },{
        "title": "[BOJ] 9095 1,2,3 더하기 (Python3)",
        "excerpt":"문제  정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.   1+1+1+1     1+1+2     1+2+1     2+1+1      2+2     1+3     3+1   정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.   출력  각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.  1 2 3 4 5 6 7 8 9 10 예제 입력 1      3    4    7    10  예제 출력 1    7    44    274      문제풀이  아 진짜 다이나믹 프로그래밍 너무 싫다. 이건 코딩이 아니라 수학문제 아니냐고…  수학적으로 점화식을 찾아야 한다는 생각으로 풀어야겠다. 아니면 다시 고딩때 배운 수열 점화식부분이라도 다시 봐야하나…   이 문제는 경우의 수를 쭉 숫자순서대로 쓰다보면 규칙이 나오는 걸 알 수 있다.   1의 경우 1개     2의 경우 2개     3의 경우 4개     4의 경우 7개     5의 경우 13개   자세히 보다보면, 5의 경우는 2,3,4를 더한 값, 4의 경우는 1,2,3을 더한순으로, 직전 세번째 숫자까지의 경우의 수를 더하면 해당 숫자의 경우의 수가 나온다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from itertools import permutations              result = [] T = int(input())  def solution(n):     if n == 1:         return 1     elif n == 2:         return 2     elif n == 3:         return 4     else:         return solution(n-1) + solution(n-2) + solution(n-3)      for i in range(T):     n = int(input())     print(solution(n))             1 2 3 1 4 7   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/1,2,3-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1463 1로 만들기 (Python3)",
        "excerpt":"문제  정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.      X가 3으로 나누어 떨어지면, 3으로 나눈다.   X가 2로 나누어 떨어지면, 2로 나눈다.   1을 뺀다.   정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.   입력  첫째 줄에 1보다 크거나 같고, 106보다 작거나 같은 정수 N이 주어진다.   출력  첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.   예제   예제 입력 1             2   예제 출력 1          1   예제 입력 2          10   예제 출력 2         3   힌트  10의 경우에 10 -&gt; 9 -&gt; 3 -&gt; 1 로 3번 만에 만들 수 있다.   문제 풀이  이 문제는 다이나믹 프로그래밍, 즉 동적계획법으로 푸는 문제이다. 사실 그동안 다이나믹 프로그래밍 문제는 솔직히 뭔말인지 잘 이해가 안되서 안풀고 있었는데, 이제 모든 유형을 번갈아가면서 풀 예정이라 오늘 다이나믹 프로그래밍부터 풀어보았다.   다이나믹 프로그래밍은 작은 문제들을 해결해감으로써 큰 문제를 해결하는 문제로, 가장 좋은 예로 피보나치 수열이 있다. 피보나치 수열의 경우 n번째 피보나치 수는 n-1의 피보나치 수와 n-2의 피보나치 수의 합으로, 이미 계산한 결과를 통해 다음의 결과가 나오는 방식이다. 이렇게 이전의 작은 문제들이 큰 문제를 해결하는데에 필요한 알고리즘을 다이나믹 프로그래밍이라고 한다.   이 문제의 경우는 N을 1로 만들기 위한 최소의 경우의 수를 출력하는 문제였는데, 맨처음에는 if와 elif 문으로 3과 2로 나눠지는 경우, 1을 빼면 3이나 2로 나누어 지는 경우로 구분해서 다이나믹이라기보다는 그리디하게 3우선으로 나눠지면 최소의 경우의수가 나올 것이라는 가정으로 풀었다. 하지만 이 문제는 모든 상황에서 동일하게 이러한 가정이 맞지 않으므로, 다이나믹 프로그래밍으로 풀어야 했다.   1 부터 차례대로 생각해보면, 3의 경우의 수는 3으로 나누는 경우 1일때, 4는 자연스럽게 3을 만들기 위해서 1을 빼고, 3으로나누는 경우의수 2가 된다. 따라서 뒤의 숫자는 2나 3으로 나누어 떨어지지 않는다면, 반드시 이전의 숫자의 경우의 수에서 1을 빼주는 경우의 수가 추가가 될 수 밖에 없다. 2나 3으로 나누어 떨어지는 경우에는, 그 수를 2,3으로 나눠서 나오는 수의 경우에 수에서 1을 더한 값이 그 수의 경우의 수가 될 것이다. 그럼 1을 빼고 나누었을 때의 경우의수와 바로 2나 3으로 나누었을때의 경우의 수중에서 작은 값을 해당 인덱스에 저장해주면 된다.   따라서 배열에 0부터 3까지의 경우를 넣어준뒤, N까지 순차적으로 각 숫자의 대한 최소 경우에 수를 찾아가며 N에 다다르면 1로 만들기 위한 최소 경우의 수를 찾을 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 N = int(input()) dp = [0,0,1,1]  for i in range(4, N+1):     dp.append(dp[i-1]+1)          if i % 2 == 0:         dp[i] = min(dp[i], dp[i//2]+1)     if i % 3 == 0:         dp[i] = min(dp[i], dp[i//3]+1) print(dp[N])   1 2 10 3   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1932 정수 삼각형 (Python3)",
        "excerpt":"문제  1 2 3 4 5         7          3   8         8   1   0       2   7   4   4     4   5   2   6   5        위 그림은 크기가 5인 정수 삼각형의 한 모습이다.   맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.   삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.   입력  첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.   출력  첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.   예제 입력 1  1 2 3 4 5 6 5    7       3 8    8 1 0    2 7 4 4    4 5 2 6 5      예제 출력 1     30   문제 풀이  다이나믹 프로그래밍은 풀수록 더 머리가 아프다.      다른 알고리즘도 마찬가지지만, 다이나믹 프로그래밍 문제는 반드시 노트를 함께해야 헷갈리지 않게 빨리 문제를 풀 수 있을 것 같다. 그래도 이 문제를 머리를 싸매고 풀고나니 대충 다이나믹 프로그래밍을 어떻게 접근해야 하는지에 대해 좀 보이는 것 같다.   피보나치 수열과 비슷하게 생각해보면, 결국 아래의 요소는 위 왼쪽 대각과 위의 요소중에서 자신과 더했을때 더 큰값을 자신으로 바꾸면 가장 큰 수가 나오는 길이 어딘지 알 수 있다. 따라서 왼쪽위가 없는경우, 위쪽이 없는경우를 예외로 처리하고 나머지는 위 두 요소를 자신과 합했을 때 더 큰값을 자신으로 하게 하면 이 문제를 풀 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 n = int(input()) triangle = [list(map(int,input().split())) for i in range(n)]  for i in range(1,len(triangle)):     for j in range(len(triangle[i])):         if j-1 &lt; 0:             triangle[i][j] += triangle[i-1][j]         elif j &gt; len(triangle[i-1])-1:             triangle[i][j] += triangle[i-1][j-1]         else:             triangle[i][j] = max(triangle[i][j] + triangle[i-1][j-1],triangle[i][j]+triangle[i-1][j]) print(max(map(max,triangle)))                                                     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 5 1 0 1 1 2 0 2 1 11 16 2 2 3 0 3 1 25 23 3 2 20 19 3 3 4 0 4 1 25 30 4 2 27 22 4 3 26 25 4 4 30   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EC%A0%95%EC%88%98-%EC%82%BC%EA%B0%81%ED%98%95/",
        "teaser": null
      },{
        "title": "[BOJ] 12865 평범한 배낭 (Python3)",
        "excerpt":"문제  이 문제는 아주 평범한 배낭에 관한 문제이다.   한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.   준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.   입력  첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.   입력으로 주어지는 모든 수는 정수이다.   출력  한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   4 7 6 13 4 8 3 6 5 12  예제 출력 1   14  문제 풀이  아무리 생각해도 안풀려서 풀이를 보고 풀었다. 이 문제는 DP중에서도 냅색(Knapsack) 알고리즘으로 풀어야 한다고 한다. DP는 참… 풀어도 풀어도 적응이 안된다.   냅색 알고리즘은     분할 가능 배낭문제 (담을 수 있는 물건을 나눌 수 있을때 ex) 설탕, 소금…)   0-1 배낭 문제 (담을 수 있는 물건이 나누어 질 수 없을때 ex) 담는다 or 안담는다)   분할하여 설명하면 다음과 같다.   1) x축에는 가방 1~K 까지의 무게, y축은 물건 N개 개수 만큼의 배열을 만들어준다.     2) 행을 차례대로 돌며 다음과 같은 알고리즘을 수행한다.   3-0) 현재 물건이 현재 돌고있는 무게보다 작다면 바로 [이전물건]같은무게를 입력해준다.      3-1) 현재 물건을 넣어준다. 물건을 넣은 뒤의 남은 무게를 채울 수 있는 최댓값(knapsack[i-1][j-weight])을 위의 행에서 가져와 더해준다.      3-2) 현재 물건을 넣어주는 것보다. 다른 물건들로 채우는 값(knapsack[i-1][j])을 가져온다.      4) 3-1과 3-2 중 더 큰 값을 knapsack[i][j]에 저장해준다. 이 값은 현재까지의 물건들로 구성할 수 있는 가장 가치 높은 구성이다.      5) knapsack[N][K]는 곧, K무게일 때의 최댓값을 가리킨다.   따라서 Knapsack[i][j]를 돌며 해당 i(물건)에 따른 j(무게)의 최댓값을 구하는 것인데, 무게인 j가 해당 물건의 무게보다 작은 경우는 가방에 넣지 못하므로, 앞의 물건의 최대값을 그대로 갖고, 무게 j가 물건의 weight와 같거나 크다면 해당 물건을 넣을수 있는 공간이 생겼다는 것이므로 그 물건이 없던값, [i][j-weight] 와 해당 물건이 들어가지 않은 값 [i-1][j]를 비교하여 더 큰값을 넣어주는 것을 반복하면 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 N, K = map(int, input().split())  feature = [[0,0]]  for i in range(N):     W,V = map(int, input().split())     feature.append([W,V])  Knapsack = [[0 for i in range(K+1)] for i in range(N+1)]  for i in range(1,N+1):     for j in range(1,K+1):         weight = feature[i][0]         value = feature[i][1]         if j &lt; weight:             Knapsack[i][j] = Knapsack[i-1][j]         else:             Knapsack[i][j] = max(value + Knapsack[i-1][j-weight], Knapsack[i-1][j])      print(Knapsack[-1][-1])         1 2 3 4 5 6 4 7 6 13 4 8 3 6 5 12 14   1 print(knapsack[N][K])   1 14   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%8F%89%EB%B2%94%ED%95%9C-%EB%B0%B0%EB%82%AD/",
        "teaser": null
      },{
        "title": "[BOJ] 1003 피보나치 함수 (Python3)",
        "excerpt":"문제  다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.   1 2 3 4 5 6 7 8 9 10 11 int fibonacci(int n) {     if (n == 0) {         printf(\"0\");         return 0;     } else if (n == 1) {         printf(\"1\");         return 1;     } else {         return fibonacci(n‐1) + fibonacci(n‐2);     }   fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.      fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.   fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다`.   두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.   fibonacci(0)은 0을 출력하고, 0을 리턴한다.   fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.   첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.   fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.   1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.   입력  첫째 줄에 테스트 케이스의 개수 T가 주어진다.   각 테스트 케이스는 한 줄로 이루어져 있고, N이 주어진다. N은 40보다 작거나 같은 자연수 또는 0이다.   출력  각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.   1 2 3 4 5 6 7 8 9 예제 입력 1   3 0 1 3 예제 출력 1   1 0 0 1 1 `  문제풀이  다이나믹 프로그래밍 문제로, 점화식을 만들어 풀면 된다.     맨처음에는 문제에 재귀함수가 그대로 나오길래, 엥? 왜 문제가 이러지 싶었는데 생각해보니까 저 재귀함수대로 0과 1을 호출할때마다 카운팅 해주면 무조건 시간초과가 날 수 밖에 없다.   그래서 1과 0을 저 재귀함수는 몇번씩 호출하는지 노트에 1부터 차근차근 써보니, 0은 N-1 과 N-2 의 0의 호출값을 더한 값이고, 1은 N-1의 0의 호출값과 1의 호출값을 더한값이었다. 따라서 이러한 점화식을 함수로 만들어주면 간단하게 풀 수 있다.   다이나믹 프로그래밍을 풀 때마다 느끼는거지만 이게 코딩실력을 테스트하기에 적합한가 싶다. 항상 코딩문제보다는 수학문제에 가깝다고 생각되니…   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 T = int(input()) result = []   def solution(N):     answer = [[1,0],[0,1]]     for i in range(2,N+1):         answer.append([answer[i-1][0]+answer[i-2][0],answer[i-1][0]+answer[i-1][1]])     return answer[-1]  for i in range(T):     N = int(input())     if N == 0:         result.append([1,0])     elif N == 1:         result.append([0,1])     else:         result.append(solution(N))      for i in result:     print(i[0],i[1])             1 2 3 1 40 63245986 102334155   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98-%ED%95%A8%EC%88%98/",
        "teaser": null
      },{
        "title": "개발지원금 당첨되다...",
        "excerpt":"2021.08.18      토스에서 상위 50퍼센트 20명만 추첨해서 주는 100만원 개발지원금에 당첨되었다…     아니 이게 말이되나?? 거의 5000명이 지원한 시험에서 상위 50프로니까 2500명 잡고 0.8퍼센트 되는 아주 극악의 확률에 내가 당첨되다니… 사실 20명이라해서 기대를 안한 정도가 아니라 아예 까먹고 있었는데 메일을 받고 깜짝 놀랐다.   얼마전에 나이키 신발도 당첨되고 오늘도 그렇고 요즘 운이 너무 좋다…      모든게 잘풀린다 싶은 요즘 이런것 까지 족족 되버리니까 너무 행복하다.   사실 그동안 난 확률이 낮은 것들에 대한 기대가 몹시 낮아서, 항상 도전도 잘안하고 저게 되겠어~ 하는 마음가짐으로     그냥 귀찮아서 안했던 것들이 너무나 많았다. 하지만 아무것도 안하고 확률이 0인것과 도전하고 아주 극악의 1퍼센트도 안되는 확률을 얻는건 아주 큰차이라는걸 오늘 깨달았다.   누군가는 성공한 사람들의 성공에는 운이 매우 크게 작용했다고 하지만, 중요한 건 그 극악의 운을 만들려 모두가 귀찮아하고 두려워하는 일에 도전했기에 그러한 운이 당첨된게 아닐까 하는 생각을 해본다.   앞으로 공부 더 열심히 해야겠다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%86%A0%EC%8A%A4-NEXT-%EA%B0%9C%EB%B0%9C%EC%A7%80%EC%9B%90%EA%B8%88-%EB%8B%B9%EC%B2%A8%EB%90%98%EB%8B%A4/",
        "teaser": null
      },{
        "title": "[Java] 플레이그라운드 with TDD, 클린코드 - AssertJ (1)",
        "excerpt":"시작하면서…  자바로 간단한 프로젝트를 만들어보려 했는데, 그냥 무작정 혼자 만들다가는 나쁜 버릇이 들 것 같아서     강의 하나를 수강하기로 했다. 특히나 자바는 객체지향이라는 개념을 사용하는 언어이고, 난 대부분 절차지향 언어만  사용해봤었기 때문에, 아직 간단한 책 한권으로는 객체지향으로 정확히 어떻게 프로그램을 구현하는지에 대한 감이 없기 때문에,  오히려 이대로 혼자 프로젝트를 진행하면, 결과물은 그런대로 작동할 수 있겠으나 코드 자체는 유지보수가 어렵고, 객체지향의 강점이  하나도 드러나지 않는 나쁜코드가 될 거라는 생각이 들었다. 개발자로써 알고리즘 자체를 짜는 것도 중요하지만 모두가 같이 일하는 환경에서는 직관적이고 유지보수가 편하게 코드를 작성하는것도 아주 중요한 덕목이라는 생각이 들었다.   그래서 이러한 관련 강의를 찾다가 아주 평이 좋은 강의를 발견해서 수강하며 블로그에 남겨두려한다.     이 강의의 좋은 점은 내용도 좋지만, 주로 미션위주의 강의라 내가 직접 만들어보며 어떤게 잘못되었고 어떤게 올바른 코드인지 알 수 있다는 것이었고, 테스트주도형 개발도 함께 배울 수 있을 뿐만 아니라 실제 개발처럼 깃허브로 버젼을 푸쉬해가며 미션을 진행 해볼 수 있다는 것이었다. 그래서 별 고민없이 바로 결제하고 수강을 시작했다.   첫번째 미션은 숫자야구게임을 만드는것이다. 그럼 시작해보자.   단위테스트  자바는 대부분의 기능을 클래스로 구현해놓고, 그 클래스들을 메인메서드에서 동작시킨다.    메인 메서드는 프로그램을 시작할 뿐만 아니라 구현한 프로그램을 테스트하는데도 사용하는데, 테스트 주도 개발을 하려면 어떻게 메인메서드에서 구현한 프로그램을 테스트 할 수 있는지 알아야 한다.   그럼 간단한 사칙연산 프로그램을 만들어 프로그램을 테스트 해보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 package TDD;  public class Calculator {     int add(int a, int b){         return a+b;     }     int subtract(int a, int b){         return a-b;     }     int multiply(int a, int b){         return a*b;     }     int divide(int a, int b){         return a/b;     }     public static void main(String[] args){         Calculator cal= new Calculator();         System.out.println(cal.add(3,4));         System.out.println(cal.subtract(5,4));         System.out.println(cal.multiply(2,6));         System.out.println(cal.divide(8,4));     } }   위 코드를 보면 클래스 Calculator에 해당하는 프로덕션 코드 부분과, main에 해당하는 테스트 코드 부분이 있다. cal이라는 인스턴스를 만들어 준 뒤, 아래에 사칙연산을 실제로 실행시켜봄으로써 이 코드가 정상적으로 작동하는지 확인해보았는데, 이러한 메인메서드 테스트는 문제점이 존재한다.   main method 테스트 문제점     프로덕션 코드와 테스트 코드가 하나에 존재한다. 이로인해 클래스 크기가 커지고 복잡도가 증가한다.   테스트 코드가 실제 서비스에 같이 배포된다.   main method 하나에서 여러 개의 기능을 테스트 하기 때문에 복잡도가 증가한다.   method 이름을 통해서 어떤 부분을 테스트 하는 것인지 알기가 힘듬   테스트 결과를 사람이 수동으로 확인해야한다.   이러한 main method를 사용한 테스트가 가지는 문제점을 해결하기 위해 등장한 것이 바로 JUnit 이다.   JUnit  JUnit은 단위 테스트 Framework로, System.out으로 번거롭게 테스트 케이스를 확인하지 않도록 해주는 도구이다. 프로그램 테스트 시 걸릴 시간도 관리할 수 있게 해주며, 오픈소스 플러그인 형태로 Eclipse에 포함되어있다. 개발을 진행하면서, 어느정도의 개발이 진행되면 반드시 프로그램에 대한 단위 테스트는 필수로 진행해주어야 한다.   그럼 단위 테스트를 어떻게 진행해야 하는지 알아보자.   String 클래스에 대한 학습 테스트  깃허브에서 내려받은 폴더에 있는 StringTest 클래스가 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 package study;  import org.junit.jupiter.api.Test;  import static org.assertj.core.api.Assertions.assertThat;  public class StringTest {     @Test     void replace() {         String actual = \"abc\".replace(\"b\", \"d\");         assertThat(actual).isEqualTo(\"adc\");     } }   replace 함수메서드를 실행하면 테스트가 가능하다.   그럼 StringTest에 다음 요구사항을 새로운 test case로 추가해보자.   AssertJ  여기서 요구하는 테스트를 하기 위해서는 AsserJ에 대해서 알아야한다.   AssertJ는 자바 테스트를 위해 좀 더 풍부한 문법을 제공하며, 메서드 체이닝을 통해 더 직관적인 테스트 흐름을 작성할 수 있도록 개발된 오픈소스 라이브러리이다.   위의 replace를 테스트한 코드를 다시 살펴보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 package study;  import org.junit.jupiter.api.Test;  import static org.assertj.core.api.Assertions.assertThat;  public class StringTest {     @Test     void replace() {         String actual = \"abc\".replace(\"b\", \"d\");         assertThat(actual).isEqualTo(\"adc\");     } }  actual이라는 문자열 “abc”.replace(“b”,”d”), abc에서 b를 d로 바꾸는 객체를 만들고,  assertThat(actual).isEqualTo(“adc”) 로 실제로 replace 메서드가 우리가 원하는 값인 “adc”를 출력하는지를 확인해준다.   이처럼 AssertJ는 간편하게 테스트 코드를 작성할 수 있도록 도와주는 오픈소스이다.      그럼 몇가지 더 유용한 사용법을 한번 알아보자.   Test Fail Message  JUnit5 에서는 마지막 인자값에 as()를 통해 테스트 실패 메시지를 명시해주어 테스트가 실패했을때 출력되는 메시지를 만들 수 있다.   인물에 대한 정보를 담는 Character 이라는 클래스가 있고, 그 안에 있는 getAge() 메서드를 테스트 한다고하자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Person {     String name;     int age;     String tribe;      public Person(String name, int age, String tribe) {         this.age = age;         this.name = name;         this.tribe = tribe;     }      public int getAge(){         return age;     }     public String getName(){         return name;     }  }  이 Character 메서드는 이름, 나이, 종족을 멤버변수로 갖고, 나이를 반환하는 getAge()와 이름을 반환하는 getName() 메서드를 갖고있다. 우리가 만약 getAge() 메서드가 테스트코드에서 실패한다면, 이 이름의 사람의 나이를 확인해보라는 메시지 창을 띄우고 싶은 경우라면, 아래와 같이 AssertJ를 이용하여 코드를 작성할 수 있다.   만약 테스트코드가 실패하게 하면 이 사람의 나이를 다시한번 확인해보라는 문구를 넣고싶다면, 아래와 같이 하면된다.   1 2 3 4 5 6 7 8 9 10 11 12 @Test     public void Character() {         Character frodo = new Character(\"Frodo\", 33, \"HOBBIT\");         // failing assertion, remember to call as() before the assertion, not after !          assertThat(frodo.getAge()).as(\"check %s's age\", frodo.getName()).isEqualTo(100);     }           &gt;&gt;&gt; [check Frodo's age]  &gt;&gt;&gt; expected: 100 &gt;&gt;&gt; but was : 33  isEqualTo를 사용하여 우리가 원하는 기댓값과 같은 결과를 출력하는지 확인해보았고, 33이 나와야하지만 100이 나왔기 때문에 우리가 삽입해주었던 문장인 “check [이름] age” 문장이 출력되었다.   이렇게 유용한 메서드인 as()를 사용할 때 주의 해야할 점이 있는데, 바로 assertion이 수행되기 전에 사용해야한다는 것이다. 마지막에 as를 사용하면 에러를 동반하게 된다.      따라서 반드시 as()는 assertion이 수행되기 전에 사용해주어야한다.   Filtering Assertions  특정 filter를 자바 람다식을 이용하여 표현할 수 있는 유용한 기능이다. 아래 예제코드를 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package TDD;  public class Human {     String name;     int age;      public Human(String name, int age){         this.name = name;         this.age = age;     }      public String getName(){         return name;     }  }   Human 이라는 클래스를 만들어주고, name과 age를 멤버변수로 선언해준 뒤 나이를 가져오는 getAge()메서드를 만들어준다.     그리고 테스크 코드를 만들어 아래와 같이 작성한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test    public void filterTest() {        List&lt;Human&gt; list = new ArrayList&lt;&gt;();        Human kim = new Human(\"Kim\", 22);        Human park = new Human(\"Park\", 25);        Human lee = new Human(\"Lee\", 22);        Human jack = new Human(\"Jack\", 23);         list.add(kim);        list.add(park);        list.add(lee);        list.add(jack);         assertThat(list).filteredOn(human -&gt; human.getName().contains(\"a\")).containsOnly(park, jack);    }  filterdOn을 사용하여 안에 람다식을 통해 “a”가 포함된 단어를 필터링해주고, 이 추출된 단어들이 park과 jack이 맞는지 테스트 해주는 코드이다.   이처럼 filter 기능을 사용하면 특정 케이스들만 골라 올바르게 동작하는지 테스트 해볼 수 있다.   또 객체의 프로퍼티를 검증할 수도 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test     public void filterTest() {         List&lt;Human&gt; list = new ArrayList&lt;&gt;();         Human kim = new Human(\"Kim\", 22);         Human park = new Human(\"Park\", 25);         Human lee = new Human(\"Lee\", 22);         Human jack = new Human(\"Jack\", 23);          list.add(kim);         list.add(park);         list.add(lee);         list.add(jack);          assertThat(list).filteredOn(\"age\", 22).containsOnly(kim, lee);     }  위의 코드와 코드는 같지만, 프로퍼티에 접근해서 값을 검증하고 있다. age가 22인 객체는 kim과 lee이다.      만약 반대로 값이 포함되는 않는 경우도 아래의 메서드를 통해 간결하게 검증할 수 있다.      not   in   notIn   1 ssertThat(list).filteredOn(\"age\", notIn(22)).containsOnly(park, jack);  이렇게 하면 age가 22가 아닌 객체를 검증한다.   프로퍼티 추출하기  테스트르르 위해 리스트에있는 객체들을 검증하려면 반복문에서 이름을 하나하나 꺼내와서 또 다른 리스트에 담고 비교하는 과정을  거쳐야한다. 하지만 extracying()을 사용하면 아주 간편하게 해결할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Test     public void filterTest() {         List&lt;Human&gt; list = new ArrayList&lt;&gt;();         Human kim = new Human(\"Kim\", 22);         Human park = new Human(\"Park\", 25);         Human lee = new Human(\"Lee\", 22);         Human jack = new Human(\"Jack\", 23);          list.add(kim);         list.add(park);         list.add(lee);         list.add(jack);          assertThat(list).extracting(\"name\").contains(\"Kim\", \"Park\", \"Lee\", \"Jack\");     }  위 코드 처럼  extracting을 사용하면, 알아서 name의 프로퍼티를 갖는 값들만 추출하여 검증해준다.   String assertions  String assertions는 다양한 메서드를 통해 간단하게 문자열을 검증할 수 있도록 도와준다.  1 2 3 4 5 6 7 @Test     public void string(){         String expression = \"This is a string\";          assertThat(expression).startsWith(\"This\").endsWith(\"string\").contains(\"a\");     }   위 코드처럼 직관적으로 startsWith이면 This로 시작하는지를 검증해주고, endsWith은 끝나는 단어가 string인지 검증해준다.   Exception 처리 테스트  AssertJ는 예외처리를 가독성있게 할 수 있도록 도와주는 assertThatThrownBy()라는 메서드를 제공한다.  기존의 에외 처리 테스트는  1 2 3 4 5 6 @Test     public void exception(){         Throwable thrown = catchThrowable(()-&gt; {throw new Exception(\"Error\");});          assertThat(thrown).isInstanceOf(Exception.class).hasMessageContaining(\"Error\");     }  이렇게 thrown 이라는 객체를 만들어 주어야 하지만, assertThatThrownBy() 를 사용해주면  1 2 3 4 5 @Test   public void exception(){      assertThatThrownBy(()-&gt;{ throw new Exception(\"Error\");})         .isInstanceOf(Exception.class).hasMessageContaining(\"Error\");   }  다음과 같이 가독성있게 코드를 짤 수 있다.   또 자주 쓰이는 예외처리에 대해서는 이미 정의된 함수를 제공하는데,      assertThatNullPointerException   assertThatIllegalArgumentException   assertThatIllegalStateException   assertThatIOException   다음과 같이 4가지이다. 사용법은 아래와 같다.  1 2 3 4 5 6 7 @Test    public void exception_example(){        assertThatIOException().isThrownBy(() -&gt; {throw new IOException(\"Error\");})                .withMessage(\"Error\")                .withMessageContaining(\"Error\")                .withNoCause();    }  자주 쓰이는 이 4가지 예외 타입이 아니라면, 다음과 같이 해주면 된다.  1 2 3 4 5 6 7 @Test    public void exception_example(){        assertThatExceptionOfType(IOException.class).isThrownBy(() -&gt; {throw new IOException(\"Error\");})                .withMessage(\"Error\")                .withMessageContaining(\"Error\")                .withNoCause();    }   그럼이제 과제에서 요구한 사항들을 하나하나 코딩해보자.   요구사항 1     “1,2”을 ,로 split 했을 때 1과 2로 잘 분리되는지 확인하는 학습 테스트를 구현한다.   “1”을 ,로 split 했을 때 1만을 포함하는 배열이 반환되는지에 대한 학습 테스트를 구현한다.   힌트     배열로 반환하는 값의 경우 assertj의 contains()를 활용해 반환 값이 맞는지 검증한다.   배열로 반환하는 값의 경우 assertj의 containsExactly()를 활용해 반환 값이 맞는지 검증한다.     1 2 3 4 5 6 7 8 9 @Test   void split(){       String[] actual = \"1,2\".split(\",\");       String[] actual2 = \"1,\".split(\",\");        assertThat(actual).contains(\"1\",\"2\");       assertThat(actual2).containsExactly(\"1\");    }          String 배열을 만들어 그 안에 “1,2”인 actual 과 “1,”인 actual2를 만들었다.      actual 들을 split() 메서드를 통해 나눠 준뒤, 우리가 원하는 결과값인 값을 만족하는지를 테스트 해줄 수 있다.       요구사항 2     “(1,2)” 값이 주어졌을 때 String의 substring() 메소드를 활용해 ()을 제거하고 “1,2”를 반환하도록 구현한다.     1 2 3 4 5 6 7 8 9 @Test  void substring(){      String actual = \"(1,2)\";      String subActual = actual.substring(1, actual.length()-1);       assertThat(subActual).isEqualTo(\"1,2\");    }          substring() 메서드로 괄호를 제거하고 출력갑과 기댓값이 같은지 확인하도록 구현하였다.       요구사항 3     “abc” 값이 주어졌을 때 String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져오는 학습 테스트를 구현한다.   String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져올 때 위치 값을 벗어나면 StringIndexOutOfBoundsException이 발생하는 부분에 대한 학습 테스트를 구현한다.   JUnit의 @DisplayName을 활용해 테스트 메소드의 의도를 드러낸다.   이 요구사항은 앞서 배운 예외처리의 두가지 방법으로 해결할 수 있다.     먼저 assertThatThrownBy( ) 로 구현하는 경우,  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //요구사항 3-1    @Test    @DisplayName(\"charAt()으로 특정 위치 문자 가져오기\")    void charAt1() {        String actual = \"abc\";         assertThat(actual.charAt(0)).isEqualTo('a');        assertThat(actual.charAt(1)).isEqualTo('b');        assertThat(actual.charAt(2)).isEqualTo('c');         assertThatThrownBy(() -&gt; {            char val = actual.charAt(3);            throw new Exception(\"범위 초과\");        }).isInstanceOf(IndexOutOfBoundsException.class).hasMessageContaining(\"String\");    }  이렇게 할 수 있고,       좀 더 가독성있게 코드를 짜고 싶다면 assertThatExceptionOfType을 사용하면 된다.  1 2 3 4 5 6 7 8 9 10 11 12 13 //요구사항 3-2     @Test     @DisplayName(\"charAt으로 특정 위치 문자 가져오기 - assertThatExceptionOfType 으로 Exception 처리\")     void charAt2(){         String actual = \"abc\";         assertThatExceptionOfType(IndexOutOfBoundsException.class)                 .isThrownBy(()-&gt;{                     char val = actual.charAt(3);                     System.out.println(val);                     throw new Exception(\"범위 초과\");                 }).withMessageContaining(\"String\");      }  ","categories": ["java"],
        "tags": [],
        "url": "/java/%EC%88%AB%EC%9E%90%EC%95%BC%EA%B5%AC-(1)/",
        "teaser": null
      },{
        "title": "[BOJ] 2206 벽 부수고 이동하기 (Python3)",
        "excerpt":"문제  N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.   만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.   한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.   맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.   입력  첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.   출력  첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.   예제  1 2 3 4 5 6 7 8 9 10 11 예제 입력 1   6 4 0100 1110 1000 0000 0111 0000  예제 출력 1   15  1 2 3 4 5 6 7 8 9 예제 입력 2   4 4 0111 1111 1111 1110  예제 출력 2   -1  문제 풀이  맨 처음에는 맵을 돌면서 1인경우에는 벽을 깼다고 가정하고 잠깐 1을 0으로 바꾼뒤 dfs를 한번 돌리고, 끝까지 도달하면 result에 최단거리를 넣어주고 아니면 넣지않는 식으로 모든 1에 대한 벽을 깬 경우를 구했다. 이렇게 하니까 답은 같게 나왔지만, dfs를 모든 좌표마다 한번씩 실행하므로 시간초과가 떴다.   틀린 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 from collections import deque  n,m = map(int,input().split())    count = 0  dx = [1,-1,0,0] dy = [0,0,1,-1]  q = deque()  def dfs(graph):     visited = [[0 for _ in range(m)]for _ in range(n)]     q.append([0,0])     visited[0][0] += 1     while q:         x,y = q.popleft()                  for i in range(4):             sx = x+dx[i]             sy = y+dy[i]              if 0 &lt;= sx &lt; n and 0&lt;= sy &lt; m and graph[sx][sy] == 0 and visited[sx][sy]== 0:                 q.append([sx, sy])                 visited[sx][sy]= visited[x][y]+1                      if visited[n-1][m-1] == 0:         return -1     else:         return visited[n-1][m-1]      graph = []    for i in range(n):     graph.append(list(map(int, input())))  result = []  for i in range(n):     for j in range(m):         if graph[i][j] == 1:             graph[i][j] = 0             answer = dfs(graph)             if answer == -1:                 graph[i][j] = 1                 continue             else:                 result.append(answer)                 graph[i][j] = 1         else:              answer = dfs(graph)             if answer == -1:                 continue             else:                 result.append(answer)                  if result:     print(min(result)) else:     print(-1)   1 2 3 4 5 6 7 8 6 4 0100 1110 1000 0000 0111 0000 15   그래서 해답을 검색해서 보니, 3차원 배열을 사용하는 문제였다. 사실 해답을 보고도 3차원 배열로 하려니까 헷갈려서 생각을 하느라 어려웠는데, 역시 말로 보는것 보다 직접 코딩한번 해보는게 훨씬 이해가 빨랐다.   3차원 배열의 visited를 생성해준다. 원래 visited는 nm의 크기의 0이나 False를 갖는 이차원 배열이지만, 이번에는 nm 크기의 [0,0]을 갖는 3차원 배열이다. 원래의 dfs처럼 [0]의 인덱스의 값에 경로의 값만큼을 세주다가, 벽을 만나면 그 벽을 부쉈다고 가정하고 [1]의 인덱스에 경로를 저장하기 시작한다. 그럼 [0]의 인덱스는 벽을 부수지 않았을때의 최단경로이고, [1]의 인덱스는 벽을 부수고 갔을때의 최단경로가 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 from collections import deque  def dfs():         q.append([0,0,0])     visited[0][0][0] = 1          while q:         x,y,z = q.popleft()         if x == n-1 and y == m-1:             return visited[x][y][z]         for i in range(4):             sx = x+dx[i]             sy = y+dy[i]              if 0 &lt;= sx &lt; n and 0&lt;= sy &lt; m:                 if graph[sx][sy] == 1 and z == 0:                     visited[sx][sy][1] = visited[x][y][0]+1                     q.append([sx,sy,1])                                      elif graph[sx][sy] == 0 and visited[sx][sy][z] == 0:                     visited[sx][sy][z] = visited[x][y][z]+1                     q.append([sx,sy,z])     return -1                      n,m = map(int,input().split())  count = 0  dx = [1,-1,0,0] dy = [0,0,1,-1]  q = deque() visited = [[[0]*2 for _ in range(m)]for _ in range(n)]      graph = []  for i in range(n):     graph.append(list(map(int, input())))  print(dfs())  answer1 = visited[n-1][m-1][0] answer2 = visited[n-1][m-1][1]      1 2 3 4 5 6 7 8 6 4 0100 1110 1000 0000 0111 0000 15   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/2206-%EB%B2%BD-%EB%B6%80%EC%88%98%EA%B3%A0-%EC%9D%B4%EB%8F%99%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1926 도화지 (Python3)",
        "excerpt":"문제  어떤 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라. 단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자. 가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다. 그림의 넓이란 그림에 포함된 1의 개수이다.   입력  첫째 줄에 도화지의 세로 크기 n(1 ≤ n ≤ 500)과 가로 크기 m(1 ≤ m ≤ 500)이 차례로 주어진다. 두 번째 줄부터 n+1 줄 까지 그림의 정보가 주어진다. (단 그림의 정보는 0과 1이 공백을 두고 주어지며, 0은 색칠이 안된 부분, 1은 색칠이 된 부분을 의미한다)   출력  첫째 줄에는 그림의 개수, 둘째 줄에는 그 중 가장 넓은 그림의 넓이를 출력하여라. 단, 그림이 하나도 없는 경우에는 가장 넓은 그림의 넓이는 0이다.   예제  1 2 3 4 5 6 7 8 9 10 11 12 예제 입력 1   6 5 1 1 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1 1 1 0 0 1 1 1 0 0 1 1 1  예제 출력 1   4 9  문제풀이  간단한 dfs 문제이다. n*m의 좌표의 요소에 하나씩 접근하여 그 값이 1이라면 그림의 개수를 1 더해주고, dfs를 실행하여 상하좌우로 이어진 1의 개수가 몇개인지 세주면된다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 from collections import deque   dx = [1,-1,0,0] dy = [0,0,1,-1]  #dfs 함수, pop할때마다 count+=1하여 최종 개수를 return한다. def dfs(x, y):     q = deque()     if graph[x][y] == 1:         q.append([x,y])         visited[x][y] = 1     count = 0     while q:         nx,ny = q.popleft()         count+=1         for i in range(4):             sx = nx+dx[i]             sy = ny+dy[i]                  if 0&lt;= sx &lt; n and 0&lt;= sy &lt; m and graph[sx][sy] == 1 and visited[sx][sy] == 0 :                 q.append([sx,sy])                 visited[sx][sy] = 1                                          return count                    n,m = map(int, input().split())  graph =[]  visited = [[0 for i in range(m)] for i in range(n)]  for i in range(n):     graph.append(list(map(int,input().split(' '))))  width = [] num = 0  # graph의 모든 좌표를 접근하다가 1이 나오면 num+=1을 해주고 dfs를 실행한다. for i in range(len(graph)):     for j in range(len(graph[0])):         if graph[i][j]== 1 and visited[i][j]== 0:             width.append(dfs(i,j))             num+=1  print(num) if width:     print(max(width)) else:     print(0)                                             1 2 3 4 5 6 7 8 9 6 5 1 1 0 1 1 0 1 1 0 0 0 0 0 0 0 1 0 1 1 1 0 0 1 1 1 0 0 1 1 1 4 9   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EA%B7%B8%EB%A6%BC/",
        "teaser": null
      },{
        "title": "[BOJ] 2178 미로 탐색 (Python3)",
        "excerpt":"문제  N×M크기의 배열로 표현되는 미로가 있다.   1\t0\t1\t1\t1\t1     1\t0\t1\t0\t1\t0     1\t0\t1\t0\t1\t1     1\t1\t1\t0\t1\t1   미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.   위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.   입력  첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.   출력  첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.   예제  1 2 3 4 5 6 7 8 9 예제 입력 1   4 6 101111 101010 101011 111011  예제 출력 1   15  1 2 3 4 5 6 7 8 9 예제 입력 2   4 6 110110 110110 111111 111101  예제 출력 2   9  1 2 3 4 5 6 예제 입력 3   2 25 1011101110111011101110111 1110111011101110111011101 예제 출력 3   38  1 2 3 4 5 6 7 8 9 10 11 12 예제 입력 4   7 7 1011111 1110001 1000001 1000001 1000001 1000001 1111111  예제 출력 4   13   문제풀이  가장 기본적인 dfs 문제이다. 오랜만에 푸니까 dfs생각이 잘안나서 한번 풀어봤다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque   def dfs():     q = deque()          if graph[0][0] == 1:         q.append([0,0])         visited[0][0] = 1     while q:         x,y = q.popleft()         for i in range(4):             nx = x+dx[i]             ny = y+dy[i]             if 0&lt;= nx &lt; n and 0&lt;= ny &lt; m and graph[nx][ny] == 1 and visited[nx][ny] == 0:                 q.append([nx,ny])                 visited[nx][ny] = visited[x][y] + 1     return visited[-1][-1]                        dx = [1,-1,0,0] dy = [0,0,-1,1]  n, m = map(int, input().split())  visited = [[0 for _ in range(m)] for _ in range(n)] graph = [] for _ in range(n):     graph.append(list(map(int, input())))  print(dfs())   1 2 3 4 5 6 7 8 9 10 11 12 13 14 7 7 1011111 1110001 1000001 1000001 1000001 1000001 1111111      13   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EB%AF%B8%EB%A1%9C-%ED%83%90%EC%83%89/",
        "teaser": null
      },{
        "title": "[BOJ] 3055 탈출 (Python3)",
        "excerpt":"문제  사악한 암흑의 군주 이민혁은 드디어 마법 구슬을 손에 넣었고, 그 능력을 실험해보기 위해 근처의 티떱숲에 홍수를 일으키려고 한다. 이 숲에는 고슴도치가 한 마리 살고 있다. 고슴도치는 제일 친한 친구인 비버의 굴로 가능한 빨리 도망가 홍수를 피하려고 한다.   티떱숲의 지도는 R행 C열로 이루어져 있다. 비어있는 곳은 ‘.’로 표시되어 있고, 물이 차있는 지역은 ‘*’, 돌은 ‘X’로 표시되어 있다. 비버의 굴은 ‘D’로, 고슴도치의 위치는 ‘S’로 나타내어져 있다.   매 분마다 고슴도치는 현재 있는 칸과 인접한 네 칸 중 하나로 이동할 수 있다. (위, 아래, 오른쪽, 왼쪽) 물도 매 분마다 비어있는 칸으로 확장한다. 물이 있는 칸과 인접해있는 비어있는 칸(적어도 한 변을 공유)은 물이 차게 된다. 물과 고슴도치는 돌을 통과할 수 없다. 또, 고슴도치는 물로 차있는 구역으로 이동할 수 없고, 물도 비버의 소굴로 이동할 수 없다.   티떱숲의 지도가 주어졌을 때, 고슴도치가 안전하게 비버의 굴로 이동하기 위해 필요한 최소 시간을 구하는 프로그램을 작성하시오.   고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다. 즉, 다음 시간에 물이 찰 예정인 칸으로 고슴도치는 이동할 수 없다. 이동할 수 있으면 고슴도치가 물에 빠지기 때문이다.   입력  첫째 줄에 50보다 작거나 같은 자연수 R과 C가 주어진다.   다음 R개 줄에는 티떱숲의 지도가 주어지며, 문제에서 설명한 문자만 주어진다. ‘D’와 ‘S’는 하나씩만 주어진다.   출력  첫째 줄에 고슴도치가 비버의 굴로 이동할 수 있는 가장 빠른 시간을 출력한다. 만약, 안전하게 비버의 굴로 이동할 수 없다면, “KAKTUS”를 출력한다.   예제  1 2 3 4 5 6 7 8 예제 입력 1   3 3 D.* ... .S.  예제 출력 1   3  1 2 3 4 5 6 7 예제 입력 2  복사 3 3 D.* ... ..S 예제 출력 2  복사 KAKTUS  1 2 3 4 5 6 7 8 예제 입력 3  복사 3 6 D...*. .X.X.. ....S.  예제 출력 3  복사 6  1 2 3 4 5 6 7 8 9 10 예제 입력 4  복사 5 4 .D.* .... ..X. S.*. ....  예제 출력 4  복사 4  문제 풀이  dfs를 복잡하게 꼬아 놓은 문제이다.   물이 놓인 자리도 여러개인데다가 고슴도치의 위치인 S와 굴의 위치인 D도 정해져있지 않으며      매분마다 퍼지는 물을 피해서 고슴도치의 최단 경로를 구해야한다.   문제에서는 동시에 고슴도치와 물이 이동하는 상황으로 가정했지만, 물이 먼저 움직이고 그 다음에 고슴도치가 움직이는게 적절하다.     그렇지 않은경우는 고슴도치가 발을 내딛은 곳에 물이 차올라 고슴도치가 죽게되버리기 때문이다.   따라서 물의 좌표를 먼저 큐에 넣어주고, 그다음에 고슴도치의 좌표를 큐에 넣어준다. 그럼 q에 있는 요소들을 순서대로 popleft하면서, 이동하게 될 좌표도 자동으로 물과 고슴도치의 순서대로 dfs가 동작하게 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 from collections import deque  def dfs(S, water):     q = deque()     for i in water:         x,y,z = i         visited[x][y] = '#'         q.append(i)              for i in S:         x,y,z = i         q.append(i)              while q:         x,y,z = q.popleft()                  for i in range(4):             nx = x+dx[i]             ny = y+dy[i]                          if 0&lt;= nx &lt; r and 0&lt;= ny &lt;c and visited[nx][ny] == 0 and graph[nx][ny] == 'D' and z == 1:                 visited[nx][ny] = visited[x][y]+1                              if 0&lt;= nx &lt; r and 0&lt;= ny &lt;c and visited[nx][ny] == 0 and graph[nx][ny] == '.':                          if z == 0:                     visited[nx][ny] = '#'                     q.append([nx,ny,0])                 if z == 1:                     visited[nx][ny] = visited[x][y] + 1                      q.append([nx,ny,1])              dx = [1,-1,0,0] dy = [0,0,-1,1]  r,c = map(int, input().split())  graph = []  S = [] water = []  visited = [[0 for i in range(c)]for i in range(r)]  for i in range(r):     graph.append(list(input()))  for i in range(len(graph)):     for j in range(len(graph[0])):         if graph[i][j] == '*':             water.append([i,j,0])         if graph[i][j] == 'S':             S.append([i,j,1])         if graph[i][j] == 'D':             Dx,Dy = [i,j]  dfs(S, water)   if visited[Dx][Dy] == 0:     print('KAKTUS') else:     print(visited[Dx][Dy])     1 2 3 4 5 3 6 D...*. .X.X.. ....S. 6   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%83%88%EC%B6%9C-2/",
        "teaser": null
      },{
        "title": "[BOJ] 11000 강의실 배정 (Python3)",
        "excerpt":"문제  수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.      김종혜 선생님한테는 Si에 시작해서 Ti에 끝나는 N개의 수업이 주어지는데, 최소의 강의실을 사용해서 모든 수업을 가능하게 해야 한다.   참고로, 수업이 끝난 직후에 다음 수업을 시작할 수 있다. (즉, Ti ≤ Sj 일 경우 i 수업과 j 수업은 같이 들을 수 있다.)   수강신청 대충한 게 찔리면, 선생님을 도와드리자!   입력  첫 번째 줄에 N이 주어진다. (1 ≤ N ≤ 200,000)   이후 N개의 줄에 Si, Ti가 주어진다. (1 ≤ Si &lt; Ti ≤ 109)   출력  강의실의 개수를 출력하라.   예제  1 2 3 4 5 6 7 8 예제 입력 1   3 1 3 2 4 3 5  예제 출력 1   2  문제풀이  맨 처음 수업의 끝나는시간을 큐에 넣어주고, 그 다음 수업부터의 시작시간을 queue[0] 과 비교한다. 만약 queue[0] 보다 시작시간이 빠르다면, 그 강의실은 아직 수업중이므로 새로운 강의실을 배정해주어야 한다. 따라서 heappush로 강의실을 하나 더 배정해준다. 만약 queue[0] 보다 시작시간이 같거나 느리다면, 그 강의실을 사용할 수 있는 것이므로 기존의 끝나는시간을 heappop해주고 새로운 끝나는시간을 push해주면 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import heapq  n = int(input())  time = []  for i in range(n):     time.append(list(map(int, input().split())))  time.sort(key = lambda x : x[0])  queue = [] heapq.heappush(queue,time[0][1])  for i in range(1,len(time)):     if queue[0] &gt; time[i][0]:         heapq.heappush(queue, time[i][1])     else:         heapq.heappop(queue)         heapq.heappush(queue, time[i][1])          print(len(queue))   1 2 3 4 5 3 1 3 2 4 3 5 2   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/11000-%EA%B0%95%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/",
        "teaser": null
      },{
        "title": "[BOJ] 12018 Yonsei TOTO (Python3)",
        "excerpt":"문제  연세대학교 수강신청이 얼마 전부터 바뀌어, 마일리지 제도로 바뀌었다. 이 제도는 각각의 학생들에게 마일리지를 주어 듣고 싶은 과목에 마일리지를 과목당 1~36을 분배한다. 그리고 모두 분배가 끝이 나면 과목에 대해서 마일리지를 많이 투자한 순으로 그 과목의 수강인원만큼 신청되는 방식이다.   성준이는 연세대학교 재학 중인 학생이다. 성준이는 저번 수강신청에서 실패하여 휴학을 했기 때문에 이번 수강신청만은 필사적으로 성공하려고 한다. 그래서 성준이는 학교 홈페이지를 뚫어버렸다.   그 덕분에 다른 사람들이 신청한 마일리지를 볼 수 있게 되었다. 성준이는 주어진 마일리지로 최대한 많은 과목을 신청하고 싶어 한다. (내가 마일리지를 넣고 이후에 과목을 신청하는 사람은 없다) 마일리지는 한 과목에 1에서 36까지 넣을 수 있다.   입력  첫째 줄에는 과목 수 n (1 ≤ n ≤ 100)과 주어진 마일리지 m (1 ≤ m ≤ 100)이 주어진다. 각 과목마다 2줄의 입력이 주어지는데 첫째 줄에는 각 과목에 신청한 사람 수 Pi과 과목의 수강인원 Li이 주어지고 그 다음 줄에는 각 사람이 마일리지를 얼마나 넣었는지 주어진다. (1 ≤ Pi ≤100, 1 ≤ Li ≤ 100)   (단 마일리지가 같다면 성준이에게 우선순위가 주어진다고 하자.)   출력  첫째 줄에 주어진 마일리지로 최대로 들을 수 있는 과목 개수를 출력한다.   예제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 예제 입력 1   5 76 5 4  36 25 1 36 36 4 4 30 24 25 20 6 4 36 36 36 36 36 36 2 4 3 7 5 4 27 15 26 8 14  예제 출력 1   4  문제 풀이  간단한 문제인데 너무 오래걸려서 풀었다.   그냥 순차적으로 계속 마일리지를 받으려고 하니까 알고리즘적으로 단순하고 쉬운게 맞는것 같은데 자꾸 안풀려서 반례를 생각해보려 노력했다. 생각해보니까 무조건 1의 마일리지로 수강신청 성공이 가능한 강의를 먼저 처리해주어야 최대의 수강신청을 성공할 수 있었다.   마일리지의 목록을 내림차순한뒤 l-1이 바로 신청하면 수강신청 성공이 가능한 마일리지가 되므로, p보다 l이 크거나 같다면 l-1에 있는 마일리지를 리스트에 저장해주고, 만약 수강신청인원이 강의 정원보다 적다면 마일리지 1을 리스트에 저장해준다. 그 후, 리스트를 오름차순 정렬하여 순서대로 리스트에 있는 마일리지를 m에서 뺴가면서 0이 될때까지 모두 사용해주면 된다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 n,m = map(int, input().split())  lecture = [] mileages = 0 answer = 0  for i in range(n):     if m == 0:         break              p,l = map(int, input().split())      mileage = list(map(int,input().split()))          mileage.sort(reverse = True)     mileage = mileage[:l]          if p &gt;= l:         lecture.append(mileage[l-1])              else:         lecture.append(1)          lecture.sort()      for i in lecture:     if mileages + i &gt; m:         break     else:         mileages += i         answer+=1          print(answer)                                    1 2 3 4 5 6 7 8 9 10 11 12 5 76 5 4 36 25 1 36 36 4 4 30 24 25 20 6 4 36 36 36 36 36 36 2 4 3 7 5 4 27 15 26 8 14 4   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/12018-Yonsei-TOTO/",
        "teaser": null
      },{
        "title": "[BOJ] 13975 파일 합치기 3(Python3)",
        "excerpt":"문제  소설가인 김대전은 소설을 여러 장(chapter)으로 나누어 쓰는데, 각 장은 각각 다른 파일에 저장하곤 한다. 소설의 모든 장을 쓰고 나서는 각 장이 쓰여진 파일을 합쳐서 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만든다. 이 과정에서 두 개의 파일을 합쳐서 하나의 임시파일을 만들고, 이 임시파일이나 원래의 파일을 계속 두 개씩 합쳐서 파일을 합쳐나가고, 최종적으로는 하나의 파일로 합친다. 두 개의 파일을 합칠 때 필요한 비용(시간 등)이 두 파일 크기의 합이라고 가정할 때, 최종적인 한 개의 파일을 완성하는데 필요한 비용의 총 합을 계산하시오.   예를 들어, C1, C2, C3, C4가 네 개의 장을 수록하고 있는 파일이고, 파일 크기가 각각 40, 30, 30, 50 이라고 하자. 이 파일들을 합치는 과정에서, 먼저 C2와 C3를 합쳐서 임시파일 X1을 만든다. 이때 비용 60이 필요하다. 그 다음으로 C1과 X1을 합쳐 임시파일 X2를 만들면 비용 100이 필요하다. 최종적으로 X2와 C4를 합쳐 최종파일을 만들면 비용 150이 필요하다. 따라서, 최종의 한 파일을 만드는데 필요한 비용의 합은 60+100+150=310 이다. 다른 방법으로 파일을 합치면 비용을 줄일 수 있다. 먼저 C1과 C2를 합쳐 임시파일 Y1을 만들고, C3와 C4를 합쳐 임시파일 Y2를 만들고, 최종적으로 Y1과 Y2를 합쳐 최종파일을 만들 수 있다. 이때 필요한 총 비용은 70+80+150=300 이다.   소설의 각 장들이 수록되어 있는 파일의 크기가 주어졌을 때, 이 파일들을 하나의 파일로 합칠 때 필요한 최소비용을 계산하는 프로그램을 작성하시오.   입력  프로그램은 표준 입력에서 입력 데이터를 받는다. 프로그램의 입력은 T개의 테스트 데이터로 이루어져 있는데, T는 입력의 맨 첫 줄에 주어진다.각 테스트 데이터는 두 개의 행으로 주어지는데, 첫 행에는 소설을 구성하는 장의 수를 나타내는 양의 정수 K (3 ≤ K ≤ 1,000,000)가 주어진다. 두 번째 행에는 1장부터 K장까지 수록한 파일의 크기를 나타내는 양의 정수 K개가 주어진다. 파일의 크기는 10,000을 초과하지 않는다.   출력  프로그램은 표준 출력에 출력한다. 각 테스트 데이터마다 정확히 한 행에 출력하는데, 모든 장을 합치는데 필요한 최소비용을 출력한다.   예제  1 2 3 4 5 6 7 8 9 10 예제 입력 1   2 4 40 30 30 50 15 1 21 3 4 5 35 5 4 3 5 98 21 14 17 32  예제 출력 1   300 826  문제풀이  자꾸 시간초과가 떴었는데, heappop을 까먹고 사용안하고 pop으로 사용해서 자꾸 시간초과가 떴다.   문제 자체는 간단한 우선순위 큐 문제로, 가장 작은 비용두개를 더한뒤 다시 heappush해주며 비용이 하나가 될때까지 반복하면서 heappush하는 값들을 cost에 기록해주면 된다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import heapq  t = int(input()) answer = [] for _ in range(t):     k = int(input())     chapter = list(map(int, input().split()))          heapq.heapify(chapter)          cost = 0          while len(chapter) != 1:         x = heapq.heappop(chapter)         y = heapq.heappop(chapter)         z = x+y         heapq.heappush(chapter, z)         cost += z     answer.append(cost)      for i in answer:     print(i)   1 2 3 4 1 4 40 30 30 50 300   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/13975-%ED%8C%8C%EC%9D%BC-%ED%95%A9%EC%B9%98%EA%B8%B0-3/",
        "teaser": null
      },{
        "title": "[BOJ] 1202 보석 도둑 (Python3)",
        "excerpt":"문제  세계적인 도둑 상덕이는 보석점을 털기로 결심했다.     상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.   상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)   다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)   다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)   모든 숫자는 양의 정수이다.   출력  첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.  1 2 3 4 5 6 7 예제 입력 1   2 1 5 10 100 100 11 예제 출력 1   10  1 2 3 4 5 6 7 8 9 예제 입력 2   3 2 1 65 5 23 2 99 10 2 예제 출력 2  164  문제풀이  이 문제는 우선순위 큐를 이용한 문제이다.   힙큐 리스트의 순서는 크기 순서가 아닌데 자꾸 리스트처럼 크기 순서라고 헷갈려서 푸는데 오래걸렸다. 힙큐는 힙트리를 리스트로 표현한것 뿐이고, heappop이나 heappush를 하면 알아서 가장 적은 값이 출력되고, 힙큐의 크기대로 push된다.   보석을 가장 적은 무게를 차지하는 보석의 순서중 가장 큰 가치를 갖는 보석부터 가방에 넣어야 한다. 가방의 무게들을 오름차순 정렬 한 뒤에, 하나씩 불러와 해당 무게보다 적은 무게를 갖는 보석을 모두 heappush 해준뒤 가장 가치가 큰값을 heappop해준다. 이때 최대힙으로 구성해야 하므로, push할때 -를 붙여 push해야 한다.   이런식으로 적은 무게에서 가장 큰 가치를 갖는 보석을 차례로 넣어주면, 가장 큰 총합의 가치의 보석을 도둑질 할 수 있다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import heapq  n,k = map(int, input().split())  jewels = [] for _ in range(n):     jewels.append(list(map(int, input().split()))) jewels.sort()  bag = [] for _ in range(k):     bag.append(int(input())) bag.sort()  answer = 0  q = []  for b in bag:     while jewels and b &gt;= jewels[0][0]:         heapq.heappush(q, -jewels[0][1])         heapq.heappop(jewels)     if q:           answer += heapq.heappop(q)     elif not jewels:         break  print(-answer)     1 2 3 4 5 2 1 5 10 100 100 11 10   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/1202-%EB%B3%B4%EC%84%9D-%EB%8F%84%EB%91%91/",
        "teaser": null
      },{
        "title": "[BOJ] 2467 용액 (Python3)",
        "excerpt":"문제  KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.   같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.   예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.   산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.   입력  첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.   출력  첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.   예제  1 2 3 4 5 6 예제 입력 1   5 -99 -2 -1 4 98  예제 출력 1   -99 98  1 2 3 4 5 6 예제 입력 2   4 -100 -2 -1 103  예제 출력 2   -2 -1  문제풀이  간단한 투포인터 문제이다.   오른쪽과 왼쪽에서 포인터 두개를 가운데로 좁혀가며 합이 0보다 작은경우 왼쪽 포인터를 오른쪽으로 한칸 옮기고, 0보다 큰 경우는 오른쪽 포인터를 왼쪽으로 한칸 옮기며 가장 최솟값일때의 포인터를 인덱싱하여 출력하면 된다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import sys  n = int(input()) liquid = list(map(int, input().split()))  start = 0 end = n-1 mix = sys.maxsize dic = {}  while start &lt; end:     print(start, end)     mix = min(mix, abs(liquid[start] + liquid[end]))          if mix in dic:         pass     else:         dic[mix] = [liquid[start], liquid[end]]          if liquid[start] + liquid[end] == 0:         break     if liquid[start] + liquid[end] &lt; 0:         start += 1     else:         end -= 1      print(sorted(dic[mix])[0],sorted(dic[mix])[1])     1 2 3 4 5 6 7 5 -99 -2 -1 4 98 0 4 1 4 1 3 1 2 -99 98   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/2467-%EC%9A%A9%EC%95%A1/",
        "teaser": null
      },{
        "title": "[BOJ] 11729 하노이탑 이동 순서 (Python3)",
        "excerpt":"문제  세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.   한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.  쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.  이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.   아래 그림은 원판이 5개인 경우의 예시이다.   입력  첫째 줄에 첫 번째 장대에 쌓인 원판의 개수 N (1 ≤ N ≤ 20)이 주어진다.   출력  첫째 줄에 옮긴 횟수 K를 출력한다.   두 번째 줄부터 수행 과정을 출력한다. 두 번째 줄부터 K개의 줄에 걸쳐 두 정수 A B를 빈칸을 사이에 두고 출력하는데, 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.  1 2 3 4 5 6 7 8 9 10 11 예제 입력 1   3 예제 출력 1   7 1 3 1 2 3 2 1 3 2 1 2 3 1 3  문제 풀이  이걸 그냥 문제만 보고 풀 수가 있다고…?   너무 어려워서 인터넷을 좀 참고했다.      재귀는 머릿속으로 생각하기가 복잡하다 보니까 조금만 문제가 꼬여도 함수를 짜는게 너무 어려운것 같다.   하노이탑의 규칙은 간단하다.     1단계는 n-1개의 원판을 2번으로 옮기는 것이고, 2단계는 맨 아래 남은 원판을 3번째 막대로 옮긴다. 3단계는 n-1개의 쌓여있는 원판을 3번째 막대로 옮기면 된다.   이를 재귀함수로 구현해주면 다음과 같다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 def hanoi_tower(n, start, end) :     if n == 1 :         print(start, end)         return             hanoi_tower(n-1, start, 6-start-end) # 1단계     print(start, end) # 2단계     hanoi_tower(n-1, 6-start-end, end) # 3단계      n = int(input()) print(2**n-1) hanoi_tower(n, 1, 3)        1 2 3 4 5 6 7 8 9 3 7 1 3 1 2 3 2 1 3 2 1 2 3 1 3   1   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/11729-%ED%95%98%EB%85%B8%EC%9D%B4%ED%83%91-%EC%9D%B4%EB%8F%99-%EC%88%9C%EC%84%9C/",
        "teaser": null
      },{
        "title": "스타트업",
        "excerpt":"2021.08.31  난 어릴때 부터 창업을 동경해왔다. 도전을 하고 창조하는 일은 나에게 너무나 즐겁고 행복한 일이라서,     항상 마음 한켠에 창업에 대한 열망을 품고 살았었다.   하지만 창업하기엔 나의 실력이 부족해보이거나, 시간이 안되거나, 상황이 아직 안되거나 하는 이유로      도전하지 못하고 그냥 눈앞에 있는 문제들을 하나씩 해결하며 살았었고, 이대로라면 그냥 코딩테스트를 준비해서   취업하거나 해서 무난하게 직장생활을 하면서 살았을 것이다.   2학기에는 오프라인 활동이라던가 최소한 내가 배운것 들을 실제로 사용할 수 있는 것들을 해보는게 나의 휴학 1년 목표 중 하나였는데,  얼마전 친한 형이 스타트업에서 앱기획자를 구하고 있다는 글을 동아리 단장인 나에게 단톡방에 뿌려달라고 했는데, 이 형이 스타트업을 하고있다는게 의외이기도 했고, 평소 내가 꿈꾸고 있던 걸 하는 모습에 부럽기도 해서 장난스럽게 얼마주냐고 나도 해도 되냐고 물어봤다.   근데 얘기를 듣고 형이 준 사업 계획서를 받아봤는데 생각보다 너무 본격적이고 준비도 많이 된 상태여서, 앱만 제작 할 수 있다면 아무리 봐도 외주주는것 보다 직접 제작하는게 유지보수로 보나 단가로 보나 훨씬 효율적이고 효과적일 것 같았다.   그때부터 조금씩 가슴이 뛰고 살짝 설레었다. 저거 내가 개발하면 무조건 훨씬 잘될 것 같은데… 내가 더 잘할 수 있는데!     그래서 우선 형이랑 만남 약속부터 잡고, 바로 컴퓨터 앞에 앉았다.   스위프트를 다뤄본적은 없었지만, 문법도 그렇게 어렵지 않고 솔직히 하려면 할 수 있을만 할 것 같았다.  그래서 이틀동안 열한시간씩 앉아서 그냥 무작정 앱을 만들었다. 이틀동안 기본적인 홈 화면을 제작해서 가는게 내 목표였고,      너무 설레고 좋아서 열한시간씩 앉아있는데도 너무 행복했다.   아 나는 이걸 위해 태어났구나 하는 생각이 들어서, 너무 확신이 들었다. 이거 나 무조건 할 수 있다. 무조건 된다.   형이랑 만나기 전까지도 아침에 눈뜨자 마자 코딩을 했다.     하나도 안힘들고 재밌기만 했다. 마음은 온통 빨리 내가 만든 결과를 보여주고 이거 내가 할 수 있다고 말하고 싶었다.   나름 서프라이즈였던 내 소개와 미팅은 성공적이었고, 나는 드디어 내가 꿈꾸던 일을 할 수 있게 되었다.     모두가 성공을 위해 자신의 시간과 젊음을 태우는 이런걸 나는 너무나 꿈꾸고 있었기에, 집에 오는길이 너무나 행복하고 즐거웠다.   앞으로 한달간 앱을 출시하는 것은 아마 매우 빠듯한 일일 것이다. 난 아이폰으로 앱을 제작해본적이 전혀 없기에, 만드는시간 뿐만 아니라 지식을 습득하는 시간도 포함되어야 하기에, 아마 하루에 열시간넘게 계속 일해야 할 거다. 그래야 이 기한을 맞출 수 있으며, 그렇게 해도 한달이란 시간은 빠듯하다. 하지만 힘들것 같다거나 괴로울 것 같다는 생각은 1도 들지않았다.   꿈을 이야기 하는 사람이 결국 그 꿈을 쟁취한다고 생각한다. 그 꿈의 크기를 부끄러워하거나 남에게 말하는게 두려운 사람은 절대 그 꿈의 크기에 닿을 수 없다.   난 이 앱이 큰 돈이 될 사업이라고 확신한다.      아니더라도 내가 그렇게 만들 거다 무조건!!!   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%8A%A4%ED%83%80%ED%8A%B8%EC%97%85/",
        "teaser": null
      },{
        "title": "다시 일기 쓰러옴...",
        "excerpt":"2021.10.13  약 한 달만에 쓰는 일기… 게을러서 안쓴게 아니라 진짜 눈코 뜰 새 없이 바빠서 못썼다.  한달간 앱을 어떻게든 1차 필드테스트까지 기능 구현하려고 너무도 애썼고 이제서야 조금 앱이 안정되서 일기 쓸 여유가 생겼다.  원래 내 계획은 버그나 하다가 막혔던 것들을 해결해가며 블로그에 글도 쓰려 했는데, 진짜 일정이 너무 빡빡해서   앱 만들기도 너무 벅찬 시간이었다. 한달만에 노베이스에서 바로 실전에 사용할 앱을 만들려고 하니,   공부하며 앱을 계속 만들고 버그 수정하고, 조금 일해서는 도저히 날짜를 맞출 수가 없는 탓에 하루에 평균열시간씩   코딩해가며 결국 어찌저찌 날짜는 맞췄다. 물론 버그때문에 겨우 맞춘 필드테스트를 3일정도 더 미루긴 했지만…   한달동안 태어나서 처음으로 모든 열정을 쏟아 본 것 같다. 나름 이렇게 까지 해낸게 뿌듯하고 자랑스럽기도 하고,  이제야 내가 뭘 하고싶은지 뭘 해야할지 감이 잡히는 기분이 들어서 너무 좋다. 어떻게 살아야 할지 찾아낸 것 만으로도 이미  절반은 했달까… 근데 지금 코드가 아주 시궁창이다. 가라앉는 배를 어떻게 이 부품떼다가 이 구멍을 막고… 다른 곳에 구멍나면   이 부품을 떼다가 또 막고 무한반복으로 어찌저찌 배를 띄워놓는 정도랄까…   그래서 오늘 부터는 조금 여유도 생겼겠다 다시 배우는 점들 블로그에 써가면서 작업하려 한다.  동기 부여 측면에서도 그렇고, 일하다 보면 분명 저번에 만났던 문제인데 기억이 안나서 또 머리를 싸매는 경우가 있어서  똑같은 문제를 반복하지 않도록 하기 위해서 다시 블로그를 열심히 써보겠다는 다짐을 해본다.   사실 일하는것도 힘들어 죽겠는데 글까지 쓰는거 다른 개발자들은 다들 어떻게 하는건지 어렵긴하지만…  그래도 남들도 다하는데 나도 할 수 있겠지.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%BC%EA%B8%B0-%EB%8B%A4%EC%8B%9C-%EC%93%B0%EB%9F%AC-%EC%98%B4/",
        "teaser": null
      },{
        "title": "[SwiftUI] ignoreSafeArea(.keyboard)가 이미지에 작동하지 않을 때",
        "excerpt":"문제  키보드를 사용하려고 하면 화면 전체가 말려올라가서, 화면이 깨질 뿐더러, 밑에 식단 버튼이 올라오지 않았다.      따라서 엔터를 눌러 식단추가 버튼이 보이도록 해야 했고, 텍스트필드도 위로 올라가서 자신이 무슨 검색어를 입력하는지  보이지 않았다.   해결방법  맨 처음에는 별 대수롭지 않게 ignoreSafeArea(.keyboard)로 간단하게 해결하려고 했는데, 생각해보니까 텍스트필드가 키보드를   가리지도 않는데 텍스트필드에 포커스를 주면 화면 전체가 위로 말려 올라가기 때문에 safeArea와는 상관이 없는 오류였다.   혹시 ignoreSafeArea 코드의 위치가 다른가? 최대한 상위뷰에 써주어야 작동하나? 라는 생각에 계속 ignoreSafeArea자체가 작동   안하는거에 대한 내용으로 검색을 했다. 하지만 계속 앱을 실행시키다보니 아래 버튼에는 ignoreSafeArea가 작동하여 아래의 버튼은 키보드가 동작해도   올라오지 않는것을 발견했다. 생각해보니 텍스트필드가 가려져있지 않음에도 올라가는 것도 이상하고 그래서 자세히 보니 추가된 이미지가 정확히 키보드위로 올라와 있었고,  키보드가 올라오면서 위의 뷰들을 밀어내어 전체적으로 올라가고 있던 것이었다.   따라서 생각을 바꿔 이미지가 키보드에 가려지지 않도록 텍스트 필드에 포커싱이 가면 이를 detecting해서 이미지 사이즈 자체가 줄어들도록 해주었다.   이를 위해서 텍스트필드에 포커스가 갔는지 안갔는지 확인 하는 코드가 필요했는데, 간단하게 StackOverFlow에서 찾을 수 있었다.   1 2 3 4 5 6 7 8 9 10 @State var text : String = false TextField(\"텍스트 필드\", text: $text, onEditingChanged: { (editingChanged) in     if editingChanged {                 ///Focus On 인 상태     } else {        ///Focus Out 인 상태              }})                                따라서 이를 통해 이미지 자체의 사이즈를 줄였는데,      내가 원하는건 키보드 거리 만큼 이미지는 그대로 사이즈만 줄어들어 자연스럽게 움직이는것이었는데, 그냥 이미지 사이즈가 줄은대로 왜곡되어  이미지가 찌부되는 현상이 일어났다. 이미지는 그대로 있고 잘리듯이 줄어들게 해주는 코드가 필요했다.   간단하게 아래 코드로 이미지의 손상없이 width 값을 줄여줄 수 있었다.  1 2 3 4 Image(\"image\")     .aspectRatio(contentMode: .fill)     .frame(width: 360, height: isFocusOn ? 150 : 280, alignment: .center)     .cornerRadius(15)   이미지에 줄수 있는 비율 옵션은 세가지가 있는데 다음과 같다.           ScaleToFill (기본값)  Image를 정해진 frame에 늘리고 줄여서 우겨넣는다. 애초에 디자인 가이드에 맞게 디자인된 이미지가 아니라면 부적합하다.            AspectToFill  원본의 비율은 유지한다. 하지만 frame을 이미지의 비율에 맞지않게 넣어주면 프레임밖의 이미지는 잘라버린다.  ImageView 내부에 절대 여백이 생기지 않는다.            AspectToFit  원본의 비율을 유지한다. Image는 절대 ImageView 바깥으로 나가지않는다.  따라서 비율이 맞지않는 부분은 여백으로 남겨두게 된다.      ","categories": ["swiftUI"],
        "tags": [],
        "url": "/swiftui/SwiftUI-safeIgnoreArea(.keyboard)%EA%B0%80-%EC%9D%B4%EB%AF%B8%EC%A7%80%EC%97%90-%EC%9E%91%EB%8F%99%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%84-%EB%95%8C/",
        "teaser": null
      },{
        "title": "[SwiftUI] 옵셔널",
        "excerpt":"문제  스위프트를 빠르게 배워서 쓰다보니까 아무래도 스위프트에만 있는 옵셔널이라는 개념이 익숙치가 않아서  뭔지도 모르고 그냥 !를 사용해 강제 언래핑을 해서 코딩을 하고 있었다. 이렇게 하다보니 서버에서 정보를 잠깐만 못불러와도 nil 값이 되어   앱이 자주 튕기는 현상이 발생해서, 이번 기회에 옵셔널에 대해 제대로 짚고 다시 코딩하기 위해서 옵셔널에 대해 적어보려한다.   옵셔널이란?  스위프트를 쓰다보면 변수에 ?,! 이러한 기호를 사용하는 것을 볼 수 있는데, 이 기호는 옵셔널 기호로 다른 언어에는 없는 스위프트의 특이한  기호이다. non-optional이 기본값이며, non-optional은 nil값을 가질 수 없는 변수이기때문에 반드시 값을 가져야한다. 이렇게 함으로써 nil에 대해서  강제적인 예외처리가 요구되고, 이는 개발 과정에 있어서 nil로 인한 여러가지 문제들을 컴파일 단계에서 예방이 가능해진다. 또한, 이 변수가 nil값을 가질수도   있는 변수인지 아닌지를 명확하게 표기하기 때문에 다른 개발자와 협업에 있어서도 좀 더 의도를 쉽게 전달 할 수 있다.   옵셔널 사용법  옵셔널 변수는 ? 기호를 이용하여 선언한다.   1 2 var name: String?    이렇게 하면 방금 선언한 name 변수는 nil을 가질 수 있게 되고, 따라서 다른 값을 할당하지 않아도 컴파일 에러가 나지 않는다. 만약 옵셔널 기호인 ?가 없는  non-optional 값으로 변수를 선언한다면,   1 2 var name : String    위의 코드는 non-optional 값에 nil이 들어갔으므로 컴파일 에러가 뜨게 된다.   ## 옵셔널 변수 사용법    옵셔널 변수는 nil을 가질 수 있는 변수이기 때문에 이를 통해 연산을 하거나 직접 사용을 하려면 이러한 optional을 해제해주는 과정이 필요하다.  1 2 3 4 5 var num1 : Int? = 20 var num2 : Int = 10  num1 + num2   만약 위처럼 non-optional인 변수와 optional인 변수의 연산을 시도하게 되면, 컴파일 단계에서 Int? optional 변수가 unwrap 되어있다는 에러가  발생하게 된다. nil값과 정수의 합은 존재 하지 않기 때문에, nil값을 가질 수 있는 optional 변수 그 자체로는 연산을 할 수 없는 것이다.   따라서 이러한 값을 사용할 수 있도록 unwrappiing 또는 binding 과정이 필요하다.   Optional Unwrapping  Optional Unwrapping은 Optional 변수에서 Optional을 벗겨내는 작업이다. 위에서 다룬 두수를 연산하는 상황으로 예를 들면,  1 2 3 4 5 6  var num1 : Int? = 20  var num2 : Int = 10    if num1 {   let sum = num1! + num2 }   if문을 사용해서 Optional 변수의 값이 nil인지 아닌지 판별 후에 ! 를 이용하여 값을 꺼내온다.  여기서 !는 unwrapping 기호로, 강제로 Optional을 벗기는 기호이다. 따라서 무분별하게 Optional 변수에 !를 사용하여 강제 unwrapping을 하게되면   Optional 변수가 nil인 경우에 에러가 발생할 수 있다. 위 코드의 경우에는 if를 통해 먼저 num1이라는 Optional 변수가 nil값인지 아닌지 확인 후 !를 통해   unwrapping 했기 때문에 nil값으로 인한 에러를 방지하게 된다.   Optional Binding  1 2 3 4 5 6 var num1 : Int? = 20 var num2 : Int = 10  if let nonOptionalNum1 = num1{     let sum = nonOptionalNum1 + num2 }  위의 Optional Unwrapping 과 비슷하지만, 새로운 상수로 num1을 받고 이렇게 받은 nonOptional을 사용한다는 차이가 있다.   새롭게 선언된 nonOptionalNum1은 non-Optional인 변수이므로, ! 기호 없이 사용할 수 있다.   ### Optional Chaining   위처럼 Optional 변수를 연산할 때 Optional Binding을 사용해야 한다는 것을 알게되었다. 하지만 만약 여러개의 Optional 변수를 한번에 연산해야 한다면   모든 변수마다 Optional Binding을 해주는 것은 너무 복잡하고 가독성도 떨어질 것이다. 따라서 Optional Chaining을 사용하면 좀 더 간단하게 Optional 예외   처리가 가능하다.   1 2 3 4 5 6 class A{     var b: B? } class B{     var c:String? }  위 코드의 경우는 A의 프로퍼티 b의 c에 접근할 때, b에대한 옵셔널, c에대한 옵셔널 이렇게 두번의 바인딩이 필요할 것이다.  따라서 이 경우에 Optional Chaining을 이용해 옵셔널 연쇄적으로 옵셔널 바인딩을 해줄 수 있다.   1 2 3 4 5 var a: A = A()  if a.b?.c{  }  이렇게 a.b?.c를 통해 b,c의 옵셔널 바인딩을 모두 처리 가능하다.   default 값 설정해주기  ??를 사용하면 optional 값이 nil일때의 default값을 설정해 줄 수 있다.  1 2 3 4  var num1 : Int? = nil  var num2 : Int = 10    print(num1 ?? 10 + num2)  위처럼 Optional 기호 자리에 ??를 사용해주면 optional 값이 nil일 때 뒤에 적어준 defualt 값을 넣어서 연산해준다.   따라서 위 코드의 경우는 20이 출력되게 된다.   ## 마치며…    사실 Optional 이란게 있다는 것도 알고 언젠가는 공부해야지 하면서 넘겼는데, 진작 공부하고 코딩했으면 이럴일이 없었겠다는 생각을 했다…  너무 기본적인 것 같아보여서 넘긴 감이 있는데, 코드에서는 가장 기본적인 것이 잘못되면 와르르 무너질 수 밖에 없다는 생각이 들었다.   얼른 가서 !로 강제 언래핑 해놓은 코드들을 고치러 가야겠다… 이제는 앱 안튕기겠지  ","categories": ["swiftUI"],
        "tags": [],
        "url": "/swiftui/SwiftUI-%EC%98%B5%EC%85%94%EB%84%90/",
        "teaser": null
      },{
        "title": "우아한 테크 코스",
        "excerpt":"2021.10.29  우아한 테크코스에 방금 지원서를 넣었다.  원래는 내년에 졸업 후 우아한테크코스를 지원해서 2023에 하는게 목표였는데, 이 치열한 기회를 두고 내가 2023년에 붙을거란 보장도 없는데  내가 낙관적이고 배부른 생각을 하고 있는게 아닌가 라는 생각이 들었다.   사실 내년에 2년 연속 휴학하는게 너무 무서워서, 남들보다 뒤쳐지는게 너무 두려워서,   우선 졸업은 해놓고 해보자라는 생각이었는데 왠지 이번 기회에 도전 하지 않으면 안될 것 같은 기분이 들었다.  만약 이번 기회에 붙는다면 내후년에 남들은 취업하고 있을때 나는 복학해서 졸업을 해야 할 수도 있을것이고,   혼자 학교를 다니며 2023년에 16학번으로써 학교에 다니고 있을 것이다. 남들 보다 많이 늦어질 거다 아마도…   그래도 남들이랑 비교하기 보다는, 어제의 나와 비교해가며 오늘 더 나은 사람이   되었는지만을 생각하며 인생을 살기로 했다. 물론 붙지도 않은 걸 걱정하는 거지만,   그래도 왠지 붙을 것 같다는 생각이 조금 든다. 내 지원서에 담긴 간절함이 닿기를 바라며.   남은건 혹시나 내게 올 기회가 물거품이 되지않도록 코딩테스트를 열심히 준비해서 과락을 피하는것…   이민재 화이팅.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[BOJ] 11399 ATM (Python3)",
        "excerpt":"문제  인하은행에는 ATM이 1대밖에 없다. 지금 이 ATM앞에 N명의 사람들이 줄을 서있다. 사람은 1번부터 N번까지 번호가 매겨져 있으며, i번 사람이 돈을 인출하는데 걸리는 시간은 Pi분이다.   사람들이 줄을 서는 순서에 따라서, 돈을 인출하는데 필요한 시간의 합이 달라지게 된다. 예를 들어, 총 5명이 있고, P1 = 3, P2 = 1, P3 = 4, P4 = 3, P5 = 2 인 경우를 생각해보자. [1, 2, 3, 4, 5] 순서로 줄을 선다면, 1번 사람은 3분만에 돈을 뽑을 수 있다. 2번 사람은 1번 사람이 돈을 뽑을 때 까지 기다려야 하기 때문에, 3+1 = 4분이 걸리게 된다. 3번 사람은 1번, 2번 사람이 돈을 뽑을 때까지 기다려야 하기 때문에, 총 3+1+4 = 8분이 필요하게 된다. 4번 사람은 3+1+4+3 = 11분, 5번 사람은 3+1+4+3+2 = 13분이 걸리게 된다. 이 경우에 각 사람이 돈을 인출하는데 필요한 시간의 합은 3+4+8+11+13 = 39분이 된다.   줄을 [2, 5, 1, 4, 3] 순서로 줄을 서면, 2번 사람은 1분만에, 5번 사람은 1+2 = 3분, 1번 사람은 1+2+3 = 6분, 4번 사람은 1+2+3+3 = 9분, 3번 사람은 1+2+3+3+4 = 13분이 걸리게 된다. 각 사람이 돈을 인출하는데 필요한 시간의 합은 1+3+6+9+13 = 32분이다. 이 방법보다 더 필요한 시간의 합을 최소로 만들 수는 없다.   줄을 서 있는 사람의 수 N과 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어졌을 때, 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 구하는 프로그램을 작성하시오.   입력  첫째 줄에 사람의 수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 각 사람이 돈을 인출하는데 걸리는 시간 Pi가 주어진다. (1 ≤ Pi ≤ 1,000)   출력  첫째 줄에 각 사람이 돈을 인출하는데 필요한 시간의 합의 최솟값을 출력한다.   1 2 3 4 5 6 예제 입력 1  복사 5 3 1 4 3 2  예제 출력 1  복사 32   코드   1 2 3 4 5 6 7 8 9 n = input() people = list(map(int, input().split())) sumPeople = 0 people.sort()  for i in range(len(people)+1):     sumPeople += sum(people[0:i])      print(sumPeople)   1 2 5 3 1 4 3 2   문제 풀이  진짜 쉬운 문제인데 파이썬을 진짜 다 까먹어서 한참 걸렸다…                           이번주 나 코딩테스트 풀 수 있는거 맞아…?   빨리 재활 열심히 해야겠다…   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/ATM/",
        "teaser": null
      },{
        "title": "[BOJ] 1260 DFS와 BFS (Pytyon3)",
        "excerpt":"문제  그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.   입력  첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.   출력  첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 예제 입력 1   4 5 1 1 2 1 3 1 4 2 4 3 4 예제 출력 1   1 2 4 3 1 2 3 4   예제 입력 2   5 5 3 5 4 5 2 1 2 3 4 3 1 예제 출력 2   3 1 2 5 4 3 1 4 2 5  풀이  좌우좌표계로 연결된 노드로 생각하고 bfs를 사용하여 방문한적이 없다면 점프하기 전의 위치에서 1을 더한값을 현재위치에 저장해 주며 앞으로 끝까지 나아간다. 그 이후에 주미가 있는 곳의 숫자를 출력해주면, 그 숫자가 동규가 주미에게 도달하기위한 최소 이동 횟수가 된다.  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from collections import deque  n, m, v = map(int, input().split())  graph = [[] for _ in range(n+1)] visited = [False] * (n+1)  for _ in range(m):     dotA, dotB = map(int, input().split())     graph[dotA].append(dotB)     graph[dotB].append(dotA)      def dfs(graph, v, visited):     # 현재 노드를 방문처리     visited[v] = True     print(v, end = ' ')     #현재 노드와 연결된 다른 노드를 재귀적으로 방문     for i in graph[v]:         if not visited[i]:             dfs(graph, i, visited)     def bfs(graph, start, visited):     queue = deque([start])          visited[start] = True          while queue:         v = queue.popleft()         print(v, end = ' ')         for i in graph[v]:             if not visited[i]:                 queue.append(i)                 visited[i] = True                  for i in range(1, n+1):     graph[i].sort()                  dfs(graph, v, visited) visited = [False] * (n+1) print() bfs(graph, v, visited)   1 2 3 4 5 6 7 8 5 5 3 5 4 5 2 1 2 3 4 3 1 3 1 2 5 4  3 1 4 2 5    문제풀이   깊이,너비우선 탐색의 기초를 구현해보는 문제였다.   dfs랑 bfs는 복잡해서 그런가 기억이 진짜 너무 안난다…   먼저 dfs는 깊이 우선 탐색으로, 인접노드를 계속 타고 들어가 방문하지 않은 인접노드가 있을때까지 탐색한뒤, 다시 돌아와 반복하며 모든 노드를 탐색하는 방식이고,   bfs는 너비 우선 탐색으로 먼저 주변 노드들을 모두 탐색한 뒤에 다음 depth로 이동해서 탐색하는 방식으로, 인접 노드를 먼저 모두 방문하고 다음 depth로 이동하는 방식이다.   dfs의 경우는 재귀함수를 이용해서, 노드를 방문하면 시작 노드와 인접한 노드를 계속 타고 들어가 재귀 함수가 종료된 후 다음 방문하지 않은 시작노드의 인접노드를 방문하여 동일하게 진행한다.   bfs는 큐를 하나 만든 뒤, 시작노드의 인접노드를 방문하며 순서대로 큐에 넣어 시작노드와 가까운 인접노드를 우선적으로 방문하며 차례대로 다음 depth를 방문하여 진행한다.   ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/DFS%EC%99%80-BFS/",
        "teaser": null
      },{
        "title": "[BOJ] 1655 가운데를 말해요 (Python3)",
        "excerpt":"문제  백준이는 동생에게 “가운데를 말해요” 게임을 가르쳐주고 있다. 백준이가 정수를 하나씩 외칠때마다 동생은 지금까지 백준이가 말한 수 중에서 중간값을 말해야 한다. 만약, 그동안 백준이가 외친 수의 개수가 짝수개라면 중간에 있는 두 수 중에서 작은 수를 말해야 한다.   예를 들어 백준이가 동생에게 1, 5, 2, 10, -99, 7, 5를 순서대로 외쳤다고 하면, 동생은 1, 1, 2, 2, 2, 2, 5를 차례대로 말해야 한다. 백준이가 외치는 수가 주어졌을 때, 동생이 말해야 하는 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에는 백준이가 외치는 정수의 개수 N이 주어진다. N은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수이다. 그 다음 N줄에 걸쳐서 백준이가 외치는 정수가 차례대로 주어진다. 정수는 -10,000보다 크거나 같고, 10,000보다 작거나 같다.   출력  한 줄에 하나씩 N줄에 걸쳐 백준이의 동생이 말해야 하는 수를 순서대로 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 예제 입력 1   7 1 5 2 10 -99 7 5 예제 출력 1   1 1 2 2 2 2 5   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 import heapq import sys input = sys.stdin.readline  n = int(input()) leftHeap = [] rightHeap = [] answer = []  for _ in range(n):     num = int(input())     if len(leftHeap) == len(rightHeap):          heapq.heappush(leftHeap, (-num, num))     else:         heapq.heappush(rightHeap, (num, num))              if rightHeap and leftHeap[0][1] &gt; rightHeap[0][0]:         max = heapq.heappop(leftHeap)[1]         min = heapq.heappop(rightHeap)[0]         heapq.heappush(leftHeap, (-min, min))         heapq.heappush(rightHeap, (max, max))     answer.append(leftHeap[0][1])      for i in answer:     print(i)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 7 1 5 2 10 -99 7 5 1 1 2 2 2 2 5   문제풀이  처음에는 정렬이랑 그냥 우선순위큐로 풀었는데 아무리 해도 시간초과가 떠서 해답을 찾아봤다.  중간값보다 작은 leftHeap과 rightHeap으로 두 힙으로 나눈뒤, leftHeap은 최대힙으로 구성하고, rightHeap은 최소힙으로 구성한다.   두 힙의 개수가 같을때는 leftHeap에 Heappush해주고, 두 힙의 개수가 다를 때는 rightHeap에 Heappush해준다.   이렇게 Heappush하다보면 leftHeap에 rightHeap보다 큰 값이 들어갈때가 있는데, 이를 보정하기 위해 if문을 두어 두 Heap의 맨 위 값을 비교 한 뒤 만약 leftHeap이 rightHeap보다 크다면 두 값을 교체해준다.  ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EA%B0%80%EC%9A%B4%EB%8D%B0%EB%A5%BC-%EB%A7%90%ED%95%B4%EC%9A%94/",
        "teaser": null
      },{
        "title": "[BOJ] 2109 순회강연 (Python3)",
        "excerpt":"문제  한 저명한 학자에게 n(0 ≤ n ≤ 10,000)개의 대학에서 강연 요청을 해 왔다. 각 대학에서는 d(1 ≤ d ≤ 10,000)일 안에 와서 강연을 해 주면 p(1 ≤ p ≤ 10,000)만큼의 강연료를 지불하겠다고 알려왔다. 각 대학에서 제시하는 d와 p값은 서로 다를 수도 있다. 이 학자는 이를 바탕으로, 가장 많은 돈을 벌 수 있도록 순회강연을 하려 한다. 강연의 특성상, 이 학자는 하루에 최대 한 곳에서만 강연을 할 수 있다.   예를 들어 네 대학에서 제시한 p값이 각각 50, 10, 20, 30이고, d값이 차례로 2, 1, 2, 1 이라고 하자. 이럴 때에는 첫째 날에 4번 대학에서 강연을 하고, 둘째 날에 1번 대학에서 강연을 하면 80만큼의 돈을 벌 수 있다.   입력  첫째 줄에 정수 n이 주어진다. 다음 n개의 줄에는 각 대학에서 제시한 p값과 d값이 주어진다.   출력  첫째 줄에 최대로 벌 수 있는 돈을 출력한다.   예제  1 2 3 4 5 6 7 8 9 10 11 12 예제 입력 1   7 20 1 2 1 10 3 100 2 8 2 5 20 50 10  예제 출력 1   185   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import heapq  n = int(input()) lecture = []  for i in range(n):     p,d = map(int, input().split())     lecture.append([p,d])  lecture.sort(key = lambda x : x[1])  total = []  for i in lecture:     heapq.heappush(total, i[0])     if len(total) &gt; i[1] :         heapq.heappop(total) print(sum(total))           1 2 3 4 5 6 7 8 9 7 20 1 2 1 10 3 100 2 8 2 5 20 50 10 185   문제풀이  기한이 지나지 않은 강의중 가장 돈을 많이 주는 강연순서대로 다녀야 최대로 많은 돈을 벌 수 있다. 따라서 먼저 0원보다는 1원이라도 버는게 더 총합액을 늘려주므로, 기한을 기준으로 오름차순 정렬해준다. 이후, 힙큐에 넣어가며 힙큐가 기한보다 많은 요소를 갖고있다면 heappop하여 가장 돈을 적게 버는 강연을 제거해주면 된다.  ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EC%88%9C%ED%9A%8C%EA%B0%95%EC%97%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 14235 크리스마스 선물 (Python3)",
        "excerpt":"문제  크리스마스에는 산타가 착한 아이들에게 선물을 나눠준다. 올해도 산타는 선물을 나눠주기 위해 많은 노력을 하고 있는데, 전세계를 돌아댕기며 착한 아이들에게 선물을 나눠줄 것이다. 하지만 산타의 썰매는 그렇게 크지 않기 때문에, 세계 곳곳에 거점들을 세워 그 곳을 방문하며 선물을 충전해 나갈 것이다. 또한, 착한 아이들을 만날 때마다 자신이 들고있는 가장 가치가 큰 선물 하나를 선물해 줄 것이다.   이제 산타가 선물을 나눠줄 것이다. 차례대로 방문한 아이들과 거점지의 정보들이 주어졌을 때, 아이들이 준 선물들의 가치들을 출력하시오. 만약 아이들에게 줄 선물이 없다면 -1을 출력하시오.첫 번째 줄에서는 아이들과 거점지를 방문한 횟수 n이 주어진다.(1≤n≤5,000)   다음 n줄에는 a가 들어오고, 그 다음 a개의 숫자가 들어온다. 이는 거점지에서 a개의 선물을 충전하는 것이고, 그 숫자들이 선물의 가치이다. 만약 a가 0이라면 거점지가 아닌 아이들을 만난 것이다. 선물의 가치는 100,000보다 작은 양의 정수이다.(1≤a≤100)   입력  첫 번째 줄에 N이 주어진다. (1 ≤ N ≤ 200,000)   이후 N개의 줄에 Si, Ti가 주어진다. (1 ≤ Si &lt; Ti ≤ 109)   출력  a가 0일 때마다, 아이들에게 준 선물의 가치를 출력하시오. 만약 줄 선물이 없다면 -1을 출력하라. 적어도 하나의 출력이 있음을 보장한다.   예제  1 2 3 4 5 6 7 8 9 10 11 12 13 예제 입력 1   5 0 2 3 2 0 0 0  예제 출력 1   -1 3 2 -1   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 n = int(input())  gift = []  for i in range(n):     location = list(map(int, input().split()))          if location == [0]:         if gift:             print(max(gift))             gift.remove(max(gift))         else:             print(-1)     else:         for loc in location[1:]:             gift.append(loc)             1 2 3 4 5 6 7 8 9 10 5 0 -1 2 3 2 0 3 0 2 0 -1   문제풀이   너무나 쉬운 문제였다. 근데 풀다가 우선순위 큐로 푸는걸 까먹음 근데 풀림 ㅎ  ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%81%AC%EB%A6%AC%EC%8A%A4%EB%A7%88%EC%8A%A4-%EC%84%A0%EB%AC%BC/",
        "teaser": null
      },{
        "title": "[BOJ] 1931 회의실 배정 (Python3)",
        "excerpt":"문제  한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.   입력  첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 2^31-1보다 작거나 같은 자연수 또는 0이다.   출력  첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 예제 입력 1  복사 11 1 4 3 5 0 6 5 7 3 8 5 9 6 10 8 11 8 12 2 13 12 14  예제 출력 1  복사 4   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 n = int(input()) timeTable = []  for _ in range(n):     n, m = map(int, input().split())     timeTable.append([n,m])      timeTable.sort(key = lambda x: (x[1], x[0]))  minTime = [0,0] count = 0  for time in timeTable:     if minTime[1] &lt;= time[0]:         count += 1         minTime = time      print(count)        1 2 3 4 5 6 7 8 9 10 11 12 13 11 1 4 3 5 0 6 5 7 3 8 5 9 6 10 8 11 8 12 2 13 12 14 4   이 문제는 정렬의 순서에 대해 잘 생각해보아야 풀 수 있는 문제이다.   먼저 회의가 끝나는 순서가 먼저 오름차순 정렬되어야 한다. 끝나는 시간이 빠를 수록 남은 회의를 더 많이 진행 할 수 있기 때문이다. 회의가 빨리 끝나는 순서대로 정렬되었다면, 다음은 회의가 빨리 시작해야한다. 따라서 끝나는 시간 정렬 다음에는 시작하는 시간을 오름차순으로 정렬해준다.   마지막으로 첫 시간부터 끝나는시간보다 시작하는 시간이 더 클때마다 회의의 개수를 카운팅 해주면 답을 구할 수 있다.  ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","Greedy"],
        "url": "/baekjoon/%ED%9A%8C%EC%9D%98%EC%8B%A4-%EB%B0%B0%EC%A0%95/",
        "teaser": null
      },{
        "title": "[BOJ] 11724 연결요소의 개수  (Python3)",
        "excerpt":"문제   title: “[BOJ] 16956 늑대와 양 (Python3)”   categories:      baekjoon  tags:      백준      파이썬      DFS      BFS  toc: true  toc_label: “On this page”  toc_sticky: true     문제  방향 없는 그래프가 주어졌을 때, 연결 요소 (Connected Component)의 개수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 정점의 개수 N과 간선의 개수 M이 주어진다. (1 ≤ N ≤ 1,000, 0 ≤ M ≤ N×(N-1)/2) 둘째 줄부터 M개의 줄에 간선의 양 끝점 u와 v가 주어진다. (1 ≤ u, v ≤ N, u ≠ v) 같은 간선은 한 번만 주어진다.   출력  첫째 줄에 연결 요소의 개수를 출력한다.   예제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 예제 입력 1   6 5 1 2 2 5 5 1 3 4 4 6 예제 출력 1   2  예제 입력 2  6 8 1 2 2 5 5 1 3 4 4 6 5 4 2 4 2 3  예제 출력 2   1  코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 from collections import deque  n, m = map(int, input().split()) graph = [[] for _ in range(n+1)]  q = deque() visited = [False] * (n+1)  count = 0  for i in range(m):     dotA, dotB = map(int, input().split())     graph[dotA].append(dotB)     graph[dotB].append(dotA)      def bfs(start):     if not visited[start]:                  q.append(start)         visited[start] = True                  while q:             node = q.popleft()             for i in graph[node]:                 if not visited[i]:                                    q.append(i)                     visited[i] = True          for i in range(1,n+1):     if not visited[i]:         bfs(i)         count+=1         if visited.count(False) == 1:             break print(count)   1 2 3 4 5 6 7 6 5 1 2 2 5 5 1 3 4 4 6 2   문제 풀이  맨 처음에는 연결 요소가 무슨말인지 몰라서 검색해봤다.   연결 요소는 노드에서 서로 연결되어있는 한 군집의 개수라고 봐도 되는데, 다른 연결요소의 노드는 연결되어있지 않기 때문에 bfs나 dfs를 실행해도 모든 노드에 방문할 수 없다. 따라서 연결요소의 수를 세기 위해서는 모든 노드에 방문할때까지 시작 위치를 바꿔가면서 그 수를 세야한다.   따라서 for문을 사용하여 시작위치를 바꿔가며 모든 노드에 방문처리가 될때까지 bfs를 실행하고, bfs가 실행될때마다 그 수를 세주었다.  ","categories": ["baekjoon"],
        "tags": ["백준","파이썬","DFS","BFS"],
        "url": "/baekjoon/%EC%97%B0%EA%B2%B0-%EC%9A%94%EC%86%8C%EC%9D%98-%EA%B0%9C%EC%88%98/",
        "teaser": null
      },{
        "title": "[BOJ] 17298 오큰수 (Python3)",
        "excerpt":"문제  크기가 N인 수열 A = A1, A2, …, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.   예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.   입력  첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, …, AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.   출력  총 N개의 수 NGE(1), NGE(2), …, NGE(N)을 공백으로 구분해 출력한다.   예제  1 2 3 4 5 6 7 8 9 10 11 예제 입력 1   4 3 5 2 7 예제 출력 1   5 7 7 -1  예제 입력 2   4 9 5 4 8 예제 출력 2   -1 8 8 -1   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 n = int(input()) numbers = list(map(int, input().split())) stack = [] answer = [-1] * n stack.append(0)  for i in range(len(numbers)):         while stack and numbers[stack[-1]] &lt; numbers[i]:             answer[stack.pop()] = numbers[i]         stack.append(i)       for i in answer:     print(i)   1 2 4 3 5 2 7   문제풀이  처음에는 이중 for문으로 풀었다가 시간초과가 떠서 스택을 이용해서 다시 풀었다.   먼저 주어진 숫자들을 배열에 넣어준 뒤, 순서대로 인덱스를 꺼내서 스택에 넣어준다. 스택에 값이 있다면  pop하여 그 인덱스에 위치한 값과 현재 i의 값을 비교해서 더 큰 값을 가질때, 이값이 바로 해당 i 인덱스의 오큰수 이므로 answer에 값을 추가해준다. 만약 스택이 비어있다면 아직 numbers의 첫 값이 아직 스택에 들어가지 않은것이므로 스택에 append 해준다.   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EC%98%A4%ED%81%B0%EC%88%98/",
        "teaser": null
      },{
        "title": "[BOJ] 7576 토마토 (Python3)",
        "excerpt":"문제  철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자 모양 상자의 칸에 하나씩 넣어서 창고에 보관한다.   창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토의 인접한 곳은 왼쪽, 오른쪽, 앞, 뒤 네 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지, 그 최소 일수를 알고 싶어 한다.   토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.   입력  첫 줄에는 상자의 크기를 나타내는 두 정수 M,N이 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M,N ≤ 1,000 이다. 둘째 줄부터는 하나의 상자에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 상자에 담긴 토마토의 정보가 주어진다. 하나의 줄에는 상자 가로줄에 들어있는 토마토의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다.   토마토가 하나 이상 있는 경우만 입력으로 주어진다.  출력  여러분은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.  예제  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 예제 입력 1   6 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1  예제 출력 1   8  예제 입력 2   6 4 0 -1 0 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1  예제 출력 2   -1  예제 입력 3   6 4 1 -1 0 0 0 0 0 -1 0 0 0 0 0 0 0 0 -1 0 0 0 0 0 -1 1  예제 출력 3   6   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from collections import deque  def dfs():     while q:         x,y = q.popleft()         for i in range(4):             nx = x + dx[i]             ny = y + dy[i]             if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; m and box[nx][ny] == 0:                 box[nx][ny] = box[x][y] + 1                 q.append([nx,ny])                  q = deque() dx = [1,-1,0,0] dy = [0,0,1,-1]  m,n = map(int, input().split()) box = []  for i in range(n):     boxLine = list(map(int, input().split()))     box.append(boxLine)  for i in range(n):     for j in range(m):         if box[i][j] == 1:             q.append([i,j])              isCant = False  if q == []:     print(0) else:     dfs()     for i in range(n):         for j in range(m):             if box[i][j] == 0:                 isCant = True     if isCant:         print(-1)     else:         print(int(max(map(max,box))-1))                 1 2 3 4 5 6 6 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 8   문제풀이  bfs하면 떠오르는 대표적인 문제 유형이라고 할 수 있다.  먼저 토마토의 위치를 받아 이차원 배열의 형태로 만들어주고 for문을 한번 돌려서 익은 토마토의 좌표를 받아서 큐에 넣어준다. 루프가 끝나면 큐에 넣어두었던 익은 토마토의 좌표를 하나씩 꺼내서 bfs를 사용해주는데, 상하좌우의 토마토에 위치에 토마토가 익는데까지 걸린 일 수를 표시해준다.   모든 노드에 방문하고 난 뒤 이 2차원 배열의 최댓값이 바로 모든 토마토가 익기까지의 걸린 날짜인데, 맨 처음 시작때의 익은 토마토가 0이 아닌 1로 표시되어 있기 때문에 2차원 배열의 최댓값에서 1을 빼주어야 한다.  ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%86%A0%EB%A7%88%ED%86%A0/",
        "teaser": null
      },{
        "title": "[Programmers] 기능개발 (Python3)",
        "excerpt":"문제 설명  프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.  또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.  먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.   제한사항  1 2 3 4 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 작업 진도는 100 미만의 자연수입니다. 작업 속도는 100 이하의 자연수입니다. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.   입출력 예  |progresses\t|speeds|\treturn|  |:—:|:—:|:—:|  |[93, 30, 55]\t|[1, 1, 1, 1, 1, 1]\t|[1, 3, 2]|   입출력 예 설명  입출력 예 #1  첫 번째 기능은 93% 완료되어 있고 하루에 1%씩 작업이 가능하므로 7일간 작업 후 배포가 가능합니다.  두 번째 기능은 30%가 완료되어 있고 하루에 30%씩 작업이 가능하므로 3일간 작업 후 배포가 가능합니다. 하지만 이전 첫 번째 기능이 아직 완성된 상태가 아니기 때문에 첫 번째 기능이 배포되는 7일째 배포됩니다.  세 번째 기능은 55%가 완료되어 있고 하루에 5%씩 작업이 가능하므로 9일간 작업 후 배포가 가능합니다.  따라서 7일째에 2개의 기능, 9일째에 1개의 기능이 배포됩니다.  입출력 예 #2  모든 기능이 하루에 1%씩 작업이 가능하므로, 작업이 끝나기까지 남은 일수는 각각 5일, 10일, 1일, 1일, 20일, 1일입니다. 어떤 기능이 먼저 완성되었더라도 앞에 있는 모든 기능이 완성되지 않으면 배포가 불가능합니다.  따라서 5일째에 1개의 기능, 10일째에 3개의 기능, 20일째에 2개의 기능이 배포됩니다.   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from collections import deque  def solution(progresses,speeds):     day = 0     count = 0     answer = []     while progresses:         if progresses[0] + (day * speeds[0]) &gt;= 100:             progresses.pop(0)             speeds.pop(0)             count+=1         else:             if count &gt; 0:                 answer.append(count)                 count = 0             day+=1     if count &gt; 0:             answer.append(count)                  print(answer)   문제풀이  처음에는 모든 기능을 하나씩 꺼내서 speeds와 꺼내 더한 뒤 계산하며 일일히 했는데,  그러다보니까 구현도 어렵고 복잡해져서, day만 늘려가며 한번에 더했다.   progress가 빌때까지 아래의 코드를 무한반복한다.             만약 progresses의 첫번째 기능이 100퍼센트 이상 개발되었다면,                 progresses의 첫번째 값을 pop()하고                 speeds의 첫번째 값을 pop()한다                  그리고 기능이 하나 개발 완료되었으므로 count +=1 해준다.               그렇지 않은경우                 만약 count가 0보다 크면,                       기능개발이 완료된 것이므로 answer 리스트에 count를 append해준다.                     count는 0으로 초기화 한다.        무한반복이 종료됐을때, count가 0보다 크다면               answer 리스트에 count를 append해준다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B8%B0%EB%8A%A5-%EA%B0%9C%EB%B0%9C/",
        "teaser": null
      },{
        "title": "우아한 테크 코스 1차 코딩테스트 후기",
        "excerpt":"2021.11.06  우아한 테크코스 1차 코딩테스트가 끝났다.        파이썬 안쓴지가 꽤 되서 다시 알고리즘 푼다고 몇 일 전부터 고생하면서 재활훈련?을 했는데,  역시 그동안 열심히 문제 푼게 헛수고는 아니었는지 생각보다 너무 너무 잘봤다.   7문제 나왔는데 7문제 다 풀었고 테스트케이스를 모두 통과하게 풀었다. 물론 시간 초과가 날 수도 있고 테스트케이스 외의 케이스에서  틀릴 수도 있지만, 생각보다 테스트 케이스에서 크게 예외가 없을 만한 문제들이라서 솔직한 맘으로는 7문제 다 맞았지 않았나 하는 생각이 든다.   문제 난이도는 아무래도 취업 코딩테스트가 아니다보니, 저번에 봤던 토스 코딩테스트에 비해서는 많이 쉬웠다. 미리 다른 후기들에서 봤던 딱 프로그래머스 레벨2, 백준 실버3 에서   어려운건 골드 3 정도???? 마지막 문제는 확실히 어려워서 당황했는데, 침착하게 패턴을 찾아서 풀었다. 삼각형을 이차원배열로 표현해서 시계 방향, 또는 120도 회전하는 문제였던걸로 기억하는데  아이패드에 그려가면서 천천히 마지막문제에만 4-50분 정도 썼다. 다 푸는데 꼼꼼히 풀었는데도 한 세시간 정도 걸린걸 보니 조금 실력이 부족해도 시간빨로 풀 수 있을것 같기도 하고???  어쨌든 최근에 스위프트만 해서 알고리즘이 가물가물 했는데 너무 잘 풀어서 나 스스로에게 감동했다. 물론 이거 7개 다맞아도 특정 개수 이상부터는 만점처리라서 당락에는 큰 의미가 없을 수도 있지만,  그래도 내 인생에서 이렇게 만족스럽게 시험을 마친 적이 별로 없는데, 이제 정말 내가 하고싶은거에 몰입해서 좋은 결과를 냈다는 생각에 뿌듯하다.   이제 19일날까지 결과를 기다릴 차례인데, 붙는다는 생각으로 자바를 공부하고 있어보려고 한다. 혹여나 떨어져도 내년에 다시 도전하면 되고, 코딩테스트 실력이 어느정도 된다는 자신감이 있으니  이번에 떨어져도 내년에는 붙을 수 있다는 마음가짐이 생겼다. 그리고 솔직히 이번에도 1차는 무난하게 붙을 것 같다는 자신감이 넘친다. 자소서도 만족스럽게 썼으니 제발…   붙는다면 내년엔 휴학이라는 큰 결정과 함께 치열한 내년이 되겠지…    마음의 준비는 이미 끝났으니,                  제발 붙게 해주세요 제발….   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%B0%EC%95%84%ED%95%9C-%ED%85%8C%ED%81%AC-%EC%BD%94%EC%8A%A4-1%EC%B0%A8-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8-%ED%9B%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 2812 크게 만들기 (Python3)",
        "excerpt":"문제  N자리 숫자가 주어졌을 때, 여기서 숫자 K개를 지워서 얻을 수 있는 가장 큰 수를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N과 K가 주어진다. (1 ≤ K &lt; N ≤ 500,000)   둘째 줄에 N자리 숫자가 주어진다. 이 수는 0으로 시작하지 않는다.   출력  입력으로 주어진 숫자에서 K개를 지웠을 때 얻을 수 있는 가장 큰 수를 출력한다.   예제 입력 1        4 2         1924   예제 출력 1          94   예제 입력 2          7 3         1231234   예제 출력 2        3234   예제 입력 3         10 4          4177252841   예제 출력 3          775841   코드   1 2 3 4 5 6 7 8 9 10 11 12 n, k = map(int, input().split()) numberList = list(input()) stack = [] answer = [] K = k for num in numberList:     while stack and stack[-1] &lt; num and k &gt;0:         stack.pop()         k -= 1     stack.append(num)          print(''.join(stack[:n-K]))   1 2 3 10 4 9876543210 987654   문제 풀이   크기를 비교해서 처리하는 문제이므로 스택을 사용해서 푼다.   1) N자리 숫자를 리스트에 넣은 뒤 하나씩 for문으로 불러와서 stack[-1]이 num보다 작으면 stack.pop()해준다. 숫자를 하나 제거했으므로 제거해야할 숫자의 개수인 k를 -1 해주어야 한다.   2) 만약 stack이 비어있으면 해당 숫자를 append()해주어 stack을 채워준다.   두가지를 반복하다가 만약 k가 0이되면 삭제할 수 있는 횟수를 모두 소진한 것 이므로, 남은 숫자를 모두 stack에 넣어준뒤 n-K만큼 잘라 출력해주면 된다.   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%81%AC%EA%B2%8C-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 2493 탑 (Python3)",
        "excerpt":"문제  KOI 통신연구소는 레이저를 이용한 새로운 비밀 통신 시스템 개발을 위한 실험을 하고 있다. 실험을 위하여 일직선 위에 N개의 높이가 서로 다른 탑을 수평 직선의 왼쪽부터 오른쪽 방향으로 차례로 세우고, 각 탑의 꼭대기에 레이저 송신기를 설치하였다. 모든 탑의 레이저 송신기는 레이저 신호를 지표면과 평행하게 수평 직선의 왼쪽 방향으로 발사하고, 탑의 기둥 모두에는 레이저 신호를 수신하는 장치가 설치되어 있다. 하나의 탑에서 발사된 레이저 신호는 가장 먼저 만나는 단 하나의 탑에서만 수신이 가능하다.   예를 들어 높이가 6, 9, 5, 7, 4인 다섯 개의 탑이 수평 직선에 일렬로 서 있고, 모든 탑에서는 주어진 탑 순서의 반대 방향(왼쪽 방향)으로 동시에 레이저 신호를 발사한다고 하자. 그러면, 높이가 4인 다섯 번째 탑에서 발사한 레이저 신호는 높이가 7인 네 번째 탑이 수신을 하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신을 한다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신을 하지 못한다.   탑들의 개수 N과 탑들의 높이가 주어질 때, 각각의 탑에서 발사한 레이저 신호를 어느 탑에서 수신하는지를 알아내는 프로그램을 작성하라.   입력  첫째 줄에 탑의 수를 나타내는 정수 N이 주어진다. N은 1 이상 500,000 이하이다. 둘째 줄에는 N개의 탑들의 높이가 직선상에 놓인 순서대로 하나의 빈칸을 사이에 두고 주어진다. 탑들의 높이는 1 이상 100,000,000 이하의 정수이다.   출력  첫째 줄에 주어진 탑들의 순서대로 각각의 탑들에서 발사한 레이저 신호를 수신한 탑들의 번호를 하나의 빈칸을 사이에 두고 출력한다. 만약 레이저 신호를 수신하는 탑이 존재하지 않으면 0을 출력한다.   예제  1 2 3 4 5 6 예제 입력 1   5 6 9 5 7 4  예제 출력 1   0 0 2 2 4   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 n = int(input()) tower = list(map(int, input().split()))  stack = []  answer = []  for index, t in enumerate(tower):     while stack:         if stack[-1][1] &lt; t:             stack.pop()         else:             answer.append(stack[-1][0])             stack.append([index+1, t])             break     else:         answer.append(0)         stack.append([index+1, t])  for i in answer:     print(i, end = ' ')            1 2 3 5 6 9 5 7 4 0 0 2 2 4    문제풀이   이렇게 순서대로 들어오는 숫자의 크기를 비교하여 처리하는 문제를 풀 때는 보통 스택을 사용한다.   이 문제 같은경우는 탑의 크기를 순서대로 받아서 앞의 탑이 뒤의 탑보다 높다면 신호를 수신 할 수 있는 것이므로, 스택을 하나 만들어서 탑의 높이와 인덱스를 앞에서부터 넣어준다. 탑의 인덱스는 0이아니라 1부터 시작하므로 인덱스 + 1을 해주어야 한다.   스택은 비어있는 상태에서 부터 시작한다. 이제, 순서대로 탑의 높이와 인덱스를 [인덱스 + 1, 탑의높이]로 하나씩 넣어주는데, 스택이 비어있다면 수신할 수 있는 탑이 없는 것 이므로 answer 리스트에 0을 넣어주고 스택에 [인덱스 + 1, 탑의높이]를 넣어준다.   다음 탑의 높이가 스택의 마지막 탑의 높이보다 높을 경우, 마찬가지로 수신가능한 탑이 없는 것이므로 스택을 pop해주고 해당 탑의 [인덱스 +1, 탑의 높이]를 넣어준다.   다음 탑의 높이가 스택의 마지막 탑의 높이보다 낮을 경우, 수신가능한 탑이 있는 것이므로 스택의 마지막 인덱스를 answer리스트에 넣어주고, 스택에 해당 탑의 [인덱스 +1, 탑의 높이]를 넣어준다.   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%ED%83%91/",
        "teaser": null
      },{
        "title": "[BOJ] 11728 배열합치기 (Python3)",
        "excerpt":"문제  정렬되어있는 두 배열 A와 B가 주어진다. 두 배열을 합친 다음 정렬해서 출력하는 프로그램을 작성하시오.   입력  첫째 줄에 배열 A의 크기 N, 배열 B의 크기 M이 주어진다. (1 ≤ N, M ≤ 1,000,000)   둘째 줄에는 배열 A의 내용이, 셋째 줄에는 배열 B의 내용이 주어진다. 배열에 들어있는 수는 절댓값이 109보다 작거나 같은 정수이다.   출력  첫째 줄에 두 배열을 합친 후 정렬한 결과를 출력한다.   예제  예제 입력 1    2 2         3 5       2 9   예제 출력 1    2 3 5 9   예제 입력 2    2 1        4 7        1   예제 출력 2    1 4 7   예제 입력 3    4 3       2 3 5 9        1 4 7   예제 출력 3    1 2 3 4 5 7 9   코드   1 2 3 4 5 6 7 8 9 10 11 12 n,m = map(int, input().split())   aList = list(map(int, input().split())) bList = list(map(int, input().split()))  sumList = aList + bList  sumList.sort()  for i in sumList:     print(i, end = ' ')   1 2 3 4 2 2 3 5 2 9 2359   1 sumList   1 [2, 3, 5, 9]   1   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EB%B0%B0%EC%97%B4-%ED%95%A9%EC%B9%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 1806 부분합 (Python3)",
        "excerpt":"문제  10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.   입력  첫째 줄에 N (10 ≤ N &lt; 100,000)과 S (0 &lt; S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다.         수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.   출력  첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.   예제  예제 입력 1         10 15          5 1 3 5 10 7 4 9 2 8   예제 출력 1             2   코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import sys  n, s = map(int, input().split()) numList = list(map(int, input().split())) answer = sys.maxsize start, end = 0,0 sumNum = 0  while True:     if sumNum &gt;= s:         answer = min(answer, end - start)         sumNum -= numList[start]         start += 1                       else:         if end == n:             break                      else:             sumNum += numList[end]             end+=1              if answer == sys.maxsize:     print(0) else:     print(answer)   1 2 3 10 15 5 1 3 5 10 7 4 9 2 8       2   문제 풀이  처음에는 이중 for문으로 풀었는데, 역시 골드난이도부터 왠만한 문제는 그냥 이중 for문 사용금지라고 생각해도 될정도로 무조건 이중 for문을 쓰면 시간초과가 난다.   그래서 이렇게 부분합이나 배열안에서 여러개의 부분집합을 구하는 유형의 문제의 경우는 투포인터를 사용하면 시간초과 당하지 않고 풀 수 있다.   투포인터는 말그대로 두개의 포인터, 보통 양쪽에서 포인터를 좁혀나가면 right, left, 나란하게 출발하면 start, end의 포인터를 사용해서 두 수를 조합하여 답을 구해낸다.   이 문제는 연속된 수의 부분합을 구하기 때문에, 포인터가 나란하게 start, end가 0을 가르키면서 시작한다.        sumNum에 해당값을 더해가면서 만약 sumNum이 s보다 크면 start 포인터를 한칸 옮겨 다음 숫자의 부분합을 구해가고, sumNum이 s보다 작다면 end포인터를 한칸 더 옮겨 해당 수의 범위를 늘려주며 찾는다.   sumNum이 s보다 클때의 end-start를 이전 answer와 min함수에 넣어 가장 최소인 end-start값을 찾아 반환하고,   만약 answer에 주었던 초깃값 sys.maxsize와 같다면 0을 출력하면 된다.   1   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/%EB%B6%80%EB%B6%84%ED%95%A9/",
        "teaser": null
      },{
        "title": "[Java] assertj 설정 방법",
        "excerpt":"문제  테스트코드를 작성해보려고 따라하는데, assertThat()이 안되서 한참을 찾았다.   처음에는 assertThat이 Junit 자체 메소드인줄 알고 Junit 버젼이 달라서 그런가했는데, assertJ라는 다른 라이브러리였다. Junit과 함께 편리하게 사용하게 해주는 라이브러리로, 테스트코드 작성을 훨씬 편리하게 도와준다.   이러한 assertJ를 사용하려면 build.gradle에서 라이브러리 의존성에 추가해주어야한다,   ## 해결 방법   build.gradle 파일에 있는 ‘dependency’ 부분에 아래와 같은 코드를 추가해준다.   1  testImplementation \"org.assertj:assertj-core:3.20.2\"   알게된 점  다른 언어들과 다르게 자바는 라이브러리의 의존성도 관리를 해주어야 한다는 걸 알았다.   효율적인 프로그램을 위해 의존성에 추가해준 코드에 따라 어떤 시점에 이 라이브러리를 호출 할지를 명시해주어야  그 상황에 라이브러리를 실행시키고 이 라이브러리를 결과물에 포함할지 안할지 정해서 프로그램이 동작한다.   의존성에 추가할 수 있는 코드는 아래의 4개이다.           Implementation  내부적으로만 사용되고 사용자에게는 의존성을 노출시키지 않게 선언한다.  의존 라이브러리를 수정해도 본 모듈까지만 재빌드한다.            compileOnly   컴파일 타임에 필요한 라이브러리  컴파일 시에만 빌드하고 빌드 결과물에는 포함하지 않는다.            runtimeOnly  런타임 시점에만 필요한 라이브러리       4.testImplementation  테스트할 때에만 사용된다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-assertj-%EC%84%A4%EC%A0%95%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "[Java] 플레이그라운드 with TDD, 클린코드 - AssertJ (다시)",
        "excerpt":"다시…  원래는 자바를 공부하면서 나쁜 습관들이 들까봐 애초에 클린 코드로 버릇을 들으려고 강의를 찾다가       플레이 그라운드에 있는 이 강의가 유용하다고 해서 봐서 결제해서 듣고 있었는데, 앱개발 한다고 결제해놓은.         강의도 내팽겨 치고 열심히 개발을 하고 왔다. 근데 우테코 붙고 자바 공부도 할겸, 프리코스 미리 예습하려고 찾아보는데  이 강의를 프리코스에서 사용하고 있었고, 이 강의 강사분이 바로 우테코 캡틴분이었다… 헐;;   그래서 뭐 나름 결제도 해놨겠다, 프리코스도 이 내용이겠다. 다시 신나게 자바 좀 공부해보려 한다.         다시 할라니까 기억이 가물가물해서 다시 처음부터!!   단위테스트  초반 부분은 좀 기억이 나서 한번 훑고만가려 한다.   자바는 절차지향 언어이기 때문에, 대부분의 기능을 클래스로 구현해놓고 그 클래스들을 메인 메서드에서 구현하는 방식으로 동작한다.  메인 메서드는 프로그램을 시작할 뿐만 아니라 구현한 프로그램을 테스트할때 중간중간 돌려보면서 사용되는데, 그냥 간단하게 내가 맨날  자바를 사용할 때 중간중간 지금까지 한게 맞나 테스트겸 빌드 해보는거랑 같다.   하지만 이러한 메인 함수에서 하는 테스트는 몇가지 문제가 있다.           프로덕션 코드와 테스트 코드가 하나에 존재한다.   이건 앱개발 할때도 느꼈던건데, 개발 초반 부분에는 그냥 메인함수를 돌려보면 되지만, 나중에 규모가 커지면 그 기능 하나를 테스트 하기  위해서 전체를 돌려야 하니까 번거롭게 로그인도 해야하고 그 기능이 있는 부분까지 도달하며 테스트해야해서 시간도 많이 들 뿐만 아니라,   그 기능만이 확실히 작동하는지 독립적으로 살펴볼 수가 없다.            테스트 코드가 실제 서비스에 같이 배포된다.  이것도 마찬가지로 앱개발할때 테스트로 넣어둔 기능을 깜빡하고 실제 사용자들 버젼에 배포한적이 여러번 있다.            main method 하나에서 여러 개의 기능을 테스트 하기 때문에 복잡도가 증가한다.  1번에서 느꼈던 내용에 포함된 내용인것 같다. 여러개가 테스트 되다 보니까 헷갈린다.            method 이름을 통해서 어떤 부분을 테스트 하는 것인지 알기가 힘들다.  main 함수로 테스트를 하면 협업간에 이게 테스트 코드인지 아닌지 모르니까 헷갈릴 것 같다.            테스트 결과를 사람이 수동으로 확인해야한다.  내가 어떤 기능을 테스트하려고 불필요한 로그인을 하고 버튼을 누르고 했던 내용을 말한다.       이렇게 main method를 사용한 테스트를 해결하기 위해 등장한게 바로 JUnit이다.   JUnit  JUnit은 단위 테스트 프레임워크로, System.out으로 번거롭게 테스트 케이스를 확인하지 않도록 도와주는 도구이다.  프로그램 테스트 시 걸리는 시간도 관리 할 수 있도록 해주며, 오픈소스 형태로 대부분의 IDE에 포함되어있다.  개발을 진행하면서 어느정도의 개발이 진행되면 반드시 프로그램에 대한 단위테스트를 진행해주어야 한다.   AssertJ  AssertJ는 Junit과 마찬가지로 테스트를 위한 라이브러리로, Junit과 함께 사용하면 테스트 코드를  훨씬 가독성있고 효율적으로 작성할 수 있도록 도와준다.   예제   1 2 3 4 5 6 7 class aboutStringTest {     @Test     void replace(){         String actual = \"abc\".replace(\"b\", \"d\");         assertThat(actual).isEqualTo(\"adc\");     } }  위 코드는 assertJ에서 제공하는 assertThat() 메소드를 사용해서 테스트 해본 예제이다.        actual 메소드가 isEqualTo(“adc”), 즉 adc 와 같은 값이 출력되는지를 테스트하게 된다.   만약 assertJ가 아닌 Junit 으로 위와 동일한 테스트를 진행한다면,   1 2 3 4 5 6 7 class aboutStringTest2 {     @Test     void replace(){         String actual = \"abc\".replace(\"b\", \"d\");         assertEquals(\"adc\", actual);     } }  위와 같은 코드가 될 것이다. Junit의 경우, assertEquals() 메소드를 사용해서 비교하게 되는데, 첫번쨰 파라미터에는 기댓값인 adc가 들어오고 두 번째 파라미터에는 우리가 테스트 할 값인 actual이 들어온다.       이렇게 봐서는 딱히 assertJ를 사용해야할 이점이 눈에 띄게 보이지 않는다. 하지만 테스트 조건을 늘리게 된다면,      assertJ의 경우   1 2 3 4 5 6 7 8 9 10 class aboutStringTest {     @Test     void replace(){         String actual = \"abc\".replace(\"b\", \"d\");         assertThat(actual).isEqualTo(\"adc\")                 .startsWith(\"a\")                 .contains(\"d\");     } }       Junit의 경우   1 2 3 4 5 6 7 8 9 class aboutStringTest2 {     @Test     void replace(){         String actual = \"abc\".replace(\"b\", \"d\");         assertEquals(\"adc\", actual);         assertTrue(actual.startsWith(\"a\"));         assertTrue(actual.contains(\"d\"));     } }   두 코드를 비교해보면, assertJ가 좀 더 많은 조건을 추가하기 쉽고 구어체에 가까운 느낌이라  헷갈리지 않고 메서드 체이닝을 하기 유리하다.   그럼 assrtJ를 사용하기 위해서 기본적인 몇가지 메소드들을 알아보자.   Test Fail Message   JUnit5 에서는 마지막 인자값에 as()를 통해 테스트 실패 메시지를 명시해주어 테스트가 실패했을때 출력되는 메시지를 만들 수 있다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class aboutStringTest {     @Test     void split(){         String[] actual = \"1,2\".split(\",\");          assertThat(actual).as(\"acutal의 값\").contains(\"1\");      }  }  &gt;&gt;&gt; java.lang.AssertionError: [acutal의 값]  Expecting:  &lt;[\"1\", \"2\"]&gt; to contain:  &lt;[\"3\"]&gt; but could not find:  &lt;[\"3\"]&gt;   이렇게 as() 메서드를 사용해주면, 이 테스트에 대한 설명을 앞에 출력해준다. as()메서드는 무조건  assertion 전에 사용해주어야한다.   Test Filtering Assertions  특정 filter를 자바 람다식을 이용하여 표현할 수 있는 유용한 기능이다.   1 2 3 4 5 6 7 8 9 10 11  class aboutStringTest {     @Test     void split(){         String[] actual = \"lee,kim,park,\".split(\",\");          assertThat(actual).filteredOn(x -&gt; x.contains(\"k\")).containsOnly(\"kim\",\"park\");      }  }   위 코드를 보면 filteredOn안에 람다식을 넣어서 k가 포함된 값만을 추출해준뒤, containsOnly를 통해 올바르게 k가 포함된 값인 kim과 park이 결과값으로 나왔는지 확인해준다.  이처럼 filteredOn을 사용하면 특정 케이스들만을 골라서 테스트 해볼 수 있다.   Exception 처리 테스트  예외처리에 대해서는 먼저 throws에 대해 알아야 한다.   보통 자바에서는 try ~ catch 문을 사용해서 try에서 에러를 감지해서 cahtch 안에서 해당 오류를 처리한다.         이렇게 예외를 처리하는 방법에는 한가지 방법이 더 있는데, 바로 throws를 사용하는 것이다.         try ~ catch는 에러가 발생했을떄 바로바로 자신을 예외처리했다면, throws는 메소드 단위로 이 메소드를 사용하는 곳으로 책임을 전가한다.       한번 다음 예제를 보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import java.io.IOException;  public class Example{     public static void main(String[] args){                  byte[] Recive = new byte[128];                  Read(Recive);     }          public static void Read(byte[] buffer) throws IOException     {         System.in.read(buffer);     } }   이렇게 작성하고 코드를 실행시키면, Read 메서드를 정의하는 부분에서 에러가 발생하지 않고, Read를 사용한 main 메서드에서 에러가 발생한다.        메서드를 사용하는 곳에서 예외를 처리하라고 throws를 사용해서 표기해주었기 떄문이다.   따라서 아래의 코드처럼,   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import java.io.IOException;  public class Example{     public static void main(String[] args){          byte[] Recive = new byte[128];         try{             Read(Recive);         } catch (IOException e){          }      }      public static void Read(byte[] buffer) throws IOException     {         System.in.read(buffer);     } }  이렇게 main 메서드에서 try ~ catch를 사용해줌으로써 예외를 처리해줄 수 있다.   또 throw라는 예약어를 사용해서 강제로 오류를 발생시킬 수 도 있는데, 아래의 코드처럼 사용하면 된다.  1 2 3 4 5 6 7 8 public class Example{     public static void main(String[] args){                 throw new Exception();              }  }  이렇게 하면 throw new Exception 위치에서는 Exception()이라는 오류가 발생한다.         마찬가지로 try ~ catch를 사용해 예외처리 할 수 있다.  1 2 3 4 5 6 7 8 9 10 11 12 import java.io.IOException;  public class Example{     public static void main(String[] args){         try{             throw new Exception();         }catch (Exception e){          }     }  }   그럼 이제 테스트코드에서의 예외처리에 대해서 알아보자.   assertJ는 가독성있는 코드를 위해 assertThatThrownBy()라는 메서드를 제공한다.  assertThat을 사용해서 예외처리를 하려면,  1 2 3 4 5 6     @Test     public void exception(){         Throwable thrown = catchThrowable(()-&gt; {throw new Exception(\"Error\");});          assertThat(thrown).isInstanceOf(Exception.class).hasMessageContaining(\"Error\");     }  이렇게 thrown과 같은 객체를 만들어주어야 하지만, assertThatThrownBy()를 사용하면  1 2 3 4 5 6 7 8 9 class aboutStringTest {     @Test     public void exception(){        assertThatThrownBy(()-&gt;{throw new Exception(\"Error\");})                .isInstanceOf(Exception.class)                .hasMessageContaining(\"Error\");      } }  이처럼 가독성 있는 코드를 짤 수 있다.   String 클래스에 대한 학습 테스트  요구사항 1     “1,2”을 ,로 split 했을 때 1과 2로 잘 분리되는지 확인하는 학습 테스트를 구현한다.   “1”을 ,로 split 했을 때 1만을 포함하는 배열이 반환되는지에 대한 학습 테스트를 구현한다.   힌트     배열로 반환하는 값의 경우 assertj의 contains()를 활용해 반환 값이 맞는지 검증한다.   배열로 반환하는 값의 경우 assertj의 containsExactly()를 활용해 반환 값이 맞는지 검증한다.   1 2 3 4 5 6 7 8 9 10 11 12 class aboutStringTest {     @Test     void split(){         String[] actual = \"1,2\".split(\",\");         String[] actual2 = \"1\".split(\",\");          assertThat(actual).contains(\"1\",\"2\");         assertThat(actual2).contains(\"1\");     }  }    요구사항 2   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import org.junit.jupiter.api.Test;  import static org.junit.jupiter.api.Assertions.*; import static org.assertj.core.api.Assertions.*;  class aboutStringTest {     @Test     void split(){         String actual = \"(1,2)\".substring(1,4);          assertThat(actual).isEqualTo(\"1,2\");      }  }    요구사항 3     “abc” 값이 주어졌을 때 String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져오는 학습 테스트를 구현한다.   String의 charAt() 메소드를 활용해 특정 위치의 문자를 가져올 때 위치 값을 벗어나면 StringIndexOutOfBoundsException이 발생하는 부분에 대한 학습 테스트를 구현한다.   JUnit의 @DisplayName을 활용해 테스트 메소드의 의도를 드러낸다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class aboutStringTest {     @Test     @DisplayName(\"charAt()이 특정 문자의 위치를 정확히 가져오는지 확인하는 코드\")     public void exception(){        String actual = \"abc\";         assertThat(actual.charAt(0)).isEqualTo('a');        assertThat(actual.charAt(1)).isEqualTo('b');        assertThat(actual.charAt(2)).isEqualTo('c');         assertThatExceptionOfType(IndexOutOfBoundsException.class)                .isThrownBy(()-&gt; {                    char val = actual.charAt(3);                    throw new Exception(\"범위초과\");                 }).withMessageContaining(\"String\");     } }    Set Collection에 대한 학습 테스트      다음과 같은 Set 데이터가 주어졌을 때 요구사항을 만족해야 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class SetTest {     private Set&lt;Integer&gt; numbers;      @BeforeEach     void setUp() {         numbers = new HashSet&lt;&gt;();         numbers.add(1);         numbers.add(1);         numbers.add(2);         numbers.add(3);     }          // Test Case 구현 }   요구사항 1     Set의 size() 메소드를 활용해 Set의 크기를 확인하는 학습테스트를 구현한다.   1 2 3 4 5 6   @Test     @DisplayName(\"Set의 사이즈 확인\")     void size(){         int size = numbers.size();         assertThat(size).isEqualTo(3);     }   요구사항 2     Set의 contains() 메소드를 활용해 1, 2, 3의 값이 존재하는지를 확인하는 학습테스트를 구현하려한다.   구현하고 보니 다음과 같이 중복 코드가 계속해서 발생한다.   JUnit의 ParameterizedTest를 활용해 중복 코드를 제거해 본다.     1 2 3 4 5 6 7  @ParameterizedTest   @ValueSource(ints = {1,2,3})   @DisplayName(\"Set에 해당 요소가 존재하는지 확인\")    void contains(int input){       assertTrue(numbers.contains(input));   }           요구사항 3     요구사항 2는 contains 메소드 결과 값이 true인 경우만 테스트 가능하다. 입력 값에 따라 결과 값이 다른 경우에 대한 테스트도 가능하도록 구현한다.   예를 들어 1, 2, 3 값은 contains 메소드 실행결과 true, 4, 5 값을 넣으면 false 가 반환되는 테스트를 하나의 Test Case로 구현한다.     1 2 3 4 5 6 7   @ParameterizedTest   @CsvSource(value = {\"1: true\", \"2: true\", \"3 : true\", \"4:false\",\"5:false\"}, delimiter = ':')   @DisplayName(\"입력 값에 따라 결과 값이 다른 경우의 테스트\")   void diffrentReturn(int input, boolean expected){       assertThat(numbers.contains(input)).isEqualTo(expected);    }          ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%ED%94%8C%EB%A0%88%EC%9D%B4%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-with-TDD,-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-AssertJ-(%EB%8B%A4%EC%8B%9C)/",
        "teaser": null
      },{
        "title": "[Java] 플레이그라운드 with TDD, 클린코드 - 문자열 계산기",
        "excerpt":"요구사항     사용자가 입력한 문자열 값에 따라 사칙연산을 수행할 수 있는 계산기를 구현해야 한다.   문자열 계산기는 사칙연산의 계산 우선순위가 아닌 입력 값에 따라 계산 순서가 결정된다. 즉, 수학에서는 곱셈, 나눗셈이 덧셈, 뺄셈 보다 먼저 계산해야 하지만 이를 무시한다.   예를 들어 “2 + 3 * 4 / 2”와 같은 문자열을 입력할 경우 2 + 3 * 4 / 2 실행 결과인 10을 출력해야 한다.   구현  StringCalculator를 객체로 만들어서 안에서 기능을 처리하도록 한다.   구현해야할 기능을 간단하게 정리해보면,      계산기에 입력된 문자열을 받아 공백을 기준으로 나눠서 배열로 반환해준다.   String을 Int형으로 바꿔준다.   사칙연산 연산 후 결과 값을 반환해준다.   들어온 문자를 순서대로 계산해준다.   들어온 문자열이 공백인지 아닌지 확인해준다.   계산 결과를 반환해준다.   기능 1번  1 2 3 public String[] StringToArray(String str) {         return str.split(\" \");     }  split(“ “)을 사용하면 “ “의 공백을 기준으로 한칸 씩 띄워서 배열의 형태로 반환해준다.   기능 2번  1 2 3 public int toInt(String str) {         return Integer.parseInt(str);     }  integer.parseInt() 메서드는 들어오는 String값이 숫자라면 Int로 반환해준다.   기능 3번  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public int calculate(int firstValue, char operator, int secondValue) {         if (operator == '+') {             return add(firstValue, secondValue);         }         if (operator == '-') {             return subtract(firstValue, secondValue);         }         if (operator == '/') {             return divide(firstValue, secondValue);         }         if (operator == '*') {             return multiply(firstValue, secondValue);         }         throw new RuntimeException();     }      public int add(int a, int b) {         return a + b;     }      public int subtract(int a, int b) {         return a - b;     }      public int divide(int a, int b) {         try {             return a / b;         } catch (Exception e) {             System.out.println(\"0으로 나눌 수 없습니다.\");         }         return 0;     }      public int multiply(int a, int b) {         return a * b;     }  기능을 최대한 나누기 위해서 calculate 메소드 안에 있는 연산들을 따로따로 메서드로 구현했다.        다른 연산들은 예외가 없지만 devide의 경우에는 0으로 나누었을 때 발생하는 예외를 따로 처리 해줘야 하기 때문에, 단순하게 바로 a/b를 리턴할 수 없기 때문에 예외처리까지한 메서드로 처리해주었다.   기능 4번  1 2 3 4 5 6 7 8 public int calculateSeparateString(String[] str) {         int result = toInt(str[0]);          for (int i = 0; i &lt; str.length - 2; i += 2) {             result = calculate(result, str[i + 1].charAt(0), toInt(str[i + 2]));         }         return result;     }  하나씩의 원소로 분리되어 배열로 반환된 문자열을 순서대로 두개씩 계산하는 기능이다.          순서에 상관없이 바로 연산해야 하므로, for 문을 사용해서 문자열의 첫번째 값부터 시작해 연산자에 따라 연산을 달리해가면서  값을 result에 계산해간다.   기능 5번  1 2 3 4 5 public boolean isBlank(String input) {         if (input.equals(\" \") || input == null)             return true;         return false;     }  혹여나 들어오는 값이 “ “와 같은 공백이거나 null 값일 때의 예외 처리를 위해 isBlank라는 메서드를 통해서 연산전에 한번 체크해주도록 한다.   기능 6번  1 2 3 4 5  public int makeResult(String input) {         if (isBlank(input))             throw new RuntimeException();         return calculateSeparateString(StringToArray(input));     }  최종적으로, 계산기에 문자열을 보내면 위의 메서드들을 통해서 바로 결과값을 반환하는 기능을 구현한다.   테스트 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class StringCalculatorTest {     StringCalculator stringCalculator;      @BeforeEach     public void setUp(){         stringCalculator = new StringCalculator();     }      @Test     public void stringToArrayTest() {         String actual = \"1 + 3\";         assertThat(stringCalculator.StringToArray(actual))                 .contains(String.valueOf('1'))                 .contains(String.valueOf('+'))                 .contains(String.valueOf('3'));     }      @Test     public void makeResultTest() {         assertEquals(4,                 stringCalculator.makeResult(\"1 + 3\"));     }      @Test     public void isBlankTest(){         assertEquals(true, stringCalculator.isBlank(\" \"));     }     원래 같았다면 따로 main함수를 만들어서 기능이 제대로 동작하는지 빌드해가면서 했겠지만, 이번에는 기능만 구현하고 모든 테스트를  테스트 코드에서 동작시켰다.   이렇게 하니까 확실히 프로그램 자체가 테스트 코드로 더러워지는 일도 없고, 만약 더 큰 프로젝트라도 일일히 main함수를 돌려가지 않으면서 제대로 코드가 짜여지고 있는지 확인 할 수 있겠다라는 생각이 들었다.   그리고 무엇보다 기댓값이 어떤거였는지 헷갈리지도 않고 한번에 테스트 결과를 확인 할 수 있으니 무척 편리했다.   맨처음 배울때는 왜 굳이 귀찮게 테스트코드를 따로 작성하는지 몰랐는데 이제는 왜 테스트 코드 작성이 중요한지 알 수 있게되었다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%ED%94%8C%EB%A0%88%EC%9D%B4%EA%B7%B8%EB%9D%BC%EC%9A%B4%EB%93%9C-with-TDD,-%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B3%84%EC%82%B0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] n^2 배열자르기",
        "excerpt":"문제 설명   정수 n, left, right가 주어집니다. 다음 과정을 거쳐서 1차원 배열을 만들고자 합니다.     n행 n열 크기의 비어있는 2차원 배열을 만듭니다.   i = 1, 2, 3, …, n에 대해서, 다음 과정을 반복합니다.   1행 1열부터 i행 i열까지의 영역 내의 모든 빈 칸을 숫자 i로 채웁니다.            1행, 2행, …, n행을 잘라내어 모두 이어붙인 새로운 1차원 배열을 만듭니다.           새로운 1차원 배열을 arr이라 할 때, arr[left], arr[left+1], …, arr[right]만 남기고 나머지는 지웁니다.   정수 n, left, right가 매개변수로 주어집니다. 주어진 과정대로 만들어진 1차원 배열을 return 하도록 solution 함수를 완성해주세요.   제한사항     1 ≤ n ≤ 107   0 ≤ left ≤ right &lt; n2   right - left &lt; 105   입출력 예  |n\t|left|\tright|\tresult|  |—|—|—|—|  |3\t|2|\t5|\t[3,2,2,3]|  |4|\t7|\t14|\t[4,3,3,3,4,4,4,4]|   1 2 3 4 5 6 def solution(n, left, right):     answer = []      for i in range(left, right+1):         answer.append(max(divmod(i, n)) + 1)     return answer   문제풀이  맨처음에는 단순하게 이차원배열로 이중 for문으로 하나하나 방문하면서 해당 행,열에 맞는 값을 넣어 주었는데, 이러니까 자꾸 시간초과가 떠서 무조건 for문 하나로 풀려고 규칙을 찾아내서 풀었다.   위와 같은 방법으로 행렬을 채우게 되면, 행의 값과 열의 값중에 더 큰 값을 갖는 값 + 1 이 해당  위치의 값이므로, 이차원배열을 divmod()로 몫과 나머지로 받아 그 중 더 큰 값에 +1 을 해서 행렬에 넣어주면된다.   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/n-2-%EB%B0%B0%EC%97%B4%EC%9E%90%EB%A5%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Java] 우테코 프리코스 1주차 - 숫자야구 (1)",
        "excerpt":"시작하며…  드디어 프리코스 1주차가 시작됐다. 걱정도 되면서 재밌을 것 같다는 생각에 몹시 설렌다!        취준을 하면서 즐거울 수 있는건 정말 개발자를 꿈꾸는 사람들의 특권인 것 같다. 열심히 준비해서 붙은 1차를 헛되이 하지 않도록  무조건 최종에 붙자. 불합을 의식하지 않고 이 과정을 즐거워하다 보면 어느새 합격해 있을 것이란 생각이 든다.   첫 미션은 어릴때 누구나 한번 쯤은 해봤을 숫자야구 게임이다. 기능적으로 보면 어렵지 않은 프로젝트라 구현 자체는   전혀 어려워 보이지 않지만, 우테코에서 원하는건 기능자체의 구현이 아닌 읽기 쉬운 코드, 아름다운 코드에 대해서 고민하고 연습하며 이로 인한 능력의 향상이다.   그동안 사실 방구석에서 혼자 코딩을 하다보니 의식적으로 예쁘게 코드를 짜야지! 하다가도 촉박한 시간이나 귀찮음에 밀려  다시 기능적으로만 작동하는 코드 작성에 그쳤는데 이제부터는 의식적인 노력과 연습을 통해 코드의 기능뿐만 아니라 가독성과 재사용성에 대해서도 고민해보며 코딩을 해야겠다는 생각이 들었다.   준비  프리코스가 시작하기 전에 프리코스를 잘해내기위한 준비로 어떤 걸 해야 할지 고민했다. 사실 프리코스 문제들은 모두 온라인에 공개가 되어있는 상태라 미리 대략 구현을 해볼 수는 있었지만,  과제가 주는 기간은 1주일 가량으로 구현하기에 전혀 부족한 시간이 아닌지라 굳이 먼저 풀어보고 싶지는 않았다. 그래서 그것보다는 어떤 코드가 깔끔한 코드인지, 아름다운 코드인지 미리 공부하고 과제를 시작해서 과제를 시작하다가 부랴 부랴 찾아 보기보다는 미리 알고있는 상태로 처음부터 코드를 작성하고 싶었다.   그래서 유튜브에 있는 우테코 캡틴이신 박재성님의 강의를 정독 했다.      https://www.youtube.com/watch?v=bIeqAlmNRrA&amp;t=2372s    확실히 영상으로 보니 이래서 클린 코드가 필요하고, 클린 코드는 이렇게 작성하는 거구나! 싶은 생각이 들었다.        영상을 보기전에는 왜 else예약어를 쓰지말라고 하는지, 왜 indent를 2로 제약하고 심지어는 되도록이면 1의 indent로 작성하라고 하는지 이유를 알 수 있었다.  지금까지는 코드의 재사용성이나 가독성을 생각하며 코딩해본적이 없어서 너무나 신선했다. 새로운 방식으로 코딩을 하고 싶은 생각에 의욕이 샘솟았다. 빨리 코딩하러 가고싶었다.   다음은 TDD에 대한 강의를 봤다.      https://www.youtube.com/watch?v=bIeqAlmNRrA&amp;t=2391s    사실 테스트코드에 대해서는 얼마전에 넥스트스텝 강의에서 학습해서 대략 알았는데, 테스트코드랑 TDD는 다르다는 말이 무슨 뜻인지 잘 몰랐는데, 이 영상을 보고 확실히 알게 되었다.  TDD는 코딩을 하는 방법론이라고 한다면 테스트코드는 코드를 테스트하기 위한 기능을 부르는 말로, 다시말해서 TDD를 하기 위해서 필요한 기능이 테스트코드였다.  프로덕션 코드보다 테스트 코드를 먼저 작성함으로써 여러가지의 버그 발생을 낮추고, 확실하게 구현할 코드만 작성하게 됨으로써 시간과 과정을 낭비하지 않을 수 있는 방법이었다.   물론 많은시간이 필요하고, 개녕이 어려우며, 매우 귀찮고 지루할 수 있다.  사실 이번 과제에서 TDD를 하면서 하라고는 명시 되있지 않았지만, 이왕 연습하고 발전하려면 처음부터 습관을 길러가는게 편할 것같아서 어려운 과정이지만 처음부터 차근차근 진행해보기로 했다.   개발 환경 세팅  드디어 수요일이 되었고 3시가 되기전까지 다른 기수 참가자들이 어떻게 프리코스를 진행했는지를 보고 있었다.  3시가 땡치자마자 메일이 왔고 프리코스 진행방식 깃허브를 보면서 먼저 개발환경 세팅을 하기로 했다.   원래는 인텔리제이를 깔고 같이 깔렸던 JDK를 그냥 사용하고 있었고, 애초에 자바 버젼에 대한 생각을 해본 적이 없었는데,  이 과제에서는 자바8 환경으로 세팅 할 것을 요구했다.   java -version 으로 내 자바의 버전을 보니까 자바 16이 깔려있었다. 그래서 엥?? 왜 16버젼이나 나왔는데 8버젼으로 세팅하라고 하는지 궁금해서 찾아봤더니,  대부분의 교육기관에서는 1.8, 즉 자바 8버젼을 통해서 사용하고 있는 것 같았다. 나온지 좀 된 버젼이라 안정적이기도 하고, 자바 1.8 이후로는 유료일뿐더러 정말 대대적이고 필수적인 기능 발전이 있는 것도 아니다 보니  아직 많은 기업이나 공공기관에서 아직 자바 8을 많이 사용하기 있고, 떄문에 대부분의 교육기관에서는 자바 8을 사용해서 보통 교육한다고 한다.   그래서 기존에 깔려있던 최신버젼의 자바를 지우고 자바 8을 까는데, 별 생각 없이 자바 8을 깔았더니 기본 환경 변수가 자꾸 최신버젼을 가르켜서 다시 삭제하고 세팅하고 뭐하느라 시간을 많이 낭비했다.   그래도 앞으로 항상 어떤 프로젝트를 할 때 jdk의 버젼까지 생각해봐야 한다는 걸 깨달았다. 최근에 Swift로 앱개발을 할때도 크게 안알아보고 swiftUI로 개발했다가 나중에 UIKit으로 할걸… 하며 후회를 많이 했었는데,  항상 어떤 새로운 프로젝트를 할 때는 개발 환경 부터 고민하고 세팅해야 겠다는 생각이 들었다.   자바 8로 세팅을 완료한 후에도 기존 인텔리제이가 이미 최신 자바 버젼으로 설정되어서 그런가 자꾸   ./gradlew clean test가 fail이 나서 거의 두세시간을 이거 고친다고 고생하다가 인텔리제이 설정 초기화 한번으로 해결했다…   그렇게 수요일 첫날을 개발 환경을 세팅하는데 하루를 다 보냈다.   Readme.md 작성  과제 요구사항에 맞춰서 우선 프로젝트 시작전에 Readme에 기능 구현 목록을 미리 정리하기로 했다.   근데 이게 처음 해보다보니까 기준도 없고 어떤 방식으로 기능을 작성해야 할지 몰라서 시간이 많이 들었다. 다른 참가자들 것도 여러개를 보면서 어떤식으로 작성 했는지 봤는데,  사실 사람마다 나눈 기준도 다르고 작성 방식이 달라서, 어떤 정답이 있다기보다는 누가봐도 기능적으로 분리되어있어서 가독성이 편하게 읽을 수 있고, 내가 개발하면서 기능단위 커밋을 하기 용이 하면 어떨게 작성해도 괜찮다는 생각이 들었다.   그래서 우선 나는 기능단위로 커밋할 수 있도록 크게 한번 나누고, 그 사이에 예외처리해야할 항목이나 큰 기능에 포함되어있는 세부 기능을 작성하기로 했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ## 🛠 구현 기능 목록 * 1-9사이의 숫자중 3개를 뽑아 3자리 수를 정한다. * 3자리 수를 입력받는다.     * 받은 값이 3자리가 아닌 경우 예외 출력     * 받은 값이 숫자가 아닌 경우 예외 출력     * 받은 값에 중복된 숫자가 있을 시 예외 출력 * 입력값에 따라 힌트를 구분한다.     * 자리와 숫자 둘다 맞춘 경우 =&gt; 스트라이크     * 숫자는 같지만 자리가 다른 경우 =&gt; 볼     * 자리와 숫자 모두 틀린 경우 =&gt; 낫싱 * 게임의 승패 유무를 판단한다.     * 3스트라이크인 경우, 게임이 종료된다.     * 3스트라이크가 아니면 다음 라운드로 자동 진행된다. * 게임 종료가 되면, 다시 게임을 진행할지 완전히 프로그램을 종료할 지를 출력한다.     * 1 입력 시 게임 재시작     * 2 입력 시 프로그램 종료  그 동안 readme를 작성해야 한다는건 알면서도 쓰다 말기를 반복했었는데, 확실히 프로그램 기능을 구현하기전에 먼저 readme에 구상하니 다음 기능을 구현하기위해 계속 readme를 업데이트하고 들락날락하게 될 뿐만아니라,  프로그램을 만들다보면 오늘 어떤기능을 만들지 앉아서 무작정 보이는거 부터 코딩하고는 했는데, 이렇게 작성을 하면 하나하나 완료해가면서 커밋하게 됨으로 매우 체계적인 단계가 생기겠다는 생각이 들었다.   그럼 기능 구현을 시작해보자.   패키지 나누기  먼저 각 클래스들의 기능을 어떤 기준으로 나누고 기능적으로 어떻게 분배 해주어야 할지 정하고 시작하려 했다.  앱개발을 할때도 이러한 문제로 인해 고민을 했었는데, 그때는 mvvm모델을 사용해서 얼추 비슷하게 따라하려 노력해봤지만   이미 개발이 한참 진행 된 뒤라서 갑자기 새로운 패턴을 적용하기에는 너무 어려워 완벽하게 구현하지 못했었다. 이번에는 기획 단계에서 부터 하나의 모델을 정하고 거기에 최대한 맞춰서 개발해보도록 하기로 했다.   이번에 내가 적용해볼 패턴은 MVC모델이다. MVC 모델은 Model, View, Controller로 나누어진 패턴으로  가장 대표적으로 많이 사용되는 패턴이다. M,V,C는 다음과 같은 역할을 담당한다.      Model - 데이터와 관련된 부분   View - 사용자에게 보여지는 부분   Controller - Model과 View를 이어주는 부분   MVC모델은 아래와 같은 규칙을 따른다.           Model은 Controller와 View에 의존하지 않아야 한다.  Model 내부에 Controller와 View에 관련된 코드가 있으면 안된다.            View는 Model에만 의존해야 하고, Controller에는 의존하면 안된다.  View 내부에는 Model에 대한 코드는 있을 수 있지만, Controller에 대한 코드는 있어선 안된다.            View가 Model로부터 데이터를 받을 때는, 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야한다.            Controller는 Model과 View에 의존해도 된다.  Controller 내부에는 Model과 View에 관한 코드가 존재할 수 있다.            View가 Model로 부터 데이터를 받을 때, 반드시 Controller를 통해서 받아야 한다.       이 내용은 우아한 테크 코스에서 진행했던 10분 테코톡 ‘제리’님의 영상을 참고했다.     https://www.youtube.com/watch?v=bIeqAlmNRrA&amp;t=2391s    기능 구현  1-9 사이의 숫자를 3개를 뽑아 3자리수를 정한다.  먼저, 게임이 시작되면 컴퓨터가 정답으로 지정할 1-9 사이의 3개의 숫자를 난수로 출력해서 저장해야 한다.   Model에 AnsewerNumberGenerater라는 클래스를 만들어 주었다.   TDD를 적용해서 연습하기로 했으므로 테스트코드 먼저 작성 해보도록 하겠다.   테스트코드  AnswerNumberGenerator 클래스는 말그대로 정답 번호 생성기이므로, 정답 번호를 생성하는 메서드가 필요하다.  따라서 GetAnswerNumber() 라는 메서드를 호출하면 정답 번호를 배열로 반환하는 메서드가 필요하다.   다음과 같이 테스트 코드를 작성해 보았다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class AnswerNumberGeneratorTest {     AnswerNumberGenerator answerNumberGenerator;      @BeforeEach     void setUp() {         answerNumberGenerator = new AnswerNumberGenerator();     }      @Test     void answerNumberGenerate() {         assertThat(answerNumberGenerator.GetAnswerNumber())                 .size()                 .isEqualTo(3);          for (int i = 0; i &lt; 3; i++) {             assertThat(answerNumberGenerator.GetAnswerNumber()                     .get(i))                     .isBetween(1, 9);         }     } }  먼저 생성한 숫자의 개수가 3개인지 확인 해주고, 이 3가지 숫자가 모두 다른 숫자인지 확인하도록 했다.  이를 기반으로 테스트 코드가 통과 할 때까지 프로덕션 코드를 작성해 보도록 하자.   프로덕션 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class AnswerNumberGenerator {     private final static int MIN_RANGE_NUM = 1;     private final static int MAX_RANGE_NUM = 9;     private final static int MAX_NUMBER_SIZE = 3;      ArrayList&lt;Integer&gt; answerNumberList = new ArrayList&lt;Integer&gt;();      public ArrayList&lt;Integer&gt; GetAnswerNumber() {         while (answerNumberList.size() &lt; MAX_NUMBER_SIZE) {             isNumberInAnswerNumberList(Randoms.pickNumberInRange(MIN_RANGE_NUM, MAX_RANGE_NUM));         }         return answerNumberList;     }      public void isNumberInAnswerNumberList(int number) {         if (answerNumberList.contains(number)) {          }         answerNumberList.add(number);     } }  answerNumberList라는 arrayList를 사용해서 3개의 숫자가 각각 다른 개수로 골라질 때 까지  while문이 돌아가게 했다.   GetAnswerNumber의 indent를 1로 줄이기 위해서 리스트에 같은 숫자가 있는지 확인하는 메서드를 따로 빼서 isNumberInAnswerNumberList 메서드로 구현했다.   테스트 코드를 돌려보니 알맞게 프로덕션 코드를 잘 작성 한 것같다.   리팩토링  애초에 의식하고 작성해서 크게 리팩토링 할 부분은 없는 듯 하다.        근데 저 isNumberInAnserNumberList를 매개변수를 두개로 하고 isNumberinList로 이름을 바꿔서  재사용성을 높이는게 나을지 고민이됐다. 매개변수를 늘리는게 좋을까 재사용성이 높아지는게 더 좋을까…   고민 끝에 재사용성을 높이는게 매개변수 하나 늘어나는 것 보다 더 효율적일거라는 생각이 들었다.   그래서 프로덕션 코드를 다음과 같이 수정했다  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class AnswerNumberGenerator {     private final static int MIN_RANGE_NUM = 1;     private final static int MAX_RANGE_NUM = 9;     private final static int MAX_NUMBER_SIZE = 3;      ArrayList&lt;Integer&gt; answerNumberList = new ArrayList&lt;Integer&gt;();      public ArrayList&lt;Integer&gt; GetAnswerNumber() {         while (answerNumberList.size() &lt; MAX_NUMBER_SIZE) {             isNumberInList(Randoms.pickNumberInRange(MIN_RANGE_NUM, MAX_RANGE_NUM), answerNumberList);         }         return answerNumberList;     }      public void isNumberInList(int number, ArrayList&lt;Integer&gt; list) {         if (list.contains(number)) {          }         list.add(number);     } }  이제 isNumberInList는 answerNumberList 말고도 다른 배열에 있어서도 해당 숫자가 포함되어있지 않을때만 배열에 숫자를 추가해줄 수 있게 되었다.   다음으로는 isNumberInList를  1 2 3 4 5 6  public void isNumberInList(int number, ArrayList&lt;Integer&gt; list) {         if (list.contains(number)) {                  }         list.add(number);     }  1 2 3 4 5  public void isNumberInList(int number, ArrayList&lt;Integer&gt; list) {         if (!list.contains(number)) {             list.add(number);         }     }  두가지 중에 어떤걸로 할지 고민되었다. 깔끔한건 아래 코드인것 같은데, !가 잘 안보여 위에 코드보다 덜 명확한 코드라는 생각이 들어서 그냥 그대로 1번으로 진행하기로 했다.   테스트 코드를 돌려보니 전과 동일하게 테스트를 통과 할 수 있었다.   커밋  기능 구현이 하나 완료된 것 같아서 커밋을 진행해 보려한다.       그동안 커밋을 할 때 별생각없이 커밋 메시지로 그냥 날짜를 표시한다거나 했는데, 이제부터는 명확하게 규칙에 따라 커밋로그를 남겨야 한다.                  태그 이름       설명                       Feat       새로운 기능을 추가할 경우                 Fix       버그를 고친 경우                 Design       CSS 등 사용자 UI 디자인 변경                 !BREAKING CHANGE       커다란 API 변경의 경우                 !HOTFIX       급하게 치명적인 버그를 고쳐야하는 경우                 Style       코드 포맷 변경, 세미 콜론 누락, 코드 수정이 없는 경우                 Refactor       프로덕션 코드 리팩토링                 Comment       필요한 주석 추가 및 변경 Docs 문서를 수정한 경우                 Test       테스트 추가, 테스트 리팩토링(프로덕션 코드 변경 X)                 Chore       빌드 태스트 업데이트, 패키지 매니저를 설정하는 경우(프로덕션 코드 변경 X)                 Rename       파일 혹은 폴더명을 수정하거나 옮기는 작업만인 경우                 Remove       파일을 삭제하는 작업만 수행한 경우           위의 태그를 붙여서  1 2 3 4 5 type(옵션): [#issueNumber - ]Subject  // -&gt; 제목 (한 줄을 띄워 분리합니다.) body(옵션) //  -&gt; 본문  (한 줄을 띄워 분리합니다.) footer(옵션) // -&gt; 꼬리말  다음과 같이 기능을 추가 한다.   이번엔 기능을 추가 했으니,      [feat] 1-9사이의 숫자중 3개를 뽑아 3자리 수를 정한다.    이렇게 커밋 로그를 작성하면 된다.   3자리 수를 입력 받는다.  사용자로부터 3자리 수를 받아야한다. 3자리 숫자가 아닌경우는 모두 예외처리되어 프로그램이 종료되어야 하는데, 따라서 숫자를 UserNumber라는 클래스로 포장해서 사용해서 사용하려 한다.   테스트 코드  이래서 TDD가 어렵다고 했구나…         테스트 코드를 먼저 작성하려면 이미 머릿속에서 어느정도 구현에 대한 감이 와야하는데, 자바가 익숙치 않아서 어렵다. 그래서 이번에는 프로덕션 코드를 먼저 구현해보고 테스트 코드를 작성해 보았다.   프로덕션 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public class UserNumber {     private final static int MAX_NUMBER_SIZE = 3;          private String userNumber;      public String getUserNumber() {         return userNumber;     }      public UserNumber(String userNumber) {         if (isStringLengthThree(userNumber) &amp;&amp; isUserNumberDigit(userNumber) &amp;&amp; isSameAllNumber(userNumber)) {             this.userNumber = userNumber;         }     }      public boolean isUserNumberDigit(String word) {         for (int i = 0; i &lt; word.length(); i++) {             isStringCharAtDigit(word, i);         }         return true;     }      public boolean isStringCharAtDigit(String word, int index) throws IllegalArgumentException {         if (!Character.isDigit(word.charAt(index))) {             throw new IllegalArgumentException();         }         return true;     }      public boolean isStringLengthThree(String word) throws IllegalArgumentException {         if (word.length() != USER_NUMBER_LENGTH) {             throw new IllegalArgumentException();         }         return true;     }      public boolean isSameAllNumber(String word) throws IllegalArgumentException {         Set&lt;Character&gt; set = new HashSet&lt;&gt;();          for (int i = 0; i &lt; word.length(); i++) {             set.add(word.charAt(i));         }         if (set.size() != word.length()) {             throw new IllegalArgumentException();         }         return true;     } }  UserNumber 클래스는 입력받은 문자열이 3자리인지 확인하고, 모든 문자열이 숫자로 들어왔는지 확인한다. 그리고 마지막으로 중복된 문자열이 있는지    세가지 유효성검사를 하는 자료형이다.   이제 프로덕션 코드를 모두 작성하고나니, 테스트 코드를 어떻게 작성해야 할지가 보였다.        중요한건 예외처리가 잘되는지 이므로 이 클래스에 값이 들어왔을때 제대로 예외처리가 진행되는지 코드를 작성 해주면 된다.   1 2 3 4 5 6 7 8 9 10 11 12  class UserNumberTest {     UserNumber userNumber;      @ParameterizedTest     @ValueSource(strings = {\"31\",\"311\",\"3io\",\"i\",\"\",\" \"})     public void ExceptionTest(String input) {         assertThatThrownBy(() -&gt; {             userNumber = new UserNumber(input);         })                 .isInstanceOf(IllegalArgumentException.class);     }   ParameterizedTest 어노테이션을 사용해서 모든 예외에서 올바르게 IllegalArgumentException을 출력하는걸 확인 했다.   리팩토링  우선 기능구현부터 해놓고 생각하자는 생각으로 가장 기본적인 인덴트 지키기나 메소드 분리는 잘한 것 같은데,  맘에 안드는 부분이 몇개 있어서 리팩토링이 필요할 것 같다. 우선 기능하나를 완료했으니 커밋부터 한 뒤에  리팩토링을 시작했다.      일일히 클래스마다 상수를 선언해주는 것보다 Constant 클래스를 만들어서 상수를 따로 모아 관리하는게 좋을 것같다.        우선 첫번째로 MVC패턴을 사용하기로 했는데, 세가지로 기능을 나누는게 좀 감이 잘 안와서 제대로 역할 분배가 안된 것같다.  다시 코드를 보면서 MVC 세가지 패키지로 클래스를 더 세분화 해보자.       유효성 검사가 너무 복잡한 것 같다. 더 간단하게 예외를 처리 할 수 있을것 같다.   먼저 1번에 대한 문제를 해결해보자.   상수들을 따로 클래스에 모아서 저장하면 한번만 선언해도 이 상수를 다른곳에서 모두 사용할 수 있고,  상수 변경이 필요할때도 일일히 찾지 않아도 된다. 따로 패키지를 만들어서 Constant 라는 클래스를 만들어주었다.  1 2 3 4 5 public class Constant {     public final static int MIN_RANGE_NUM = 1;     public final static int MAX_RANGE_NUM = 9;     public final static int USER_NUMBER_LENGTH = 3; }   그 다음 2번 문제를 해결해보자.   우선 AnswerNumberGenerator이름을 PlayerNumber로 바꾸고, PlayerNumber가 좀 더 모델의 클래스에 가깝게 AnswerNumber 객체를 만들면   생성자가 세자리 난수를 부여하고 이를 getNewPlayerNumber() 메서드를 따로 만들어서 만약 다음게임이 시작되어 난수를 새로 부여받아야 한다면   이 메소드로 모델의 값을 변경 하는게 좋을 것 같다.   이렇게 하면 좀 더 기능적으로 구분이 잘 될 것이다.   추가로 반환하는 값이 지금 ArrayList로 되어있는데, PlayerNumber와 동일하게 String으로 통일하는게 맞는 것 같다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class AnswerNumber {     private String answerNumber;      public AnswerNumber() {         getNewAnswerNumber();     }      public String getAnswerNumber() {         return answerNumber;     }      public void getNewAnswerNumber() {         ArrayList&lt;String&gt; answerNumberList = new ArrayList&lt;String&gt;();          while (answerNumberList.size() &lt; Constant.USER_NUMBER_LENGTH) {             isNumberInList(getStringRandomNumber(), answerNumberList);         }         this.answerNumber = String.join(\"\", answerNumberList);     }      public static void isNumberInList(String number, ArrayList&lt;String&gt; list) {         if (list.contains(number)) {          }         list.add(number);     }      public static String getStringRandomNumber() {         return Integer.toString(Randoms.pickNumberInRange(Constant.MIN_RANGE_NUM, Constant.MAX_RANGE_NUM));     } }  이렇게 하면 AnswerNumber라는 객체가 모델 기능에 더 맞는 느낌으로 바뀐것 같다.        밖에서 접근 할 수 없도록 클래스 멤버 변수는 private로 선언하고 getAnswerNumber로 값을 받아올 수 만 있게 했다.   새로운 난수가 필요하다면, getNewAnswerNumber() 메서드를 사용해서 모델의 데이터를 변경해주면 된다.   UserNumber도 마찬가지로 좀 더 모델의 역할에 충실하게 리팩토링 해주었다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class PlayerNumber {     private String playerNumber;      public String getUserNumber() {         return playerNumber;     }      public void setPlayerNumber(String playerNumber) {         if (isStringLengthCorrect(playerNumber) &amp;&amp; isDigitPlayerNumber(playerNumber) &amp;&amp; isDifferentPlayerNumber(playerNumber)) {             this.playerNumber = playerNumber;         }     }      public static boolean isStringLengthCorrect(String word) throws IllegalArgumentException {         if (word.length() != Constant.USER_NUMBER_LENGTH) {             throw new IllegalArgumentException(SystemMessage.NUMBER_LENGTH_NOT_CORRECT);         }         return true;     }      public boolean isDigitPlayerNumber(String word) {         for (int i = 0; i &lt; word.length(); i++) {             isDigitCharInString(word, i);         }         return true;     }      public static boolean isDifferentPlayerNumber(String word) throws IllegalArgumentException {         Set&lt;Character&gt; set = new HashSet&lt;&gt;();          for (int i = 0; i &lt; word.length(); i++) {             set.add(word.charAt(i));         }         if (set.size() != word.length()) {             throw new IllegalArgumentException(SystemMessage.HAS_SAME_NUMBER);         }         return true;     }      public static boolean isDigitCharInString(String word, int index) throws IllegalArgumentException {         if (!Character.isDigit(word.charAt(index))) {             throw new IllegalArgumentException(SystemMessage.STRING_IS_NOT_NUMBER);         }         return true;     } }  커밋  [refactor] mvc모델에 맞게 리팩토링   입력값에 따라 힌트를 구분한다.  이제 본격적으로 앞에서 구현한 클래스들을 사용하는 객체를 만들어 보려고 한다.  게임에 참가하는 Player와 상대방인 Computer 객체를 만들어 Player는 숫자를 고르고,  Computer는 이 숫자를 받으면 힌트를 주도록 할 것이다.   Player, Computer라는 모델 두개를 만들어 준다.   먼저 Computer 클래스를 만들어보자.   Computer 테스트 코드  Computer 객체는 getHint() 메서드를 호출하면 userNumber에 맞는 힌트를 출력해주어야 한다.  따라서 다음과 같이 테스트 코드를 작성 할 수 있다.   1 2 3 4 5 @ParameterizedTest     @CsvSource(value = {\"123: 3스트라이크\", \"132:1볼 2스트라이크\",\"456 : 낫싱\"},delimiter = ':')     public static void getHintTest(String input, String output){         assertThat(computer.getHint(input).isEqualTo(output);     }   Computer 프로덕션 코드  테스트 코드를 만족하는 프로덕션 코드를 작성 해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Computer {     private AnswerNumber computerAnswerNumber;      public Computer() {         computerAnswerNumber = new AnswerNumber();     }      public String getAnswerNumber() {         return computerAnswerNumber.getAnswerNumber();     }      public static int CountingBall(String userNumber, String answerNumber) {         int ball = Constant.BALL_INITIAL_VALUE;          for (int i = 0; i &lt; userNumber.length(); i++) {             if (answerNumber.contains(Character.toString(userNumber.charAt(i)))) {                 ball += 1;             }         }         return ball;     }      public static int CountingStrike(String userNumber, String answerNumber) {         int strike = Constant.STRIKE_INITIAL_VALUE;          for (char userNum : userNumber.toCharArray()) {             if (answerNumber.indexOf(userNum) == userNumber.indexOf(userNum)) {                 strike += 1;             }         }         return strike;     }      public int[] getHint(String userNumber) {         int ballCount = CountingBall(userNumber, computerAnswerNumber.getAnswerNumber());         int strikeCount = CountingStrike(userNumber, computerAnswerNumber.getAnswerNumber());         return new int[]{ballCount - strikeCount, strikeCount};     } }  Computer는 인스턴스를 만들면 랜덤으로 수를 하나 정한 뒤, 플레이어에 답에 따라 줄 힌트를 골라준다.   Player 테스트 코드  Player 클래스가 하는 일이 받은 수 를 저장하는 것뿐이라 따로 테스트 코드를 작성할 필요가 없을 것 같다.  그럼에도 굳이 Player 클래스를 만들어야 하는 이유는 후에 만약 Player에게 기능이 추가 될때 유지보수가 더 용이하기 때문이다.   Player 프로덕션 코드  1 2 3 4 5 6 7 public class Player {     private TryNumber playerNumber = new TryNumber();      public void setUserNumber(String userNumber) {         playerNumber.setUserNumber(userNumber);     } }   그럼 이제 이 기능들을 출력하는 View를 따로 만들어주자.   readme 수정  생각해보니 readme 파일에 입출력도 따로 기능 구현 목록으로 추가 해주고 분리해서 커밋하는게 맞을 것 같아서 readme 파일을 수정했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ## 🛠 기능 구현 목록 * 1-9사이의 숫자중 3개를 뽑아 3자리 수를 정한다. v * \"숫자를 입력하세요\" 문구를 출력한다. * 3자리 수를 입력받는다. v   * 받은 값이 3자리가 아닌 경우 예외 출력 v   * 받은 값이 숫자가 아닌 경우 예외 출력 v   * 받은 값에 중복된 숫자가 있을 시 예외 출력 v * 입력값에 따라 힌트를 구분한다. v   * 자리와 숫자 둘다 맞춘 경우 =&gt; 스트라이크 v   * 숫자는 같지만 자리가 다른 경우 =&gt; 볼 v   * 자리와 숫자 모두 틀린 경우 =&gt; 낫싱 v * 답에따른 힌트 문구를 출력한다. * 게임의 승패 유무를 판단한다.   * 3스트라이크인 경우, 게임이 종료된다.   * 3스트라이크가 아니면 다음 라운드로 자동 진행된다. * 게임 종료가 되면, 다시 게임을 진행할지 완전히 프로그램을 종료할 지를 출력한다.   * 1 입력 시 게임 재시작   * 2 입력 시 프로그램 종료   InputView 기능 구현  1 2 3 4 5 6 public class InputView {     public static String setUserNumber() {         System.out.printf(SystemMessage.SET_USER_NUMBER_MESSAGE);         return Console.readLine();     } }  InputView 클래스를 따로 만들어서 입력을 받는 View를 구성해준다.         입력을 받을때마다 “숫자를 입력하세요”를 함께 출력한다.   OutputView 기능 구현  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class OutputView {     public static void printHintMessage(int[] computerHint) {         if (computerHint[0] != 0) {             System.out.print(computerHint[0] + SystemMessage.BALL_MESSAGE + \" \");         }          if (computerHint[1] != 0) {             System.out.print(computerHint[1] + SystemMessage.STRIKE_MESSAGE + \" \");         }          if (computerHint[0] == 0 &amp;&amp; computerHint[1] == 0) {             System.out.print(SystemMessage.NOTHING_MESSAGE + \" \");         }         System.out.println();     } }  마찬가지로 출력값을 담당하는 Output 클래스를 만들어서 출력에 관한 View는 여기서 담당하도록 해준다.   Computer에서 힌트를 받아서 그에 맞는 메시지를 출력한다.   종료  오늘은 여기까지…       솔직히 기능 구현만 하면 한시간이면 다 할 것 같은데 진짜로 코드하나 쓰기전에 생각을 한시간씩 하게 된다.  어떤게 올바른 코드인지 한 한시간을 검색하고 고민한뒤에 코드를 적으니 진도가 너무 더디지만, 뭔가 성장해가는 기분이 들어 뿌듯하다. 그동안 코딩해보면서 이렇게 고민하고 코드 적었던 적이 없었던것 같다…   아직도 너무너무 불만족스러운 코드라서, 내일 마저 열심히 더 예쁜코드를 위해 노력해보겠다!  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-1%EC%A3%BC%EC%B0%A8-%EC%88%AB%EC%9E%90%EC%95%BC%EA%B5%AC-(1)/",
        "teaser": null
      },{
        "title": "[Java] 우테코 프리코스 1주차 - 숫자야구 (2)",
        "excerpt":"다시 시작…  자고 일어나서 다시 어제 쓴 코드를 읽는데, 뭔가 어제 쓸때만해도 좀 감을 잡았다 싶었던 코드가      오징어처럼 보였다…   잠깐 멈추고 생각을 다시해보기로 했다.   객체지향  객체지향에 대해서 근본적인 공부가 필요하다고 생각되서 더 여러가지 코드를 보고 mvc패턴 예제도 더 찾아봤다.   우선 객체에 대해서 다시 생각해 보았다. 이 프로그램을 코드로 보지말고 마치 현실에서 내가 숫자야구 게임을 주최한다면 어떻게 진행할 지 생각해보기로 했다. 그럼 어떤 객체가 필요하고 기능을 어떻게 분리해야할지가 훨씬 명확해 질 것 같았다.   숫자야구 게임을 주최한다면 우선 참가자가 당연히 필요할 것이다. 랜덤으로 세자리를 뽑아줄 컴퓨터도 한대 필요 할 것이고, 이걸 바탕으로 숫자가 맞았는지 틀렸는지 판단하는 심판이 한명 필요할 것이다.   이렇게 그냥 현실에서의 객체로 생각을 하니 조금 더 기능 분담이 명확해졌다.   그래서 지금 Computer가 담당하고 있던, 유저가 입력한 숫자를 판단한 기능을 Referee라는 새로운 클래스를 만들어서 옮겨 주었다.   MVC 패턴  MVC 패턴에서 가장 어렵고 이해가 되지않았던 내용은 컨트롤러의 기능이었다.   이게 뷰와 모델을 이어준다는 느낌인데 정확히 어떤느낌인지 딱 감이 오지 않았다. 그래서 무작정 mvc패턴으로 작성된 예제들은 무작정 여러개 찾아 보았다.  뷰와 모델을 이어서 뷰에서 변화를 요청받으면 이를 모델에 전해주고, 모델의 변경점을 받아서 뷰로 전해주는 중개자라는 설명과 함께 코드를 보니 조금 감이 오는 것 같으면서도 너무 어려웠다…   그렇게 거의 두시간을 mvc만 생각해본 결과, Player 객체와 Computer 객체와 사용자가 보는 View가를 연결해주는 거라면 결국 숫자야구 한판이 진행되는 과정 하나하나가 Controller의 기능이 아닐까하는 생각이 들었다.   그래서 다시 코드를 대대적으로 리팩토링 했다.   Controller  BaseballGame 이라는 클래스를 만들어서 게임 한판도 객체로 만들어주기로 했다.   게임 한판을 하고 싶다면, Computer 하나와 Player한명, 그리고 Referee 한명이 필요하기 때문에  BaseballGame이 시작되면 이 세개의 객체가 생성 되고,   이 세개의 모델과 뷰가 서로 정보를 주고 받으면서 뷰는 모델에 유저의 입력값을 바탕으로 모델의 값을 변경하고,   뷰의 Output 요청을 받으면 갖고있는 정보를 뷰에게 전달해주면 뷰는 이걸 출력한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class BaseballGame {     private Computer computer;     private Player player;     private Referee referee;      public BaseballGame() {         computer = new Computer();         player = new Player();         referee = new Referee();     }      public void start() {         getNumberFromPlayer();         printHint();     }      public void getNumberFromPlayer() {         player.setPlayerNumber(InputView.getNumber());     }      public void printHint() {         OutputView.printHintMessage(referee.getHint(player.getPlayerNumber(), computer.getAnswerNumber()));     }  }   이제 이 컨트롤러를 메인함수에서 사용해 BaseballGame 객체를 하나 생성해주고 BaseballGame.start()  를 하면 1회에 한해서 사용자의 숫자를 입력받고 힌트를 출력한다.  1 2 3 4 5 6 7 public class Application {     public static void main(String[] args) {         //TODO: 숫자 야구 게임 구현         BaseballGame baseballGame = new BaseballGame();         baseballGame.start();     } }  이렇게 하고나니까 훨씬 코드가 깔끔해졌다는 생각이 들었다.   왜 mvc모델을 사람들이 많이 사용하는지 조금 알 것 같았다!   우선 basballGame.start()라는 이 코드가 너무 마음에 들었다. 가독성이 훨씬 좋아진 느낌이라고 해야하나???  사용자가 숫자야구 게임을 하고 싶다면 BaseballGame 객체를 생성해주고, 이 객체의 start()를 사용해주면 바로 게임이 시작된다.   만약 서로다른 게임을 두개 개최하고 싶다면 객체를 두개 생성해서 객체 두개를 start()해주면 된다.   뿐만 아니라 숫자야구에 기능을 추가하는 경우, 예를들어 심판인 Refree가 힌트 뿐만아니라 오답횟수를 출력해준다던가, Computer가 두개 여서 Player가 두개의 숫자를 맞추도록 룰을 변경할 때도 유지보수가 간편하다.   전자의 경우는 Refree에 가서 오답횟수를 세는 메서드를 하나 더 추가하고 이를 뷰로 연결해서 BaseballGame에서 출력하도록 이어주면되고,   후자의 경우는 BasebllGame 객체가 생성되면 Computer객체가 두개 생성되도록 해주면 된다.   그리고 만약 이 프로그램에 숫자야구 말고 다른 게임을 추가 하고 싶다면, 또 다른 컨트롤러 객체를 만들어서 다른 게임을 진행할 수 있도록 만들면 된다.   리팩토링  다음 기능을 추가하기전에 한번 더 검토할 사항이 있는지 코드를 한줄 씩 읽어 봤다.   내가 코드를 처음 보는 사람이라는 생각으로 다시 코드를 검토했는데, 가독성이 그다지 좋지 않다는 생각이 들었다…   근데 유독 가독성이 좋다고 느껴지는 부분이 있었는데, 바로 BaseballGame 클래스의 start() 메서드 부분이었다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class BaseballGame {     private final Computer computer;     private final Player player;     private final Referee referee;      public BaseballGame() {         computer = new Computer();         player = new Player();         referee = new Referee();     }      public void start() {         getNumberFromPlayer();         printHint();     }      public void getNumberFromPlayer() {         player.setPlayerNumber(InputView.getNumber());     }      public void printHint() {         OutputView.printHintMessage(referee.getHint(player.getPlayerNumber(), computer.getAnswerNumber()));     }  }   코드가 짧아서 그런가 싶었지만, start() 부분을 보면 이 메서드가 무슨 일을 하는지 명확하다.         getNumberFromPlayer, 플레이어로부터 숫자를 받아오고, printHint, 힌트를 출력한다.   이 메서드가 궁금하다면 아래로 내려가서 메서드가 하는일을 체크하면 된다.   이 코드를 보니 왜 이름을 알아보기 쉽게 지으라고 했는지, 메서드는 왜 최대한 하나의 일을 하게 만들어야 하는지, 왜 매개변수는 최대한 적게 써야하는지에 대한 해답을 찾은 느낌이었다.   지금까지는 단순히 메서드 이름을 기능을 설명하는데만 충실하게 지으려 했는데, 가독성을 위해서는 기능을 잘 설명할 뿐만 아니라 마치 메서드의 이름들을 모아 놓으면 하나의 책 문장을읽는듯이 읽혀야 된다는 생각이 들었다.   다시 지금까지 썼던 코드를 리팩토링 해보기로 했다.   먼저 PlayerNumber 부터 리팩토링 해보자.   PlayerNumber   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class PlayerNumber {     private String playerNumber;      public PlayerNumber(String playerNumber) {         if (isStringLengthCorrect(playerNumber) &amp;&amp; isDigitPlayerNumber(playerNumber) &amp;&amp; isDifferentPlayerNumber(playerNumber)) {             this.playerNumber = playerNumber;         }     }      public String getPlayerNumber() {         return playerNumber;     }      public static boolean isStringLengthCorrect(String word) throws IllegalArgumentException {         if (word.length() != Constant.USER_NUMBER_LENGTH) {             throw new IllegalArgumentException(SystemMessage.NUMBER_LENGTH_NOT_CORRECT);         }         return true;     }      public boolean isDigitPlayerNumber(String word) {         for (int i = 0; i &lt; word.length(); i++) {             isDigitCharInString(word, i);         }         return true;     }      public static boolean isDifferentPlayerNumber(String word) throws IllegalArgumentException {         Set&lt;Character&gt; set = new HashSet&lt;&gt;();          for (int i = 0; i &lt; word.length(); i++) {             set.add(word.charAt(i));         }         if (set.size() != word.length()) {             throw new IllegalArgumentException(SystemMessage.HAS_SAME_NUMBER);         }         return true;     }      public static boolean isDigitCharInString(String word, int index) throws IllegalArgumentException {         if (!Character.isDigit(word.charAt(index))) {             throw new IllegalArgumentException(SystemMessage.STRING_IS_NOT_NUMBER);         }         return true;     } }  위에서 읽었을때 너무 복잡하다는 생각이 들었다. 내가 생각한건 PlayerNumber가 생성될때 아래의 유효성 검사를 진행하고 나서야 playnumber라는 클래스 멤버변수가 생기는 건데,  모르는 사람이 한번 봐서 읽기가 쉽지 않았다. 그래서 아래와 같이 리팩토링을 진행했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public class PlayerNumber {     private String playerNumber;      public PlayerNumber(String playerNumber) {                  isStringLengthCorrect(playerNumber);         isDigitPlayerNumber(playerNumber);         isDifferentPlayerNumber(playerNumber);                  this.playerNumber = playerNumber;              }      public String getPlayerNumber() {         return playerNumber;     }      public static void isStringLengthCorrect(String word) throws IllegalArgumentException {         if (word.length() != Constant.USER_NUMBER_LENGTH) {             throw new IllegalArgumentException(SystemMessage.NUMBER_LENGTH_NOT_CORRECT);         }     }      public void isDigitPlayerNumber(String word) {         for (int i = 0; i &lt; word.length(); i++) {             isDigitCharInString(word, i);         }     }      public static void isDifferentPlayerNumber(String word) throws IllegalArgumentException {         Set&lt;Character&gt; set = new HashSet&lt;&gt;();          for (int i = 0; i &lt; word.length(); i++) {             set.add(word.charAt(i));         }         if (set.size() != word.length()) {             throw new IllegalArgumentException(SystemMessage.HAS_SAME_NUMBER);         }     }      public static void isDigitCharInString(String word, int index) throws IllegalArgumentException {         if (!Character.isDigit(word.charAt(index))) {             throw new IllegalArgumentException(SystemMessage.STRING_IS_NOT_NUMBER);         }     } }  우선 예외를 출력하는 메소드들을 굳이 boolean형으로 반환하지 않아도 된다는 생각이 들었다. 예외 상황이 발생되면 IllegalArgumentException이 알아서 예외를 출력하기 때문에 굳이 if문을 사용하지 않아도 된다.   이렇게 바꾸고 PlayerNumber의 생성자 부분을 보면 전보다 아주 깔끔하게 읽힌다.   마치 한 문장을 읽는것처럼 유효성 검사들을 읽을 수 있다.   AnswerNumber   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class AnswerNumber {     private String answerNumber;      public AnswerNumber() {         getNewAnswerNumber();     }      public String getAnswerNumber() {         return answerNumber;     }      public void getNewAnswerNumber() {         ArrayList&lt;String&gt; answerNumberList = new ArrayList&lt;String&gt;();          while (answerNumberList.size() &lt; Constant.USER_NUMBER_LENGTH) {             isNumberInList(getStringRandomNumber(), answerNumberList);         }         this.answerNumber = String.join(\"\", answerNumberList);     }      public static void isNumberInList(String number, ArrayList&lt;String&gt; list) {         if (!list.contains(number)) {             list.add(number);         }      }      public static String getStringRandomNumber() {         return Integer.toString(Randoms.pickNumberInRange(Constant.MIN_RANGE_NUM, Constant.MAX_RANGE_NUM));     } }  getNewAnswerNumber와 isNumberInList를 보면, 단순히 메소드를 줄이라는 말에 어거지로 두개로 나눠놓은 걸 볼 수 있다.   이러면 메소드 하나가 하나의 일을 하는게 아니라 하나의 일을 억지로 두개의 메서드가 하는 꼴이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class AnswerNumber {     private String answerNumber;      public AnswerNumber() {         getNewAnswerNumber();     }      public String getAnswerNumber() {         return answerNumber;     }      public void getNewAnswerNumber() {         LinkedHashSet&lt;String&gt; answerNumberList = new LinkedHashSet&lt;String&gt;();          while (answerNumberList.size() &lt; Constant.USER_NUMBER_LENGTH) {             answerNumberList.add(getStringRandomNumber());         }         this.answerNumber = String.join(\"\", answerNumberList);     }      public static String getStringRandomNumber() {         return Integer.toString(Randoms.pickNumberInRange(Constant.MIN_RANGE_NUM, Constant.MAX_RANGE_NUM));     } }   이렇게 코드를 바꿔주었다. 원래는 set을 사용하려 했는데 set함수는 순서가 없어서 입력받은 숫자를 순서대로 출력할 수 없다는 생각에   ArrayList로 구현했었던 거였는데, 역시 찾아보니까 순서가 있는 LinkedHashSet이 있었다…   이렇게 자바에서 이미 지원하는 라이브러리를 사용하니 코드가 훨씬 깔끔해지는 걸 보고, 자바의 라이브러리를 적극적으로 찾아보고 사용해야겠다는 생각이 들었다.   Referee  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public class Referee {     public int[] getHint(String playerNumber, String answerNumber) {          int ballCount = CountingBall(playerNumber, answerNumber);         int strikeCount = CountingStrike(playerNumber, answerNumber);          return new int[]{ballCount - strikeCount, strikeCount};     }      public static int CountingBall(String playerNumber, String answerNumber) {         int ball = Constant.BALL_INITIAL_VALUE;          for (int i = 0; i &lt; playerNumber.length(); i++) {             if (answerNumber.contains(Character.toString(playerNumber.charAt(i)))) {                 ball += 1;             }         }         return ball;     }      public static int CountingStrike(String playerNumber, String answerNumber) {         int strike = Constant.STRIKE_INITIAL_VALUE;          for (char userNum : playerNumber.toCharArray()) {             if (answerNumber.indexOf(userNum) == playerNumber.indexOf(userNum)) {                 strike += 1;             }         }         return strike;     } }  어쩌면 지금 짠 코드중에 제일 가독성이 떨어지는 것 같다…   Referee는 getHint 요청을 받으면 PlayerNumber와 AnswerNumber를 비교해서 볼과 스트라이크 개수를 int[] 형태로 반환하는데, OutputView에서 이 값을 바탕으로 볼과 스트라이크를 출력한다.   좀 더 기능을 나누어서 깔끔하게 읽히도록 만들어보자.  1 2 3 4 5 6 7 8 9 10 11 public class Referee {     private final Hint hint;      public Referee() {         hint = new Hint();     }      public int[] getHint(String answerNumber, String playerNumber){         return hint.getHint(answerNumber, playerNumber);     } }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 public class Hint {     private int ball;     private int strike;      public int[] getHint(String playerNumber, String answerNumber) {         resetCount();         ballCount(playerNumber, answerNumber);         strikeCount(playerNumber, answerNumber);         strikeExceptBall();                  return new int[]{ball, strike};     }      public void resetCount(){         ball = Constant.BALL_INITIAL_VALUE;         strike = Constant.STRIKE_INITIAL_VALUE;     }      public void ballCount(String playerNumber, String answerNumber){         for (int i = 0; i &lt; playerNumber.length(); i++) {             if (answerNumber.contains(Character.toString(playerNumber.charAt(i)))) {                 ball ++;             }         }     }      public void strikeCount(String playerNumber, String answerNumber){         for (char playerNum : playerNumber.toCharArray()) {             if (answerNumber.indexOf(playerNum) == playerNumber.indexOf(playerNum)) {                 strike ++;             }         }     }      public void strikeExceptBall(){         ball = ball - strike;     } }   strike와 ball을 클래스 변수로 만드는게 훨씬 코드가 깔끔해져서, 따로 클래스 변수로 만든 뒤 원시값포장을 위해 Hint 클래스를 따로 만들었다.   리팩토링을 하며 느낀건데, 코드를 우선 한 메소드로 기능적으로 동작하게 먼저 쓰고 메소드를 차분히 분리하는게 훨씬 편한것 같다. 그렇게 메소드를 분리한 뒤에 클래스로 분리 할 수 있다면, 클래스로 분리 하면 된다.   1 2 3 4 5 6 7 8 public int[] getHint(String playerNumber, String answerNumber) {         resetCount();          ballCount(playerNumber, answerNumber);         strikeCount(playerNumber, answerNumber);          return new int[]{ball, strike};     }   이제 힌트를 가져다주는 getHint 메서드가 아주 깔끔해졌다. count들을 리셋해주고,  볼을 세고, 스트라이크를 센 다음 볼에서 스트라이크를 빼고 이 둘의 값을 배열로 반환해주면 된다.   게임의 승패 유무를 판단하는 기능 추가  만약 3스트라이크 인 경우 “3개의 숫자를 모두 맞히셨습니다! 게임종료” 문구 출력과 함께 게임을 새로 시작할것인지 프로그램을 종료 할 것인지 입력을 받아 처리해야한다.   우선 3스트라이크인지 판단하는 기능은 심판인 Referee가 담당하도록 해주어야 한다고 생각했다.  1 2 3 4 5 6 public boolean isThreeStrike() {         if (hint.getStrike() == Constant.GAME_SET_STRIKE_VALUE) {             return true;         }         return false;     }  Referee에 위와 같이 3스트라이크를 판별하는 메서드를 추가해 주었다.   1 2 3  public static void printGameSetMessage(){         System.out.println(SystemMessage.GAME_SET_MESSAGE);     }  게임이 종료된걸 알리기 위한 메시지를 출력하는 printGameSetMessage()를 OutputView에 추가해주고, BaseballGame에서 종료 할지 말지를 결정하도록 했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14  public void start() {         do {             getNumberFromPlayer();             printHint();         } while (!isGameSet());     }       public boolean isGameSet() {         if (referee.isThreeStrike()) {             OutputView.printGameSetMessage();             return true;         }         return false;     }  isGameSet() 메서드가 3스트라이크인지를 판별해서 3스트라이크라면 게임을 종료하고 게임 종료 메시지를 출력한다.   리팩토링  OutputView에 대한 코드를 보다보니, OutputView는 오직 출력에 관한 기능만 가져야 할 것 같은데, 들어온 힌트를 판단해주는 기능까지 갖고 있었다.   OutputView를 조금 더 OutputView 답게 만드는 리팩토링을 진행 하였다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class OutputView {     public static void printBallMessage(){         System.out.printf(SystemMessage.BALL_MESSAGE);     }      public static void printStrikeMessage(){         System.out.printf(SystemMessage.STRIKE_MESSAGE);     }      public static void printNothingMessage(){         System.out.printf(SystemMessage.NOTHING_MESSAGE);     }      public static void printCount(int count){         System.out.print(count);     }      public static void printGameSetMessage(){         System.out.println(SystemMessage.GAME_SET_MESSAGE);     } }   힌트를 판단하는 기능은 BaseballGame 컨트롤러에서 담당해주도록 하였다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 public class BaseballGame {     private final Computer computer;     private final Player player;     private final Referee referee;      public BaseballGame() {         computer = new Computer();         player = new Player();         referee = new Referee();     }      public void start() {         do {             getNumberFromPlayer();             printHint(getHint());         } while (!isGameSet());     }      public void getNumberFromPlayer() {         player.setPlayerNumber(InputView.getNumber());     }      public void printHint(int[] hint) {         printBallHint(hint);         printStrikeHint(hint);         printNothingHint(hint);         printEnter();     }      public static void printBallHint(int[] hint) {         if (hint[0] != 0) {             OutputView.printCount(hint[0]);             OutputView.printBallMessage();         }     }      public static void printStrikeHint(int[] hint) {         if (hint[1] != 0) {             OutputView.printCount(hint[1]);             OutputView.printStrikeMessage();         }     }      public static void printNothingHint(int[] hint) {         if (hint[0] == 0 &amp;&amp; hint[1] == 0) {             OutputView.printNothingMessage();         }     }      public int[] getHint() {         return referee.getHint(player.getPlayerNumber(), computer.getAnswerNumber());     }      public static void printEnter() {         System.out.println();     }      public boolean isGameSet() {         if (referee.isThreeStrike()) {             OutputView.printGameSetMessage();             return true;         }         return false;     }  }  이렇게 해주면 모델의 상태에 따라서 사용자에게 보여주는 출력을 바꿔주는게 됨으로 훨씬 더 View는 View답고 Controller는 더 Controller의 기능에 충실해진 것 같다.   게임 종료가 되면, 다시 게임을 진행할지 완전히 프로그램을 종료할 지를 출력한다.  이 기능을 구현하기 전에 한참 고민을 했다. 이 기능은 과연 Computer가 담당해야 하는 기능인지, 아니면 Referee가 담당해야 할지 아니면 BaseballGame 컨트롤러에 추가 해야할지 고민이 됐다.   그래서 만약 이 프로그램이 후에 여러 게임을 가진 프로그램이 될수도 있다고 생각하고 가정해보았다.   이 프로그램에 숫자야구 게임 뿐만아니라, 새로운 게임이 추가된다고 생각해보자.   이제 이 프로그램이 시작하면 어떤게임을 플레이 할지 선택하고, 그 게임이 종료되면 이 게임을 한번 더 할지, 다른 게임을 다시 선택하러 갈지, 프로그램을 종료할 것인지 고를수가 있는 기능 추가가 필요해질 것이다.   이때 숫자야구 게임의 종료여부를 묻는 기능은 어디 클래스에 있을때 가장 유지보수가 편할까??   이렇게 생각해보니, 게임 재시작과 종료 여부를 묻는 이 기능은 아예 BaseballGame과 독립된 클래스가 가져야할 기능 같았다.   그래서 이 기능은 프로그램 자체가 가져야 할 기능 같아서, Application 클래스에 추가하기로 했다.   RetryNumber 클래스  재시작 여부를 받을 숫자의 유효성 검사를 해주기 위해서 RetryNumber로 원시값인 int retryNumber를 포장해주었다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class RetryNumber {     private String retryNumber;      public RetryNumber(String retryNumber) {         isCorrectRetryNumber(retryNumber);         this.retryNumber = retryNumber;     }      public void isCorrectRetryNumber(String number) throws IllegalArgumentException {         if (number != Constant.GAME_RETRY_NUMBER || number == Constant.PROGRAM_END_NUMBER) {             throw new IllegalArgumentException();         }     } }  들어온 문자열이 “1” 이나 “2”가 아닌 경우는 IllegalArgumentException을 출력한다.   Application 클래스  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Application {     public static void main(String[] args) {         //TODO: 숫자 야구 게임 구현         do {             BaseballGame baseballGame = new BaseballGame();             baseballGame.start();         } while (askRetry());     }      public static boolean askRetry() {         RetryNumber retryNumber = new RetryNumber(InputView.getRetryNumber());          if (retryNumber.getRetryNumber() == Constant.GAME_RETRY_NUMBER) {             return true;         }         return false;     } }   askRetry() 메서드를 만들어 앞서 만든 retryNumber에 값을 받아 처리하도록 한다.   만약 retryNumber 가 1이라면 재시작, 아니라면 게임을 종료한다.   이로써 모든 프로그램 구현이 완료되었다.   테스트도 모두 통과했고, 내가 직접 프로그램을 돌려 잘 작동 하는 것을 확인 하였다.   아쉬운점  첫번째로는 깃, 커밋을 이렇게 기능단위로 해본적이 없어서 초반에 좀 엉망진창 커밋이 됐는데, 다음 과제 때는 정말 완벽하고 깔끔하게 해보고싶다.  두번째로는 TDD 사실 이건 너무 무리해서 초반부터 적용해보려 했으나, 아예 구조를 어떻게 짜야 할지 상상이 안돼서 처음에는 해보다가 나중에는 적용하지 못했다. 다음 과제부터는 TDD를 제대로 해서 코드를 짜보고 싶다.   느낀점…  진짜 이렇게 간단한 프로그램에 이렇게 시간을 쏟아본적이 처음이다.   코드를 하나 작성하기 전에 기본 최소 30분 이상씩은 고민만 하다가 코드를 작성하느라 너무너무 시간이 오래걸렸다. 5일 가량 동안 거의 30시간에 가까운 시간을 투자해서 작성을 완료했다.   처음에는 구조를 짜는데에 굉장히 많은 시간을 투자했다. 어떤 기준으로 패키지를 나누고 기능을 나눠야 할지 정해져야 좋은 코드가 나올 것같아서 mvc패턴에 대해 공부하고, 클래스 분리와 메소드 분리를 하는데만 이틀을 넘게 쓴것 같다.   지금 생각해보면 무작정 기능만 돌아가게 작성하고 리팩토링하는게 훨씬 속도가 빨랐겠다는 생각이 들지만, 5일동안 머리를 싸매고 좋은 코드란 무엇인가에 대해 고민하는 시간이 재밌었다.   이렇게 열심히 작성한 코드를 1대1 피드백을 못받는게 너무나 아쉽다. 아직도 궁금하고 모호한게 너무 많아서 만약에 우테코에 못가더라도 꼭 수준있는 사람을 수소문해서 코드 리뷰를 받아보고 싶다.   이번 기회를 통해 클린코드가 중요하다는건 알고있었지만, 직접 클린코드에 대해서만 머리를 싸매보면서 클린코드가 ‘왜’ 중요한지를 절실하게 깨달을 수 있는 순간이었고, 앞으로도 어떤 언어로 어떤 일을 하던간에 이 개념은 평생 갈고 닦을 생각이다.  힘들고 처음에는 너무 막막했지만, 한편으로는 뭔가에 집착해서 이렇게 노력하는 과정이 너무나 즐거웠다. 마지막에는 거의 내가 변태가 된것 마냥 불편한점들을 쥐잡듯이 찾아다니는 모습을 보며, 깊은 뿌듯함을 느끼기도 했다.   첫번째 과제만에 이렇게 큰 성장을 이뤘는데 3주가 지나면 얼마나 더 성장해있을지 기대된다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-1%EC%A3%BC%EC%B0%A8-%EC%88%AB%EC%9E%90%EC%95%BC%EA%B5%AC-(2)/",
        "teaser": null
      },{
        "title": "[Java] 상속과 인터페이스",
        "excerpt":"시작하며…  다음 과제까지 어떤걸 할까 고민하다가 자바의 스트림, 상속이나 인터페이스같은 걸 공부해보기로했다.           클린하게 코드를 작성하려면 좀더 자바의 기능들을 사용해야 복잡한 코드를 자바의 기능하나로 대체 할 수 있다는 생각에,         다음과제에서 사용할 수 있는 여러가지 기능들을 미리 익히기로 했다.   먼저 공부 할 것은 상속과 인터페이스이다.   공부 했던 내용들이지만 또 막상 실제 구현에서 사용하려니 확 와닿지가 않아서, 다시 복습해보려한다.   상속  상속이란?  상속은 객체지향 프로그래밍의 중요한 특징으로, 우리가 아는 상속의 의미와 동일하게 자식에게 물려주는걸 말한다.       예를들어 B클래스가 A클래스를 상속받으면, A클래스의 멤버변수와 메서드를 사용할 수 있게 되는 것이다.   객체 지향프로그램의 장점은 유지보수가 간편한 것인데, 이것의 기반이 되는 기술이 바로 상속이다.   이전에 공부했던 내용     전에 작성했던 상속에 관한 내용    상속이 어떤 기능인지는 공부했지만, 정확히 어떤 상황에서 상속을 통해 클린코드를 작성할 수 있는지 생각해보지 않았다.   이런 상속이라는 기능을 어떻게 사용하면 코드를 줄일 수 있는지에 대한 예제가 넥스트 스텝 클린코드에 있어서 한번 따라해보았다.   커피와 차라는 두개의 객체를 각각 Coffee, Tea로 구현해보자.  상속 예제   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Coffee {     void prepareRecipe() {         boilWater();         brewCoffeeGrinds();         pourInCup();         addSugarAndMilk();     }      public void boilWater() {         System.out.println(\"물을 끓인다.\");     }      public void brewCoffeeGrinds() {         System.out.println(\"필터를 활용해 커피를 내린다.\");     }      public void pourInCup() {         System.out.println(\"컵에 붓는다.\");     }      public void addSugarAndMilk() {         System.out.println(\"설탕과 우유를 추가한다.\");     } }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class Tea {     void prepareRecipe() {         boilWater();         steepTeaBag();         pourInCup();         addLemon();     }      public void boilWater() {         System.out.println(\"물을 끓인다.\");     }      public void steepTeaBag() {         System.out.println(\"티백을 담근다.\");     }      public void pourInCup() {         System.out.println(\"컵에 붓는다.\");     }      public void addLemon() {         System.out.println(\"레몬을 추가한다.\");     } }  이 클래스들은 prepareRecipe() 메서드를 사용하면 각각의 레시피대로 음료를 만들기 시작한다.   지금 코드를 보면 중복된 메서드가 두개 있는데, boilWater()와 PourInCup() 두 메서드는 이름과 기능이 모두 동일하다.   바로 이런경우에 상속을 사용해서 중복을 제거해 줄 수 있다.         두 음료 모두 카페인을 가진 음료이므로, CaffeineBeverage라는 클래스를 만들어, 두 클래스에 상속해주도록 해보자.  1 2 3 4 5 6 7 8 9 public class CaffeineBeverage {     protected void boilWater() {         System.out.println(\"물을 끓인다.\");     }      protected void pourInCup() {         System.out.println(\"컵에 붓는다.\");     } }  두 메서드를 묶어 CaffeieBeverage라는 클래스로 만들어 주었으니, 두 클래스의 중복된 메서드를 지우고          새로만든 클래스를 상속해주자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Coffee extends CaffeineBeverage {     void prepareRecipe() {         boilWater();         brewCoffeeGrinds();         pourInCup();         addSugarAndMilk();     }      public void brewCoffeeGrinds() {         System.out.println(\"필터를 활용해 커피를 내린다.\");     }      public void addSugarAndMilk() {         System.out.println(\"설탕과 우유를 추가한다.\");     } }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Tea extends CaffeineBeverage {     void prepareRecipe() {         boilWater();         steepTeaBag();         pourInCup();         addLemon();     }      public void steepTeaBag() {         System.out.println(\"티백을 담근다.\");     }      public void addLemon() {         System.out.println(\"레몬을 추가한다.\");     } }  두 클래스 모두 extends를 사용하여 새로만든 클래스를 상속해주었다.         이제 CaffeineBeverage라는 큰 범주안에 Coffee와 Tea가 존재하게 된다.         이 두클래스는 따로 작성을 하지 않아도 상위클래스의 멤버변수와 메서드를 사용할 수 있다.   그럼 이제 또 중복되는 부분을 제거해주어야 하는데, prepareRecipe()가 두 클래스모두 비슷한 기능을 갖고있지만        두 메서드가 서로 이름이 달라 prepareRecipe()를 CaffeineBeverage로 옮겨 줄 수는 없다.   이럴때 필요한게 바로 추상화인데, 두기능이 비슷한 역할을 한다면 기능을 조금 더 추상화 해서 같은 이름의 메서드로 관리해주면,         상속을 통해 중복을 더 제거 할 수 있다.   두 메서드는 각각 물을 끓인 후, brewCoffeeGrind()와 steepTeaBag()의 과정을 거치는데, 두 행위 모두 재료가 다를 뿐 물에 무언가를 우려낸다는 기능은 같다.           따라서 이 메서드의 이름을 brew()로 통일 해줄 수 있을 것이다.   또, 마지막 부분에 있는 addSugarAndMink()와 addLemon() 메서드도 위와 동일하게 재료만 다를 뿐 추가한다는 기능은 같으므로,         이 메서드는 addCondiments()로 통일 해 줄 수 있다.   이렇게 하면 이제 prepareRecipe() 메서드가 두 클래스 모두 완전히 동일해졌으므로, 이 메서드를 CaffeineBeverage에 상속해 줄 수 있게 되었다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public abstract class CaffeineBeverage {     void prepareRecipe() {         boilWater();         brew();         pourInCup();         addCondiments();     }          protected void boilWater() {         System.out.println(\"물을 끓인다.\");     }      protected void pourInCup() {         System.out.println(\"컵에 붓는다.\");     } }  하지만 이렇게 코드를 작성하면 오류가 발생한다. prepareRecipe() 안에 있는 brew()와 addCondiments()메서드를 이 클래스는 갖고있지 않기 떄문에          두 메서드가 오류를 일으킨다. 하지만 이 두 메서드는 이름이 같을 뿐 메서드의 기능은 다르기 떄문에 이 두 메서드를 추가 해줄 수도 없다.   이럴 때 사용하는 것이 바로 추상 클래스 이다.   CaffeineBeverage를 추상클래스로 선언해주게 되면, 몸통이 없는 메서드인 추상 메서드 를 만들어 줄 수 있다.   아래의 예시를 보자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public abstract class CaffeineBeverage {     abstract void brew();          abstract void addCondiments();          void prepareRecipe() {         boilWater();         brew();         pourInCup();         addCondiments();     }          protected void boilWater() {         System.out.println(\"물을 끓인다.\");     }      protected void pourInCup() {         System.out.println(\"컵에 붓는다.\");     } }   abstract를 클래스 선언부에 선언 해준뒤, abstract로 메서드를 선언해주면, 위와같이 이름만 있는 함수를 사용할 수 있다.   이렇게 abstract 메서드를 선언해주면, 상속을 받는 클래스는 무조건 abstract 메서드와 동일한 이름의 메서드를 구현해주어야 한다.   1 2 3 4 5 6 7 8 9 10 public class Coffee extends CaffeineBeverage{      public void brew() {         System.out.println(\"필터를 활용해 커피를 내린다.\");     }      public void addCondiments() {         System.out.println(\"설탕과 우유를 추가한다.\");     } }  1 2 3 4 5 6 7 8 9 10 public class Tea extends CaffeineBeverage{      public void brew() {         System.out.println(\"티백을 담근다.\");     }      public void addCondiments() {         System.out.println(\"레몬을 추가한다.\");     } }   이렇게 추상화 클래스를 사용하면, 중복을 최대한 제거 할 수 있다.   인터페이스  인터페이스란??   ###이전에 공부 했던 내용      전에 작성했던 인터페이스에 관한 내용    하나의 시스템을 구성하는 2개의 구성 요소 (하드웨어, 소프트웨어) 또는 2개의 시스템이 상호 작용할 수 있도록        접속되는 경계 (Boundary), 이 경계에서 상호 접속하기 위한 하드웨어, 소프트웨어, 조건, 규약 등을 포괄적으로 가리키는말이다.   말이 너무 어렵다…   예제를 통해 알아보자.   인터페이스를 이해하기 위한 예제  만약 우리가 MSSQL DB로 서비스를 시작했는데, 갑자기 사용자가 너무 늘어 비용을 감당할 수 없게 되었다고 가정해보자.         그래서 우리가 사용하는 DB를 무료 데이터베이스인 MySQL로 바꾸고 싶다.   이러한 경우, MSSQL에서만 작동하게 코드를 짜놨다면, MySQL로 DB를 변경하는데 많은 시간과 비용이 소모될 것이다.        또한 갑자기 많은 소스 코드가 변경 되면 서비스도 불안정해 질 수 밖에 없을 것이다.   따라서 이러한 문제를 사전에 방지 하도록 공통 부분을 추상화 해서 표준으로 만들어 놓은것을 “인터페이스” 라고 한다.   위의 경우는 DB연결이나 SQL쿼리 생성, 쿼리에 인자 전달과 같은 공통 기능들을 인터페이스로 만들어놓으면, 사용자가 이 인터페이스만 지켜준다면  추후에 DB가 변경되더라도 서로 호환이 되므로 소스 코드를 수정하지 않아도 된다.   위의 예시에는 다음과 같은 인터페이스들이 존재 할 것이다.   한마디로 어떠한 기능은 반드시 이런 모양의 클래스로 구현해야 한다고 강제해주는 가이드라인이자 설명서 라고 할 수 있다.   아래의 소스코드를 보자.   1 2 3 4 5 6 7 8 9 public interface Calc {     double PI = 3.14;     int ERROR = -99999999;          int add(int num1,int num2);     int substract(int num1, int num2);     int times(int num1, int num2);     int divide(int num1,int num2); }  위 코드는 계산기 프로그램에 대한 interface이다. interface 예약어를 사용한 것을 볼 수 있는데,           이렇게 하면 예약어를 명시하지 않아도 컴파일 과정에서 자동으로 추상메서드로 변환되고, 변수는 상수가 된다.   interface를 따르는 클래스는 implements 예약어를 사용하는데, 아래와 같이 사용한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class completeCalc implements Calc{          @Override     public int add(int num1, int num2) {         return num1 + num2;     }      @Override     public int substract(int num1, int num2) {         return num1 - num2;     }          @Override     public int times(int num1, int num2) {         return num1 * num2;     }      @Override     public int divide(int num1, int num2) {         if(num2 != 0)             return num1 / num2;         else             return Calc.ERROR;     }     public void showInfo(){         System.out.println(\"Calc 인터페이스 구현 완료\");     } }   implements를 사용해주고, interface에서 명시된 메서드 규칙에 따라서 메서드를 만들어주었다.        이렇게 하면 인터페이스 하나를 보고 모두 공통된 입출력을 갖는 메서드로 소스코드를 구성하게 되기 때문에, 호환성이 올라간다.   만약, 메서드를 전부 구현하지 않고 일부만 구현한다면 어떻게 될까?  1 2 3 4 5 6 7 8 9 10 11 public class Calculator implements Calc{     @Override     public int add(int num1, int num2) {         return num1 + num2;     }      @Override     public int substract(int num1, int num2) {         return num1 - num2;     } }  이 코드는 오류를 출력하는데, 인터페이스를 따랐지만 모든 메서드를 구현하지 않아서이다.   전부 구현하지 않았음으로 추상클래스가 되어 예약어 abstract를 추가해주어야 오류를 출력하지 않는다.   1 2 3 4 5 6 7 8 9 10 11 public abstract class Calculator implements Calc{     @Override     public int add(int num1, int num2) {         return num1 + num2;     }      @Override     public int substract(int num1, int num2) {         return num1 - num2;     } }   이러한 클래스는 다른 추상클래스와 마찬가지로 상속해서 사용할 수 있다.   이 클래스를 상속해서 위에서 구현한 CompleteCal 클래스를 만들어보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class CompleteCalc extends Calculator{       @Override     public int times(int num1, int num2) {         return num1 * num2;     }      @Override     public int divide(int num1, int num2) {         if(num2 != 0)             return num1 / num2;         else             return Calc.ERROR;     }        public void showInfo(){         System.out.println(\"Calc 인터페이스 구현 완료\");     } }  위의 클래스에서 인터페이스의 일부만 구현한 Calculator를 상속하고 나머지 부분을 구현해주면,       올바른 인터페이스 규칙을 따른것이므로 오류가 발생하지 않게된다.   만약 뭇시적 형변환을 사용하면 어떻게 될까?? 인터페이스 calc 형으로 CompletCalc를 형변환하여 선언해보자.   1 Calc calc = new CompleteCalc();   이렇게 되면 CompleteCalc는 Calc에 없는 메소드인 showInfo() 를 사용 할 수 없고 오직 인터페이스에서 선언한 메서드만 사용할 수 있게된다.   이것이 바로 인터페이스의 중요한 역할이다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%83%81%EC%86%8D%EA%B3%BC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[Java] 우테코 프리코스 2주차 - 자동차 경주 게임",
        "excerpt":"2주차 시작  2주차 과제가 또 시작됐다.          저번주에는 많이도 헤메고 힘들었지만, 그렇게 힘들었던 만큼 2주차 과제는 훨씬 수월하게 할 수 있을 것 같다!   이번에는 1주차 과제가 끝났고 공부했던 내용을 좀 더 적용해서 더 나은 코드를 작성 해보려고 한다.   그래서 코딩을 시작하기 전 규칙을 몇가지 세웠다.      한개 이상의 stream 사용하기   for문의 도배를 막아주고 훨씬 가독성 있는 코드를 쓸 수 있도록 도와준다.   enum 타입으로 상수 작성하기   상수를 단순히 final로 선언했는데, final은 enum 보다 안전하고, 또 클래스로 취급받기 떄문에 더욱 유용하게 사용할 수 있다.   TDD 적용해보기   프로그램 구현 시간 재보기   최종 코딩 테스트를 위해서…   기능 구현 목록 작성  사실 저번주에 의외로 시간이 많이 들고 막막했던게 이 부분이었는데, 확실히 두번째라 큰 부담없이 슥슥 작성했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 * 경주할 자동차들의 이름을 입력받는다.     * \"경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)\" 메시지를 출력한다.     * 자동차의 이름들을 쉼표로 분리해서 받는다.     * 만약 자동차의 이름이 5글자가 넘으면 예외를 발생시키고 다시 값을 받는다.         * 예외상황 시 [Error]로 시작하는 해당 상황에 맞는 에러 문구를 출력해야 한다.          * 시도할 횟수를 입력받는다.     * \"시도할 회수는 몇회인가요?\" 메시지를 출력한다.     * 숫자외에 다른 문자열이 들어오면 예외를 발생시키도 다시 값을 받는다.         * 예외상황 시 [Error]로 시작하는 해당 상황에 맞는 에러 문구를 출력해야 한다.          * 자동차는 입력받은 횟수만큼 차례로 난수를 생성한다.     * 생성한 난수가 4 이상일 경우 전진, 미만일 경우 멈춰있는다.      * 매 회차마다 자동차는 자기가 간 거리만큼을 '-'로 표시해서 사용자에게 출력해준다.  * 모든 회차가 종료되면 가장 먼 거리를 이동한 우승자를 출력한다.     * 우승자는 여러명일 수 있다.    기능 구현을 목록을 작성하다보니, 컨벤션에도 제약사항이 늘어나고 Car라는 객체에도 제약이 생기는 등 제약사항은 늘었지만,  기능 자체는 구현이 숫자야구보다 쉬울 것 같다는 생각이 들었다.   이번에는 꼭 기능 구현대로 커밋을 좀 더 꼼꼼히 해보자는 생각을 했다!!   경주할 자동차들의 이름을 입력받는다.  테스트 코드 작성   첫번째 기능은 5글자 넘어가는 예외만 잘 처리해주는지 확인하면 될 것 같았다.   그래서 간단하게 아래와 같이 테스트 코드를 작성해보았다.   1 2 3 4 5 6 7  @Test  void 자동차_이름에_대한_예외_출력테스트() {         assertThatThrownBy(() -&gt; {             cars.addCar(\"pobi,minjaea\");         })                 .isInstanceOf(IllegalArgumentException.class);     }   “경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)” 메시지를 출력한다.   출력이니까 OutputView를 만들어서 추가해주었다.          중요한 점은 시스템 메시지인 상수를 enum 타입을 선언해보는 것이다.   1 2 3 4 5 6 7 8 9 10 11 12 13 public enum SystemMessage {     SET_CAR_NAME_MESSAGE(\"경주할 자동차 이름을 입력하세요.(이름은 쉼표(,) 기준으로 구분)\");      private final String message;      SystemMessage(String message) {         this.message = message;     }      public String print() {         return message;     } }  이렇게 enum을 이용해서 SystemMessage라는 클래스를 만들어서 상수를 선언해주었다.   메시지 출력 메소드는 사용자가 보는 화면이므로 View 패키지의 OutputView에 작성해주었다.   1 2 3 4 5 public class OutputView {     public static void printSetCarNameMessage(){         System.out.println(SystemMessage.SET_CAR_NAME_MESSAGE.print());     } }   자동차의 이름들을 쉼표로 분리해서 받는다.   먼저 InputView에 자동차 이름을 문자열로 받도록 해주었다.  1 2 3 4 5 public class InputView {     public String getCarName(){         return Console.readLine();     } }  이렇게 하고보니까 쉼표를 기준으로 분리한 문자열로 각각의 Car 객체를 만들어주어야 하는데,  Cars 라는 Car들이 모인 집단을 하나의 객체로 새로 만들어서 Car에서는 각각의 이름의 유효성 검사를 하는게 맞을 것 같았다.   라고 생각했는데, Car에다가 유효성 검사를 추가하려 했더니 이런 규칙이 있었다…      Car 기본 생성자를 추가할 수 없다.    1 2 3     public Car(String name) {         this.name = name;     }      이 생성자를 변경 할 수가 없었다. 내가 생각하기에는 차의 이름의 유효성인데 차에서 하는게 맞지않을까?? 생각했지만,       규칙을 지키기 위해서 Cars에서 유효성 검사를 해서 예외를 발생시키기로 했다.    1 2 3 4 5 6 7 8 9 public class Cars {     CarList carList = new CarList();      public void addCar(String carNames){         for (String carName : carNames.split(\",\")) {             carList.add(carName);         }     } }  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class CarList {     List&lt;Car&gt; carList = new ArrayList&lt;Car&gt;();      public void add(String carName) throws IllegalArgumentException {         carNameValidation(carName);         carList.add(new Car(carName));     }      public void carNameValidation(String carName) throws IllegalArgumentException {         isNull(carName);         isOverSizeCarName(carName);     }      public static void isOverSizeCarName(String carName) throws IllegalArgumentException {         if (carName.length() &gt; Constant.CAR_NAME_MAX_SIZE.value()) {             throw new IllegalArgumentException();         }     }      public static void isNull(String carName) throws IllegalArgumentException {         if (carName.isEmpty()){             throw new IllegalArgumentException();         }     } }   Car객체를 담는 CarList를 일급 컬렉션으로 따로 만들어주었다. 이 CarList 자료형은 자동차의 이름이 5글자 이상이거나, 자동차의 이름을  입력하지 않으면 예외를 출력한다.   이렇게 CarList로 일급컬렉션을 만들고나니, Car 생성자에 왜 추가를 하지 말라고 했는지 이해가 갔다. 결국 Cars에 이름 개수만큼의 Car를 만들으려면         이를 담는 리스트가 필요할텐데, Car에서 이 이름을 유효성 검사하는 것보다 여기서 이름에 대한 유효성을 아예 검사하고 추가하는 자료형을 따로 만들어주는게 더 맞는 것 같았다.   예외상황 시 [Error]로 시작하는 해당 상황에 맞는 에러 문구를 출력하고 다시 값을 받는다.   CarList 객체에서 throws한 IllegalArgumentException 예외를 catch해서 처리 해주어야 한다.  에러 메시지도 출력해주어야 했는데, 이 메시지를 OutputView에 따로 넣어서 출력하게 되면, Model이 View에 의존하는 코드가 나오게 되서 Exception 자체에 메시지를 주고 이를 출력하도록 했다.   먼저 ErrorMessage 라는 Enum을 하나 만들어주고,  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 package racingcar.constant;  public enum ErrorMessage {     CAR_NAME_OVER_SIZE_ERROR(\"[ERROR] 자동차 이름은 5글자를 넘을 수 없습니다.\"),     CAR_NAME_NULL_ERROR(\"[ERROR] 자동차의 이름을 입력하지 않았습니다.\");      private final String message;      ErrorMessage(String message) {         this.message = message;     }      public String print() {         return message;     } }   그리고 CarList에 있는 유효성을 검사하는 아래 코드에서,   1 2 3 4 5 6 7 8 9 10 11 public static void isOverSizeCarName(String carName) throws IllegalArgumentException {         if (carName.length() &gt; Constant.CAR_NAME_MAX_SIZE.value()) {             throw new IllegalArgumentException(ErrorMessage.CAR_NAME_OVER_SIZE_ERROR.print());         }     }      public static void isNull(String carName) throws IllegalArgumentException {         if (carName.isEmpty()){             throw new IllegalArgumentException(ErrorMessage.CAR_NAME_NULL_ERROR.print());         }     }  이렇게 예외를 검사하는 두 메서드가 만드는 예외에 메시지를 넣어주고 이걸 getMessage()를 사용해서 출력해주기로 했다.   그래서 여기까지 완성한 차들의 입력을 받고 처리하는 기능까지를 CarRacingGame이라는 Controller를 만들어서 구현해주기로 했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class CarRacingGame {     public void start() {         Cars cars = new Cars();         setCarsName(cars);     }      public void setCarsName(Cars cars){         try{             cars.addCar(InputView.printSetCarsNameMessage());         }catch (IllegalArgumentException e){             OutputView.printErrorMessage(e);             setCarsName(cars);         }     } }  setCarsName은 예외를 발생하면 에러 메시지를 출력하고 다시 입력을 받는다.   이 메서드를 구현하면서 While을 이용하는 방식과 재귀함수를 이용하는 방식 두가지를 놓고 고민했는데,   While의 경우는 구간만 반복하지만, 재귀 호출의 경우는 메서드를 새로 호출하고 해당 부분의 처리가 완료되면 남은 부분들을 처리하기 떄문에 성능면에서는 While이 낫다.   하지만 이 부분이 그렇게 성능면에서 중요한 메서드가 아닐뿐더러, 두 코드를 놓고 봤을 때 재귀함수를 쓰는게 가독성에서 압도적으로 높았다.   따라서 클린 코드를 작성하는게 가장 중요한 과제인만큼 이 부분에서는 재귀함수를 사용하는게 맞다는 결론을 내렸다.   시도할 횟수를 입력받는다.  테스트 코드  시도할 횟수의 유효성을 만족 못할시 IllegalArgumentException 예외를 제대로 발생시키는지만 확인하면 될 것같다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class TryNumberTest {      private TryNumber tryNumber;      @BeforeEach     void SetUp(){         tryNumber = new TryNumber();     }      @Test     void 시도할_횟수_유효성_테스트() {         assertThatThrownBy(() -&gt; {             tryNumber.getTryNumber(\"as\");         }).isInstanceOf(IllegalArgumentException.class);     } }  TryNumber로 따로 시도 횟수를 클래스로 만들어 관리할 예정이기 때문에 위와 같이 테스트 코드를 작성하였다.   시도할 회수는 몇회인가요?” 메시지를 출력한다.  1 2 3 4 5 6 7 8 9 10 11 public class InputView {     public static String printSetCarsNameMessage() {         System.out.println(SystemMessage.GET_CAR_NAME_MESSAGE.print());         return Console.readLine();     }      public static String printGetTryNumberMessage() {         System.out.println(SystemMessage.GET_TRY_NUMBER_MESSAGE.print());         return Console.readLine();     } }  마찬가지로 InputView에 메시지 출력과 함께 입력을 받도록 구현하였다.   이제 TryNumber라는 클래스를 따로 만들어서 Cars의 클래스 변수로 사용할 수 있도록 해주자   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public class TryNumber {     private String tryNumber;      public String getTryNumber() {         return tryNumber;     }      public void setTryNumber(String tryNumber) throws IllegalArgumentException {         tryNumberValidation(tryNumber);         this.tryNumber = tryNumber;     }      public void tryNumberValidation(String tryNumber) {         isDigitString(tryNumber);         isNull(tryNumber);     }      public void isDigitString(String tryNumber) throws IllegalArgumentException {         for (int i = 0; i &lt; tryNumber.length(); i++) {             isDigitChar(tryNumber.charAt(i));         }     }      public void isDigitChar(char tryNum) throws IllegalArgumentException {         if (!Character.isDigit(tryNum)) {             throw new IllegalArgumentException(ErrorMessage.TRY_NUM_NOT_DIGIT_ERROR.print());         }     }      public static void isNull(String tryNumber) throws IllegalArgumentException {         if (tryNumber.isEmpty()) {             throw new IllegalArgumentException(ErrorMessage.TRY_NUM_NULL_ERROR.print());         }     } }   TryNumber는 들어온 문자열이 숫자가 아닌 문자가 섞여있거나 빈칸이라면 예외를 출력한다.   테스트 케이스를 모두 만족하는걸 확인했으니, 기능적으로 작동하도록 CarRacingGame 컨트롤러에 기능을 추가해주었다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class CarRacingGame {     public void start() {         Cars cars = new Cars();          setCarsName(cars);         setTryNumber(cars);     }      public void setCarsName(Cars cars) {         try {             cars.addCar(InputView.printSetCarsNameMessage());         } catch (IllegalArgumentException e) {             OutputView.printErrorMessage(e);             setCarsName(cars);         }     }      public void setTryNumber(Cars cars) {         try {             cars.setTryNumber(InputView.printSetTryNumberMessage());         } catch (IllegalArgumentException e) {             OutputView.printErrorMessage(e);             setTryNumber(cars);         }     } }  setCarsName과 마찬가지로 재귀함수로 예외가 발생하면 다시 입력을 받도록 해주었다.   여기까지 구현 후 테스트 코드 역시 통과를 완료했다.   그럼 이제 입력값들을 받고 유효성 검사를 완료하도록 했으니, 본격적으로 게임내의 기능을 구현해보자.   자동차는 난수를 생성한다.  생성한 난수가 4 이상일 경우 전진, 미만일 경우 멈춘다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 public void SelectMoveOrStop() {     if (generateRandomNumber() &gt; 3){         Move();     }@!! }  public int generateRandomNumber() {     return Randoms.pickNumberInRange(Constant.RANDOM_NUMBER_MIN_SIZE.value(),             Constant.RANDOM_NUMBER_MAX_SIZE.value()); }  public void Move(){     this.position++; }  Car 클래스에 난수를 뽑아 전진할지 정지해있을지 정하는 메서드들을 만들어주었다.   매 회차마다 자동차는 난수를 생성하고, 그 결과에 따라 자기가 간 거리만큼을 ‘-‘로 표시해서 사용자에게 출력해준다.  1 2 3 4 5  public static void printCarPosition(int carPosition) {         for (int i = 0; i &lt; carPosition; i++) {             System.out.print(\"-\");         }     }  carPosition의 개수만큼 “-“를 출력하는 메서드를 OutputView에 만들어주었다.   이제 CarRacingGame 컨트롤러로 가서, 모델과 뷰를 이어주었다.   1 2 3 4 5 6 7 8 9  public void printCarsPosition(Cars cars) {         for (Car car : cars.getCarList()) {             car.SelectMoveOrStop();             OutputView.printCarName(car.getName());             OutputView.printCarPosition(car.getPosition());             OutputView.printSpace();         }         OutputView.printSpace();     }  먼저 printCarsPosition을 통해서 carList에 있는 차들의 이름과 포지션 만큼의 “-“ 기호를 출력하고,   1 2 3 4 5 public void printAllTry(Cars cars) {         for (int i = 0; cars.getTryNumber() &gt; i; i++) {             printCarsPosition(cars);         }     }  printAllTry 메서드를 통해 모든 시도를 출력하도록 했다.   우승자를 출력한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public int getCarsPosition(){         List&lt;Integer&gt; carPositionList = new ArrayList&lt;Integer&gt;();         for (Car car : carList.getCarList()){             carPositionList.add(car.getPosition());         }         return Collections.max(carPositionList);     }      public String getWinner(int maxPosition){         List&lt;String&gt; winnerList = new ArrayList&lt;String&gt;();          for (Car car : carList.getCarList()){             if (maxPosition == car.getPosition()){                 winnerList.add(car.getName());             }         }        return String.join(\", \",winnerList);     }  Cars 클래스에 모든 차들의 Position을 가져오고, 그 포지션을 바탕으로 maxPosition을 구한 뒤,        이 maxPosition과 같은 포지션 값을 갖는 Car들의 이름을 문자열로 반환해 준다.   이렇게 구현한 메서드들을 CarRacingGame 클래스에서 View와 이어주면 모든 구현이 끝이난다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private void printCarsPosition(Cars cars) {         for (Car car : cars.getCarList()) {             car.SelectMoveOrStop();             OutputView.printCarName(car.getName());             OutputView.printCarPosition(car.getPosition());             OutputView.printSpace();         }         OutputView.printSpace();     }      private void printWinner(Cars cars) {         OutputView.printWinner(getWinner(cars));     }      private String getWinner(Cars cars) {         return cars.getWinner(cars.getCarsPosition());     }   2주차 후기  확실히 1주차보다 개념이 많이 정리되어서 그런지 코드를 빠르게 써내려가는 내 모습이 만족스러웠다!           최종 코딩테스트 대비를 위해서 시간도 재고 풀었는데 5시간 반 정도만에 모든 코드를 구현하고 리팩토링을 마칠 수 있었다.   물론 최종 코딩테스트는 2주차 과제보다 난이도가 더 높겠지만, 남은 시간동안 열심히 한다면   충분히 5시간안에 구현을 모두 완료할 수 있을것 같다는 자신감이 생겼다.   하지만 역시 이번 과제를 하면서 몇가지 의문점과 함께 아쉬운점이 몇가지 있는데, 우선 1주차 과제 후 상속과 스트림을 공부해서       꼭 실제 과제에 적용시켜보자고 생각했는데, 딱히 상속이나 스트림을 사용할만한 부분이 없어 사용하지 못했다.       내가 실력이 부족해서 위의 두 기능을 사용하면 더 깔끔해질 코드인데 발견을 못한건지, 애초에 기능 자체가 상속과 스트림을 사용하기 애매한        가능인지는 모르겠지만 배운 걸 바로 꼭 써보고 싶은 마음이었는데 아쉬웠다.   또, 새로 공부한 enum을 적용해서 상수값들을 관리하는 클래스를 만들어봤는데, 상수를 과연 이렇게 모아놓는 것이 효율적인지, 각 클래스에서 사용할때마다   위에 선언해주는게 효율적인지에 대한 고민이 생겼다. 처음에는 단순하게 클래스로 따로 모아서 이를 관리하면, 어떤 메시지를 바꾸고 싶을때 클래스의 위치를 찾을 필요없이 바로 내가 만들어준         SystemMessage 클래스에서 수정하면 되고, 모든 상수값을 한 클래스에서 관리하기 떄문에 같은 상수를 사용하는 클래스가 있다면 중복 코드 없이 클래스에서 가져다 쓸 수 있어         당연히 클래스로 따로 모아서 관리 하는게 효율적이라고 생각했는데, 다른 사람들이 클래스내에 상수를 선언하는걸 많이 보기도 했고,             사용하는 클래스 자체에서 관리하게 되면, 클래스 기능을 읽다가 바로 상수를 확인 할 수 있으니 유지보수가 더 편한건가? 라는 의문이 들어서 많은 고민을 했다.   그래도 내가 판단하기에는 전자의 장점이 더 많다고 생각해서 우선은 enum으로 상수들을 선언해서 constant 패키지에서 관리 하는걸로 제출하긴 했다. 물론 내가 아직 아는게 적어 후자가 더 많은 장점을 가질 수도 있지만, 우선 지금까지의 내가 공부한 내용으로 판단한 답을 내보기로 했다.   2주차는 생각보다 빠르게 과제가 끝나서, 3주차 과제 전에 비슷한 다른 프로젝트를 하나 더 구현해보고 리팩토링 해볼 생각이다.  다른 시험과 다르게 코딩테스트가 너무너무 기다려진다. 최종 코딩 테스트는 제발 오프라인에서 했으면… 거기서 코딩테스트를 보면 뭔가 동기부여가 확실히 되서             집에서 할때보다 한 두배는 더 열정적으로 불타오를 것 같은 느낌이 든다.   남은 기간도 화이팅 또 화이팅!   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-2%EC%A3%BC%EC%B0%A8-%EC%9E%90%EB%8F%99%EC%B0%A8-%EA%B2%BD%EC%A3%BC-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[Java] 람다와 스트림",
        "excerpt":"시작하며…  3주차 과제가 시작하기 전에 좀 더 연습해보기 위해 우테코 지난 프리코스에 진행했던 블랙잭 프로그램을 구현해보기로 했다.            저번 기수는 지하철 노선도 구현이 나왔다고 해서 이번에도 지하철 노선 구현이 나올까봐 블랙잭 프로그램을 연습 과제로 정했다.   먼저 람다와 스트림을 저번 과제 때 적극적으로 사용하지 못해서 몇가지 람다와 스트림에 대한 문제를 해결해보고 연습과제를 시작해보려 한다.   람다  자바 8부터 적용된 기능으로, 람다식이 없던 자바 8 이전버젼에서는 인터페이스의 다형성을 사용하기위해서는             인터페이스를 만든 뒤, 인터페이스에 작성된 메서드를 익명 클래스로 선언해서 오버라이딩 해주어야했다.   하지만 람다식이 나온후로는 이를 간결하게 람다식으로 표현할 수 있게되었다.                그럼 아래 예제를 통해 중복된 코드를 제거하고 다른부분을 인터페이스 선언을 통해 먼저 오버라이딩하여 익명클래스로 사용해주고, 이를 람다식으로 바꿔보자.  익명 클래스를 람다로 전환     다음 테스트 코드에서 MoveStrategy에 대한 익명 클래스로 구현하고 있는데 람다를 적용해 구현한다.     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // nextstep.fp.CarTest의 이동, 정지 method public class CarTest {   @Test   public void 이동() {       Car car = new Car(\"pobi\", 0);       Car actual = car.move(new MoveStrategy() {           @Override           public boolean isMovable() {               return true;           }       });       assertEquals(new Car(\"pobi\", 1), actual);   }    @Test   public void 정지() {       Car car = new Car(\"pobi\", 0);       Car actual = car.move(new MoveStrategy() {           @Override           public boolean isMovable() {               return false;           }       });       assertEquals(new Car(\"pobi\", 0), actual);   } }          인터페이스인 MoveStrategy 에 FunctionalInterface 어노테이션을 선언해주고, 람다식을 사용해서 오버라이딩된  isMovable() 메서드를 대체해준다.       1 2 3 4 @FunctionalInterface public interface MoveStrategy {     boolean isMovable(); }  1 2 3 4 5 6 7 8 9 10 11 12 13 public class CarTest {     @Test     public void 이동() {         Car car = new Car(\"pobi\", 0);         assertThat(car.move(()-&gt; true)).isEqualTo(new Car(\"pobi\", 1));     }      @Test     public void 정지() {         Car car = new Car(\"pobi\", 0);         assertThat(car.move(()-&gt; false)).isEqualTo(new Car(\"pobi\", 0));     } }  람다식을 사용한 후가 코드의 가독성이나 복잡도가 훨씬 개선된 것을 볼 수 있다.   람다를 활용해 중복 제거  1 2 3 4 5 6 7 8 9 10 // nextstep.fp.Lambda의 sumAll method List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);  public int sumAll(List&lt;Integer&gt; numbers) {     int total = 0;     for (int number : numbers) {         total += number;     }     return total; }  1 2 3 4 5 6 7 8 9 10 11 12 // nextstep.fp.Lambda의 sumAllEven method List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);  public int sumAllEven(List&lt;Integer&gt; numbers) {     int total = 0;     for (int number : numbers) {         if (number % 2 == 0) {             total += number;         }     }     return total; }  List에 담긴 값 중 3보다 큰 수만을 더해야 한다.  이 기능을 구현하려고 보니 앞의 요구사항 1,2와 많은 중복이 발생한다. 람다를 활용해 중복을 제거한다.   // nextstep.fp.Lambda의 sumAll, sumAllEven, sumAllOverThree method 소스 코드를 확인하고 중복 제거한다.   힌트      변경되는 부분과 변경되지 않는 부분의 코드를 분리한다.   변경되는 부분을 인터페이스로 추출한다.   인터페이스에 대한 구현체를 익명 클래스(anonymous class)로 구현해 메소드의 인자로 전달한다.   구글에서 자바의 익명 클래스로 검색해 익명 클래스가 무엇인지 학습한다.   인터페이스는 다음과 같은 형태로 추출할 수 있다.     1 2 3 public interface Conditional {   boolean test(Integer number); }           Conditional을 활용해 공통 메소드의 구조는 다음과 같다.     1 2 3 4 public int sumAll(List&lt;Integer&gt; numbers,   Conditional c) {   // c.test(number)를 활용해 구현할 수 있다. }           익명 클래스를 자바 8의 람다를 활용해 구현한다.   우선 sumAll만 남기고 sumAllEven, sumAllOverThree 메서드를 지워주었다.   sumAll의 코드에서 if 문의 조건문을 제외한 코드가 중복되므로, if문의 조건문을 지워준다.   1 2 3 4 5 6 7 8 9  public static int sumAll(List&lt;Integer&gt; numbers, Conditional conditional) {         int total = 0;         for (int number : numbers) {             if(){                 total += number;             }         }         return total;     }   이제 Conditional 이라는 인터페이스를 선언해주고, 인터페이스에서 test라는 boolean을 반환하는 메서드를 하나 선언한다.  1 2 3 4 @FunctionalInterface public interface Conditional {     boolean test(Integer number); }  그리고 if문의 조건문을 Conditional 클래스의 test메서드로 채워준다.  1 2 3 4 5 6 7 8 9  public static int sumAll(List&lt;Integer&gt; numbers, Conditional conditional) {         int total = 0;         for (int number : numbers) {             if(Conditonal.test(number){                 total += number;             }         }         return total;     }   이제 lambdaTest 코드로 이동해서 sumAll메서드 하나로 기존의 sumEvenAll과 sumAllOverThree 메서드가 있던  테스트코드를 모두 통과하도록 익명 클래스를 작성해주자.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Test public void sumAll() throws Exception {     int sum = Lambda.sumAll(numbers, new Conditional() {         @Override         public boolean test(Integer number) {             return true;         }     });     assertThat(sum).isEqualTo(21); }  @Test public void sumAllEven() throws Exception {     int sum = Lambda.sumAll(numbers, new Conditional() {         @Override         public boolean test(Integer number) {             return number % 2 == 0;         }     });     assertThat(sum).isEqualTo(12); }  @Test public void sumAllOverThree() throws Exception {     int sum = Lambda.sumAll(numbers, new Conditional() {         @Override         public boolean test(Integer number) {             return number &gt; 3;         }     });     assertThat(sum).isEqualTo(15); }  이를 간소화 하여 람다식으로 표현해주면 아래와 같다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void sumAll() throws Exception {     int sum = Lambda.sumAll(numbers, (Integer number) -&gt; true);     assertThat(sum).isEqualTo(21); }  @Test public void sumAllEven() throws Exception {     int sum = Lambda.sumAll(numbers, (Integer number) -&gt; number % 2 == 0);     assertThat(sum).isEqualTo(12); }  @Test public void sumAllOverThree() throws Exception {     int sum = Lambda.sumAll(numbers, (Integer number) -&gt; number &gt; 3);2     assertThat(sum).isEqualTo(15); }  익명 클래스를 사용했을때에 비해서 코드량도 훨씬 줄었을 뿐더러 가독성도 월등하게 좋아진 것을 확인할 수 있다.   스트림  스트림도 람다와 함께 마찬가지로 자바8에서부터 추가된 기능으로, 스트림은 배열 또는 컬렉션 인스턴스를 더 간결하고, 유연하게 표현할 수록 도와주는 기능이다.   이름 그대로 데이터의 흐름에 관한 기능이며, 기존에는 배열이나 컬렉션을 다룰 때 for문 또는 foreach문으로 작성한 데이터 하나하나에 일일히  접근하면서 처리를 해주어야 했다면, 스트림을 사용하면 훨씬 더 간결하고 가독성있게 배열 또는 컬렉션 인스턴스를 조합하여 결과를 필터링하고 가공할 수 있다.        즉, 배열과 컬렉션을 함수형으로 처리할 수 있게 된다.   또, 병렬처리가 가능하여 하나의 작업을 여러개로 잘게 나눠서 처리가 가능하다는 장점이있다.   스트림을 사용하는 방법은 크게 세 단계로 나눌 수 있는데,   생성하기 : 스트림 인스턴스 생성.  가공하기 : 필터링(filtering) 및 맵핑(mapping) 등 원하는 결과를 만들어가는 중간 작업(intermediate operations).  결과 만들기 : 최종적으로 결과를 만들어내는 작업(terminal operations).   이 순서대로 원하는 처리를 원하는 메서드를 나열해주면 된다.   스트림을 사용하기 위해선 배열이나 컬렉션을 스트림 자료형으로 변환해주어야 한다.   만약 String 배열 형태인 {“a”,”b”,”c”}로 이루어진 arr배열이 있다면 다음과 같이 스트림으로 변환해 줄 수 있다.  1 2 3 4 String[] arr = new String[]{\"a\", \"b\", \"c\"}; Stream&lt;String&gt; stream = Arrays.stream(arr); Stream&lt;String&gt; streamOfArrayPart =    Arrays.stream(arr, 1, 3); // 1~2 요소 [b, c]   컬렉션 타입 (List,Set,Collection)의 경우는 뒤에 .stream() 메서드를 사용함으로써 스트림으로 변환해 줄 수 있다.  1 2 List&lt;String&gt; list = Arrays.asList(\"a\", \"b\", \"c\"); Stream&lt;String&gt; stream = list.stream();   이렇게 만들어준 스트림을 가공해주는데, 가장 많이 사용하는 메서드의 예제를 한번 보도록 하자.   map, filter, reduce  filter  1 2 3 4 5 6 7 8 9 10 // nextstep.fp.StreamStudy countWords method  String contents = new String(Files.readAllBytes(   Paths.get(\"../ war-and-peace.txt\")), StandardCharsets.UTF_8); List&lt;String&gt; words = Arrays.asList(contents.split(\"[\\\\P{L}]+\"));  long count = 0; for (String w : words) {   if (w.length() &gt; 12) count++;   }  이 코드는 resource.txt 파일에 있는 문자 중 길이가 12자리가 넘는 문자의 수를 구한다.   words를 for문으로 하나씩 접근해 count를 1씩 증가시키고 있는데, 이를 스트림으로 변환하여 filter메서드를 사용하면 더 간결하게 나타낼 수 있다.   1 2 3 4 5 6 String contents = new String(Files.readAllBytes(   Paths.get(\"../alice.txt\")), StandardCharsets.UTF_8); List&lt;String&gt; words = Arrays.asList(contents.split(\"[\\\\P{L}]+\"));  long count =    words.stream().filter(w -&gt; w.length() &gt; 12).count();  이처럼 filter는 람다식을 매개변수로 받아 조건을 충족하는 요소만을 반환해준다.           이렇게 반환한 요소들에 count메서드를 사용해주면 해당 조건을 충족하는 요소의 개수를 알 수 있다.   map  1 2 3 4 5 6 // nextstep.fp.StreamStudy 클래스의 doubleNumbers method 참고 List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6); List&lt;Integer&gt; doubleNumbers = ArrayList&lt;Integer&gt;(); for (int number : numbers) {     doubleNumbers.add(number * 2); }  위 코드는 (1,2,3,4,5,6)으로 이루어진 numbers 리스트의 모든 요소를 두배한 새로운 리스트를 만드는 코드이다.            이 코드또한 스트림을 사용하여 간결하게 만들어줄 수 있다.   요소의 형태를 변환하는 스트림 메서드로는 map을 사용해준다.   1 2 3 4 // nextstep.fp.StreamStudy 클래스의 doubleNumbers method 참고 List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6); List&lt;Integer&gt; dobuleNumbers =   numbers.stream().map(x -&gt; 2 * x).collect(Collectors.toList());  map()은 메서드로 람다식을 받아 요소들의 형태를 변환시켜준다. 이렇게 변환한 요소들을 리스트로 받고 싶다면,  collect() 메서드를 선언하고 매개변수로 원하는 형태로 변환하는 함수를 넣어주면 된다.   reduce  1 2 3 4 5 6 7 8 9 10 11 // nextstep.fp.StreamStudy 클래스의 sumAll method 참고  List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);    public static int sumAll(List&lt;Integer&gt; numbers) {         int total = 0;         for (int number : numbers) {             total += number;         }         return total;     }  위 메서드는 리스트의 모든값을 더해서 total로 반환한다. 이렇게 리스트의 모든값에 대한 연산을 해서 하나의 값으로 출력할때는 스트림의 reduce() 메서드를 사용하면   간편하게 값을 구할 수 있다.   1 2 3 4 5 6 7 // nextstep.fp.StreamStudy 클래스의 sumAll method 참고  List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);  public int sumAll(List&lt;Integer&gt; numbers) {     return numbers.stream().reduce(0, (x, y) -&gt; x + y); }  reduce() 메서드는 param으로 (total, n) -&gt; total + n가 전달되고, reduce는 a1, a2, a3, a4…의 stream을 a1 + a2 + a3 + a4…로 연산을 수행한다.  첫번째로 total=a1, n=a2가 되고, 두번째로 total=(a1+a2), n=a3가 되어 초깃값인 첫번째 파라미터를 total로 받아 모든 배열의 수를 초깃값에 차례 차례 더해서 숫자 하나로 반환한다.   초깃값이 0이라면, 다음과 같이 초깃값을 생략하여 표현할 수 도 있다.  1 Optional&lt;Integer&gt; numbers = numbers.reduce(Integer::sum);   map, reduce, filter 실습 1  List에 담긴 모든 숫자 중 3보다 큰 숫자를 2배 한 후 모든 값의 합을 구한다. 지금까지 학습한 map, reduce, filter를 활용해 구현해야 한다.      nextstep.fp.StreamStudyTest 클래스의 sumOverThreeAndDouble() 테스트를 pass해야 한다.   1 2 3 4 5 6 @Test public void sumOverThreeAndDouble() throws Exception {     numbers = Arrays.asList(3, 1, 6, 2, 4, 8);     long sum = StreamStudy.sumOverThreeAndDouble(numbers);     assertThat(sum).isEqualTo(36); }  filter를 사용해서 먼저 3보다 큰 숫자를 추출하고, 추출한 숫자들을 map을 사용해서 2배로 만들어준다. 그 다음 reduce를 사용해서 모든 숫자를 더해 반환하면 된다.  1 2 3 4 5 6 @Test public void sumOverThreeAndDouble() throws Exception {     numbers = Arrays.asList(3, 1, 6, 2, 4, 8);     Optional&lt;Integer&gt; sum = numbers.stream().filter(x -&gt; x &gt; 3).map(x -&gt; 2 * x).reduce(Integer :: sum);     assertThat(sum.orElse(0)).isEqualTo(36); }  reduce는 Optional로 반환되는데, 여기서 Optional의 개념이 등장한다.           아이폰 앱개발을 할 때 사용하는 언어인 스위프트에서는 거의 모든 자료형을 Optional을 염두에 두고 선언했어야 됐어서 앱개발을 했었던 나로써는 익숙한 개념인데,               이 값은 NullpointerException문제를 해결하기 위한 자료형으로 값을 넣으면 래핑된 상태로 보존된다.   Optional값은 래핑 되어있기 때문에 사용하기 위해서는 ofElse혹은 ofElseGet을 사용해서 Null값이 들어왔을때 넣어줄 기본값을 넣어주어야 래핑이 해제된다.  자바에서는 orElse 혹은 orElseGet을 사용하여 기본값을 지정해준다.   따라서 Optional을 사용하게 되면 if를 통한 Null값에 대한 유효성 검사에 대한 코드를 더 간결하게 표현 할 수 있다.   map, reduce, filter 실습 2  nextstep.fp.StreamStudy 클래스의 printLongestWordTop100() 메서드를 구현한다. 요구사항은 다음과 같다.  1 2 3 4 5 6 7 public static void printLongestWordTop100() throws IOException {         String contents = new String(Files.readAllBytes(Paths                 .get(\"src/main/resources/fp/war-and-peace.txt\")), StandardCharsets.UTF_8);         List&lt;String&gt; words = Arrays.asList(contents.split(\"[\\\\P{L}]+\"));          // TODO 이 부분에 구현한다.     }     단어의 길이가 12자를 초과하는 단어를 추출한다.   12자가 넘는 단어 중 길이가 긴 순서로 100개의 단어를 추출한다.   단어 중복을 허용하지 않는다. 즉, 서로 다른 단어 100개를 추출해야 한다.   추출한 100개의 단어를 출력한다. 모든 단어는 소문자로 출력해야 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 public static void printLongestWordTop100() throws IOException {     String contents = new String(Files.readAllBytes(Paths             .get(\"src/main/resources/fp/war-and-peace.txt\")), StandardCharsets.UTF_8);     List&lt;String&gt; words = Arrays.asList(contents.split(\"[\\\\P{L}]+\"));      // TODO 이 부분에 구현한다.     words.stream()             .filter(x -&gt; x.length() &gt; 12)             .sorted()             .distinct()             .map(x -&gt; x.toLowerCase())             .forEach(System.out :: println); }  아주 간편하게 for문으로 로직을 짤 필요없이 요구사항 순서대로 알맞는 메서드만 입력해주면         원하는 값을 얻을 수 있으면 매우 가독성이 높아 읽기 편한 걸 알 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EB%9E%8C%EB%8B%A4,-%EC%8A%A4%ED%8A%B8%EB%A6%BC/",
        "teaser": null
      },{
        "title": "[Java] 옵셔널",
        "excerpt":"옵셔널  옵셔널은 자바의  NullPointerException을 방지하기 위해 만들어진 기능이다.      프로그래밍에서 가장 많이 발생하는 오류가 이 NullPointerException인데, 보통 프로그래밍을 할 때  변수에 일일히 Null값이 들어올 상황에 대비해주는 코드를 넣어주는 것은 매우 복잡하고 번거로운 일이기 때문에,           입력을 받는 부분에서는 항상 Null에 대한 유효성을 체크해주어야 한다.   따라서 이러한 유효성을 검사하기 위해서 일일히 if문을 넣어 Null값이 들어왔을 때의 예외를 선언해주어야 했던 번거로움을 해결하기 위해,  자바8에서부터는 Optional이란 기능이 추가되었다.   옵셔널로 변수를 선언하는 방법은 아래와 같이 Optional 자료형으로 변수를 선언해주면 되는데,  1 2 3 Optional&lt;String&gt; optional = Optional.empty(); Optional&lt;String&gt; optionalOf = Optional.of(\"str\");  Optional&lt;String&gt; optionalOfNull = Optional.ofNullable(null);  첫번째 줄은 빈 옵셔널 타입을 선언해준 것이고, 두번째 줄은 str이라는 문자열이 들어있는 옵셔널타입의 변수를 선언 해주었다.          하지만 두번째 줄같은 경우 Null값이 of메서드 안에 들어오면 에러를 출력하므로, 만약 Null값이 들어올 수 있는 값이라면 세번째 줄 처럼 ofNullable을 사용해주어야 한다.   이렇게 옵셔널로 선언한 값을 런해서 출력해보면 다음과 같이 뜨는걸 볼 수 있는데,  1 2 3 4 5 6 public static void main(String[] args) {     Optional&lt;String&gt; optionalOf = Optional.of(\"hello\");     System.out.println(optionalOf); }      &gt; Optional[hello]  이렇게 Optional[]이란 괄호안에 값이 들어있는걸 볼 수 있다.   이것을 래핑되었다고 하는데, 비유하자면 물건이 박스에 들어가 있는 상태라고 생각하면 된다.    박스에 들어가 있기 때문에, 아직 Null값임이 확정되지 않아 NullException 에러를 출력하지 않는 것이고, 이 값을 꺼낼 때 Null이라면 그때서야 에러를 출력하게 되는 것이다.   따라서 우리가 물건을 사용하려면 박스에서 꺼내야 하듯이, 이 값을 사용하려면 언래핑 이라는 과정을 거쳐서 상자에서 이 값을 꺼내주어야 한다.  1 2 3 4 5 public static void main(String[] args) {     Optional&lt;String&gt; optionalOf = Optional.of(null);          System.out.println(optionalOf); }  위 코드를 돌리게 되면 NullPointException이 발생하게 되는데, 이는 Optional.of는 Null값을 입력하면 오류를 출력하기 때문이다.  따라서 Optional에 Null값을 넣고 싶다면, empty() 메서드를 사용하거나, ofNullable()을 사용해서 값을 할당해야 한다.   그렇다면 이 상자에서 어떻게 해야 이 값을 꺼낼 수 있을까??   상자에서 꺼내는 방법은 두가지가 있는데, get()을 사용하는 방법과 orElse() 혹은 orElseGet()를 사용하는 방법이 있다.   먼저 get()의 경우 강제로 박스를 여는것에 가까운데, get()은 Null값에 대한 대비 없이 바로 상자를 열어버리기 때문에 래핑된 값이     Null이라면 에러를 출력한다.   orElse()의 경우는 orElse() 파라미터 단에 해당 옵셔널 변수가 Null일때의 예외 값을 지정해줌으로써, 만약 박스를 열었는데 안에 Null값이 있다면 해당 예외값이 들어있던 것으로 판단한다.   orElseGet()은 기본적으로 orElse와 같지만, 파라미터단에 값자체가 아닌 함수가 들어오며 null이던 아니건 우선 예외값을 불러오는   orElse()와 달리 안에 있는 값이 Null일 때만 해당 예외처리를 불러온다.   따라서 특이한 상황이 아니라면 Null값이 들어올 수 있는 옵셔널 변수에는 orElseGet()을 사용해주는게 가장 NullPointerException에서 가장 안전하다.   이러한 특성 때문에 만약 NullPointerException을 막으려면 아래와 같이 복잡한 코드를 선언해야했던 이전과 달리,  1 2 3 4 5 6 public static void main(String[] args) {     String number = null;     if (number != null){         System.out.println(number);     } }  다음과 같이 Optional을 사용해서 코드를 더 간소화 할 수 있게 되었다.  1 2 3 4 5 public static void main(String[] args) {     String number = null;     Optional&lt;String&gt; opt = Optional.ofNullable(number);     System.out.println(opt.orElseGet(() -&gt; \"null\")); }  이렇게 옵셔널은 더 안정적이고, 간소화된 코드를 위해 사용되는 유용한 기능이다.   그럼, 이 기능을 더 자연스럽게 사용하기 위해 몇가지 예제를 풀어보자.   ###요구사항 1 - Optional을 활용해 조건에 따른 반환  nextstep.optional.User의 ageIsInRange1() 메소드는 30살 이상, 45살 이하에 해당하는 User가 존재하는 경우 true를 반환하는 메소드이다.  1 2 3 4 5 6 7 8 9 10 public static boolean ageIsInRange1(User user) {     boolean isInRange = false;      if (user != null &amp;&amp; user.getAge() != null             &amp;&amp; (user.getAge() &gt;= 30             &amp;&amp; user.getAge() &lt;= 45)) {         isInRange = true;     }     return isInRange; }  같은 기능을 Optional을 활용해 ageIsInRange2() 메소드에 구현한다. 메소드 인자로 받은 User를 Optional로 생성하면 stream의 map, filter와 같은 메소드를 사용하는 것이 가능하다.   nextstep.optional.UserTest의 테스트가 모두 pass해야 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class UserTest {     @Test     public void whenFiltersWithoutOptional_thenCorrect() {         assertThat(ageIsInRange1(new User(\"crong\", 35))).isTrue();         assertThat(ageIsInRange1(new User(\"crong\", 48))).isFalse();         assertThat(ageIsInRange1(new User(\"crong\", null))).isFalse();         assertThat(ageIsInRange1(new User(\"crong\", 29))).isFalse();         assertThat(ageIsInRange1(null)).isFalse();     }      @Test     public void whenFiltersWithOptional_thenCorrect() {         assertThat(ageIsInRange2(new User(\"crong\", 35))).isTrue();         assertThat(ageIsInRange2(new User(\"crong\", 48))).isFalse();         assertThat(ageIsInRange2(new User(\"crong\", null))).isFalse();         assertThat(ageIsInRange2(new User(\"crong\", 29))).isFalse();         assertThat(ageIsInRange2(null)).isFalse();     } }      Guide To Java 8 Optional 문서를 참고해 Optional 사용 방법을 익힌다.   Optional.ofNullable(user)을 활용해 User을 Optional로 생성하는 것이 가능하다.   Optional의 map(), filter() 메소드등을 활용해 필요한 데이터를 추출   Optional의 isPresent() 메소드 활용   1 2 3 4 public static boolean ageIsInRange2(User user) {     Optional&lt;User&gt; targetUser = Optional.ofNullable(user);     return targetUser.map(User :: getAge).filter(age -&gt; age &gt;= 35).filter(age -&gt; age &lt; 45).isPresent(); }  user를 Optional로 감싸주고, ofNullable로 선언함으로써 Null값이 들어올 수 있도록 선언해준다.           user의 getAge를 비교해주어야 하므로, map을 사용해서 들어온 user에서 age를 얻어오고, 이를 조건에 맞게 filter()를 사용해 걸러준다.         그리고 isPresent()를 통해 값이 존재하면 true, 존재하지않으며 false를 반환하면 된다.   ###요구사항 2 - Optional에서 값을 반환  nextstep.optional.Users의 getUser() 메소드를 자바 8의 stream과 Optional을 활용해 구현한다.  1 2 3 4 5 6 7 8  User getUser(String name) {         for (User user : users) {             if (user.matchName(name)) {                 return user;             }         }         return DEFAULT_USER;     }  자바 8의 stream과 Optional을 사용하도록 리팩토링한 후 UsersTest의 단위 테스트가 통과해야 한다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class UsersTest {      @Test     public void getUser() {         Users users = new Users();         assertThat(users.getUser(\"crong\")).isEqualTo(new User(\"crong\", 35));     }       @Test     public void getDefaultUser() {         Users users = new Users();         assertThat(users.getUser(\"codesquard\")).isEqualTo(Users.DEFAULT_USER);     } }     Guide To Java 8 Optional 문서를 참고해 Optional 사용 방법을 익힌다.   Optional의 orElse() 메소드 활용해 구현한다.   1 2 3 User getUser(String name) {     return users.stream().filter(user -&gt; user.matchName(name)).findFirst().orElse(DEFAULT_USER); }  users는 User 자료형을 갖는 리스트이므로, 먼저 filter를 통해 user.matchName이 true인 값만을 필터링 해주고,  findFirts()를 통해 해당 값을 찾아준다. 만약 Null값이라면 orElse를 사용해서 예외에 대한 디폴트값을 설정해준다.   요구사항 3 - Optional에서 exception 처리  nextstep.optional.ExpressionTest의 테스트가 통과하도록 Expression의 of 메소드를 구현한다.  1 2 3 4 5 6 7 8 9 static Expression of(String expression) {     for (Expression v : values()) {         if (matchExpression(v, expression)) {             return v;         }     }      throw new IllegalArgumentException(String.format(\"%s는 사칙연산에 해당하지 않는 표현식입니다.\", expression)); }  단, of 메소드를 구현할 때 자바 8의 stream을 기반으로 구현한다.      Guide To Java 8 Optional 문서를 참고해 Optional 사용 방법을 익힌다.   자바의 enum 전체 값은 values() 메소드를 통해 배열로 접근 가능하다.   Arrays.stream()을 이용해 배열을 stream으로 생성할 수 있다.   일치하는 값 하나를 추출할 때 findFirst() 메소드를 활용 가능하다.   Optional의 orElseThrow() 메소드 활용해 구현한다.   1 2 3 4 5 6 static Expression of2(String expression) {     return Arrays.stream(values())             .filter(value -&gt; matchExpression(value, expression))             .findFirst()             .orElseThrow(() -&gt; new IllegalArgumentException(String.format(\"%s는 사칙연산에 해당하지 않는 표현식입니다.\", expression))); }  Expression의 value를 받아 filter해준 뒤, orElseThrow를 사용해 예외 발생시 IllegalArgumentException를 출력하도록 해준다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%98%B5%EC%85%94%EB%84%90/",
        "teaser": null
      },{
        "title": "[Java] 우테코 프리코스 3주차 - 자판기",
        "excerpt":"시작하며…  어느덧 3주의 프리코스의 마지막 과제가 출제되었다.        보통 최종 코딩테스트가 3주차와 비슷한 수준으로 나오는 것 같아서, 더 열심히 과제를 풀어보려 한다.   항상 1,2번째 과제는 동일하고 3번째 과제가 다르게 나와서 내심 어떤게 나올지 궁금했는데, 자판기를 구현하는 과제가 나왔다.           그 동안에는 모르는 부분이 있었다면 인터넷에서 로직을 찾아 보고 대략 해답을 얻을 수 있었지만 이번에는 혼자서 모든 걸 해내야한다는 생각에        설레기도 하면서 두렵기도 하다. 물론 PR된 다른참가자걸 보고 힌트를 얻을 수도 있지만, 마지막 과제인만큼 혼자 힘으로 처음부터 구현해보려 한다!   추가로 다음주에 있을 코딩테스트가 온라인으로 바뀌었다고 한다…           내심 직접 가서 우형 본사가 어떻게 되어있는지 구경도 해보고 더 자극도 받고 싶었는데 아쉬웠다.         이제 우형 본사를 직접 눈으로 볼 방법은 우테코에 붙는 방법밖에 없다. 화이팅!!!   기능 구현 목록 작성  이제 어느덧 익숙해진 기능 구현 목록 작성이다.        이번에도 기능과 예외를 중점으로 프로그래밍 실행 결과를 보며 어느 기능이 모여 이 프로그램이 되는지 따져가며 하나씩 적어 내려갔다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ## 🛠 기능 구현 목록 * 자판기가 보유할 금액을 입력받는다.      * 사용자가 입력한 값은 숫자로만 이루어져야 한다.     * 사용자가 입력한 값은 10으로 나누어 떨어져야 한다.     * 공백이 입력되서는 안된다. * 보유하고 있는 금액으로 갖고있는 동전을 무작위로 생성한다. * 자판기가 보유한 동전들의 갯수를 출력한다. * 자판기에 추가할 상품명과 가격, 수량을 입력받는다.     * 상품명, 가격, 수량은 쉼표(,)로 구분한다.         * 가격과 수량은 숫자로 이루어져야 한다.         * 공백값이 들어와서는 안된다.     * 개별 상품은 세미콜론(;)으로 구분한다. * 투입 금액을 입력 받는다.     * 투입금액은 숫자로만 이루어져야한다.     * 투입금액은 공백이 들어와서는 안된다. * 현재 자판기가 갖고있는 돈을 출력한다. * 구매할 상품명을 입력받는다.     * 없는 상품을 입력받으면 안된다.     * 구매할 상품의 가격보다 적은 돈을 갖고있으면 안된다. * 남은 금액이 상품의 최저가격보다 적으면 바로 잔돈을 돌려준다. * 모든 상품이 소진 됐다면, 바로 잔돈을 돌려준다.   기능 구현 목록을 적으며 느낀점은, 역시 마지막 과제… 만만치 않다는 것이다.   우선 보유하고 있는 금액으로 동전을 무작위로 생성하는 부분이 조금 어려워보였다.      하지만 막상 구현하면 어렵지 않은 경우가 많으니, 직접 몸으로 부딪혀 보며 만들어 보자!   자판기가 보유할 금액을 입력받는다.  테스트 코드 작성  테스트 코드 작성은 진짜 오랫동안 연습해야 정착될 것같다는 생각이든다…           나름 꽤 열심히 해보려 하는데 도메인 지식이 부족해서 그런가 너무 까다롭고 어렵다.   테스트 코드를 작성해야하는 기능과 안해도 되는 기능에 대한 기준이 애매해서 항상 헷갈렸는데,         우테코 회고글 중에서 public이 붙은 메서드는 왠만하면 모두 작성하는게 좋다고 해서 그렇게 해보려고 한다.  1 2 3 4 5 6 7 class VendingMachineTest {     @ParameterizedTest     @ValueSource(strings = {\"\", \"qwe\", \"1413\"})     public void 자판기_투입금액_예외테스트(String input) {         assertThatThrownBy(() -&gt; new MachineMoney(input)).isInstanceOf(IllegalArgumentException.class);     } }   입력을 받고 유효성 검사  우선 VendinMachine이라는 클래스를 하나 만들어주고, 자판기가 가진 돈을 저장받아야 하므로 int money를 포장한 MachineMoney라는          클래스를 만들어 주었다. 여기서 돈에 대한 유효성 검사를 진행하도록 했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class MachineMoney {     final static int MIN_COIN_UNIT = 10;      private int money;      public int getMoney() {         return money;     }      public MachineMoney(String money) throws IllegalArgumentException {         machineMoneyValidation(money);         this.money = Integer.parseInt(money);     }      private void machineMoneyValidation(String money) throws IllegalArgumentException {         isDigitString(money);         isBlank(money);         isCorrectAmount(money);     }      private void isDigitString(String money) throws IllegalArgumentException {         for (char c : money.toCharArray()) {             isDigit(c);         }     }      private void isDigit(char c) throws IllegalArgumentException {         if (!Character.isDigit(c)) {             throw new IllegalArgumentException(\"[ERROR] 입력값은 숫자로만 이루어져야 합니다.\");         }     }      private void isBlank(String money) throws IllegalArgumentException {         if (money.isEmpty()) {             throw new IllegalArgumentException(\"[ERROR] 입력값이 비어있습니다.\");         }     }      private void isCorrectAmount(String money) throws IllegalArgumentException {         if (Integer.parseInt(money) % MIN_COIN_UNIT &gt; 0) {             throw new IllegalArgumentException(\"[ERROR] 입력값은 10으로 나누어 떨어져야 합니다.\");         }     }  상수에 대한 관리를 어떻게 해야할지 내내 고민했는데, 모든 상수를 Constant 클래스에서 모아서 관리하는것 보다는, 공용으로 쓰지 않고 그 클래스에서만         사용하는 간단한 상수는 클래스 자체에서 관리하는게 더 편할 것 같다는 생각이 들어 그렇게 하기로 했다.   이제 throw한 예외가 출력되면 이를 catch하고 다시 값을 받을 값들을 구현해보자.             먼저, “자판기가 보유하고 있는 금액을 입력해 주세요.” 라는 문구를 출력하고 값을 받도록 InputView 클래스를 정의해주고, 해당 메서드를 작성해준다.   1 2 3 4 5 6 public class InputView {     public static String printSetMachineMoney() {         System.out.println(\"자판기가 보유하고 있는 금액을 입력해 주세요.\");         return Console.readLine();     } }  그리고 출력되는 메시지는 상수이므로, 따로 SystemMessage 클래스를 만들어, 모든 시스템 메시지를 이 클래스에서 관리 하도록 해줄 것 이다.  1 2 3 4 5 6 7 8 9 10 11 12 13 public enum SystemMessage {     PRINT_SET_MACHINE_MONEY_MESSAGE(\"자판기가 보유하고 있는 금액을 입력해 주세요.\");      private String message;      SystemMessage(String message) {         this.message = message;     }      public String print() {         return message;     } }  그럼 이제 다시 InputView를 수정해주면,   1 2 3 4 5 6 public class InputView {     public static String printSetMachineMoney() {         System.out.println(SystemMessage.PRINT_SET_MACHINE_MONEY_MESSAGE.print());         return Console.readLine();     } }  이로써 입력을 받고 유효성 검사를 하도록 기능을 추가했다.   테스트 코드도 올바르게 동작하는것으로 보아, 이 코드가 유효성을 올바르게 체크하고 예외를 출력하고 있음을 알 수 있다.   그럼 만들어준 MachinMoney를 멤버 변수로 갖는 VendingMachine 클래스를 만들어서 MachinMoney를 set할 수 있도록 작성 해준다.  1 2 3 4 5 6 7 8 public class VendingMachine {     MachineMoney machineMoney;          public void setMachineMoney(String money) throws IllegalArgumentException {         machineMoney = new MachineMoney(money);     }  }   이제 이 기능이 Application에서 돌아가도록 Controller를 만들어 뷰와 도메인을 이어주자!   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class VendingMachineController {     public void run() {         VendingMachine vendingMachine = new VendingMachine();         setMachineMoney(vendingMachine);     }      private void setMachineMoney(VendingMachine vendingMachine) {         try {             vendingMachine.setMachineMoney(InputView.printSetMachineMoney());         } catch (IllegalArgumentException exception) {             OutputView.printErrorMessage(exception);             setMachineMoney(vendingMachine);         }     }   VendingMachineController 클래스를 만들어주고, 이 객체를 main에서 생성해주고 run() 메서드를 실행하면 프로그램이 동작하게 메서드를 만들어 줄 것 이다.   setMachineMoney() 메서드가 먼저 동작되어, 자판기가 보유할 돈을 입력받고 이에 대한 유효성 검사를 진행한 뒤, 만약 IllegarArgumentException이     발생하면 이를 catch해서 에러 메시지를 출력한 후, 다시 그 부분의 입력을 받게 될 것이다.   For input string : 에러 해결  이 부분에서 사실 한참을 헤멨는데, 테스트 코드는 모두 통과하는데도 불구하고 자꾸 에러메시지가 출력이 안되고 “For input string: “ㅁㄴㅇ”“라는 에러가 출력되었다.           분명 코드대로라면 IllegalArgumentException을 받으면 이에 대한 에러메시지를 출력해야 하는데, 모든 에러에 대해서 이러한 메시지만을 출력하였다.   그래서 이 에러를 검색했더니 Integer.ParseInt()에서 문자열이 들어올 때 출력되는 에러라고 해서, MachinMoney의 Money를 스트링으로 받아서 ParseInt로 넘겨주어 int로 변경하는 부분에서 발생하는 줄 알고, money의 자료형을 String으로 바꾸었는데도 안 고쳐져서 한참을 헤매버렸다.   다시 코드를 천천히 검토해보니, 유효성 검사 순서에서 isCorrectAmount 메서드가 가장 첫줄에 있어 숫자가 아닌 문자가 들어왔을때 먼저 예외를 출력해주지 못하고 바로 parseInt로 들어가서 생긴 오류였다. 그래서 간단하게 isCorrectAmount() 메서드를 가장 마지막에 검사하도록 했더니 바로 해결 되었다.   입력받은 금액을 사용해 랜덤으로 동전 생성  받은 금액을 기준으로 랜덤으로 동전을 생성해야 하는데, 이 부분이 가장 구현하기 조금 까다로웠다.   우선 Coin 클래스를 사용해서 만들어야했는데, enum을 다루는게 익숙하지 않다보니 Coin과 내가 구현해야할 기능을 연결하는 과정에서 많이 헤멨다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 public enum Coin {     COIN_500(500),     COIN_100(100),     COIN_50(50),     COIN_10(10);      private final int amount;      Coin(final int amount) {         this.amount = amount;     }     // 추가 기능 구현  }   우선 코인들이 한글이름을 하나씩 갖고있고 이걸 받아와 출력하는게 좋을것 같아서 클래스 멤버 변수를 더 추가해주기로 했다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public enum Coin {     COIN_500(500,0),     COIN_100(100, 0),     COIN_50(50, 0),     COIN_10(10, 0);      private final int amount;     private final String coinUnit = \"원 - \";     private int count;     private final String countUnit = \"개\";      Coin(final int amount, int count) {         this.amount = amount;         this.count = count;     }     // 추가 기능 구현      public int getAmount() {         return amount;     }      public void setCount(int count) {         this.count = count;     }      @Override     public String toString() {         return amount + coinUnit + count + countUnit;     } }  Coin은 amount와 count를 갖고, amount는 금액을 나타내고 count는 동전의 개수를 나타낸다.          toString()을 호출하면, 동전의 단위와 함께 동전이 몇개 있는지 출력해준다.   이제 \u001fVendingMachine에서 coin과 machineMoney를 사용해서 입력받은 돈을 기준으로 랜덤으로 동전을 생성해보려고 한다.   우선, 내가 생각한 로직은 다음과 같다.      입력으로 받은 돈을 500원으로 먼저 나눈다.  ex) 1000 / 500 = 2   몫은 pickNumberInRange(0, ) 메서드의 두번째 매개변수가 된다.   pickNumberIntange()로 나온 값은 해당 동전의 count가 된다.   pickNumberInRange()로 나온 값 * MachineMoney 값을 MachinMoney에서 뺴준다.   해당 로직을 모든 coin에 적용시켜준다. 앞코인에서 변경된 MachineMoney값이 뒤 코인의 입력값이 된다.   단, 마지막 coin은 남은돈을 모두 해당 coin으로 전환한다.   MachoneMoney는 마지막에 항상 0이어야 한다.   해당 로직을 구현하여 VendingMachine 클래스에 메서드로 작성해보았다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public void makeRandomAllCoin() {         for (Coin c : coin.values()) {             makeRandomCoin(c);         }     }      private void makeRandomCoin(Coin coin) {         if (coin == Coin.COIN_10) {             coin.setCount(machineMoney.getMoney() / coin.getAmount());             return;         }         int number = Randoms.pickNumberInRange(0, machineMoney.getMoney() / coin.getAmount());         machineMoney.minusMoney(coin.getAmount() * number);         coin.setCount(number);     }  그럼 이렇게 만든 메서드들을 사용하여 VendingMachineController에서 View와 이어주자.  1 2 3 4 5 6 7 8 9 10 11 public void run() {     VendingMachine vendingMachine = new VendingMachine();     setMachineMoney(vendingMachine);      makeRandomCoin(vendingMachine); }  private void makeRandomCoin(VendingMachine vendingMachine) {     vendingMachine.makeRandomAllCoin();     OutputView.printCoinStatus(vendingMachine.getCoin()); }  해당 코드 구현까지의 실행 결과는 다음과 같다.  1 2 3 4 5 6 자판기가 보유하고 있는 금액을 입력해 주세요. 1000 500원 - 0개 100원 - 3개 50원 - 10개 10원 - 20개   자판기에 추가할 상품명과 가격, 수량을 입력받는다.  Merchandise라는 클래스를 만들어 상품의 이름, 가격, 수량을 관리하기로 했다.          여기서 가격이랑 수량은 아까 MachineMoney와 동일하게 숫자, 공백에 대한 유효성 검사가 필요한 항목이라서, 중복을 방지하기 위해                   MachineMoney에서 숫자의 유효성을 검증하는 메서드들을 추상화 해서 따로 클래스로 만들어 상속해주기로 했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 public class MachineMoney {     final static int MIN_COIN_UNIT = 10;      private int money;      public int getMoney() {         return money;     }      public MachineMoney(String money) throws IllegalArgumentException {         machineMoneyValidation(money);         this.money = Integer.parseInt(money);     }      private void machineMoneyValidation(String money) throws IllegalArgumentException {         isDigitString(money);         isBlank(money);         isCorrectAmount(money);     }      private void isDigitString(String money) throws IllegalArgumentException {         for (char c : money.toCharArray()) {             isDigit(c);         }     }      private void isDigit(char c) throws IllegalArgumentException {         if (!Character.isDigit(c)) {             throw new IllegalArgumentException(\"[ERROR] 입력값은 숫자로만 이루어져야 합니다.\");         }     }      private void isBlank(String money) throws IllegalArgumentException {         if (money.isEmpty()) {             throw new IllegalArgumentException(\"[ERROR] 입력값이 비어있습니다.\");         }     }      private void isCorrectAmount(String money) throws IllegalArgumentException {         if (Integer.parseInt(money) % MIN_COIN_UNIT &gt; 0) {             throw new IllegalArgumentException(\"[ERROR] 입력값은 10으로 나누어 떨어져야 합니다.\");         }     }  여기서 isCorrectAmount를 제외한 메서드들은 모든 숫자 유효성 검사에서 사용할 수 있는 메서드이므로, 따로 NumberValidation 클래스를 만들어          숫자의 유효성 검사가 필요한 클래스는 이 클래스를 상속받아 사용 하기로 했다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public class NumberValidation {     protected void numberValidation(String number) throws IllegalArgumentException {         isDigitString(number);         isBlank(number);     }      protected void isDigitString(String number) throws IllegalArgumentException {         for (char c : number.toCharArray()) {             isDigit(c);         }     }      protected void isDigit(char c) throws IllegalArgumentException {         if (!Character.isDigit(c)) {             throw new IllegalArgumentException(ErrorMessage.NOT_DIGIT_MESSAGE.print());         }     }      protected void isBlank(String number) throws IllegalArgumentException {         if (number.isEmpty()) {             throw new IllegalArgumentException(ErrorMessage.NULL_ERROR_MESSAGE.print());         }     } }  money를 모두 number로 바꾸고, machineMoneyValidation도 numberValidation으로 바꾸어 추상화 해주었다.   이렇게 만들어진 클래스를 MachineMoney와 Merchandise클래스에 상속해준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Merchandise extends NumberValidation{     String name;     int price;     int quantity;        public Merchandise(String name, String price, String quantity) {         isBlank(name);         this.name = name;          numberValidation(price);         this.price = Integer.parseInt(price);          numberValidation(quantity);         this.quantity = Integer.parseInt(price);     } }  name은 숫자 자료형은 아니지만, 공백에 대한 유효성검사가 필요해서 isBlank를 사용해서 검사해 주기로 했다.   이제 이렇게 구현한 Merchandise를 리스트로 가질 MerchandiseList를 만들어 입력이 들어오면 문자열을 분해해서 Merchandise형식으로           변환하여 넣어주자.  1 2 3 4 5 6 7 public class MerchandiseList {     private ArrayList&lt;Merchandise&gt; merchandiseList;      public MerchandiseList() {         merchandiseList = new ArrayList&lt;Merchandise&gt;();     } }  만들어준 MerchandiseList가 문자열로 들어온 상품들의 정보대로 새로운 Merchandise를 생성해서 리스트에 담을 수 있도록 하자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 public class MerchandiseList {     final static int MERCHANDISE_NAME_INDEX = 0;     final static int MERCHANDISE_PRICE_INDEX = 1;     final static int MERCHANDISE_QUANTITY_INDEX = 2;     final static int SUBSTRING_BRACKET_INDEX = 1;     final static int MERCHANDISE_INFO_COUNT = 3;      private ArrayList&lt;Merchandise&gt; merchandiseList;      public MerchandiseList() {         merchandiseList = new ArrayList&lt;Merchandise&gt;();     }      public String getAllMerchandiseInfo() {         ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();         for(Merchandise merchandise : merchandiseList) {             list.add(merchandise.toString());         }         return String.join(\",\", list);     }      public void addAllMerchandise(String merchandises) throws IllegalArgumentException {         for (String merchandise : merchandises.split(\";\")) {             isCorrectBracket(merchandise);             addMerchandise(merchandise.substring(SUBSTRING_BRACKET_INDEX, (merchandise.length() - 1)));         }     }      public void addMerchandise(String merchandise) throws IllegalArgumentException {         ArrayList&lt;String&gt; array = new ArrayList&lt;String&gt;(Arrays.asList(merchandise.split(\",\")));          isBlank(merchandise);         isNullInList(array);          merchandiseList.add(new Merchandise(array.get(MERCHANDISE_NAME_INDEX),                 array.get(MERCHANDISE_PRICE_INDEX),                 array.get(MERCHANDISE_QUANTITY_INDEX)));     }      private void isBlank(String merchandise) throws IllegalArgumentException{         if (merchandise.isEmpty()) {             throw new IllegalArgumentException(ErrorMessage.NULL_ERROR_MESSAGE.print());         }     }      public void isCorrectBracket(String merchandise) throws IllegalArgumentException {         if (!merchandise.startsWith(\"[\") || !merchandise.endsWith(\"]\")) {             throw new IllegalArgumentException(ErrorMessage.NOT_CORRECT_BRACKET.print());         }     }      public void isNullInList(ArrayList&lt;String&gt; array) {         if (array.size() &lt; MERCHANDISE_INFO_COUNT) {             throw new IllegalArgumentException(ErrorMessage.NULL_IN_LIST.print());         }     } }  아까 랜덤 코인을 생성하는 부분이 까다롭다고 생각했는데, 이 부분이 이번 미션에서 제일 까다로웠다…          새로운 Merchandise 생성을 위해서 문자열로 받은 값을 ;를 기준으로 나누고 []을 벗기고 ,를 기준으로 나눠 각각 이름, 가격, 수량을 가진 Merchandise를 만들어 MerchandiseList에 넣어주면 되는데,  사실 그냥 벗겨서 넣는 기능 자체만을 구현하면 쉬웠겠지만 이를 깨끗하고 읽기쉽게 구현하는게 어려웠다. 그리고 분류하는 기준이 늘어난 만큼 발생하는 예외가 많아서  예외들을 모두 처리해주느라 복잡했다.   테스트 코드 작성  테스트코드 작성하는게 너무 까다로워보여서 귀찮은 마음에 중간까지는 계속 Application을 실행시켜서 테스트 하다가 결국 빠른 검증을 위해 테스트 코드를 작성했는데, 정말 테스트 코드를 작성 했을때 낭비되는 시간이 일일히 테스트하던 때에 비해서 비약적으로 줄었다…;;;   그동안도 머리로는 알고있었는데 역시 사람은 직접 겪어서 생고생을 해야 말을 듣나보다… 앞으로는 무조건 테스트 코드를 작성해서 테스트하는 습관을 진짜 꼭!!! 들여야겠다.   테스트를 위해 작성한 테스트 코드는 다음과 같다.  1 2 3 4 5 6 7 8 9 10 11 12 13 @Test public void 자판기_상품등록_테스트() {     VendingMachine vendingMachine = new VendingMachine();     vendingMachine.addMerchandises(\"[사이다,2000,10];[콜라,1500,20]\");     assertThat(vendingMachine.getAllMerchandiseInfo()).isEqualTo(\"사이다200010,콜라150020\"); }  @ParameterizedTest @ValueSource(strings = {\"\", \"[],[]\", \"[]\",\"[asd,d,10]\",\"[asd,20],[사이다,2000,20][콜라,2000,20]\"}) public void 자판기_상품등록_예외_테스트(String input) {     VendingMachine vendingMachine = new VendingMachine();     assertThatThrownBy(() -&gt; vendingMachine.addMerchandises(input)).isInstanceOf(IllegalArgumentException.class); }  테스트를 위해서 vendingMachine에 getAllMerChandiseInfo()라는 메서드를 만들어서, Merchandise에 오버라이딩 해준 toString이 상품이름, 가격, 수량을 붙여서 출력하게 했다.   예외 출력 테스트는 많은 예외를 한번에 테스트 하기 위해 ValueSource를 사용해서 되도록 많은 예외를 잡아보려 했다.   역시 테스트 코드를 작성하고 개발을 하니 코딩하고 바로 컨트롤 R로 한번에 다 테스트 해버리면 되니까 개발 속도가 너무 빠르게 올라갔다.        뿐만 아니라 과제가 아닌 실제 서비스하는 프로그램이었다면 테스트 코드를 작성함으로써 혹여나 유지보수 중에 같이 발생 하는 오류를 지나치지 않고 내가 원하는 출력값을 항상 얻을 수 있는 상태가 되어 더욱 안정적일 것이다.   물론 아직 실력이 조금 부족해서 테스트코드를 프로덕션 코드보다 먼저 작성하는건 어렵지만, 후에라도 꼭 작성해서 테스트코드 작성하는 실력을 키워야겠다.   프로덕션 코드 구현  이제 merchandiseList를 VendinMachine에 멤버 변수로 추가해주고 VendinMachine이 입력을 받아 상품을 자판기에 추가할 수 있도록 해보자.   public class VendingMachine {     MachineMoney machineMoney;     Coin coin;     MerchandiseList merchandiseList;      public VendingMachine() {         merchandiseList = new MerchandiseList();     }      public void setMachineMoney(String money) throws IllegalArgumentException {         machineMoney = new MachineMoney(money);     }      public Coin getCoin() {         return coin;     }      public void makeRandomAllCoin() {         for (Coin c : coin.values()) {             makeRandomCoin(c);         }     }      private void makeRandomCoin(Coin coin) {         if (coin == Coin.COIN_10) {             coin.setCount(machineMoney.getMoney() / coin.getAmount());             return;         }         int number = Randoms.pickNumberInRange(0, machineMoney.getMoney() / coin.getAmount());         machineMoney.minusMoney(coin.getAmount() * number);         coin.setCount(number);     }      public void addMerchandise(String merchandise) {         merchandiseList.addAllMerchandise(merchandise);     }      public String getAllMerchandiseInfo() {         return merchandiseList.getAllMerchandiseInfo();     } }  vendinMachine은 상품의 정보를 입력받으면 해당 정보를 바탕으로 상품을 만들고 이를 merchandiseList에 추가한다.   메서드의 이름 짓기  테스트 코드는 통과하는데 계속 Application에 값을 넣으면 “]” 기호가 제거가 안되는 버그가 발생해서 진짜 한참을 헤맸는데,          상품을 추가하는 addMerchandise 메서드와, 이를 사용해서 받은 입력의 상품을 모두 추가하는 addMerchandises의 이름이 비슷해서 잘못 선언한것이 문제였다.   메서드 이름을 지을 때 for문이 indent가 2가 되는경우, 하나만 받아 기능하는 메서드를 하나 만들고 이를 여러개를 받는 메서드에서 사용하는 경우가 많아 메서드 이름을 s를 붙여 단수와 복수로 선언하곤 했는데, 이렇게 하니까 자동완성기능에서 제대로 확인을 안하고 사용하게 되는 경우가 많은것 같다.   그래서 s를 붙이지 않고 addAllMerchandise로 메서드명을 바꿔주었다.   투입 금액을 입력받는다.  테스트 코드  1 2 3 4 @Test public void 자판기_투입금액_예외_테스트() {     assertThatThrownBy(() -&gt; vendingMachine.setInputMoney(\"1000\")).isInstanceOf(IllegalArgumentException.class); }  setInputMoney라는 메서드를 실행해서 투입금액을 입력받고, 만약 예외 상황시 올바르게 에외를 출력하는지 확인 하는 코드를 작성해보았다.   투입 금액에 대한 유효성 검사를 담당하는 InputMoney 클래스를 만들어 주도록 하자.  1 2 3 4 5 6 7 8 public class InputMoney extends NumberValidation {     private int inputMoney;      public InputMoney(String inputMoney) {         numberValidation(inputMoney);         this.inputMoney = Integer.parseInt(inputMoney);     } }  마찬가지로 숫자이므로, NumberValidation을 상속해 숫자에 대한 유효성 검사를 간결하게 해줄 수 있었다.   이제 InputView에 view를 구성해주고, 이를 controller에서 모델과 연결해주자.  1 2 3 4 public static String printSetInputMoneyMessage() {     System.out.println(SystemMessage.SET_INPUT_MONEY_MESSAGE.print());     return Console.readLine(); }  InputView에서는 메시지 출력과 함께 입력을 받는 printSetInputMoneyMessage()를 만들어주고,   이를 VendinMachineController에서 VendingMachine과 이어준다.  VendingMachine.class  1 2 3  public void setInputMoney(String inputMoney) {         new InputMoney(inputMoney);     }   VendingMachineController.class  1 2 3 private void setInputMoney(VendingMachine vendingMachine) {     vendingMachine.setInputMoney(InputView.printSetInputMoneyMessage()); }   테스트 코드를 통과하는 것으로 보아, 올바르게 코드가 작동하는 것을 알 수 있다.   현재 자판기에 남아있는 금액과 함께 구매할 상품명을 입력받는다.  테스트 코드  1 2 3 4 5 6 @Test public void 물건_구매_테스트() {     vendingMachine.addMerchandise(\"[사이다,2000,20]\");     vendingMachine.sell(\"사이다\");     assertThat(vendingMachine.getAllMerchandiseInfo()).isEqualTo(\"사이다200019\"); }  테스트 코드로 우선 물건을 구매 했을 떄, 해당 물건의 수량이 줄어드는지 확인해보는 것 까지만 작성해보았다.   메서드 이름 변경  지금까지 VendingMachineContoller에서 set이라는 이름을 붙여서 다음과 같이 메서드 이름을 명명했는데,  1 2 3 setMachineMoney(); setMerchandiseInfo(); setInputMoney();  get은 객체에다가 물어봐서 값을 가져오는거니까 사용자에게 받아오는건 set을 써야한다고 생각했다.   그러나 객체가 있는 메서드는 앞에 객체의 이름이 붙기떄문에 (ex) vendinMachine.getMoney) 객체에서 값을 가져오고, 객체에다가 값을 지정해주기 때문에 get으로 얻어오지만, controller에서는 메서드의 이름만 사용하므로 사용자에게 받아온다는 의미로 get을 쓰는게 더 자연스로운것 같아서 set으로 되어있던 이름들을 아래와 같이 변경해주었다.  1 2 3 getMachineMoney(); getMerchandiseInfo(); getInputMoney();   프로덕션 코드  VendingMachine에 purchase() 메서드를 추가해서 사용자가 물건을 입력하면 사용자가 자판기에게서 구매하는 코드를 작성해보려 한다.   Merchandise 클래스에 purchase() 메서드를 만들어주고 이를 merchandiseList에서 모든 상품들을 순환하며 입력받은 이름의 상품을 찾아 해당 상품의 sell()을 실행하는 방식으로 로직을 작성하기로 했다.  merchandise.class  1 2 3 4 5 6 7 8 9 10 public void purchase(String merchandiseName) {     merchandiseList.purchase(merchandiseName, inputMoney.getInputMoney());     inputMoney.use(merchandiseList.getPrice(merchandiseName)); } public boolean canPurchase() {     if (merchandiseList.cantBuyAllMerchandise(inputMoney.getInputMoney()) || merchandiseList.AllMerchandiseSoldOut()){         return true;     }     return false; }  merchandiseList.class  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 public void purchase(String merchandiseName, int money) {     for (Merchandise merchandise : merchandiseList) {         if (isExist(merchandise, merchandiseName)) {             merchandise.purchase(merchandiseName, money);             return;         }     }     throw new IllegalArgumentException(ErrorMessage.NOT_EXIST_MERCHANDISE.print()); }  public boolean isExist(Merchandise merchandise, String merchandiseName) {     if (merchandise.isSameName(merchandiseName)) {         return true;     }     return false; }  public boolean AllMerchandiseSoldOut() {     for (Merchandise merchandise : merchandiseList) {         try{             merchandise.isSoldOut();             return false;         }         catch (IllegalArgumentException e) {          }     }     return true; }  public boolean cantBuyAllMerchandise(int money) {     for (Merchandise merchandise : merchandiseList) {         try{             merchandise.isExpensive(money);             return false;         }         catch (IllegalArgumentException e) {          }     }     return true; }  merchandise.class  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 public boolean isSameName(String merchandiseName) {     if (merchandiseName.equals(name)) {         return true;     }     return false; }  public boolean isExpensive(int money) throws IllegalArgumentException {     if (money &lt; price) {         throw new IllegalArgumentException();     }     return false; }  public boolean isSoldOut() throws IllegalArgumentException{     if (quantity &lt;= SOLD_OUT_QUANTITY) {        throw new IllegalArgumentException();     }     return false; }  public void decreaseQuantity() {     this.quantity -= DECREASE_QUANTITY_VALUE; }   근데 여기서 자꾸 merchandise의 isSamName() 메서드 if(merchandiseName == name) 부분이 실행이 안되서 거의 30분을 헤맸는데,        자바가 문자열은 == 연산자 사용 시 값을 비교한느게 아니라 주소값을 기준으로 비교한다는걸 처음 알았다… 이걸 이제 알다니…                   그래서 분명 똑같은 문자열인데 혹시 공백이 섞여들어갔나 해서 그걸 찾는다고 30분동안 생고생을 했다.   이래서 파이썬을 너무 오래쓰면 안된다 ㅜ   어쨌든 값을 비교하는 equals 메서드 사용으로 해당 오류를 해결했다.   제품 중복 예외 추가  물건을 자판기가 판매하는 로직을 작성하다 보니, 제품을 추가 할 때 중복검사로 같은 제품이 추가 되지 않도록 예외를 하나 더 추가 해주어야 한다는 사실을 알았다.      Readme 파일을 변경하고 다음과 같이 예외처리 코드를 추가 해주었다.   merchandise.class  1 2 3 4 5 public void isSameName(String merchandiseName) throws IllegalArgumentException {     if (merchandiseName.equals(name)) {         throw new IllegalArgumentException(ErrorMessage.DUPLICATE_MERCHANDISE_EXIST_MESSAGE.print());     } }   merchandiseList.class  1 2 3 4 public void isDuplicationInList(String merchandiseName) {     merchandiseList.stream()             .forEach(merchandise -&gt; merchandise.isSameName(merchandiseName)); }  다음과 같이 만약 이미 생성된 상품명중에 동일한 이름을 가진 상품이 있다면 에러메시지와 함께 예외를 출력하게 했다.   모든 상품이 소진되었거나, 남은 금액이 최저가격보다 적다면 잔돈을 돌려준다.  테스트코드  여기서부터는 테스트 코드 작성 도저히 감도 잘 안잡히기도 하고 마지막 부분이라 그냥 과제에 있던 ApplicationTest를 사용해서 하기로 했다…        랜덤 요소가 들어간 테스트코드를 테스트 가능하게 하는게 정말 어려운 것 같다 ㅜ 더 연습해야 겠다는 생각이 든다.   프로덕션 코드  이제 잔돈을 반환해주는 코드를 만들어줘야하는데, 여기는 코딩테스트 공부할 때 많이 풀었었던 그리디 알고리즘을 적용해서 코드를 짜주면 된다.         알고리즘 배워서 어따 쓰나 했는데, 알고리즘을 실제 코드에서 응용해보는건 처음인 것 같다.   로직은 다음과 같다.      잔돈의 상태를 저장할 changeList를 만든다.   모든 Coin을 하나씩 방문하며 다음과 같은 로직을 실행한다.            해당 코인의 amount를 현재 남은 투입금액으로 나누어 해당 동전의 단위로 환전해준다.       환전한 동전의 개수가 자판기가 현재 갖고있던 돈보다 크다면, 해당 동전의 정보를 changeList에 넣는다.       환전한 동전의 개수가 자판기가 현재 갖고있던 돈보다 적다면, 바로 해당 동전의 count를 환전한 동전의 개수로 변경한뒤,     이 동전의 정보를 changeList에 넣고 함수를 종료한다.           코인의 정보는 toString을 오버라이딩하여, 과제의 출력에 형식에 맞게 “amount원 - count개”의 문자열을 출력하게 하여 changeList에 저장하도록 했다.   구현한 프로덕션 코드는 아래와 같다  Coin.enum  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 public enum Coin {     COIN_500(500, 0),     COIN_100(100, 0),     COIN_50(50, 0),     COIN_10(10, 0);      private final int amount;     private final String coinUnit = \"원 - \";     private int count;     private final String countUnit = \"개\";      Coin(final int amount, int count) {         this.amount = amount;         this.count = count;     }     // 추가 기능 구현      public int getAmount() {         return amount;     }      public List&lt;Integer&gt; getAmountList() {         return Arrays.stream(Coin.values())                 .map(coin -&gt; coin.getAmount())                 .collect(Collectors.toList());     }      public int getCount() {         return count;     }      public void setCount(int count) {         this.count = count;     }      public void addCount(Coin coin) {         coin.count++;     }      public void randomCoinCount(int number) {         for (Coin coin : Coin.values()) {             if (coin.getAmount() == number) {                 addCount(coin);             }         }     }      @Override     public String toString() {         return amount + coinUnit + count + countUnit;     } }  vendingMachine.class  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public ArrayList&lt;String&gt; getChange() {     ArrayList&lt;String&gt; changeList = new ArrayList&lt;String&gt;();     for(Coin coin : Coin.values()){         int moneyToCoin = inputMoney.getInputMoney() / coin.getAmount();          if (moneyToCoin &lt; coin.getCount()) {             coin.setCount(moneyToCoin);             changeList.add(coin.toString());             return changeList;         }         changeList.add(coin.toString());         inputMoney.subtractMoney(moneyToCoin * coin.getAmount());     }     return changeList; }  위의 로직 그대로 else문을 사용하지 않기 위해서 만약 환전한 동전의 개수가 자판기의 현재 갖고있던 돈보다 적다면, 해당 coin의 count를 환전한 동전의 개수로 변경 한 뒤, 바로 changeList를 return 함으로써 종료하도록 했다.   이제 이를 vendingMachine()에서 getChange를 통해 얻은 ChangeList를 출력해주는 메서드를 OutputView에서 구현해줌으로써 controller에서 출력하게 만든다.   OutputView.class  1 2 3 4 public static void printChange(ArrayList&lt;String&gt; changeList) {     changeList.stream()             .forEach(System.out::println); }   VendingMachineContoller.class  1 2 3 4 private void printChange(VendingMachine vendingMachine) {     OutputView.printMoneyStatus(vendingMachine);     OutputView.printChange(vendingMachine.getChange()); }  추가로, 잔돈 출력 전에 현재 투입금액을 한번 더 출력해주기 위해 다시 한번 prinMoneyStatus() 메서드를 사용해주었다.   이로써 VendinMachineController의 run() 함수를 사용하여 모든 테스트를 통과 할 수 있었다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class VendingMachineController {     public void run() {         VendingMachine vendingMachine = new VendingMachine();         getMachineMoney(vendingMachine);          makeRandomCoin(vendingMachine);         getMerchandiseInfo(vendingMachine);          getInputMoney(vendingMachine);          do {             purchase(vendingMachine);         } while (!vendingMachine.canPurchase());          printChange(vendingMachine);     }      private void getMachineMoney(VendingMachine vendingMachine) {         try {             vendingMachine.setMachineMoney(InputView.printGetMachineMoneyMessage());         } catch (IllegalArgumentException exception) {             OutputView.printErrorMessage(exception);             getMachineMoney(vendingMachine);         }     }      private void makeRandomCoin(VendingMachine vendingMachine) {         vendingMachine.makeRandomAllCoin();         OutputView.printCoinStatus(vendingMachine.getCoin());     }      private void getMerchandiseInfo(VendingMachine vendingMachine) {         try {             vendingMachine.addMerchandise(InputView.printGetMerchandiseMessage());         } catch (IllegalArgumentException exception) {             OutputView.printErrorMessage(exception);             getMerchandiseInfo(vendingMachine);         }     }      private void getInputMoney(VendingMachine vendingMachine) {         vendingMachine.setInputMoney(InputView.printGetInputMoneyMessage());     }      private void purchase(VendingMachine vendingMachine) {         try {             OutputView.printMoneyStatus(vendingMachine);             vendingMachine.purchase(InputView.printPurchaseMessage());         } catch (IllegalArgumentException exception) {             OutputView.printErrorMessage(exception);             purchase(vendingMachine);         }     }      private void printChange(VendingMachine vendingMachine) {         OutputView.printMoneyStatus(vendingMachine);         OutputView.printChange(vendingMachine.getChange());     } }  ","categories": ["java"],
        "tags": [],
        "url": "/java/Java-%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-3%EC%A3%BC%EC%B0%A8-%EC%9E%90%ED%8C%90%EA%B8%B0/",
        "teaser": null
      },{
        "title": "우테코 프리코스 마무리 회고",
        "excerpt":"우테코를 마치며  지원동기  작년 이맘때즈음에 나의 전공과 잠시 거리를 두고 휴학을 하기로 결정하고, 벌써 1년의 시간이 흘렀다.             그 시간동안 나의 꿈은 한때는 퀀트였으며, 빅데이터 전문가였고 마지막으로는 개발자의 꿈을 갖게 되었다.   우테코는 개발자가 되기로 결심한 순간부터 내 로드맵에 있는 큰 단계중 하나였는데, 아직 졸업도 하지 못했고, 우테코를 하기에는 실력이 부족하기 때문에 2022년을 졸업과 함께 실력을 키워 우테코 5기를 하는것이 원래의 계획이었다. 하지만 우테코 4기 공고가 올라오고, 나의 계획이 수정되어야 할 필요성을 느꼈다. 내가 우테코 5기에 붙을 수 있다는 확신도 없는데 준비가 안됐다는 이유로 두번의 도전 기회를 한번으로 줄이는 것 보다, 설사 떨어지더라도 도전해보고 그 경험을 발판 삼아 다음에 또 다른 기회를 잡는게 맞다고 생각했다.   우테코 4기 지원은 나에겐 나름대로 큰 결심이자 도전이었는데, 이유는 다음과 같았다.      아직 졸업을 하지 않은 상태라서, 만약 2년 연속 휴학한다면 전공지식을 많이 잊어버릴 것 같았다.   2년 휴학을 하게되면, 4학년을 정말 아는사람 한명도 없이 학교를 다녀야 한다는게 솔직히… 무서웠다.   난 올해 낸 휴학계로도 이미 남들보다 뒤쳐진다는 생각에 힘들 때가 많았는데, 이걸 1년 더 늦추는게 두려웠다.   이러한 이유들 때문에 지원을 몇일정도 고민했었는데, 너무 복잡하게 생각하던 문제들을 단순하게 생각하기로 했다.        그냥 아예 메모장을 켜서 내가 가진 문제들을 쭉 적고 이에대해서 단순하게 해결책을 한번 써보았다.      전공지식을 잃어버려도 상관없다. 어차피 이미 전공과 크게 다른 길을 가게되었기 때문에, 졸업만 하면된다.   솔직히 남은 학점 계산해보면 얼마 되지도 않아서, 학교에 갈 날이 몇일 되지도 않는다.   어차피 졸업을 먼저 하고 1년 공부를 하나, 1년 공부를 하고 졸업을 하나 조삼모사다.   직관적으로 눈에 보이도록 내가 가진 문제들을 적어놓고 하나하나 생각하니 전혀 큰 문제들이 아니었다. 내가 몇일을 고민한게 우스울 정도로 막상 글로 써놓으니 나의 문제들은 모두 아주 사소한 것들이었다. 그래서 그날 바로 자기소개서를 작성하고 코딩테스트를 준비하기 시작했다.   이처럼 우테코 지원은 시작도 전부터 큰 깨달음을 얻게 된 이벤트였다.   1차 과제 - 숫자야구 게임  사실 과제 구현 난이도로 보면 3주차 과제가 어려웠지만, 나에게 있어서 가장 어려웠던 과제는 1차과제였다.          난 자바로는 아주 간단한 프로그램을 만들어본 적도 없는데다가 다뤄본 언어는 C언어, 파이썬과 스위프트로 모두 절차지향에 가까운 언어였다.        물론 객체지향이 어떤 개념인지는 알고 있었고, 자바의 아주 기초적인건 공부했었지만 이론으로는 알아도 절차지향으로만 코딩하던 나의 사고를 객체지향으로 바꾸는 과정은 너무나 고통스러웠다.        게다가 내가 가장 자신있게 쓰고 연습했던 파이썬과 자바는 너무나… 대척점에 있었다. 파이썬은 극동적타입을 사용한다면, 자바는 극정적타입으로 모든걸 하나하나 선언해줘야 동작했다.        파이썬을 사용하면서도 왠만하면 정적타입으로 선언하려고 노력했던 나지만, 그래도 파이썬은 파이썬인지라 반환타입을 자꾸 빼먹는다거나 하는일이 빈번했다.         이런 상태에서 클린코드라는, 한번도 생각도 해본적 없는 개념까지 적용하며 여러 제약사항을 지키려니 너무나 힘들고 괴로운 시간이었다.   지금까지 내가 작성해온 코드는 모두 나 혼자만 만들고 보수하는 코드였고, 심지어는 앱을 출시하겠다는 큰 목표를 갖고 임했던 앱개발에서도 나 혼자서 모든 앱을 만들었기 때문에, 항상 나는 코드를 기능에 우선해서 작성했다. 기능만 돌아간다면 만사 오케이, 가끔은 어제 했던 작업인데 다음날 내 코드를 분석해야하는 날도 있었다. 물론, 어느새부터인가 앱의 기능이 늘어나고, 자주 발생하는 버그에 유지보수를 진행하게 되면서 어느 순간부터, 침몰하는 배의 판자를 고치기 위해 다른 판자를 떼서 막고, 또 거기가 구멍이 나면 또 다른 판자를 떼서 막는, 돌이킬 수없는 수렁에 빠진 듯한 기분이 들었다. 하지만, 이미 다시 처음으로 돌아가 클린코드로 다시 작성할 수 없었기 때문에 혼자 시간을 갈아 넣으며 내가 싼 똥(?)을 치우느라 엄청난 고생을 했었다.   이런 경험을 해봤었기 때문에 프리코스의 과정에서 배우는 내용들이 너무나 와닿았고, 클린코드에 대해 고민하는 시간들이 너무나 즐거웠다.   또, 객체지향 코드를 작성하는건 절차지향에 비해서 너무나 합리적이고 즐거운 일이었다. 절차지향이 그냥 나의 의식의 흐름대로 하나씩 프로그램을 작성하는 거라면, 객체지향은 중복 코드도 훨씬   줄일 수 있을 뿐더러 체계적으로 내가 클래스를 만들고 이를 통해서 인스턴스를 만들어 그 인스턴스들을 모아 일을 한다는 개념이 너무 신박하고, 객체지향을 처음 생각한 사람은 도대체 얼마나 머리가 좋은걸까… 하는 생각이 들었다.   그래서 1주차는 너무나 힘들고 괴로웠지만 정말 오랫만에 내가 왜 개발자를 택하게 됐는지, 내가 왜 코딩하는 것을 너무나 즐거워하는지 다시금 떠올릴 수 있는 한주였다.   프리코스 중에서 나는 1주차에 가장 많은 배움을 얻고 성장했다는 생각이 든다.   1주차 숫자야구 - 과정과 후기     https://learnote-dev.com/java/Java-우테코-프리코스-1주차-숫자야구-(1)/  https://learnote-dev.com/java/Java-우테코-프리코스-1주차-숫자야구-(2)/    2차 과제 - 자동차 경주  2차 과제는 뭔가 너무나 자연스럽게 클린한 코드를 작성하고, 자연스럽게 프로그래밍을 하는 내 모습을 보면서 너무나 뿌듯한 시간이었다.   1주차때 고생한 만큼, 실력이 부쩍 늘어서 2주차는 정말 금방 과제를 마무리 했다. 1주차에만 해도 머리를 싸매고 코드를 한시간에 한줄 씩 작성하던 내가 맞나 싶을정도로 내 성장한 실력을 시험해보는 즐거운 시간이었다. 2주차에는 큰 어려움 없이 과제를 마무리 했고, 시간이 남아서 우테코 다른 기수 3주차 문제였던 블랙잭 과제를 한번 구현해보며 2주차를 보냈다.   근데 이때 연습삼아 구현한 블랙잭 과제가 너무 어려워서 당황했는데, 이때까지만 해도 와 이떄 기수는 우테코 진짜 과제 어렵게 냈구나… 생각했다.   하지만 원래 우테코는 이런 레벨 디자인을 갖고 있었다는 사실을, 3주차 과제를 받고 깨닫게 되었다.   2주차 자동차 경주 - 과정과 후기     https://learnote-dev.com/java/Java-우테코-프리코스-2주차-자동차-경주-게임/    3차 과제 - 자판기  디아블로2는 아주 잘만들어진 레벨디자인으로 유명하다.   플레이어는 레벨이 오르고, 스토리가 진행됨에 따라서 점점 능력치가 높은 몹들을 상대하게 되는데, 이 몹들의 능력치가 아주 절묘하게 조절되어 있다.        능력치가 높고 난이도가 있는 맵을 몇개 클리어 하면, 반드시 능력치가 조금 떨어지는 몹이 있는 맵이 등장해서 플레이어로 하여금 “와 나 이만큼 쎄졌구나… 몹들이 그냥 녹네;;”         하는 생각이 들게 해서, 플레이어가 성장에 대한 체감을 직관적으로 할 수 있게 하여 더 게임에 몰입하게 만든다.   나는 프리코스를 진행하며, 프리코스가 디아블로2식 레벨 디자인을 갖고 있다고 생각했다.           어렵고 힘든 난이도인 1주차를 지나, 내가 얼마나 성장 했는지 느낄 수 있는 2주차 과제, 그리고 다시 난이도가 있는 3주차 과제…   2주차에서 자신만만해하던 내 모습이 창피할 정도로 3주차 과제는 어려웠다…            검사해줄 유효성도 배로 늘었고, 분리해야할 클래스도 훨씬 늘었다. 나름 클린코드에 익숙해졌다고 생각했는데, 프로그램이 조금 더 커지고 로직이 복잡해지니까 내 밑천이 드러나 버렸다.        하지만 2주차에는 오히려 괴롭지가 않고 너무 빨리 끝나서 뿌듯하면서도 아쉬운 느낌이 들었었는데, 3주차의 이 괴로움이 너무나 즐겁고 반가웠다.   그래서 3주차 과제에는 오히려 더 큰 제약을 걸어 TDD까지 적용해보기로 했다. 반드시 테스트 코드 작성 -&gt; 프로덕션 코드 기능 구현 -&gt; 리팩토링을 거치기로 규약을 정했다.   3주차 과제를 하면서 가장 어려웠던 부분은 첫부분인 코인을 랜덤으로 생성하는 부분과, 마지막 부분인 잔돈을 출력하는 부분이었다. 지금까지의 과제에서는 따로 로직이라고 부를 만한 메서드가 없었는데, 이 부분들은 로직이 필요한 부분이다보니 해당 메서드를 어떤방법으로 내용을 처리해서 어떤 타입으로 반환하고 출력할지 고민하는 부분이 너무 어려웠다. 물론 로직 자체가 어려운것도 아니고, 잔돈을 반환하는 부분은 코딩테스트를 준비하며 수도없이 풀어본 그리디 알고리즘이었지만, 각 객체에 답을 보내서 값을 변경하도록 구현하다보니 머리가 복잡해지고 자꾸 꼬여서 종이에 쓰고 지우고를 반복해가며 코드를 작성 했다.   반대로 3주차과제를 하며 뿌듯했던 부분은 상속과 stream, enum을 3주차에서 적용했다는 점이었다.   stream과 enum을 알고는 있었지만 실전에서 사용하는 방법이 어색해서 2주차에서는 사용하지 못했는데, 2주차가 끝나고 stream과 enum에 관련된 예제를 풀면서 실력을 좀 키웠더니 놀랍게도 2주차에서는 도통 이거를 어디다 쓰라는거야? 싶었던 stream과 enum을 어떻게 사용하면 코드가 더 간소화되고 읽기 쉬워지는지가 보여서, 전보다도 더 깔끔하고 읽기 쉬워진 코드를 보면 이루 말할 수 없는 뿌듯함이 밀려왔다. 또, 상속을 통해서 기존에 작성했던 코드를 재사용할때는 알수없는 쾌감마저 느껴졌다.   그리하여 마침내 ApplicationTest 두개를 모두 통과 했을때는 바로 책상에서 일어나 침대에 누워 그 행복감을 만끽했다.   비록 중간에 여러가지 버그도 발생하고, 테스트코드도 결국 모두 완벽하게 작성하지 못했지만, 너무나 막막하고 어려웠던 3차과제를 나름 만족스러운 코드로 요구 기능을 완벽하게 구현해서 너무나 기뻤다.   3주차 자판기 - 과정과 후기     https://learnote-dev.com/java/Java-우테코-프리코스-3주차-자판기/    마무리…  프리코스를 진행하기 전에는 그저 내 실력을 평가하고, 시험에 가까운 과제제출이라고 생각했다. 여타 시험들이 그렇듯, 당연히 나 혼자서 이뤄놓은 성장에 대한 결과를 증명하는 시간이고, 같이 참여하는 사람들을 경쟁자로 생각했다. 하지만 프리코스는 이름에 걸맞게 시험이 아닌 말그대로 “pre-course”였다. 우테코는 나의 실력을 테스트 하는 자리가 아니라, 우테코가 어떤방식으로 가르치는지 미리 경험해보고 내가 이 방식을 즐기고 익숙해질 준비가 되어있는지를 확인하는 느낌에 가까웠다.   참가자 분들도 자신의 PR에 자기가 작성한 코드에 대한 과정을 남긴 글들을 공유하거나, 자기에게 큰 도움이 됐던 글을 공유하기도 하며 서로를 경쟁자가 아닌 같은 교육과정을 듣는 동료로 생각하는게 보이는게 신기했다. 코드를 구현하다 막히는 부분이 있거나 이해가 안가는 어려운 부분이 있으면 먼저 PR을 보낸 다른 분들의 코드를 읽어보기도 했는데, 각자 클린 코드라는 큰 목표는 같지만, 각자가 생각하는 디테일한 방향은 달라서 역시 코딩은 정답이 없는 창작예술이라는 생각이 들었다. 우테코에 간다면 이렇게 서로 다른 코드를 놓고 더 나은 코드는 뭔지 토론할 수 있겠다는 생각에 더, 더 우테코에 가고 싶어졌다.   또, 기술적인 부분의 성장뿐만 아니라 배움의 방법에 대해서도 많이 깨우쳤다. 프리코스 진행 전, 우테코 캡틴인 Pobi의 강의를 거의 모두 봤는데, “의식적인 연습”의 중요성에 대해 설명한 부분이 너무 인상깊었다. 양치질을 맨날 한다고 해서 양치질 실력이 늘지 않듯이, 자신이 일정 횟수 이상 반복한 행위에 대해서는 의식 없이 그 일을 할 수 있게 되기 때문에 의식적으로 노력하지 않으면 실력이 늘지 않는다는 이야기였다. 자신이 익숙해진 자신의 세이프티존을 의식적으로 벗어나서 더 괴롭고 어려운 무언가를 해내야만, 내 실력이 늘고 내가 하지 못했던 일을 할 수 있게 된다는것이다. 특히나 코딩을 하다보면 항상 습관처럼 아무 생각없이 코드를 작성할 때가 많은데, 최근에 앱개발을 할 때도 머리로는 내 코드가 잘못된걸 알면서도 이미 손이 익숙해진대로 코드를 짜곤했다. 하지만 우테코에서는 확실하게 의식적인 연습이 가능한 제약사항을 정해 줌으로써, 제약사항을 준수하려면 어쩔 수 없이 의식적인 연습이 자동으로 되는 구조를 만들어놔서, 항상 의식적으로 내 코드를 점검하고 확인 할 수 있었다. 내가 앞으로 어떤 일에 대해 “의식적인 연습”을 하고 싶다면 나만의 제약사항을 먼저 정한 뒤 그것이 익숙해질때까지 연습을 반복하고, 익숙해진다면 제약사항을 추가하는 식으로 자연스럽게 스스로 “의식적인 연습”을 할 수 있다는 걸 깨달았다.   프리코스는 최종 결과와 상관없이 너무나 많은 것을 느끼고 배우는 시간이었다. 혹시나 우테코 지원을 고민하며 이 글을 읽는 사람이 있다면, 나는 자신있게 꼭! 프리코스라도 한번 참여해보는 것을 추천하고 싶다. 나에게는 프리코스 만으로도 그냥 학교에서나 학원에서는 배울 수 없는 너무 많은 값진 것들을 배울 수 있는 시간이었다.   이제, 다음주면 최종 코딩테스트가 진행된다. 3주차 수준으로 나온다면 5시간안에 구현할 수 있을지 걱정도 되고 두렵지만, 남은시간을 더 열심히 해낸다면 해낼 수 있을거라고 믿어 의심치 않는다. 프리코스를 진행하고나니, 정말 너무나 우테코에 가고싶은 마음이 간절해졌다.   정말 최선을 다해서 코딩테스트를 준비해야겠다. 그리고 꼭 내년에는 우테코와 함께하고 싶다! 제발…   ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%94%84%EB%A6%AC%EC%BD%94%EC%8A%A4-%EB%A7%88%EB%AC%B4%EB%A6%AC-%ED%9A%8C%EA%B3%A0/",
        "teaser": null
      },{
        "title": "2021년 결산 + 우테코 탈락...",
        "excerpt":"2021년 결산  짧디 짧은 2021년이 어느새 막을 내렸다.            여러모로 2021년은 나한테 뜻깊고 인상적인 해였다. 휴학을 결심하고 내가 하고싶은 일이 무엇인지, 어떻게 살 것인지를 생각하며 보냈던 1년이었다.             지난 1년간 나는 아무걱정없이 쉬어보기도 하고, 태어나서 가장 치열하게 무엇을 해보기도 하며 내가 하고싶은 것들을 마음껏 했다. 지금 생각하면 만약 휴학을 결정하지 않았더라면               그냥 또 하고싶지도 않은 공부를 하며 살아지는대로 살았겠다는 생각에, 나를 휴학하자고 꼬신 지섭이에게 고맙다는 말도 전하고 싶다… ㅎㅎㅎ   목표한 바를 얼마나 이뤘을까?  7월에 작성한 휴학 반년 결산은 아래의 링크에서 볼 수 있다.     휴학 반년 결산    7월에는 지난 6개월의 휴학을 돌아보고 피드백함과 동시에 남은 6개월에 대한 목표와 다짐을 적어 놓았는데, 동일하게 7-12월을 돌아보며 피드백을 해보려 한다.          우선 지난 상반기 결산에서 하반기에 이루고자 했던 목표는 다음과 같았다.           영어 실력 향상  프로그래머로써 영어는 매우 중요하다. 인터넷에서 얻는 정보의 대부분은 영어로 되어있는데, 특히나 프로그래머로써의 원하는 정보들은 대다수가 영어이다.            프로그래머로써의 포트폴리오 채우기  내가 무엇을 공부하고, 어떤 방향성을 가졌는지 나 혼자 공부해서는 아무도 알아주지않는다. 꾸준히 블로그에 기록하고, 커밋하고 무언가를 남겨야 한다. 기억하지말고 기록해야 나의 기억을 다른 사람도 이해해준다.            투자를 통한 자산증가  단기간에 큰 수익률을 올리는 것에서 이제 손을 떼고, 연 수익률 딱 15퍼센트를 목표로 천천히 매매하는 것을 목표로 지속 가능한 투자를 하는것이 목표이다.            오프라인 개발자 모임 참여  혼자 방구석에서 공부해서는 수많은 길이 있는지도 모른채로 한길만 택해서 나아갈 뿐이다.  또, 포트폴리오로 나를 증명하는것 보다, 남이 나를 증명해주는것이 백배는 효과적이다. 내 실력을 알아줄 다른 사람들을 사귀어야 한다.       이와 동시에 막상 결산을 하려고보니, 성과에 대한 마땅한 지표가 없어서 내가 잘했는지 못했는지, 앞으로 어떤 점을 개선해야하는지에 대한 판단을 내리기가 모호하여 내 성과를 측정할 수 있는 여러 장치를 만들어서        평가하고, 이전과 비교하고, 개선할 수 있도록 기록을 꾸준히 하기로 다짐했다.   첫번째로 영어실력 향상은 크게 이루어졌다기 보다는 코딩에 관해서 영어를 읽는 능력이 조금 늘어난 것 같다. 사실 영어공부를 따로 진행할 시간이 마땅히 없어서, 그냥 스택오버플로우나 언어관련 서칭을 하다가 영어를 많이 접하면서           실력이 아주 조오오금 늘어난 것 같은데, 지금은 영어보다는 기본적인 코딩실력을 키우는걸 중점으로 하는게 맞다고 판단되어서, 영어는 자연스럽게 문서나 스택오버플로우에서 읽고 이해하고 질문 정도를 할 수 있을 정도로 숙달하는 것이 좋겠다는 생각이 들었다.   두번째로 프로그래머로써의 포트폴리오 채우기는, 나름 간단한 스타트업 초기단계 앱을 제작해보기도 하고 우테코에도 지원해보기도 하면서 이력아닌(?) 이력을 남겼고, 공부한 것도 부족하지만 나름 꾸준히 기록했다고 생각한다. 아쉬운 점이 있다면 공부기록량을 한 두배정도는 늘려야 할 것같다. 공부한것을 기록하다보니 나름 방문자수가 조금씩 조금씩 (물론 아아아아아주 조금이다 애초에) 늘어나는걸 보니 좀 더 방문자수가 늘어나면 나를 아는 사람도 늘어날거라는 생각에, 공부를 좀 더 읽기 편하게 기록해야겠다는 생각이 들었다.   세번째는 사실 저때만 해도 투자에 되게 관심이 많은 상태라 저런 목표를 적어 놓았는데, 공부하다 보니 투자를 하려고 서칭하고 공부하는 시간을 따로 내는게 어려웠다. 지금 내 일을 하는것도 빠듯한 상태에서 본업이 아닌일에 시간을 쏟는게 더 맞다고 생각했고, 간간히 시장흐름이나 간단하게 내가 매수한 종목들만 체크하는 걸로, 이전에는 조금 단기내지 중기적인 투자였다면 이제는 정말 최소 5년이상을 보는 장기투자를 하는게 낫다는 판단을 내렸다. 물론 꾸준히 경제나 투자관련 유튜브와 사이트를 구독해놓고 틈틈히 읽고있기는 하다. 하지만 트레이딩 자체에 이제 정신력이나 체력을 쏟지는 않기로 했다. 물론 현재는 장이 많이 안좋아서 수익률이 꽤나 마이너스를 기록하고 있기는 하다…   네번째, 오프라인 개발자 모임 참여는 클레이 앱제작이 좋은 기회라고 생각해서 참여했지만, 사실 개발자가 모여있는 사업체가 아니었다보니 아무래도 개발 역량이 커졌다기보다는 대략적인 창업과정에서의 어려움이나 치열하게 어떤일에 몰두해본 경험을 얻게된 좋은 시간이었다. 물론 결국에는 개발자들의 모임이 필요하다고 생각해서 우테코에 지원했지만, 아쉽게도 탈락하면서 이 목표는 반쯤 애매하게 지켜졌다…   이렇게 보니까 2021년 상반기 결산 때 다짐 했던 것을 거의 다 못지킨 것 같다… 하지만 저때만 해도 개발자의 로드맵에 대한 지식이 부족했고, 정확히 어떤걸 해야할지 몰라서 목표가 조금 내가 해야할 일들과 동떨어져 있었지 않나 싶다.          2022년에는 조금 더 명확한 목표가 필요하다는 생각이 들었고, 중간에 수정도 조금 필요하겠다는 생각이 들었다. 그리고 결산에서의 다짐이나 목표가 흐려지지 않게끔 2022년에는 분기별 결산을 해야겠다는 생각이 강하게 들었다.   상반기 결산에서 정했던 목표에 대한 피드백은 여기까지 하고, 본격적으로 2021년 하반기에 내가 무엇을 했는지 기록해보도록 하자.   2021년 하반기 회고  토스 코딩테스트 도전  8월에 있었던 토스 코딩테스트에 도전했었다. 한창 코딩테스트를 여러개 풀면서, 취업을 위해 필요한 능력들을 키우고 있었는데, 토스 코딩테스트가 좋은 기회가 될 것같아서 무작정 지원해서 도전해보았다.           문제가 내가 풀던 수준보다 너무 어려워서 한두문제를 제외하고는 잘 풀지 못했지만 그래도 풀 집중한 상태로 실제 기업의 코딩테스트를 본 경험이 아주 큰 도움이 되었고, 내가 어느정도까지 알고리즘에 대한 실력을 키워야 하는지 감을 잡을 수 있는 좋은 경험이었다. 토스 코딩테스트 이후로, 왠만한 기업에서 실시하는 코딩테스트들을 모두 참여해봐야겠다는 생각이 들었다. 또, 운이 아주아주 좋게 개발지원금 대상자로 선정이 되서 100만원 까지 받으며 역시 혜택은 도전하는 자의 것이라는 깨달음과 함께 나의 강력한 운빨을 테스트할 수 있는 좋은 시간이었다… ㅎㅎㅎ 물론 상위 50퍼센트에서 추첨이라서, 나름 그래도 50퍼센트 안에는 들었구나 하는 생각이 들어 더욱 뿌듯했던 경험이었다.   관련 기록     토스 NEXT 코딩테스트 후기  토스-NEXT-개발지원금-당첨되다    클레이 프로토타입 앱 제작  아는 형이 창업지원금을 받아서 도전했던 “클레이” 라는 식단관리 앱에 1인 개발자로 참여하여 나름 개발자로써의 첫 급여를 받으며 2달정도 ios앱을 제작해 보았다.      ios앱 개발경험이 전무한 상태에서 시작해서 매우 힘들었지만, 정말 하나에 몰두해서 일해본 아주 즐거운 경험이었다. 정말 하루를 밤을 꼬박새가며 아침 아홉시에 잠든적도 있고, 하루에 13시간을 코딩만 해보는 경험도 해보며           태어나서 가장 열심히 해봤던 경험임에는 틀림없는 정말 값진 시간이었다. Swift와 xcode 그리고 firebase를 정말 한번도 안해본 상태로 시간을 갈아 넣어가며 나름대로 서버가 존재하고, 테스트 유저들이었지만 정말 돈을 내고 우리 앱을 사용하는 유저들과 함께 진행했던 필드테스트 기간은 정말 많이 힘들고, 매일 발생하는 버그에 머리가 아팠지만 돌이켜 생각해보면 너무너무 즐겁고 값진 시간이었다. 또, 실제로 창업을 위해서 머리를 모아서 맞대고 어떠한 서비스가 시장에 먹힐까를 고민하며 토론만 다섯시간씩 진행했던 회의들은 아직도 너무너무 좋은 경험으로 남아있어서, 2022년에는 꼭 정부 지원금을 받아서라도 내 사업을 한번 꾸려보고 싶은 마음이 크게 생겼다.   또, 기술적으로는 Swift라는 언어를 다뤄볼 수 있는 좋은기회였고, 어플개발 특성 상 혼자서 프론트엔드와 백엔드를 간접적으로 둘 다 경험할 수 있어서 아주 좋은 시간이었다. 비록 Firebase를 이용해서 비교적 간단한 서버였지만 서버를 내가 직접 구축하고, 서버에서 정보를 받아오며 발생하는 여러문제점들을 개선하며 좀 더 백엔드 개발자의 꿈을 굳건히 하는 계기가 되었다. 또, 프리랜서 디자이너님과 함께 협업도 경험해 보는 시간이었는데, 디자이너분이 주신 디자인을 기능적으로 움직이고 동작하게 하는 경험들이 너무나 새롭고 즐거웠다. 원래 프론트엔드에는 아예 뜻이 없었는데, 프론트엔드를 꿈꾸는 사람들은 어떤거에 흥미를 느껴 프론트엔드 개발자가 되고싶어하는지 느꼈던 시간이었다.   아마 올해 가장 강력하고 성장하는데 가장 큰 도움이 됐던 경험을 꼽으라면 클레이에서 앱을 개발했던 2개월인 것 같다.   관련 기록     스타트업  다시 일기 쓰러옴…    우아한 테크 코스  다음은 가장 올해 아쉽고 쓰라렸던 경험인 우아한테크코스이다.        원래는 1년후에 학교를 졸업하고 지원할 예정이었는데, 붙는다는 보장도 없는 상태에서 그렇게 안일하게 계획을 짜는것보다는 떨어지더라도 지원해보는게 좋겠다는 생각이 들어서 지원서를 냈다.   1차를 무난하게 통과해서 나름 지난 기간동안 공부한 알고리즘 공부가 빛을 발하는 것 같아 너무 뿌듯했지만, 최종에서는 탈락하게 되면서 2021년을 마무리하는데에 있어 조금 아쉬운 부분으로 남게 되었다. ㅜ         그래도 사실 우테코는 내가 상반기에 세웠던 오프라인 개발자들과의 모임 참여라는 목표를 나름 달성하게 해준 것 같다. 주변에 코딩을 어떻게 하라고 말해줄 사람도 없고 배울 사람도 없어서, 사실 이게 맞나… 하는 맘으로 기능만 돌아가는 코딩을 하고 있었고, 그 부분을 항상 어떻게 해야할지 고민 했었는데, 프리코스를 지나며 정말 정답에 가까운 코딩 방법들을 배우며 정말 개발자로써의 3번째 눈이 떠졌다고 표현해도 과언이 아닌 정말 좋은 시간이었다.   클레이 앱개발로 인해 개발자에 대한 열정이 끓어 올랐다면, 우테코 프리코스는 어떠한 개발자가 좋은 개발자고 어떻게 공부해야하는지에 대한 해답이 되어주었다. 올해는 아쉽게 최종에는 탈락했지만, 이를 기반으로 내 자바 실력을 갈고 닦아, 내년에는 반드시 우테코에 합격하고 싶다.   관련 기록     우아한 테크 코스  우아한 테크 코스 1차 코딩테스트 후기       우테코 프리코스 마무리 회고    지표로 알아보는 2021년 하반기  지난 상반기때 목표한 것 중 하나가 바로 기록을 통한 지표를 만들기였는데, 블로그 게시물로도 많은 기록을 남겼지만 내가 코딩한 시간들을 매일 매일 기록해가며 이전과 비교하고 개선할 수 있도록 했다.       5월 부터 시작한 코딩시간 기록표를 이곳에 첨부해서 얼마나 노력했는지 확실하게 수치로 알아보도록 하자.   2021년 코딩시간 기록표     위 코딩 시간 기록표를 바탕으로 여러가지 재밌는 수치들을 여기에 기록해보고, 다음 2022년 1분기 결산 때는 더 나은 수치를 가져오도록 하자!           가장 많이 코딩한 달  가장 많이 공부한 달은 10월달로, 클레이 필드테스트를 앞두고 버그개선과 기능 개발로 인해 정말 눈코 뜰 새 없이 코딩을 했다. 무려 137시간에 달하는 시간을 코딩을 했으며, 이를 일로 환산하면 5.7일이다.            가장 적게 코딩한 달  가장 적게 코딩한 달은 12월로, 64시간을 코딩했다. 사실 12월은 우테코도 끝나고 연말이라 좀 휴식도 필요하고 사람 만날일이 많아서, 우테코 최종 코딩테스트 이후로는 컴퓨터를 켜지도 않았다. ㅎㅎㅎ            가장 많이 코딩한 날  가장 많은 코딩을 한 날은 10월 2일로, 이날은 13시간 25분동안 코딩을 했다! 아마 필드테스트 시작을 하루 앞두고 밤을 새웠던 날이었던 걸로 기억한다.            코딩을 한번도 안한 날은 총 몇일?  코딩을 한번도 안한날은 총 66일로, 7월부터 12월은 184일이 있으므로 118일은 코딩을 했고, 66일은 코딩을 하지않았다. 대략 35퍼센트의 확률로 이민재는 코딩을 하루에 하나도 안했다.            그래서 총 얼마나 코딩을 했는데?  올해 상반기 후반부터 기록을 시작해서 상반기는 총 코딩시간을 측정할 수 없어 비교해볼 수는 없지만 하반기에는 모든 날을 기록했기에 총 코딩시간을 알 수 있다.           2021년 하반기에 나는 총 620시간 1분을 코딩했다! 이를 일로 환산하면 25일이다.            평균 코딩시간  총 620시간을 코딩하고, 7-12월의 총 날짜가 184일이 있으므로, 평균적으로 하루에 3시간 20분 정도를 코딩했다.       확실히 지표로 나타내보니까 재밌기도 하고 확실한 개선점이 눈에 보일 것 같아서 내년 1분기 결산이 벌써 기다려진다. 이전 결산보다 개선되는 지표를 항상 낼 생각으로 열심히 살아야겠다!   2022년 목표!  2021년은 개발자로써의 꿈을 찾고 이를 굳건히할 열정을 끓어올리고, 개발자로써의 방향성을 견고히했던 년도였다면, 2022년은 정말 프로페셔널한 개발자가 되기위한 나의 실력과 경험을 끌어올릴 수 있는 한해가 되어야 한다.   그래서 목표는 아래와 같다!           스타트업 창업해보기  클레이에서 일해보며 사업이 크게 리스크 있지도 않고 도전하기 무서운 일이 아니라는 것을 알게되었다. 게다가 우테코 탈락으로 인해 다시 학교로 돌아가게 되었으므로, 창업을 지원받을 수 있는 수단이 하나 늘어나게 되었다. 물론 만약에 사업이 잘될경우에 목표의 많은 부분이 변경되어야겠지만, 2022년에는 학교로 돌아가는 만큼 반드시 창업을 한번 경험해보고 싶다. 그냥 실력 키울라고 하는게 아니라 진짜 성공할 다짐으로! 물론 망해도 이득이니까…            코딩 시간 지표 개선  위에서 정리한 지표 중, 두 지표가 가장 중요하다고 생각되서 이 두 지표를 개선할 생각이다. 첫 번째는 코딩을 한번도 안하는 날의 퍼센테이지 감소, 두 번째는 평균코딩시간의 증가이다!         코딩하는 시간의 양도 물론 중요하지만, 내 꾸준함을 개선하는 것이 어쩌면 시간의 양보다도 더 중요하다는 생각이 들어서 시간의 양보다 우선적으로는 하루에 시간이 없다면 코딩테스트라도 한문제씩 풀면서 코딩을 하루에 한번도 안하는 날을 줄이는게 2022년의 우선적인 지표개선의 목표이다. 2022년 1분기까지 공부 미참여 퍼센트를 20퍼센트를 넘지 않게 하는 것을 목표로, 평균 공부 시간은 4시간을 넘기는 것을 목표로 개선해보도록 할 것이다.            자바 실력 늘리기  사실 그동안은 무작정 파이썬으로 알고리즘 준비를 하기도 했고, 사용했던 언어들이 주로 절차지향언어라 자바를 갑자기 하기에는 너무 어렵고 힘들었다. 이번에 우테코에서 얻은 경험들을 바탕으로, TDD 그리고 클린코드를 습관화 해서 몸에 체득할 수 있을 정도로 자바실력을 갈고 닦는 것이 목표이다.            4개 이상의 웹페이지 만들기  분기별로 반드시 하나씩, 웹페이지를 직접 만들어보며 여러가지 실력을 늘리고 싶다. 3번과 어쩌면 중복되는 부분일 수 있지만, 수치적으로 정확히 정해두고 싶은 생각이 들어 2022년에는 반드시 4개 이상의 웹페이지를 제작해보도록 할 것 이다! 물론 아직 지식이 부족해서 과한 목표가 될 수도 있겠지만, 아주 간단한 웹페이지라도 좋으니 기능적으로 동작하는 웹페이지를 클론 코딩 해서라도 4개 이상 만들어 보도록 하겠다.            우테코 합격  올해의 경험을 바탕으로 반드시 내년에는 우테코를 합격하도록 할 것이다. 만약 1번의 목표가 너무 잘될 경우는 패스… 해야하나? 잘되면 그때 고민해 보고 우선 2022년의 목표중 하나는 우테코 합격이다 무조건!!!       마치며…  2022년의 목표를 이렇게 대략 설정해보았다. 코딩을 할때 우선적으로 어떤 기능을 개발하는지 README 파일에 작성하면 코딩 할때 어떠한 기능을 먼저 만들어야할지 고민하지 않듯이, 내 2022년을 어떤 목표들을 향해 달려가야할지 2022년 README파일을 만들면 2022년 동안에 내가 어떤 일을 해야 내가 목표한 바를 이룰 수 있을지가 명확해진다고 생각해서, 이렇게 2021년 회고와 함께 2022년 목표를 적어 보았다. 2022년에는 다시 학교로 돌아가는 만큼 졸업을 포함해 여러가지로 바쁘고 힘든 한해가 되겠지만, 위의 목표를 모두 이뤄 2023년을 맞이 할 수 있도록 힘차게 달려가 볼 것이다.   이민재 화이팅!!!  ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/2021%EB%85%84-%EA%B2%B0%EC%82%B0-+-%EC%9A%B0%ED%85%8C%EC%BD%94-%ED%83%88%EB%9D%BD/",
        "teaser": null
      },{
        "title": "2022년",
        "excerpt":"2022.01.02  드디어 2022년의 새해가 밝았다. 아직 낯선 2022년을 맞이하며 올해는 훨씬 더 많은 일기를 써보려한다.        2022년에는 조금 더 기록을 세세하고 자주 남겨보려고 한다. 결국 내 입장에서는 내 이야기가 내 세상의 전부니까, 나중에 다시 읽어봤을 때 누가 봐도 재밌고 서사가 있는 이야기였으면 좋겠다.   누구나 의욕 넘치는 새해지만, 나는 좀더 의욕이 넘친다! 올해가 끝날 때는 꼭 성공이 아니더라도 2021년보다 더 이야깃거리가 많은 2022년이었으면 한다. 2022년의 이민재 화이팅!   ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/2022%EB%85%84/",
        "teaser": null
      },{
        "title": "[Spring] Bean이란 무엇일까?",
        "excerpt":"스프링에서 @Autowired를 사용하려다가 Bean이 무엇인지 잘 모르겠어서 Bean에 대해 정리해보려 한다.   Java Bean  먼저 Java Bean은 특정 형태 클래스를 가르키는 뜻으로, DTO 혹은 VO의 형태가 Java Bean이라고 생각하면 된다.   필드는 private로 구성되어 getter와 setter를 통해서만 접근할 수 있고, 전달인자가 없는 생성자를 가지는 형태의 클래스이다.   Java Bean의 조건을 정리해보면 다음과 같다.     변수는 getter / setter를 통해서만 접근 가능하도록 private로 선언되어야 한다.   생성인자는 전달 인자가 없는 생성자여야한다.   Spring Bean  Spring에서의 Bean은 스프링 IoC컨테이너가 관리하는 Java 객체를 뜻한다.         Java Bean과 똑같은 개념이지만, 이 객체는 스프링 IoC컨테이너에서 관리된다.   스프링 IoC가 관리하는 객체라함은 스프링에 의해 생성되고, 라이프 사이클을 수행하고, 의존성 주입이 일어나는 객체들을 말한다.       즉, 정리하면 개발자가 관리하는 객체가 아닌 스프링에게 제어권을 넘긴 객체를 스프링에서 Bean이라고 부른다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-Bean%EC%9D%B4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[Spring] IoC란 무엇일까?",
        "excerpt":"스프링을 사용하다보니, 스프링의 특징 중 하나인 IoC, Inversion of Control의 개념이 이해가 잘되지 않아서 정리해보았다.   이 게시물은 유튜브의 백기선님의 강의인 “스프링 입문”을 보고 공부하며 작성한 글입니다.      출처  스프링 입문 - 5.Inversion of Control    일반적인 제어권  일반적으로 자바에서는 의존성에 대한 제어권이 개발자에게 있다. 따라서 내가 사용할 의존성은 내가 만들어야한다.   1 2 3 class OwnerContoller {     private OwnerRepository repository = new OwnerRepository(); }  위 와 같이 repository라는 new OwnerRepository(); 처럼 직접 만들어주어야한다.   IoC  하지만 위와 다르게 아래 코드를 보면,  1 2 3 4 5 6 7 8 9 class OwnerController{     private OwnerRepository repo;          public OwnerController(OwnerRepository repo) {         this.repo = repo     }          // repo를 사용한다. }  이렇게 하면 OwnerContoller는 OwenerRepository를 사용은 하지만, 이 객체를 만들지는 않는다. 따라서 외부에서 누가 만들어준 OwnerRepository를 받아와야 사용할 수 있으므로, 의존성을 외부에서 만들어주어야 한다. 그렇기 떄문에 이것은 제어권이 역전되었다고 볼 수 있는데, 이를 Inversion of Control, IoC라고 한다.   스프링은 관리하는 bean으로 등록되어 있다면, 이 의존성을 알아서 타입에 맞도록 가져와서 주입해준다. 그렇기 때문에 제어권을 스프링이 가지므로 제어권이 개발자에게 있는게 아니라 스프링에게 있다고 할 수 있는데, 이렇게 하면 스프링이 알아서 제어권을 갖고 직접 관계를 부여하기 때문에 개발자 입장에서는 훨씬 신경 써야 할 것이 줄어든다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-IoC%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[Spring] WAS란 무엇일까?",
        "excerpt":"이 게시물은 유튜브에 있는 “10분 테코톡 희봉의 웹서버 vs WAS”가 설명을 아주 잘해놔서 해당 영상을 보고 정리하였습니다.   10분 테코톡 = 희봉의 웹서버 vs WAS   공부를 하다보니 WAS라는 개념이 나오는데, 이 개념이 모호하였다. 찾아보니 유튜브에 아주 잘 정리해놓은 영상이 있어 이를 간단하게 블로그에 정리해 보기로 했다.   먼저 Web과 Serverd의 정확한 개념부터 정리해보자.   Web     인터넷을 기반으로 한, 정보를 공유, 검색할 수 있게 하는 서비스   URL(주소), HTTP(통신 규칙), HTML(내용)의 세가지 요소로 이루어져 있다.   Server     클라이언트에게 네트워크를 통해 정보나 서비스를 제공하는 컴퓨터 시스템   WebServer     인터넷을 기반으로 클라이언트에게 웹 서비스를 제공하는 컴퓨터   클라이언트가 웹서버에게 주소(URL)을 가지고 통신규칙(http)에 맞게 요청하면, 알맞은 내용(html)을 응답받을 수 있다.   그렇게 하면 서버는 클라이언트의 요청을 기다리고, 웹 요청(http)에 대한 데이터를 만들어서 응답해주는데, 이때 데이터는 웹에서 처리할 수 있는 html, css, 이미지 등 정적인 데이터로 한정된다.   태초에 Web이 생겼을때는 이러한 문제 때문에, 만약 우리가 어떤 정보를 web에 올리고 싶다면 일일히 모든 정보를 작성해주어 올려야 했다. 만약 구구단을 web에 올리고싶다면 for문을 사용해서 연산을 통해 출력하는것이 아니라, 일일히 모든 단수를 적어서 올려주어야 했던것이다. 그래서 이러한 정적인 데이터만을 취급하는 webServer의 문제점을 해결하기 위해 나온 것이 바로 WAS (Web Application Server)이다.   WAS  WAS는 웹 애플리케이션과 서버 환경을 만들어 동작시키는 기능을 제공하는 소프트웨어 프레임워크로, 웹 애플리케이션을 실행시켜 필요한 기능을 수행하고 그 결과를 웹서버에게 전달함으로써, 원래는 정적인 데이터만을 취급 가능했던 웹서버가 이제는 어플리케이션을 통해 연산한 데이터를 받아 웹서버에 표시하게 됨으로써 동적인 데이터를 사용할 수 있게 된 서버를 말한다.   따라서 WAS는 php, jsp, asp와 같은 언어를 사용해서 동적인 페이지를 생성할 수 있으며, 프로그램 실행 환경과 데이터베이스 접속기능을 제공하고, 이를통해서 비즈니스 로직을 수행 가능하다.   Was는 WebServer와 WebContainer로 구성되는데, 여기서 WebContainer는 jsp나 seevlet과 같은 것들을 실행 시킬 수 있는 소프트웨어로, 웹애플리케이션이 배포되는 공간을 말한다.   따라서 클라이언트에서 Was로 요청을 보내면, 먼저 WebServer에서 이 요청이 정적요청인지, 동적 요청인지를 판별한다. 만약 동적 페이지를 요청한다면, 이 요청을 WebContainer에게 전송해 WebContainer가 이를 받아 동적 컨텐츠를 생성한다. 그렇게 받은 동적 컨텐츠를 Client로 전송하는 방식으로 Was가 동작한다.   따라서 상황에 따라 변하는 정보를 제공할 수 있다면 WAS, 그게 아니라면 WebServer라고 생각하면 간단하게 이 둘을 구분할 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-WAS%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/",
        "teaser": null
      },{
        "title": "[Spring]스프링부트 초기설정",
        "excerpt":"이 게시물은 이동욱님의 “스프링 부트와 AWS로 혼자 구현하는 웹 서비스”를 읽고 공부하며 작성한 게시물입니다.   시작하며…  올해의 목표들을 이루고, 본질적으로 나의 실력을 키우기 위해서 자바 스프링으로 웹사이트를 구현해보려 한다.      뭐든지 가장 제일 빠르게 배우고 흥미있게 배우는 방법은 실제로 만들어 보는것이므로 직접 간단한 웹사이트를 만들어 가면서 숙달해보기로 했다.   아무래도 가장 좋은건 책을 따라 하는 것 같아서 책을 한권 구입해서 따라해가며 만들어 보고, 그 다음에는 혼자서 원하는 기능의 웹사이트를 하나 만들어가는 것을 목표로 해보려고 한다. 책은 최대한 이론서 보다는 따라하면서 직접 만드는 결과가 눈에보이며, 완독 후에는 내 힘으로 웹사이트를 만들 수 있는 기술을 배울 수 있고, 현직에서 사용하는 방식을 설명해주는 책을 원했는데, 고맙게도 딱 맞는 책이 있어 구입했다. 맨 처음에는 목차와 커리쿨럼을 보고 골랐는데 알고보니까 평소에 블로그도 많이 접하고 유튜브로도 많이 접했던 이동욱님이 쓰신 책이어서 구입 후 책을 펼치자마자 책 잘샀다는 생각이 들었다.   그럼 스프링푸트 초기설정부터 시작해보자.   스프링 부트 초기설정  스프링 프레임워크는 타 언어와 프레임워크, 예를들어 NodeJS와 Express, Python과 Django, Ruby와 Rails에 비해서 복잡하고 어렵다는 인식이 있는데, 현재에는 스프링부트가 나오면서 훨씬 편하게 설정을 할 수 있게 되었다.   먼저 gradle 프로젝트를 생성해서 이를 스프링 부트 프로젝트로 변경해보자.   스프링부트 이니셜라이즈를 사용하면 이 부분을 간단하게 설정할 수 있지만, 그래도 어떤 방식으로 스프링 부트 프로젝트를 생성할 수 있는지, 어떤 역할을 하는지 그 원리를 배우기 위해 직접 설정해보도록 한다.   build.gradle 파일을 열어 설정해주자.   1 2 3 4 5 6 7 8 9 10 11 12 buildscript {     ext {         springBootVersion = '2.1.7.RELEASE'     }     repositories {         mavenCentral()         jcenter()     }     dependencies {         classpath(\"org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}\")     } }  기본적인 코드 에다가 위와 같은 부분을 먼저 맨앞에 추가 해주는데, 먼저 ext 부분은 전역변수를 설정하는 부분으로 springBootVersiond르 전경변수로 생성하고 그 값을 “2.1.7.RELEASE”로 하겠다는 뜻이다. 이렇게 하면 각 라이브러리들의 버젼을 한 곳에 모아 관리할 수 있어 관리도 편하고, 충돌문제도 해결할 수 있다.   그 다음은 앞서 선언한 플러그인 의존성들을 적용할지를 결정하는 코드이다.   1 2 3 4 apply plugin: 'java' apply plugin: 'eclipse' apply plugin: 'org.springframework.boot' apply plugin: 'io.spring.dependency-management'  특히 io.spring.dependency-management 플러그인은 스프링 부트의 의존성들을 관리해주는 플러그인이기 때문에 꼭 추가해주어야 한다.  위 플러그인들은 자바, 스프링부트를 사용할 떄 필수이기 떄문에 항상 추가해주면 된다.   그리고 나머지 코드들을 아래에 추가해주면 된다.   1 2 3 4 5 6 7 8 9 repositories {     mavenCentral()     jcenter() }  dependencies {     implementation('org.springframework.boot:spring-boot-starter-web')     testImplementation('org.springframework.boot:spring-boot-starter-test') }  rpositiories는 각종 의존성들을 어떤 원격 저장소에서 받을지를 정한다. 보통은 mavenCentral을 사용하지만, 라이브러리가 어려운 mavenCentral에 비해 라이브러리 관리가 간편한 jcenter도 많이 사용한다. 따라서 mavenCentralr과 jcenter둘다 등록해주도록 하자.   dependencies는 프로젝트 개발에 필요한 의존성들을 선언하는 곳으로, 여기서는 org.springframework.boot:spring-boot-starter-web과 org.springframework.boot:spring-boot-starter-test를 받도록 선언해준다.   단 의존성 코드를 선언할때 특정 버젼을 명시하지 않아야만 위에 선언했던 springBootVersion의 버젼을 따라가게 되기 때문에,   특정 버젼은 명시하지 않아야한다.   이렇게 하면 기본적인 스프링 부트 개발환경 구축을 완료할 수 있으며, 추가적인 의존성 선언이 필요할때도 헤메지 않고 build.gradle 파일에 의존성을 추가할 수 있게되었다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-%EC%B4%88%EA%B8%B0%EC%84%A4%EC%A0%95/",
        "teaser": null
      },{
        "title": "[Spring] 웹브라우저로 Hello World 출력해보기",
        "excerpt":"이 게시물은 이동욱님의 “스프링 부트와 AWS로 혼자 구현하는 웹 서비스”를 읽고 공부하며 작성한 게시물입니다.   시작하며…  어떤 프로그램이던 프레임워크던간에 새로운 기술을 시작했다면, 개발자들의 국룰을 Hello World를 띄워보는 것이다.         Hello World를 띄우는것은 언제나 설레고 신난다! 그럼 스프링부트에서 웹 브라우저에 Hello World를 출력해보자..   Application 클래스  먼저 메인으로 동작할 Application 클래스를 만들어주어야 한다.   1 2 3 4 5 6 7 8 9 import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @SpringBootApplication public class Application {     public static void main(String[] args) {         SpringApplication.run(Application.class, args);     } }   @SpringBootApplication  @SpringBootApplication 어노테이션은 이 클래스가 메인 클래스가 된다는것을 알려주는 어노테이션으로, @SpringbootApplication으로 인해 스프링 부트의 자동 설정, 스프링 Bean 읽기와 생성을 모두 자동으로 설정하게 된다.   특히나 항상 프로그램은 @SpringBootApplication이 있는 위치부터 설정을 읽어가기 떄문에 이 클래스는 항상 프로젝트 최상단에 위치하여야 한다.   main 메소드에 있는 SpringApplication.run으로 인해서 내장 WAS (Web Application Server)를 실행한다. 내장 WAS란 별도로 외부에 WAS를 두지 않고 애플리케이션을 실행할 때 내부에서 WAS를 실행하는 것을 이야기 하는데, 이렇게 하면 항상 서버에 톰캣을 설치할 필요가 없게되고, 스프링 부트로 만들어진 jar 파일로 실행하면 된다.   스프링 부트는 내장 WAS를 사용하는데, 어플리케이션을 실행할 때 내부에서 WAS를 실행하기 때문에 외부에 별도의 추가 서버를 두지 않기 떄문에 서버를 배포할때 마다 일일히 WAS의 종류와 버젼, 설정을 일치시키지 않아도 된다.   여기서 WAS라는 개념이 등장하는데 이를 따로 정리해서 따로 게시물로 남겨놓았다..      WAS란 무엇일까?    그럼 이제 Application클래스의 코드를 모두 작성했으니, 이제 Controller를 만들고 이를 테스트 해보자.   HelloController  web이라는 이름을 가진 패키지를 만들어 그 안에 HelloController 클래스를 만들어 준 뒤, 아래와 같이 코드를 작성해 준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; import springboot.web.dto.HelloResponseDto;  @RestController public class HelloController {      @GetMapping(\"/hello\")     public String hello() {         return \"hello\";     }      @GetMapping(\"/hello/dto\")     public HelloResponseDto helloDto(@RequestParam(\"name\") String name,                                      @RequestParam(\"amount\") int amount) {         return new HelloResponseDto(name, amount);     } }  @RestController     컨트롤러를 JSON을 반환하는 컨트롤러로 만들어 준다.   예전에는 @ResponseBody를 각 메소드마다 선언했었는데, @RestController를 사용하여 쉽게 사용할 수 있게 되었다.   @GetMapping     HTTP Method인 Get의 요청을 받을 수 있는 API를 만들어주는 어노테이션이다.   예전에는 @RequestMapping으로 사용되었다. 이제 이 프로젝트는 /hello 요청이 오면 문자열 hello를 반환하는 기능을 가지게 되었다.   그렇다면 이렇게 작성한 코드가 제대로 작동하는지 알아보고, 웹API를 테스트하기위한 코드를 어떻게 작성하는 지를 배워보자.   HelloControllerTest  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.test.context.junit4.SpringRunner; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.request.MockMvcRequestBuilders;  import static org.hamcrest.Matchers.is; import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;  @RunWith(SpringRunner.class) @WebMvcTest(controllers = HelloController.class) public class HelloControllerTest {      @Autowired     private MockMvc mvc;      @Test     public void hello가_리턴된다() throws Exception {         String hello = \"hello\";          mvc.perform(MockMvcRequestBuilders.get(\"/hello\"))                 .andExpect(status().isOk())                 .andExpect(content().string(hello));     } }  @RunWith(SpringRunner.class)     테스트를 진핼할 때 JUnit에 내장된 실행자 외에 다른 실행자를 실행시킨다.   여기서는 SpringRunner라는 스프링 실행자를 사용한다.   다시말해, 스프링 부트 테스트와 JUnit 사이에 연결자 역할을 한다.   @WebMvcTest     여러 스프링 테스트 어노테이션 중, Web(Spring Mvc)에 집중할 수 있는 어노테이션이다.   선언할 경우 @Controller, @ControllerAdvice는 사용할 수 있지만, @Service, @Component, @Repository는 사용할 수 없다.   여기서는 컨트롤러만을 사용하기 때문에 선언한다.   @Autowired     스프링이 관리하는 빈(Bean)을 주입받는다.   여기서 나오는 Bean이 무엇인지 잘몰라서 아래 게시물에 정리해보았다.      Bean이란 무엇일까?    private MockMvc mvc     웹 API를 테스트 할 때 사용한다.   스프링 MVC 테스트의 시작점이다.   이 클래스트를 통해서 HTTP GET, POST 등에 대한 API 테스트를 할 수 있다.   mvc.perform(get(“/hello”))     MockMvc를 통해서 /hello 주소로 HTTP GET 요청을 한다.   체이닝이 지원되어 아래와 같이 여러 검증 기능을 이어서 선언할 수 있다.   .andExpect(status().isOk())     mvc.perform의 결과를 검증한다.   HTTP Header의 Status를 검증한다.   우리가 알고 있는 200,404,400등의 상태를 검증하는데, isOk()는 200인지 아닌지를 검증한다.   ###​ .andExpect(content().string(hello))     mvc.perform의 결과를 검증한다.   응답 본문의 내용을 검증한다.   Controller에서 “hello”를 리턴하기 떄문에 이 값이 맞는지 검증한다.   이렇게 작성한 테스트를 실행시켜보면, 테스트가 통과 됨을 볼 수 있다. /hello 주소로 GET요청을 하면 hello라는 문자열이 정상적으로 출력되는 것을 직접 눈으로 보지 않고도 우리가 작성한 테스트 코드로 확인 할 수 있는 것 이다.   실제로 확인해보기  테스트 코드가 아니라 실제로 hello가 출력되는지 직접 확인하고 싶다면, Application 클래스를 실행 시키면 된다.   1 2022-01-03 21:45:50.916  INFO 66709 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)  그럼 이러한 스프링 부트 로그가 여러개 뜨는데 위 로그를 보면 톰캣 서버가 8080 포트로 실행되었다는 것을 알 수 있다.   이제 웹브라우저를 열어 localhost:8080/hello로 접속해보면, 문자열 hello가 잘 출력되는 것을 확인 할 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EC%9B%B9%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%A1%9C-Hello-World-%EC%B6%9C%EB%A0%A5%ED%95%B4%EB%B3%B4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] 게시판 만들기 (1)",
        "excerpt":"이 게시물은 이동욱님의 “스프링 부트와 AWS로 혼자 구현하는 웹 서비스”를 읽고 공부하며 작성한 게시물입니다.   시작하며…  이 책은 3장부터 6장까지는 하나의 게시판을 만들어보고 7장부터 10장까지는 이 서비스를 AWS에 무중단 배포하는것 까지를 진행한다고 한다.   게시판 기능은 CRUD, Create, Read, Update, Delete가 가능하게 함으로써, 데이터베이스를 사용하기 위한 기초적인 4가지의 쿼리 형식을 배울 수 있도록 만들어 볼 것 이다.   요구사항 분석  먼저 프로그램을 만들기 전에 어떤 기능들을 추가할지 간단하게 README 파일에 기능별로 정리해준다. 이렇게 하면 어떤걸 개발하여야 할지 망설이지 않아도 되며, 기능 별로 커밋하여 버젼관리를 용이하게 할 수 있다.   구현해야할 기능 목록을 대략 정리해보면, 다음과 같다.      게시판 기능            게시글 조회       게시글 등록       게시글 수정       게시글 삭제           회원기능            구글/네이버 로그인       로그인한 사용자 글 작성 권한       본인 작성 글에 대한 권한 관리           의존성 추가  게시판 기능은 게시글이나 유저에 대한 데이터베이스가 필요하기 때문에 이를 사용하기 위해서 데이터베이스를 설정해주어야 한다. 이 책에서는 JPA를 사용하고 있다. 따라서 스프링 부트용 JPA 라이브러리와 h2의 의존성을 추가해주어야 한다.   build.gradle 파일의 dependencies 부분에 다음과 같은 코드를 추가해준다.   1 2 3 4 5 dependencies {     implementation('org.springframework.boot:spring-boot-starter-data-jpa')     implementation('com.h2database:h2')  }  spring-boot-starter-data-jpa     스프링 부트용 Spring Data Jpa 추상화 라이브러리   스프링 부트 버전에 맞추어 자동으로 JPA관련 라이브러리들의 버전을 관리해 준다.   h2     인메모리 관계형 데이터베이스   별도의 설치 없이 프로젝트 의존성만으로 관리가 가능하다.   메모리에서 실행되기 떄문에 애플리케이션을 재시작할 때마다 초기화 된다는 점을 이용하여 테스트 용도로 많이 사용된다.   이 책에서는 JPA테스트 및 로컬 환경에서의 구동에서 사용된다.   Posts 클래스  게시물들을 담당하는 Posts 클래스를 만들어보자.   먼저 Posts가 위치할 패키지 구조를 만들어주어야 한다. domain이라는 패키지를 만들어주고, 그 안에 posts라는 패키지를 만들어 그 안에 Posts클래스가 위치하게 될 것이다.   domain 패키지는 말그대로 도메인을 담을 패키지인데, 여기서 도메인이란 게시글, 회원, 정산, 결제 등 소프트웨어에 대한 요구사항 혹은 문제영역이라고 생각하면 된다.   Posts 클래스의 코드는 다음과같다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor;  import javax.persistence.*;  @Getter @NoArgsConstructor @Entity public class Posts {      @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      @Column(length = 500, nullable = false)     private String title;      @Column(columnDefinition = \"TEXT\", nullable = false)     private String content;      private String author;      @Builder     public Posts(String title, String content, String author) {         this.title = title;         this.content = content;         this.author = author;     } }  @Entity     테이블과 링크될 클래스임을 나타낸다.        기본값으로 클래스의 카멜케이스 이름을 언더스코어 네이밍(_)으로 테이블 이름을 매칭한다.  ex) SalesManager.java -&gt; salse_manager table       웬만하면 Entity의 PrimaryKey는 Long 타입의 Auto_increment를 사용하는 것이 좋다. (이렇게 하면 MySQL 기준으로는 bigint 타입이 된다.) 주민등록 번호와 같이 비즈니스상 유니크 키나, 여러키를 조합한 복합키로 PrimaryKey를 설정할 경우 난감한 상황이 종종 발생 하게 된다.  (1) FK(Foreign Key)를 맺을 떄 다른 테이블에서 복합키 전부를 갖고 있거나, 중간 테이블을 하나 더 둬야 하는 상황이 발생한다.  (2) 인덱스에 좋은 영향을 끼치지 못한다.  (3) 유니크한 조건이 변경될 경우 PK 전체를 수정해야 하는 일이 발생한다. 주민번호나 복합키 등은 유니크 키로 별도로 추가하는 것이 좋다.   @Id     해당 테이블의 Primary Key 필드를 나타낸다.   @GeneratedValue     PK의 생성규칙을 나타낸다.   스프링 부트 2.0 에서는 GenerationType.IDENTITY 옵션을 추가해야만 auto_increment가 된다.   @Column     테이블의 칼럼을 나타내며 굳이 선언하지 않더라도 해당 클래스의 필드는 모두 칼럼이 되지만, 기본값외에 추가로 변경이 필요한 옵션이 있다면 사용한다.   문자열의 경우 VARCHAR(255)가 기본값인데, 위처럼 length나 타입을 변경하고 싶다면 Column을 선언하여 변경할 수 있다.   이 Posts 클래스에는 한가지 특징이 있는데, 바로 Setter 메소드가 없다는 것이다. 자바빈 규약을 생각하면서 getter/setter를 무작정 생성부터 하고보는 경우가 있는데, 이렇게 하면 해당 클래스의 인스턴스 값들이 언제 어디서 변해야 하는지 코드상으로 명확하게 구분할 수가 없어, 차후 기능 변경이 정말 복잡해진다.   그래서 Entity 클래스에서는 절대로 Setter 메소드를 만들지 않는다 대신, 해당 필드의 값 변경이 필요하다면 명확히 목적과 의도가 나타나는 메소드를 추가해야하만 한다.   예를들어 주문을 취소하는 메서드를 만든다고 가정하면 setter를 사용했다면 아래와 같이,  1 2 3 4 5 6 7 8 9 public class Order {     public void setStatus(boolean status) {         this.status = status     } }  public void 주문서비스의_취소이벤트() {     order.setStatus(false); }  setter 메서드를 사용하는게 아니라   목적과 의도가 명확한 방식인  1 2 3 4 5 6 7 8 9 public class Order {     public void cancleOrder() {         this.status = false     } }  public void 주문서비스의_취소이벤트() {     order.cancleOrder(); }  위와 같은 메서드를 사용해 주어야 한다.   그렇다면 Setter가 없다면 어떻게 값을 채워 DB에 삽입해야 할까?   기본적인 구조는 생성자를 통해서 최종값을 채우고 DB에 삽입하는 것이며, 값 변경이 필요한 경우에만 해당 이벤트에 맞는 pulic 메소드를 호출하여 변경하는 것을 전제로 한다.   이 책에서는 생성자 대신에 @Builder를 사용하게 될텐데, 생성자와 빌더 모두 생성 시점에 값을 채워주는 역할은 똑같지만, 생성자의 경우 지금 채워야 할 필드가 무엇인지 명확히 지정할 수가 없다.   예를들어, 다음과 같은 생성자가 있다고 가정하자.  1 2 3 4 public Example(String a, String b) {     this.a = a;     this.b = b; }  이 경우에는 만약 개발자가 new Example(b,a)와 같이 a와 b의 위치가 변경해도 코드가 실행되기 전까지는 문제를 찾을 수가 없다   하지만 @Builder를 사용하면 다음과 같이 어느 필드에 어떤 값을 채워야 할지 명확하게 인지가 가능하다.   1 2 3 4 Example.builder()     .a(a)     .b(b)     .build();  이렇게 .a(), .b()와 같이 어느 필드에 값을 채우는지를 정확하게 명시하기 떄문에 훨씬 더 명확해짐을 알 수 있다.   그럼 이제, Posts 클래스로 Database를 접근하게 해줄 JpaRepository인 PostsRepository를 생성해주자.   PostsRepository  동일하게 posts 패키지에 PostsRepository라는 이름의 인터페이스를 하나 생성해주고 다음과 같은 코드를 입력해준다.   1 2 3 4 5 import org.springframework.data.jpa.repository.JpaRepository;  public interface PostsRepository extends JpaRepository&lt;Posts, Long&gt; {      }  생성된 interface인 PostsRepository에 JpaRepository &lt;Entity 클래스, PK 타입&gt;를 상속하면, @Repository를 추가할 필요도 없이 기본적인 CRUD 메소드가 자동으로 생성된다.   여기서 주의해야할 점은 Entity 클래스와 기본 EntityRepository는 함께 위치해야한다는 점이다. 둘은 아주 밀접하고 Entity 클래스는 기본 Repository 없이는 제대로 역할을 할 수 없기 때문이다.   만약 프로젝트 규모가 커져서 도메인별로 프로젝트를 분리해야 한다면 Entity 클래스와 기본 Repository는 함께 움직여야 하므로 도메인 패키지에서 함께 관리한다.   Spring Data JPA 테스트 코드  만들어준 postsRepository를 테스트 해보기위해 테스트 코드를 작성해보자. 테스트 코드에서는 save와 findAll 기능을 테스트 할 것 이다.   test 폴더에 동일하게 domain.posts패키지를 만들어주고, PostsRepositoryTest라는 테스트 클래스를 만들어준다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.test.context.junit4.SpringRunner;  import java.util.List;  import static org.assertj.core.api.Assertions.assertThat;  @RunWith(SpringRunner.class) @SpringBootTest public class PostsRepositoryTest {      @Autowired     PostsRepository postsRepository;      @After     public void CleanUp() {         postsRepository.deleteAll();     }      @Test     public void 게시글저장_불러오기() {         //given         String title = \"테스트 게시글\";         String content = \"테스트 본문\";          postsRepository.save(Posts.builder()                 .title(title)                 .content(content)                 .author(\"lmj938@naver.com\")                 .build());          //when         List&lt;Posts&gt; postsList = postsRepository.findAll();          //then         Posts posts = postsList.get(0);          assertThat(posts.getTitle()).isEqualTo(title);         assertThat(posts.getContent()).isEqualTo(content);     } }  @After     Junit에서 단위 테스트가 끝날 때마다 수행되는 메서드를 지정   보통은 배포 전 전체 테스트를 수행할 때 테스트간 데이터 침범을 막기 위해 사용한다.   여러 테스트가 동시에 수행되면 테스트용 데이터베이스인 H2에 데이터가 그대로 남아 있어 다음 테스트 실행 시 테스트가 실패할 수 있다.   @postsRepository.save     테이블 posts에 insert/update 쿼리를 실행한다.   id 값이 있다면 update가 실행되고, 없다면 insert 쿼리가 실행된다.   postsRepository.findAll     테이블 posts에 있는 모든 데이터를 조회해오는 메서드이다.   별다른 설정 없이 @SpringBootTest를 사용해주면 H2 데이터베이스를 자동으로 실행해 준다.   테스트 코드를 실행시키면, Tests passed와 함께 테스트가 올바르게 통과 했음을 알 수 있다.   실제 실행된 쿼리 보기  테스트 코드로 쿼리가 올바르게 실행됐는지를 보는것이 아니라 실제로 실행된 쿼리를 보고 싶다면 어떻게 해야할까?   자바 클래스로도 이러한 기능을 구현할 수 있지만, 스프링 부트 자체에서는 application.properties나 application.yml 등의 파일로 한줄의 코드로 설정할 수 있으니 이를 사용하는게 훨씬 편리하다.   먼저, src/main/resources 디렉토리 아래에 application.properties 파일을 생성해보자.   생성한 파일에 아래와 같은 옵션을 추가해 준뒤, 다시 postsRepositoryTest를 실행해준다.  1 spring.jpa.show_sql = true   그렇게 하면 다음과 같이 콘솔에서 쿼리로그를 확인 할 수 있다.  1 2 3 4 5 6 7 8 Hibernate: drop table posts if exists Hibernate: create table posts (id bigint generated by default as identity, author varchar(255), content TEXT not null, title varchar(500) not null, primary key (id))  Hibernate: select posts0_.id as id1_0_, posts0_.author as author2_0_, posts0_.content as content3_0_, posts0_.title as title4_0_ from posts posts0_ Hibernate: select posts0_.id as id1_0_, posts0_.author as author2_0_, posts0_.content as content3_0_, posts0_.title as title4_0_ from posts posts0_ Hibernate: delete from posts where id=?  Hibernate: drop table posts if exists   여기서 create table의 쿼리를 보면 id bigint generated by default as identity라는 옵션으로 생성되는데, 이는 H2의 쿼리 문법이 적용되었기 떄문이다. H2는 MySQL의 쿼리를 수행해도 정상적으로 작동하기 때문에, 이후 디버깅을 위해 출력되는 쿼리 로그를 MySQL 버전으로 변경해보자.   이 옵션도 마찬가지로 application.properties레서 옵션을 추가해 설정이 가능하다.   1 spring.jpa.properties.hibernate.dialect = org.hibernate.dialect.MySQL5InnoDBDialect   다시 테스트 코드를 run하면,  1 Hibernate: create table posts (id bigint not null auto_increment, author varchar(255), content TEXT not null, title varchar(500) not null, primary key (id)) engine=InnoDB  다음과 같이 옵션이 잘 적용되어 id bigint not null auto_increment로 바뀐 것을 확인 할 수 있다.   등록/수정/조회 API 만들기  API를 만들기 위해 총 3개의 클래스가 필요하다.      Request 데이터를 받을 Dto   API 요청을 받을 Controller   트랜잭션, 도메인 기능간의 순서를 보장하는 Service   여기서 많은 사람들이 오해하는 것이, Service에서 비지니스 로직을 처리해야 한다는 것이다. 하지만, Service는 트랜잭션, 도메인 간의 순서 보장만 할뿐, 비즈니스 로직을 처리하지는 않는다.   비즈니스 로직의 처리를 담당해야 할 곳은 Service가 아닌 바로 Domain이다.   Domain에서 비즈니스로직을 처리하고, Service에서는 이를 사용해 트랜잭션과 도메인간의 순서를 보장해주는 역할 만을 담당 하는 것이다.   그럼 이를 바탕으로 등록, 수정, 삭제 기능을 만들어보자.   web 패키지를 만들어 PostsApiController를 만들어주고,  web.dto 패키지에 PostsSaveRequestDto를,  service 패키지를 만든 뒤, service.posts 패키지를 만들어 PostsService를 만들어준다.   PostApiController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import lombok.RequiredArgsConstructor; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RestController; import springboot.service.posts.PostsService; import springboot.web.dto.PostsSaveRequestDto;  @RequiredArgsConstructor @RestController public class PostsApiController {          private final PostsService postsService;          @PostMapping(\"/api/v1/posts\")     public Long save(@RequestBody PostsSaveRequestDto requestDto) {         return postsService.save(requestDto);     } }    PostsService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Service; import springboot.domain.posts.PostsRepository; import springboot.web.dto.PostsSaveRequestDto;  import javax.transaction.Transactional;  @RequiredArgsConstructor @Service public class PostsService {      private final PostsRepository postsRepository;      @Transactional     public Long save(PostsSaveRequestDto requestDto) {         return postsRepository.save(requestDto.toEntity()).getId();     } }  위 코드를 보면 Controller와 Service에서 @Autowired 없이 Bean을 주입 받았는데, 스프링에선 Bean을 주입받는 방식들이 몇가지 있는데,      @Autowired   setter   생성자   이렇게 세가지로 Bean을 주입받을 수 있다. 이 중 가장 권장되는 방법은 생성자로 주입받는 방식인데, 위 코드에서도 @RequiredArgsConstructor을 사용하여 생성자를 만들어 주입받은 걸 알 수 있다.   생성자를 직접 작성하지 않고 롬복 어노테이션을 사용하는 이유는 해당 클래스의 의존성 관계가 변경될 때마다 생성자 코드를 계속해서 수정하는 번거로움을 해결하기 위해서다.   PostsSaveRequestDto  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor; import springboot.domain.posts.Posts;  @Getter @NoArgsConstructor public class PostsSaveRequestDto {     private String title;     private String content;     private String author;      @Builder     public PostsSaveRequestDto(String title, String content, String author) {         this.title = title;         this.content = content;         this.author = author;     }      public Posts toEntity() {         return Posts.builder()                 .title(title)                 .content(content)                 .author(author)                 .build();     } }  여기서는 Entity 클래스와 거의 같은 코드임에도 Dto 클래스를 추가로 생성해주었다. Entity클래스는 데이터베이스와 맞닿아 있는 핵심 클래스이기 때문에 Entity 클래스를 기준으로 테이블이 생성되고, 스키마가 변경된다. 따라서 화면 변경은 아주 사소한 변경이기 때문에 이를 위해서 Entity 클래스를 변경하는 것은 너무나 큰 변경이다. 따라서 Entity 클래스를 절대로 Request/Response 클래스로 사용해서는 안된다.   이처럼 View Layer와 DB Layer는 역할 분리를 철저하게 해주는 것이 좋은데, 실제로 Controller에서 결과값으로 여러 테이블을 조인해서 줘야하는 경우가 많기 때문에 Entity 클래스만으로 표현하기가 어려울 때가 많다. 하지만 그럼에도 꼭 Entity 클래스와 Controller에서 쓸 Dto는 분리해서 사용해주어야 한다.   그럼 이렇게 만들어준 PostsApiController를 테스트 하는 PostsApiControllerTest를 작성해보자.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 import org.junit.After; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.boot.web.server.LocalServerPort; import org.springframework.http.HttpStatus; import org.springframework.http.ResponseEntity; import org.springframework.test.context.junit4.SpringRunner; import springboot.domain.posts.Posts; import springboot.domain.posts.PostsRepository; import springboot.web.dto.PostsSaveRequestDto;  import java.util.List;  import static org.assertj.core.api.Assertions.assertThat;  @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class PostsApiControllerTest {      @LocalServerPort     private int port;      @Autowired     private TestRestTemplate restTemplate;      @Autowired     private PostsRepository postsRepository;      @After     public void tearDown() throws Exception {         postsRepository.deleteAll();     }      @Test     public void Posts_등록된다() throws Exception {         String title = \"title\";         String content = \"content\";         PostsSaveRequestDto requestDto = PostsSaveRequestDto                 .builder()                 .title(title)                 .content(content)                 .author(\"author\")                 .build();          String url = \"http://localhost:\" + port + \"/api/v1/posts\";          ResponseEntity&lt;Long&gt; responseEntity = restTemplate.postForEntity(url, requestDto, Long.class);          assertThat(responseEntity.getStatusCode()).isEqualTo(HttpStatus.OK);         assertThat(responseEntity.getBody()).isGreaterThan(0L);          List&lt;Posts&gt; all = postsRepository.findAll();         assertThat(all.get(0).getTitle()).isEqualTo(title);         assertThat(all.get(0).getContent()).isEqualTo(content);     } }  ApiController를 테스트 하는데 HelloController와 다르게 @WebMvcTest를 사용하지 않았다. @WenMvcTest의 경우 JPA 기능이 작동하지 않기 때문인데, Controller와 ControllerAdvice 등 외부 연동과 관련된 부분만 활성화되니 지금 같이 JPA 기능까지 한번에 테스트할 때는 @SpringBootTest와 TestRestTemplate을 사용하면 된다.   이 테스트를 수행해 보면 아래와 같이  1 2 3  INFO 87751 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 49982 (http) with context path ''과    Hibernate: insert into posts (author, content, title) values (?, ?, ?)  WebEnvironment.RANDOM_PORT로 인한 랜덤 포트 실행과 insert 쿼리가 모두 실행된 것을 확인했다.   이렇게 하면 게시판 기능의 등록 기능의 구현이 완료되었음을 테스트 코드로 확인할 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EA%B2%8C%EC%8B%9C%ED%8C%90-%EB%A7%8C%EB%93%A4%EA%B8%B0-(1)/",
        "teaser": null
      },{
        "title": "부산 여행",
        "excerpt":"2022.01.09  1월 5,6,7 예진이랑 1주년기념으로 부산여행을 다녀왔다.           난 사실 태어나서 부산을 한번도 가본 적이 없어서 되게 기대되기도 하고, 연말에 시험에 떨어지기도 해서 머리도 식힐 겸 빨리 가고싶은 생각에 한 이틀전부터 기대가 너무 됐었다.   광안리에 숙소를 잡아서 3일내내 광안리에서 시간을 보냈는데, 막 여러군데 보러다니지 않고 한곳에서 여유롬게 숙소 앞에서 맛있는거 먹고 커피먹고 하니까 너무 재밌었고 행복했다. 부산 바다는 처음이라 많이 기대했는데, 동해는 조금 더 시골스러운 바다 느낌이라면 부산은 번화한 바다느낌?? 광안리는 해운대에 비하면 조금 더 시골시럽긴 해도 여느 동해에 비하면 훨씬 도심느낌에 바다가 있는 느낌이었다. 프랜차이즈도 왠만한건 다있어서 정말 숙소잡고 힐링하기는 좋았다. 물론 난 좀 더 고립되고 시골스러운걸 좋아해서 제주도나 강원도 처럼 바다만 있고 뭐 하고 싶어도 못하는 분위기를 좋아하기는 하지만, 부산도 색다른 바다라 너무 좋았다.   무엇보다 숙소를 에어비앤비로 잡았는데, 그동안 보통 호텔을 잡거나 했었는데 에어비앤비를 이용하니까 뭔가 훨씬 아늑하고 감성진 디자인의 숙소에서 지낼 수 있어서 너무 좋았다. 호텔도 물론 편하지만 뭔가 숙소의 느낌이 강한데에 비해서 에어비앤비는 진짜 잠깐 내 집이 생긴거 같아서 좋았다. 취사가 됐다면 더 좋았겠지만, 정말 호텔급으로 깔끔하고 좋아서 다음에 여행 갈때 또 에어비앤비를 이용해야겠다는 생각이 들었다. 게다가 오션뷰호텔에 가격에 비해 훨씬 저렴한 가격으로 정말 정말 좋은 오션뷰를 즐길 수 있어서 너무 좋았다.      나중에 진짜 돈많이 벌어서 꼭 한강뷰나 오션뷰 살고 싶다는 생각이 들었다… 아니면 노마드 코더가 되어서 강원도 같은데 가는것 도 나쁘지 않을지도…? 확실히 바다가 계속 보이니까 마음도 편해지고 힐링되는 느낌이 들었다.   사실 원래는 여행가는거 시간아깝고 돈아까워 했는데, 요즘은 여행이 즐겁다. 가면 아무래도 현실에서의 생각들이 잊히니까 마음도 편해지고 조금 내려놓을 수 있는 시간이라서 즐거운것 같은데, 바다가 있다던가, 해외라던가, 풍경이 내가 사는곳과 다를수록 그게 잘되는 것 같다. 그래서 사람들이 해외여행을 좋아하는게 아닐까?   다음주에는 엄마도 볼겸 친구도 볼겸 제주도를 가려한다. 거기서는 혼자 여행간 느낌으로 예쁜 카페에서 바다좀 보고, 공부좀 하다가 와야겠다.   돈이 없으니, 닌텐도 스위치를 이제 당근마켓에 올려야지…  ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EB%B6%80%EC%82%B0-%EC%97%AC%ED%96%89/",
        "teaser": null
      },{
        "title": "[Spring] 스프링 기초 - 뷰 템플릿과 MVC 패턴",
        "excerpt":"이 게시물은 홍팍님의 “스프링 부트입문”을 시청하며 공부한 내용을 작성한 글입니다.           출처  홍팍 유튜브 링크       시작하며…  게시판을 만들며 스프링을 배워보려 했는데, 그러려고 산 책이 조금 스프링에 대한 기본지식을 아는 사람을 대상으로 쓴 책 같아서 설명이 부족한것 같아 스프링의 기본적인 기능들을 숙지해보려고 강의를 찾아보던 중 홍팍님의 스프링 부트 입문 강의가 좋은 것 같아 영상을 보며 공부해보려 한다.   뷰 템플릿과 MVC 패턴  우리가 만약 어떤 웹페이지에 로그인을 한 상태라면, 웹페이지에 표시되는 내 정보, 예를들어 내 이름이나 아이디 등 이러한 정보들은 나만을 위한 정보일 것이다. 그렇다면 이 정보들이 담긴 화면을 모두 하나 하나 웹페이지로 저장한 것일까? 그렇게 한다면 가입자가 생길때마다 가입자에 맞는 정보가 담긴 웹페이지를 하나하나 코딩해주어야 할 것 이다.   그래서 웹페이지를 만들 때는 뷰템플릿이란 기술을 사용한다. 뷰템플릿이란 화면을 담당하는 기술로, 틀이되는 화면을 만들고 안에 있는 몇몇 정보만을 변수로 만들어 뷰템플릿하나로 정보가 다른 여러 화면을 만든 것과 같은 효과를 낼 수 있다.   이러한 뷰템플릿에서는 컨트롤러와 모델이 있는데, 컨트롤러는 로직을 담당하고 모델을 데이터를 담당하게 된다. 그렇게 되면 뷰, 모델, 컨트롤러 세가지가 각각 임무를 맡아 하나의 프로그램을 동작하게 되는데 이를 MVC 패턴이라고 한다.   Hello World 출력해보기  먼저 resource 폴더에 있는 templates 폴더에 새로운 파일을 하나 만들어준다. greetings.mustache      그럼 이렇게 파일을 인식할 수 없다는 창이 뜨는데, mustache 플러그인을 설치해주어야 정상적으로 이 파일을 인식할 수 있다.   커맨드 + 시프트 + A를 눌러 인텔리제이의 액션 검색창을 열어주고, plugins를 입력한 후에 마켓플레이스에서 mustache를 인스톨 해주면 올바르게 파일이 mustache 파일로 인식된다.      이제 만들어준 greetings.mustache 파일에 아래와 같은 html을 입력해준다.  1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;html&gt;     &lt;head&gt;         &lt;meta charset=\"UTF-8\"&gt;         &lt;meta name = \"viewport\"             content=\"width = device-width, user-scalable = no, initial-scale = 1.0\"&gt;         &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;         &lt;title&gt;Document&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;Hello World&lt;/h1&gt;     &lt;/body&gt;     &lt;/head&gt; &lt;/html&gt;   이렇게 했으면, 이 html코드를 브라우저로 전송할 controller를 만들어보자.   main 폴더에 controller 폴더를 만들어주고, GreetingsController라는 클래스를 하나 만들어준다.   1 2 3 4 5 6 7 8 9 import org.springframework.stereotype.Controller;  @Controller public class GreetingsController {      public String greetings() {         return \"greetings\";     } }  위와 같이 코드를 입력해주면, @Controller를 통해 스프링부트가 이 클래스를 컨트롤러로 인식하고, greetins() 함수가 파일명이 “greetings”인 파일을 찾아 브라우저로 전송한다.   그럼 이렇게 만든 컨트롤러가 제대로 작동하는지 main파일에 있는 Application 파일을 실행 시킨뒤, http://localhost:8080/greetings.mustache 주소로 들어가 올바르게 브라우저로 전송이 되었는지 확인해보자.      그럼 위처럼 NotFound 404 에러가 뜬다. 아직 파일을 찾을 수 없다는 것으로, 브라우저에 mustache 파일을 전송하려면 추가적인 코드가 더 필요하다.   1 2 3 4 5 6 7 8 9 10 11 import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping;  @Controller public class GreetingsController {          @GetMapping(\"/greetings\")     public String greetings() {         return \"greetings\";     } }  위 코드를 보면 @GetMapping 어노테이션을 사용해서 해당 함수가 반환할 값을 표시할 주소를 명시해준다. 그럼 우리는 해당 주소로 이동하면 해당 함수가 리턴하는 greetings.mustache를 확인 할 수 있게 되는 것이다.   이제 다시 Application 파일을 실행시키고 http://localhost:8080/greetings 로 이동하면 아래 처럼 올바르게 우리가 적은 html코드가 출력되는 것을 확인 할 수 있다.      그럼 이번에는 뷰템플릿을 만들어 hello world 부분에서 wordl부분에 사람의 이름이 들어갈 수 있도록 해보자.   다시 html로가서, world 부분이 변수가 들어갈 수 있도록 바꾸어보면,  1 2 3 4 5 6 7 8 9 10 11 12 13 &lt;html&gt;     &lt;head&gt;         &lt;meta charset=\"UTF-8\"&gt;         &lt;meta name = \"viewport\"             content=\"width = device-width, user-scalable = no, initial-scale = 1.0\"&gt;         &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt;         &lt;title&gt;Document&lt;/title&gt;     &lt;/head&gt;     &lt;body&gt;         &lt;h1&gt;Hello &lt;/h1&gt;     &lt;/body&gt;     &lt;/head&gt; &lt;/html&gt;  이렇게 mustache 문법에 따라 Hello 와 같이 중괄호 두개를 사용해주면, 해당 부분을 변수화 하게 됨으로, 고정되어있던 웹페이지가 변수에 따라 달라질 수 있는 뷰템플릿이 된다.   그럼 이제 username이라는 변수를 프로그램이 인식할 수 있도록 Model을 추가하고, 이를 컨트롤러가 받아오도록 해주자.   1 2 3 4 5 6 7 8 9 10 11 12 import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping;  @Controller public class GreetingsController {      @GetMapping(\"/greetings\")     public String greetings(Model model) {         model.addAttribute(\"username\", \"민재\");         return \"greetings\";     }  greetings 메서드가 Model 형태의 model이 받아와서, “username”이라는 변수명을 찾아 “민재”라는 문자열을 넣은 뒤, 이를 웹페이지에 출력해준다.      테스트 코드 작성해보기  이를 일일히 서버를 작동하고 직접 웹페이지로 가서 확인하는게 아니라, 테스트 코드 동작만으로 현재 프로그램에 이상이 없는지를 확인하는 코드를 만들어 간편하게 테스트를 진행 할 수 있도록 해보자.   GreetingsControllerTest라는 클래스를 test폴더에 만들어 준 뒤, 아래와 같은 코드를 작성한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import com.example.hongPark.Message; import org.junit.jupiter.api.Test;  import org.junit.runner.RunWith; import org.springframework.beans.factory.annotation.Autowired;  import org.springframework.boot.test.context.SpringBootTest; import org.springframework.boot.test.web.client.TestRestTemplate; import org.springframework.test.context.junit4.SpringRunner;   import static org.assertj.core.api.Assertions.assertThat; import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;  @RunWith(SpringRunner.class) @SpringBootTest(webEnvironment = RANDOM_PORT) class GreetingsControllerTest {      @Autowired     private TestRestTemplate restTemplate;      @Test     public void Hello_민재를_잘_출력하는지_확인() throws Exception {         Message message;         String body = this.restTemplate.getForObject(\"/greetings\", String.class);          assertThat(body).contains(\"Hello 민재\");     } }  이렇게 변하는 변수가 있는 뷰템플릿은 TestRestTemplate 객체를 만들어 준 뒤, getForObject 메서드를 사용해서 해당 주소를 입력해준 뒤 이를 assertThat을 사용하여 해당 문자열을 포함하는 뷰가 정상적으로 출력되었는지 확인해 줄 수 있다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EC%8A%A4%ED%94%84%EB%A7%81-%EA%B8%B0%EC%B4%88-%EB%B7%B0-%ED%85%9C%ED%94%8C%EB%A6%BF%EA%B3%BC-MVC-%ED%8C%A8%ED%84%B4/",
        "teaser": null
      },{
        "title": "스키장",
        "excerpt":"2022.01.19     친구들과 오랜만에 스키장을 다녀왔다. 작년에는 코로나 때문에 스키장을 못가서 2년만에 가는거라 너무 설레서 진짜 몇일전부터 계속 스키장 영상 유튜브로 보고 시간도 빨리 보내려고 공부도 안했다… 맨날 스키만 타니까 좀 질리기도 하고, 아무래도 스키는 좀 멋이 안나서 이번에는 보드를 타보고 싶은 마음이 좀 있었는데, 갑자기 내가 보드를 타면 다른애들은 중급 상급에서 쌩쌩 달릴 때 혼자 초보에서 구르면 재미 없을까봐 망설여져서 고민하고 있었다.   그러다가 보민이를 스키장 가자고 꼬시는데 자꾸 실력차이 나서 니네들 자기 버리고 가버릴거 아니냐고 해서, 그냥 그러면 나도 보드 탈테니까 같이 가자고 꼬셔서 나도 보드를 타게 됐다. 그 이후로는 하루종일 보드 강의 유튜브를 보며 스키장 가는날을 손꼽아 기다렸다.   원래 우리는 급진용평스키파로, 용평이외의 스키장은 스키장이 아니다! 라는 아주 스키장사대주의적인 사상을 가진 사람들이었지만, 휘닉스파크의 숙소비와 리프트값이 말도안되게 저렴해서 이번에는 부득이하게 휘닉스파크로 행선지를 정하게 되었다. 용평만이 가진 고즈넉한 산속에서 스키를 타는 느낌과 기가막힌 밸런스의 코스를 포기한건 너무 아쉬웠지만, 그러기엔 너무나 합리적인 가격의 휘닉스파크였다…   출발하자마자 휴게소에 들려서 밥을 먹었는데, 민구랑 나는 아침을 먹고나와서 밥먹기가 조금 그래서 그냥 간식거리나 하나 먹으려고 핫도그를 하나 샀다. 먹기전에 핫도그는 맛이 없을수가 없다면서 민구랑 개호들갑을 떨면서 포장해서 가져왔는데, 진짜 태어나서 먹은 핫도그 중에 제일 맛없었다… 사기전에 무슨 저지방 소세지니 뭐니 써있었는데, 소세지가 저지방이라 그런지 진짜 너무 맛없고 소스도 그냥 케찹이랑 머스타드나 뿌려주지 무슨 이상한 맵기만한 소스를 뿌려서 너무 별로였다…      그래도 휴게소에서 친구들이랑 뭐를 사먹는다는 것 자체가 오랜만이라서 너무 설레고 재밌었다. 그렇게 한 두시간반을 달려서 휘닉스파크에 도착했다. 숙소가 1박에 9만원 짜리였는데, 20평정도되는 온돌방이었다. 역시 친구들이랑 스키장가서는 온돌방이 최고인것 같다. 슬로프 오지게 타고 온돌 바닥에 다같이 이불깔고 누워서 떠들다보면 진짜 천국이 따로 없다.      첫날은 야간권을 끊어서 도착해서 짐을 풀고 누워서 애들이랑 떠들면서 핸드폰좀 하다가 슬슬 준비를 하구 나갔다. 오랜만에 스키장에 왔다는 설렘과 처음으로 보드를 탄다는 새로움 때문에 너무 설렜다. 진짜 이렇게 친구들이랑 노는게 얼마만인지! 그렇게 준비를 마치고 가서 보드를 빌려서 신발을 신는데, 신발신는것 부터 난관이었다… 스키는 그냥 인라인처럼 되어있어서 딱딱 레버만 채우면 되는데, 보드는 무슨 끈으로 되어있어서 운동화 끈 조이듯이 조여야 하는데 이게 또 완전 밀착해서 조여야 나중에 타기 수월해서 끈을 묶느라 한참을 걸렸다.   힘들게 준비를 마치고 드디어 리프트에 몸을 올렸다. 스키장은 스키타는것도 재밌지만 리프트 타는것도 너무 재밌다. 뭔가 산속에 고립된듯한 기분과 공중에서 산속을 바라보는 이 기분이 너무 좋다. 뭔가 조용한 숲에 갇혀서 친구들이랑 이야기 하는 느낌이랄까 물론 한두번 타다보면 리프트가 그렇게 감질날 수가 없지만…   처음 탄 보드는 진짜 멘붕이었다. 아니 이상한게 보드를 신발에 체결하고 일어나려는데, 아무리 일어나려고 해도 몸이 안일어나져서 돌아버리겠는거였다. 다들 일어나는건 한번에 된다는데, 아무리 일어나도 몸이 안일어나졌다. 진짜 내 몸에 이상이 있는 줄 알았다. 후에 알고보니 무릎보호대가 너무 짱짱했었는데, 그게 무릎을 못펴게 해서 못일어나는거였다… 무릎보호대를 정강이로 내려버리고 일어나니까 한번에 일어나졌다. 내 몸이 이상한게 아니어서 다행이었다…   초등학교때 아빠랑 스키장에 가서 아빠가 보드를 가르쳐줬던적이 있는데, 그게 나한테는 거의 트라우마급으로 너무 안 배워지고 자꾸 넘어져서 엉덩이가 너무 아픈 경험이었다. 그래서 친구들이랑 스키장을 처음갔을때도 보드는 절대로 타지 않겠노라 다짐해서 스키를 타게 되었던건데, 한번 넘어지자마자 진짜 그때의 기억이 생생하게 떠오르면서 좀 무서웠다. 하루전에 급하게 쿠팡에서 엉덩이 보호대까지 구매해서 착용했는데도, 넘어지니까 엉덩이가 부서지는 줄 알았다. 하지만 여기서 멈추면 하루종일 초급에서 낙엽만 타다가 집에 갈거라는 불안감에 트라우마고 뭐고 진짜 망한 탑라이너처럼 계속 갖다 박았다. 아마 2박 3일동안 넘어진 수를 셌으면 50번은 넘게 넘어졌을거다.   그렇게 계속 눈바닥에 갖다 박으면서 친구가 가르쳐준대로 하니까 점점 실력이 늘었다. 그리고 전날에 보고간 유튜브 영상이 진짜 많이 도움이 되었는데, 혹시 스키장에가서 보드탈 사람은 무조건 유튜브 “범빠덕션”님의 보드 강의를 꼭 보고 가기를 바란다. 진짜 보드 1타 강사급 실력이라서, 아마 이 영상 안보고 갔으면 2박3일내내 낙엽만 하다 왔을 수도 있다.           범빠덕션 스노보드 강좌       첫날은 낙엽이랑 반대방향 낙엽을 열심히 하고 둘쨰날부터는 S자를 연습했는데, 솔직히 내가봐도 좀 보드 재능충이었다. 보민이랑 연준이는 원래도 보드 몇번탔었었는데도, 내가 하루만에 다 따라잡아서 이튿날 마지막에는 그냥 내가 압도적으로 잘탔다. 역시 뭐를 배우려면 만족없이 계속 더 잘타려고 노력을 해야한다. 쟤네는 그냥 내려와지니까 자꾸 연습은 안하고 낙엽으로 중급만 주구장창 내려오니까 실력이 안느는거다 ㅎㅎ 중간부터는 보민이랑 같이 초급에서 계속 둘이 연습했는데, 그러다보니까 보민이도 실력이 엄청 늘었다. 솔직히 박보민은 스키장 별로 가고싶지도 않아 하는 눈치였었는데, 이번기회에 실력이 많이 늘어서 보드의 참재미를 느낀 것 같아서 맘이 좀 뿌듯했다. 김연준도 우리랑 특훈했으면 잘 탔을텐데 끝까지 고집부리더니 결국 끝날때까지 슬라이드 주행만 오지게 하다 마무리했다.   원래 우리 계획은 첫날은 야간권을 타고 둘쨰날은 종일권에 뷔페가 포함된 올데이패스를 타는거였는데, 첫날 타보니까 원래 우리는 스키를 한타임이상 못탔었다는 사실을 다시금 깨달아서, 바로 올데이패스 취소하고 야간권으로 바꿨다… 남은돈으로는 그냥 차라리 치킨을 시켜먹기로 했다. 스키라는게 참 체력을 너무나 많이 쓰는 운동인것 같다. 특히 첫날에 열두시쯤에 휴게소에서 뭘 사먹고 그상태로 야간권 밤 열시에 끝날때까지 아무것도 안먹은 상태로 스키를 탔는데, 인덕션은 또 한개밖에 없어서 음식 준비하는데 또 한시간반이 걸려버려서 12시간이 넘은 공복 상태에서 첫날 저녁 식사를 하게되었다. 진짜 태어나서 먹은것중에서 손에 꼽을 정도로 맛있는 식사였다. 아무리 시장이 반찬이라지만 열두시간 공복에 추운데서 보드타고 와서 먹는 저녁은 좀 선넘을 정도로 맛이 있었다.     (위 사진에 있는 음식에 추가로 삼겹살도 있었는데, 삼겹살 구워지는걸 더 이상 기다릴 수가 없어서 삼겹살을 올려놓고 식사를 시작했다.)   그렇게 첫날 식사를 마무리하고 오지게 부른배로 토크를 하다가 온돌방에서 이불을 깔고 누워서 한참을 토크하다가 잠들었다. 온돌에서 이불깔고 애들이랑 떠드는게 솔직히 제일 웃기고 재밌는것 같다. 사실 이거하려고 스키장 가는것 같은 기분이다.   둘째날에는 몸이 그냥 다 부서져서 다들 내내 잠만잤다. 괜히 자는게 아까운 나랑 강민구만 깨서 둘이 포커를 열심히 쳤다. 온라인으로 열심히 쳐서 내가 당연히 바를줄 알았는데, 또 이게 실제로 하니까 온라인보다 훨씬 루즈하기도 하고 헤즈업이다보니까 좋은패를 기다리는게 너무 감질나서 실수를 많이해서 따고 잃고 따고 잃고 결국 본전치기를 했다. 그래도 실제로 카드 잡고 하는게 온라인보다 훨씬 재밌었다.   둘째날에는 실력이 많이 늘어서 끝날때쯤에는 진짜 감잡아서 잘탔는데 그때쯤에 딱 시간이 끝나서 너무 아쉬웠다. 차라리 낮부터 탔으면 진짜 연장도 했을텐데 아쉬웠다 ㅜ 그래도 끝나고 가자마자 시켜서 한시간반을 기다려 받은 치킨이 정말 너무 맛있어서 행복했다. 역시 배고플때 먹는 치킨은 그냥 세상 모든 음식 중에서 제일 맛있다.      둘째날밤에는 애들이랑 단체로 포커좀 치고, 또 누워서 이야기를 한참하다가 새벽 다섯시반에 잠들었는데 뭔가 자는게 너무 아쉬웠다. 맨날 방구석에서 코딩하고 공부만하다가 진짜 오랜만에 동네 친구들이랑 이불에 누워서 떠드니까 너무 재밌고 행복했다. 원래는 사실 여행가고 어디가서 돈쓰는걸 별로 안좋아했는데, 요즘은 돈모으거나 내가 좋아하는거 뭐 사는것 보다도 어디 놀러가고 여행가는게 더 좋은것 같다. 이래서 취업한 친구들이 주말마다 그렇게 어디를 돌아다니고 놀러다니는 걸까.   방학 끝나기전에 누구랑 가던간에 스키장이나 한번 더 갈까… 하는 생각이 들었다.   다음 여행때는 다들 취업좀 해서 소고기도 좀 먹고 방도 좀더 큰데서 놀았으면 좋겠다는 생각을 하며, 2박 3일간의 스키장 일기를 마친다.  ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EC%8A%A4%ED%82%A4%EC%9E%A5/",
        "teaser": null
      },{
        "title": "병원 생활기",
        "excerpt":"2022.01.22  이틀전 목요일날 저녁에 갑자기 할아버지가 혈압이 안떨어지셔서 입원하게 되셨다. 코로나로 인해서 상주 보호자 1인 외에는 면회도 안되고 아무것도 안되서 내가 상주보호자로 급히 택시를 타고와서 당분간 병원에서 생활하게 되었다. 저번에도 한번 스텐트 시술때문에 입원하셨는데, 그때는 내가 클레이때문에 바빠서 동생이 2일동안 상주보호자를 해줬어서 이번에는 내가 상주보호자로 오게 되었다.   사실 코로나가 일상에서는 체감도 별로 안되고, 맨날 병상부족이라고 해봤자 하나도 체감안됐었는데, 병원에 오니까 너무 체감이됐다. 들어가려면 pcr검사부터 해야하는데 가격은 또 12만원에다가 하루종일 기다려야한다. 거기다가 병상도 없어서 할아버지랑 함께 응급실에서만 거의 7시간을 있었는데, 11시에 도착해서 새벽 6시반이 되서야 병상 자리가 나서 올라갈 수 있었다. 응급실에는 보호자용 침대가 없어서 나는 의자에 앉아서 한숨도 못자고 올라가서 병상을 옮기고서야 겨우 누웠는데, 우선 보호자용 침대가 진짜 너무 불편하고 허리가 아팠고, 좀 잠들라치면 할아버지 뭐 검사 받으셔야 하고 소변보셔야 하고 해서 도저히 잠을 잘 수가 없었다. 진짜 잠을 못자니까 사람이 예민함이 극에 달해서 짜증이 났지만, 열시까지 겨우 모든 검사 마치고 그제서야 불편한 보호자 침대에서 잠을 잘 수가 있었다.   이렇게 힘든일이 있을때마다 생각나는 곳이 있다. 밤을새가며 의자에서 불편하게 있고, 그 이후에도 계속 꺠워대고 불편한데서 재운다? 이렇게 극한의 경험을 심심치 않은 주기로 계속 겪는 곳이 있는데, 바로 군대다. 군대에서 이미 경험해봤던 것들이라서 이게 은근히 한번 해보고 안해보고가 도움이 좀 되는것 같다. 이렇게 힘든일이 있을때마다 그래도 여기는 훈련이라도 안시키지, 그래도 여기는 내가 맛있는거 사먹을수라도 있지, 라고 위로를 하며 버티게 되는 것 같다.   어쨌든 응급실에서 병상으로 올라오고, 또 다시 할아버지 병에 맞는 과가 있는 병상으로 또 한번을 옮기고 나서야 보호자 침대 위치도 좀 편하고, 짐도 다 풀 수 있어서 여기 앉아 커피를 마시며 일기를 쓰고 있다. 이제 잠자리가 너무 불편해서 몸이 아픈거랑 할아버지 부축하는거 빼고는 좀 적응이 됐다. 그리고 아빠가 밥사먹으라고 카드를 줬는데, 맨날 밥때가 오면 뭘먹을지 나름 고민하는 재미도 있다. 어제는 아침에 설렁탕을 먹고 저녁에는 제육볶음을 먹었는데, 어제 제육볶음 사먹은 집이 너무 맛있었다. 꼬막에 계란찜에 두부부침에 밑반찬도 맛있고 제육도 맛있어서, 오늘도 또 갈까 고민중이다. 원래는 혼밥하는거 너무 싫어했는데, 나이가 먹었는지 이제는 혼밥에 재미가 조금 들렸다;;   최근에 닥터프렌즈 유튜브에 꽂혀서 병원에 관련한 영상들을 많이 봤었는데, 그래서 그런지 병원 생활이 힘들지만서도 어딘가 조금 친근하다. 그리고 와서보니까 물론 의사선생님들도 고생하시지만 간호사분들이 진짜 존경스러웠다. 간호사 힘들다 힘들다 했지만 이렇게 보호자로 와서 직접 보니까 돈이고 뭐고 사명감 없이 저렇게 절대 못하겠다 싶었다. 주변에 간호학과다니는 애들이 왕왕 있는데, 쟤네가 나중에 저걸 한다니 좀 대단해보였다.   어쨌든 당분간은 부득이하게 병원에 갇혀서 생활하게 되서 병원생활기나 꼬박 꼬박 써보려한다. 물론 월요일날 퇴원안되면 동생한테 sos치고 교대해달라고 하려고한다… 잠자리 불편한건 그 이상은 너무 힘들어서 못참아…   ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EB%B3%91%EC%9B%90-%EC%83%9D%ED%99%9C%EA%B8%B0/",
        "teaser": null
      },{
        "title": "당신의 삶에, 버려 마땅한 기억은 없다",
        "excerpt":"2022.01.30  월가아재님이 유튜브에서 하신 이벤트에 당첨되서 책을 받았다.   몇가지 기준을 나눠서 점수를 기준으로 추첨했는데, 나는 아무래도 꽤 초기 구독자다 보니까 가산점이 100점이나 되서, 책을 쉽게 받았다.   초반에 댓글을 하나라도 달아서 다행이지, 댓글 안달았으면 초기 구독자인거 증명도 못할 뻔했다.   책을 받자마자 그 날 저녁에 다 읽었는데, 사실 한창 월가아재님의 블로그 일기를 정독한 적이 있었어서 대부분 읽어본 내용이었다. 일기 내용을 보기 좋게 편집하셔서 책으로 엮으신 것 같았는데, 그래도 이렇게 소중한 한권의 책으로 보관할 수 있게 되었다는게 너무 좋고, 다시 모아서 한번에 읽으니까 또 새로웠다.   특히 군대시절 이야기는 내가 블로그에서 스킵하고 안 읽었던 이야기라서, 정말 재밌었다. 한편으로는 이 사람이 얼마나 지독한 사람인지를 보여주는 부분이 군대파트가 아닌가 싶다. 탈장 상태를 고무링으로 삐져나온 장을 막아가면서 훈련을 했다고…?\u001d 솔직히 자꾸 저도 여러분과 똑같은 20대를 보냈습니다 이런 말을 하는데, 군대 얘기보면 진짜 집념이 일반인들이랑 좀 다른사람 같다.   사실 나의 군생활을 돌이켜보면 뭐 페급은 아니었지만서도, 전혀 군생활에 1도 이입되지 않았었다. 항상 불합리하게 돌아가는 시스템에 분노하는게 내 일상이었고, 날 갈구는 선임들은 사회에서 가져보지 못한, 그리고 앞으로도 계속 갖지못할 권력이란 걸 처음 맛본 사람처럼 아랫사람들에게 휘두르는게 너무 한심해보였다. 물론 선임이 되어서도 마찬가지로, 정말 가슴에 손을 얹고 후임에게 한번도 혼내거나 뭐라해본적이 없다. 항상 뭔가를 잘못해도, “야 어차피 군생활이거 잘해봤자 도움도 안된다.” 식으로 그냥 어깨 몇번 두드려주고 말 뿐이었다. 내가 누구한테 뭐라하는걸 좀 많이 싫어하는 성격이기도 하고, 무엇보다 군생활을 열심히 한다는게 너무 바보같았다. 어차피 2년 때우고 가는거, 사회에 도움도 1도 안되는일을 내가 왜 열심히 해야하지? 쟤네는 왜 열심히 하지? 이런 생각 뿐이었다.   가끔은 이곳에서는 이곳에서 배울 수 있는 것을 배우고, 이곳에서 할 수 있는 최선을 다하자! 싶다가도, 몇일만 지나면 이해할 수 없는 행동들과 군대가 돌아가는 방식에 또 그냥 에휴하며 시간을 죽였다. 병장부터는 그냥 시간을 빨리 보내려고 잠을 오지게 잤던 것 같다.  그럴 이해가 안되고 막막한 그곳에서 KCTC의 응봉교육대를 이겨내고, 최종적으로는 원하던 파병의 목표까지 이루었다니, 항상 어쩔 수 없는 상황에서도 가장좋은 방법을 찾기 위해 내가 노력했는지 돌이켜 보게 되었다.   또, 인상깊었던 말중에서 결국 해내야만 지난 나의 고통들과 과오들이 좋은 추억으로 바뀐다는 이야기였다. 내가 아무리 못난 짓을 하고, 힘든일을 겪고, 수많은 실수를 할지라도, 결국에 마지막에 다시 정진해서 해낸다면 그 고통들과 실수들은 목표를 위한 발판으로 남게되어 나를 돌아봤을때 괴롭지 않은 추억으로 남길 수 있다는 이야기였는데, 이게 너무 공감이 가면서도 내가 이제부터는 이걸 의식적으로 머릿속에 새기고 살아야겠다는 생각이 들었다. 살다보면 피할 수 없는 불행이 오기마련이고, 거기에 주저앉아서 멈추면 결국 나중에 그 기억은 너무나 괴롭고 잊고싶은 기억으로 남게된다. 하지만 내가 그 불행을 발판삼아 일어선다면, 나중에 돌아봤을 때 “그런 추억이 있었지…” 하며 회상할 수 있는 괴롭지 않은 기억으로 남겨놓을 수 있으며, 심지어 이를 종종 회상해볼 수도 있을 것 이다.   그래서 이 책의 이름을 “당신의 삶에 버려 마땅한 기억은 없다”라고 지었다고 한다. 결국 내가 이뤄내고 해낸다면, 그 기억들은 버릴 수 없는 나의 기억들이 되는거니까. 결국 미래만이 나에게 달려있는게 아니라, 과거와 지나가는 현재조차도 내 남은 미래로 바꿀 수 있는게 아닐까? 인생을 살아가는 과정에 있어 항상 지나간 과거의 사실 자체를 바꿀 수는 없지만, 그 기억을 좋은 경험으로 바꿀 수 있다는걸 명심하고 살아야겠다.   그리고, 일기도 좀 자주 자주 쓰고… 이민재 화이팅!   ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EB%8B%B9%EC%8B%A0%EC%9D%98-%EC%82%B6%EC%97%90,-%EB%B2%84%EB%A0%A4-%EB%A7%88%EB%95%85%ED%95%9C-%EA%B8%B0%EC%96%B5%EC%9D%80-%EC%97%86%EB%8B%A4/",
        "teaser": null
      },{
        "title": "[Programmers] 괄호 변환",
        "excerpt":"문제 설명  카카오에 신입 개발자로 입사한 “콘”은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다.  수정해야 할 소스 파일이 너무 많아서 고민하던 “콘”은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다.   용어의 정의  ’(‘ 와 ‘)’ 로만 이루어진 문자열이 있을 경우, ‘(‘ 의 개수와 ‘)’ 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다.  그리고 여기에 ‘(‘와 ‘)’의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다.  예를 들어, “(()))(“와 같은 문자열은 “균형잡힌 괄호 문자열” 이지만 “올바른 괄호 문자열”은 아닙니다.  반면에 “(())()”와 같은 문자열은 “균형잡힌 괄호 문자열” 이면서 동시에 “올바른 괄호 문자열” 입니다.  ‘(‘ 와 ‘)’ 로만 이루어진 문자열 w가 “균형잡힌 괄호 문자열” 이라면 다음과 같은 과정을 통해 “올바른 괄호 문자열”로 변환할 수 있습니다.     입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.   문자열 w를 두 “균형잡힌 괄호 문자열” u, v로 분리합니다. 단, u는 “균형잡힌 괄호 문자열”로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.   문자열 u가 “올바른 괄호 문자열” 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.            3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.           문자열 u가 “올바른 괄호 문자열”이 아니라면 아래 과정을 수행합니다.            4-1. 빈 문자열에 첫 번째 문자로 ‘(‘를 붙입니다.       4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.       4-3. ‘)’를 다시 붙입니다.       4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.       4-5. 생성된 문자열을 반환합니다.  “균형잡힌 괄호 문자열” p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 “올바른 괄호 문자열”로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요.  매개변수 설명  p는 ‘(‘ 와 ‘)’ 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다.  문자열 p를 이루는 ‘(‘ 와 ‘)’ 의 개수는 항상 같습니다.  만약 p가 이미 “올바른 괄호 문자열”이라면 그대로 return 하면 됩니다.           입출력 예                  p       result                       ”(()())()”       ”(()())()”                 ”)(“       ”()”                 ”()))((()”       ”()(())()”           입출력 예에 대한 설명  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 입출력 예 #1 이미 \"올바른 괄호 문자열\" 입니다. 입출력 예 #2 두 문자열 u, v로 분리합니다. u = \")(\" v = \"\" u가 \"올바른 괄호 문자열\"이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 빈 문자열이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 \"\"이 됩니다. 따라서 생성되는 문자열은 \"(\" + \"\" + \")\" + \"\"이며, 최종적으로 \"()\"로 변환됩니다. 입출력 예 #3 두 문자열 u, v로 분리합니다. u = \"()\" v = \"))((()\" 문자열 u가 \"올바른 괄호 문자열\"이므로 그대로 두고, v에 대해 재귀적으로 수행합니다. 다시 두 문자열 u, v로 분리합니다. u = \"))((\" v = \"()\" u가 \"올바른 괄호 문자열\"이 아니므로 다음과 같이 새로운 문자열을 만듭니다. v에 대해 1단계부터 재귀적으로 수행하면 \"()\"이 반환됩니다. u의 앞뒤 문자를 제거하고, 나머지 문자의 괄호 방향을 뒤집으면 \"()\"이 됩니다. 따라서 생성되는 문자열은 \"(\" + \"()\" + \")\" + \"()\"이며, 최종적으로 \"(())()\"를 반환합니다. 처음에 그대로 둔 문자열에 반환된 문자열을 이어 붙이면 \"()\" + \"(())()\" = \"()(())()\"가 됩니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def solution(string):     if not string :         return \"\"          u, v = splitString(string)          if correctString(u):         return u + solution(v)          else:         answer = '(' + solution(v) + ')'          newU = u[1:-1]         for i in newU:             if i == '(':                 answer += ')'             if i == ')':                 answer += '('         return answer               def correctString(string):     stack = []          for s in string:         if stack and stack[-1] == '(' and s == ')':             stack.pop()         else:             stack.append(s)              return False if stack else True      def splitString(p):     open_p = 0     close_p = 0          for i in p:         if i == '(':             open_p += 1         else:             close_p += 1         if open_p == close_p:             return p[:open_p * 2], p[open_p * 2:]          return (''.join(splitList), newString)        1 solution(\"(()())()\")   1 '(()())()'   문제풀이  오늘 부터 다시 하루에 한문제씩 풀려고 하는데, 오랜만에 풀려고하니까 이 문제 하나 푸는데 한시간 반이 넘게 걸렸다… ㅜ 다시 재활 열심히 해야겠다.   이 문제는 아예 문제 자체에서 분기점을 설명해줘서, 괄호문자를 둘로 나누는 splitString()과 올바른 괄호인지를 체크하는 correctString() 메서드를 만들어주고 이를 문제대로 그대로 solution() 메서드를 코딩해주면 된다. 오랜만에 하려니까 머리가 굳어서 문제에서 대놓고 solution 함수를 말로 설명해주었는데도 불구하고 구현 방식이 제대로 떠오르지 않아서 오래 걸린 것 같다. 항상 노트를 옆에 두고 분기점을 체크해가며 어떻게 구현할지를 먼저 생각하고 문제를 풀어야겠다.   다른 풀이  프로그래머스에 너무 깔끔하게 푼 정답이 하나 있어서 첨부한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solution(p):     if p=='': return p     r=True; c=0     for i in range(len(p)):         if p[i]=='(':              c-=1         else:              c+=1         if c&gt;0:              r=False         if c==0:             if r:                 return p[:i+1]+solution(p[i+1:])             else:                 return '(' + solution(p[i+1:]) + ')' + ''.join(list(map(lambda x:'(' if x==')' else ')',p[1:i]) ))   아예 괄호문자를 나누고 올바른 문자인지를 확인하는 로직을 간단하게 짜서 solution함수 안에 작성했다. 사실 나도 이렇게 하고싶어서 한시간 넘게 머리를 쓴건데, 또 막상 작성된 코드를 보고나니 로직자체가 그렇게 복잡하지는 않았다고 생각한다. 아무래도 재귀함수가 껴있다보니까 복잡해져서 헷갈린것 같은데, 더 열심히 해야겠다…  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B4%84%ED%98%B8-%EB%B3%80%ED%99%98/",
        "teaser": null
      },{
        "title": "일벌리기",
        "excerpt":"2022.02.04  2022년의 2월이 또 어느새 시작됐다. 사실 2022년 시작하자마자 빡! 해서 열심히 했어야했는데, 아무래도 설도 있고 여행도 하다 보니까 조금 흐지부지 1월을 흘려보냈다. 그래도 나름 친구들이랑 스키장도 갔다오고 부산도 다녀오고 오랜만에 여행을 여기저기 다니며 시간을 보내서 공부 좀 못한거에는 크게 아쉽지는 않다. 이제부터 열심히 하면 되니까! 바램이 있다면 스키장 한번 더 가고싶은거?? 보드가 진짜 자꾸 어른거린다… 진짜 경지를 눈앞에 두고 스키장이 끝나버려서, 눈앞에 산 정상을 두고 다시 내려온 기분이다. 다시 그 산을 정복하려면 또 가야지싶다가도 같이 갈 친구가 없다. ㅜ 26살이란 원래 이렇게 외로운건가…   어쨌든 그건 기회가 오면 가도록하고, 우선 2월부터는 다시 여러가지를 시작해보려한다. 목표한 바를 이루기 위해서 작년보다 더 열심히 더 많이 공부 할거다. 그리고 우선 빨리 해보고싶은 아이템이 있어서, 창업을 시작해보려한다. 아직 아이디어 단계에 있는 사업이지만 충분히 구체화하면 가능성이 보인다. 자꾸 실력을 키우고 하려고 하니까 너무 흐지부지되고 목표가 흔들려서, 오늘부터는 좀 일을 벌려보려고 한다. 항상 뭔가를 시작할때는 망설이며 가만히 서있는것 보다, 우선 벌려놓고 하나씩 수습해가는게 차라리 나은것같다.   아직 사업을 시작하려면 뭐부터 해야하는지 정말 하나도 모르지만, 그래서 더 설레고 떨린다. 망하던말던간에 뭔가에 도전하고 부딪히는 일은 실력도 많이늘고 세상을 바라보는 시각도 한층 더 성장시켜주는 좋은 기회니까…   2022년은 학점도 얼마 안남았고, 졸업도 학점이 딱히 급해지지 않은 만큼 조금 더 자유롭게 취업전에만 해볼 수 있는 도전들을 더 해보면 보내보려 한다. 꼭 좋은 한해가 되었으면 좋겠다!  ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EC%9D%BC%EB%B2%8C%EB%A6%AC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] 게시판 만들기 - 데이터 등록",
        "excerpt":"이 게시물은 이동욱님의 “스프링 부트와 AWS로 혼자 구현하는 웹 서비스”를 읽고 공부하며 작성한 게시물입니다.   시작하며…  이 책으로 바로 시작하려니 사전지식이 너무 부족해서 홍팍님의 유튜브 강의로 대략적인 스프링부트의 기본적인 흐름에 대해서 이해하고 다시 책을 보니, 맨 처음에는 그냥 베끼기만 했던 내용들이 이제 무슨뜻인지 이해가 되기 시작했다. 다시 처음부터 게시판 웹서비스를 만들어보도록 하자.   이번에는 View가 없이 http요청을 통해 Json형태로 정보를 받아오는 Rest api를 만들도록 한다.  게시판 웹페이지를 만든다고 생각하고 CRUD 네 기능을 모두 구현해보자.   새글 등록하기  Domain  도메인이란 소프트웨어에 대한 요구사항 및 문제영역이라고 생각하면 되는데, 여기에 있는 클래스들은 대부분 Entity가 된다. Entity는 데이터베이스에 저장된 값으로, 이 값은 함부로 접근하거나 변경되어서는 안되므로, 항상 이 값을 꺼내올때는 Entity 자체에 접근 하는게 아니라, Dto라는 다른 형태로 가져와 처리를 하고 다시 Entity화 하여 저장하도록 한다.   그럼 먼저 게시판의 게시글이 될 Posts 클래스부터 구현해보자.   springboot/domain/posts/Posts  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @NoArgsConstructor @Entity public class Posts extends BaseTimeEntity{      @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      @Column(length = 500, nullable = false)     private String title;      @Column(columnDefinition = \"TEXT\", nullable = false)     private String content;      private String author;      }  @Entity 어노테이션은 이 클래스가 Entity가 될 클래스임을 명시하는 어노테이션으로, 이 어노테이션을 사용하면 테이블과 해당 클래스가 링크 된다. 따라서 Posts라는 테이블이 생성되고, @Column 어노테이션을 클래스 변수들에게 지정해 줌으로써 해당 변수들은 모두 칼럼이 된다.   id에 붙은 @Id는 이 값이 이 테이블의 PK, Primary Key가 된다고 선언하는 것인데, 추가로 GeneratedValue 어노테이션을 사용해주면, 이 PK를 스프링 부트가 알아서 생성한다. 직접 PK를 개발자가 지정해주면 오류가 발생할 확률이 매우 크므로, 특정상황을 제외하고서는 GenerationType.IDENTITY를 사용하여 자동생성 해주도록 해야한다.   이 Posts 클래스는 게시물에 대한 데이터가 되어야 하므로 PK인 id와 게시물의 제목인 title, 그리고 내용인 content, 작성자인 author를 칼럼으로 갖는다. @Column은 특정 세부설정을 할때는 선언해주어 title과 content와 같이 설정해주어야 하지만, author 처럼 따로 설정해야할 세부 설정이 없다면 @Column 없이도 알아서 해당 변수를 칼럼으로 인식한다.   이 변수명들은 그대로 칼럼의 이름이 되며, 카멜케이스 방식으로 사용하면 알아서 언더바 형식으로 변환된다.  ex) mainTitle =&gt; MAIN_TITLE   Entity를 만들었으니, 이 Entity를 데이터베이스에 접근하게 해줄 JpaRepository를 생성해주자.   Repository  Repository는 직접적으로 데이터베이스에 접근할 수 있도록 해주는 역할을 하는데, 굳이 데이터베이스에 복잡하게 SQL명령을 보내지 않아도 Jpa를 사용하면, 객체지향적으로 훨씬 편하게 데이터베이스를 관리할 수 있다.   springbood/domain/posts/PostsRepository  1 2 3 public interface PostsRepository extends JpaRepository&lt;Posts, Long&gt; {  }  인터페이스로 PostsRepository를 생성해 준 뒤, JpaRepository를 &lt;Entity 클래스, PK타입&gt;과 함께 상속해주면 Posts 클래스가 데이터베이스에 접근할 수 있도록 하는 Repository가 된다.   이제 해당 클래스를 통해서 save나 delete등의 메소드를 사용해 해당 엔티티의 데이터베이스에 접근할 수 있게 되었다.   이제 본격적으로 데이터를 등록, 삭제, 변경하는 Rest API를 만들어보자.   Service   서비스 메소드는 도메인에 접근하는 기능들의 순서를 보장해주며, 이를 @Transactional 어노테이션을 사용함으로써, 데이터베이스에 접근하는 도중 오류가 발생하면 해당 기능을 모두 완수하지 않은 상태로 멈추는게 아니라, 아예 데이터베이스에 접근하기 전의 상태로 돌아가게 해주는 역할을 해서 데이터자체에 오류가 섞이지 않도록 해준다.   springboot/service/posts  1 2 3 4 5 6 7 8 9 10 11 @RequiredArgsConstructor @Service public class PostsService {      private final PostsRepository postsRepository;      @Transactional     public Long save(PostsSaveRequestDto requestDto) {         return postsRepository.save(requestDto.toEntity()).getId();     } }  마찬가지로 @Service를 통해서 이 클래스가 서비스 메서드임을 선언해주고, 아까 생성해준 Repository를 선언해준다. final을 사용하고 @RequiredArgsConstructor를 사용해주면, 롬복이 final 변수에 대한 생성자를 만들어주기 때문에 따로 @AutoWired를 사용하지 않고도 Bean을 주입할 수 있다.   먼저 테이블에 데이터를 등록하는 기능을 위해서 save 메서드를 만들어준다. 여기서 save 메소드는 매개변수로 RequestDto의 자료형을 받는데, 이 RequestDto는 앞서 말했듯이 데이터에 직접 접근하지 않기 위해서 데이터와 비슷한 모양의 데이터를 만들어준다고 생각하면 편하다.   만약 우리가 어떤 밑그림만 그려져 있는 그림을 칠한다고 생각해보자. 바로 밑그림에다가 색부터 칠한다면, 색을 칠하고보니 잘 안어울리거나 잘못된 색을 칠했을때는 이미 원본이 훼손되었기 때문에 돌이킬 수 없을 것이고, 돌이킬 수 있더라도 많은 고생과 시간이 소요될 것 이다. 하지만 그 밑그림을 복사해서 한번 칠해보고 오류가 없는 것이 확인되면, 복사본을 토대로 원본에 색을 안전하게 입힐 수 있을 것이다. 여기서 원본이 Entity라면 Dto가 바로 이 원본의 복사본이다.   springboot/web/dto/PostsSaveRequestDto  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Getter @NoArgsConstructor public class PostsSaveRequestDto {     private String title;     private String content;     private String author;      @Builder     public PostsSaveRequestDto(String title, String content, String author) {         this.title = title;         this.content = content;         this.author = author;     }      public Posts toEntity() {         return Posts.builder()                 .title(title)                 .content(content)                 .author(author)                 .build();     } }  Dto 클래스의 모습을 보면 Entity 와 거의 똑같은 모습을 볼 수 있다. 앞서 말했듯이 데이터의 손상이나 오류를 방지하기 위해 Entity와 아주 비슷한 모습의 형태로 Entity를 가져와 가공하고 다시 toEntity() 메서드를 통해 다시 Entity로 변환하여 데이터베이스에 접근하게 되는 것이다.   여기서 PostsRequestDto를 보면, toEntity 메서드를 제외하고는 Posts와 아예 똑같은 것 같은데 굳이 ‘비슷한’이라는 단어를 사용한 이유는, 만약 Dto에 옮겨야할 데이터를 굳이 모두 가져올 필요가 없다면 title만 선언해준다던가 하는 식으로 Entity와 모습이 살짝 다른경우도 있기 때문이다.   이렇게 PostsRequestDto를 통해서 Service는 Dto 형태의 Post 요청을 받아 Repository로 넘겨 이를 데이터베이스에 저장하도록 한다. 그럼 JSon형태의 요청을 받아오기 위한 마지막 단계를 알아보자.   Controller  Contoller는 우리가 요청을 보내고 받는 부분으로, 웹페이지를 보는 View에서 서버에게 보내는 모든 요청은 Controller를 통해 서버에 전달 된다. 따라서 사용자가 보는 View에서 가장 가까이있는 클래스이다.   springboot/web/PostsApiController  1 2 3 4 5 6 7 8 9 10 11 @RequiredArgsConstructor @RestController public class PostsApiController {      private final PostsService postsService;      @PostMapping(\"/api/v1/posts\")     public Long save(@RequestBody PostsSaveRequestDto requestDto) {         return postsService.save(requestDto);     } }  @RestController 어노테이션을 선언함으로써, 이 클래스가 RestAPI를 만들기 위한 Contoller부분임을 선언한다. 이로써 web에서 우리가 요청을 보내면 Controller가 가장 먼저 받아 데이터베이스까지 요청을 전달해준다.   마찬가지로 PostsService 객체를 만들어주고 여기에 빈을 주입하기 위해 @RequiredArgsConstructor를 선언해준다.   우리는 새로운 글을 등록해야 하므로 Post 요청을 보내야 한다. 따라서 글을 등록하는 save 메서드는 @PostMapping 어노테이션을 사용해 Post 요청을 어노테이션 안에 있는 주소로 받는다. 따라서 우리는 /api/v1/posts로 Post 요청을 양식에 맞게 Json 데이터로 만들어 보내면, 해당 요청을 받아 보낸 요청에 담긴 데이터를 데이터베이스에 추가할 것 이다.   @RequestBody 어노테이션이 바로 받아온 Json 데이터를 스프링부트의 변수에 담을 수 있도록 해주는 어노테이션으로, 우리가 Json 요청을 아래와 같이 보내면,   1 2 3 4 5 {     \"title\": \"제목\",     \"content\": \"내용\",     \"author\": \"이민재\" }    알아서 PostsSaveRequestDto 변수에 해당 값들을 할당한다. 이렇게 받아온 dto를 Service로 보내고, Service가 dto를 Entity형태로 바꾸어 Repository로 넘겨주면 Repository가 해당 데이터를 데이터베이스에 저장한다.   지금까지 배운 모든 구조를 간략화해서 데이터베이스에서 우리가 요청을 받고 요청을 보내는 View까지의 단계를 대략적으로 나타내자면, 다음과 같다.      Json 데이터를 담은 요청 -&gt; (dto로 변환) -&gt; Controller -&gt; Service -&gt; (Entity로 변환) -&gt; Repository -&gt; 데이터 베이스    만약 반대로 데이터베이스로 부터 데이터를 얻어온다면,      데이터베이스 -&gt; Repository -&gt; (Entity) -&gt; Service -&gt; (dto로 변환) -&gt; Controller -&gt;\u001d 요청에 따른 데이터    가 될 것이다.   이로써 데이터 등록을 완료했다. 크롬 Talend를 통해 Post요청을 해당 주소로 보내면,         위와같이 해당 요청이 정상적으로 200의 Response를 보내며 등록되는 것을 볼 수 있다.   h2-console을 사용해서 Posts의 데이터베이스를 조회해도 다음과 같이,     데이터가 정상적으로 등록된 것을 볼 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EA%B2%8C%EC%8B%9C%ED%8C%90-API-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] TestRestTemplate Patch 요청 오류날 때",
        "excerpt":"문제  게시글 수정 테스트 코드를 작성하던 중, restTemplate의 exchange() 메서드에 아래와 같이  1 2 3 4 HttpEntity&lt;PostsUpdateRequestDto&gt; requestEntity = new HttpEntity&lt;&gt;(requestDto);   ResponseEntity&lt;Long&gt; responseEntity = restTemplate.exchange(url, HttpMethod.PATCH, requestEntity, Long.class);  PATCH 요청을 보내면 오류가 계속 떴는데, PutMapper로 바꾸고 exchange에도 PUT 요청을 보내면 테스트가 통과되었다. 그래서 PATCH로 했을 때의 로그를 확인해 보니,   org.springframework.web.client.ResourceAccessException: I/O error on PATCH request for “http://localhost:65324/api/v1/posts/1”: Invalid HTTP method: PATCH; nested exception is java.net.ProtocolException: Invalid HTTP method: PATCH   PATCH를 아예 올바른 HTTP 요청으로 인식하지 못하는 것 같았다. 그래서 구글링을 해보니 스택오버플로우에 해결방법이 나와있어 문제를 해결할 수 있었다.   출처링크   따로 apache HttpClientFactory를 주입하여 RestTemplate을 생성해주면 된다.   apache를 사용하기 위해 build.gradle 파일에 의존성을 아래와 같이 추가해주고,   1 implementation 'org.apache.httpcomponents:httpclient:4.5.13'   테스트 코드가 동작하기전에 준비할 작업을 모아두는 @Before 어노테이션의 setUp 메서드에 다음을 추가해주면 된다.   1 2 3 4 @Before public void setup() {     restTemplate.getRestTemplate().setRequestFactory(new HttpComponentsClientHttpRequestFactory()); }   이렇게 하고 다시 PATCH 요청을 exchange를 사용해서 보내주면 올바르게 요청이 보내져 테스트가 통과하는것을 볼 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-TestRestTemplate-Patch-%EC%9A%94%EC%B2%AD-%EC%98%A4%EB%A5%98%EB%82%A0-%EB%95%8C/",
        "teaser": null
      },{
        "title": "[Spring] 게시판 만들기 - JPA Auditiong으로 생성시간 / 수정시간 자동화 하기",
        "excerpt":"이 게시물은 이동욱님의 “스프링 부트와 AWS로 혼자 구현하는 웹 서비스”를 읽고 공부하며 작성한 게시물입니다.   보통 Entity는 해당 데이터의 생성시간과 수정시간을 포함한다. 이러한 생성/수정 정보는 후에 유지보수에 있어서 굉장히 중요한 정보이기 때문에 항상 데이터와 함께 저장해주는게 좋다. 하지만 이를 매번 DB에 삽입할때 날짜 데이터를 등록/수정하는 코드를 만들어 주는 것은 코드도 너무 지저분하고, 너무 많은 노동력이 들어가는 일일 것이다. 그래서 이러한 문제를 해결하고자 JPA Auditing을 사용해서 이를 자동화 해보자.   LocalDate  Java8부터는 LocalDate와 LocalDateTime이 등장했는데, 그동안 Java의 기본날짜 자료형인 Date가 문제점을 너무 많이 갖고 있어서  Java8 이전에는 JodaTime이라는 오픈소스를 사용해서 이러한 문제점들을 해결했다. 따라서 만약 Java8을 사용하고 있다면, 날짜타입은 무조건적으로 LocalDate와 LocalDateTime을 사용해야 한다.   데이터에 날짜를 추가하기 위해서 BaseTimeEntity 클래스를 만들어주자.   springboot/domain/posts/BaseTimeEntity  1 2 3 4 5 6 7 8 9 10 11 @Getter @MappedSuperclass @EntityListeners(AuditingEntityListener.class) public class BaseTimeEntity {      @CreatedDate     private LocalDateTime createdDate;      @LastModifiedDate     private LocalDateTime modifiedDate; }           @MappedSuperClass  JPA Entity 클래스들이 BaseTimeEntity를 상속할 경우 이 클래스의 변수인 createdDate와 modifiedDate도 칼럼으로 인식하게한다.            @EntityListners(AuditingEntityListener.class)  BaseTimeEntity 클래스에 Auditing 기능을 포함시킨다.            @CreatedDate  Entity가 생성되면, createdDate에 저장 시간이 자동으로 저장된다.            @LastModifiedDate  조회한 Entity의 값을 변경할 때 시간이 자동 저장된다.       이렇게 만들어준 BaseTimeEntity를 Entity인 Posts에 상속해주고, JPA Auditing을 활성화 할 수 있도록 Application 클래스에 활성화 어노테이션을 추가해주면, 자동으로 데이터베이스에 생성시간과 수정시간을 포함하여 저장할 수 있다.   springboot/domain/posts/Posts  1 2 3 4 5 6 7 @Getter @NoArgsConstructor @Entity public class Posts extends BaseTimeEntity{                     ...                     ... }  BaseTimeEntity를 상속해준다.   springboot/Application  1 2 3 4 5 6 7 8 @EnableJpaAuditing @SpringBootApplication public class Application {     public static void main(String[] args) {         SpringApplication.run(Application.class, args);     } }   @EnableJpaAuditing 어노테이션으로 JPA Auditing을 활성화 해준다.      Post 요청을 통해 게시글 데이터를 하나 추가해주면, 데이터베이스에 자동으로 생성시간과 수정시간이 함께 저장된 것을 확인할 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EA%B2%8C%EC%8B%9C%ED%8C%90-API-%EB%A7%8C%EB%93%A4%EA%B8%B0-JPA-Auditing%EC%9C%BC%EB%A1%9C-%EC%83%9D%EC%84%B1%EC%8B%9C%EA%B0%84-%EC%88%98%EC%A0%95%EC%8B%9C%EA%B0%84-%EC%9E%90%EB%8F%99%ED%99%94-%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] 게시판 만들기 - 데이터 조회/수정/삭제",
        "excerpt":"이 게시물은 이동욱님의 “스프링 부트와 AWS로 혼자 구현하는 웹 서비스”를 읽고 공부하며 작성한 게시물입니다.   게시글 조회  Get 요청을 보내 서버로부터 작성한 특정 게시물을 가져오는 API를 만들어보자.   데이터베이스 -&gt; Repository -&gt; (Entity) -&gt; Service -&gt; (dto로 변환) -&gt; Controller를 거쳐 우리가 보낸 요청에 맞는 데이터가 호출될 것이다.   이번에는 요청을 제일먼저 받는 Controller부터 작성해보도록 하자.   Contoller  springboot/web/PostsController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RequiredArgsConstructor @RestController public class PostsApiController {      private final PostsService postsService;      @PostMapping(\"/api/v1/posts\")     public Long save(@RequestBody PostsSaveRequestDto requestDto) {         return postsService.save(requestDto);     }              @GetMapping(\"/api/v1/posts/{id}\")     public PostsResponseDto findById(@PathVariable Long id) {         return postsService.findById(id);     } }  PostsController에 @GetMapping()으로 조회 요청을 받을 주소를 작성해주자.   여기서 id 부분이 {}로 감싸져있는데, 이는 주소에 있는 문자를 이 함수에 매개변수로 사용할 수 있게 해주는 기호이다. 이렇게 중괄호로 감싸주고 매개변수 앞에 @PathVarialble 어노테이션을 사용하면 중괄호 안에있는 id가 findById 메서드의 매개변수인 id로 매칭된다. 만약 1번 게시물을 조회 하고싶다면, /api/v1/posts/1의 주소에 Get요청을 보내면 @PathVariable이 1을 id로 넘겨주는 것이다.   Service  springboot/service/posts/PostsService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @RequiredArgsConstructor @Service public class PostsService {      private final PostsRepository postsRepository;      @Transactional     public Long save(PostsSaveRequestDto requestDto) {         return postsRepository.save(requestDto.toEntity()).getId();     }          @Transactional     public PostsResponseDto findById (Long id) {         Posts entity = postsRepository.findById(id)                 .orElseThrow(() -&gt; new IllegalArgumentException(\"해당 게시글이 없습니다 id =\" +id));         return new PostsResponseDto(entity);     } }  이제 Controller로 들어온 id를 Service 클래스에서 받아 Repository에서 해당 id에 맞는 데이터를 꺼내온다. 이렇게 꺼내온 데이터를 마찬가지로 Dto에 담아서 반환해준다. 응답에 대한 Dto이므로 또 새로운 Dto인 PostsResponseDto를 만들어주자. 앞으로 어떤 요청에 대해서 응답이 필요하다면, 데이터를 PostsResponseDto에 담아 반환해줄 것이다.   springboot/web/dto/PostsResponseDto  1 2 3 4 5 6 7 8 9 10 11 12 13 @Getter public class PostsResponseDto {     private String title;     private String content;     private String author;      @Builder     public PostsResponseDto(Posts entity) {         this.title = entity.getTitle();         this.content = entity.getContent();         this.author = entity.getAuthor();     } }  이렇게 하면 데이터를 조회하는 기능이 완성 되었다. 다시 정리해보자면,   api/v1/posts/1로 Get 요청을 보내면, 이를 GetMapping 어노테이션에 의해 id인 1을 Controller로 넘겨주고 PostsApiController는 이를 PostsService로 넘긴다. 그러면 Service는 이를 PostsRepository에게 전달해 해당 id에 맞는 데이터를 찾아오도록한뒤, 이를 PostsResponseDto에 담아 반환한다.   그럼 이제 서버를 재동작 시킨 후, 저번 게시물에서 만들었던 Post요청을 보내고 이를 조회해보자.      만들고 싶은 새 게시글의 정보를 담아서 Post 요청을 보내 게시글을 만든 뒤,      Get요청을 api/v1/posts/1로 보내면 위 사진과 같이 올바른 응답과 함께 아까 작성했던 게시글의 데이터를 불러오는 것을 알 수 있다.   게시글 수정  이번에는 Patch 요청을 보내 서버로부터 작성한 특정 게시물을 수정하는 API를 만들어보자.   조회 기능과 동일하게 Controller 부터 작성해보자.  Contoller  springboot/web/PostsController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @RequiredArgsConstructor @RestController public class PostsApiController {      private final PostsService postsService;      @PostMapping(\"/api/v1/posts\")     public Long save(@RequestBody PostsSaveRequestDto requestDto) {         return postsService.save(requestDto);     }              @GetMapping(\"/api/v1/posts/{id}\")     public PostsResponseDto findById(@PathVariable Long id) {         return postsService.findById(id);     }          @PatchMapping(\"/api/v1/posts/{id}\")     public Long update(@PathVariable Long id, @RequestBody PostsUpdateRequestDto requestDto) {         return postsService.update(id, requestDto);     } }  마찬가지로 @PathVariable을 사용해 주소로부터 수정할 게시물의 id를 받아오고, 수정할 내용도 받아와야하므로, @RequestBody를 사용해서 변경요청 사항을 Json으로 받아오도록 하자. 이번에는 PostsUpdateRequestDto에 해당 Json 데이터를 받아 Dto로 Service에 전달할건데, 변경이라면 제목과 내용만 변경하고 작성자는 변경할 필요가 없으므로 PostsUpdateRequestDto에는 title과 content만 존재해도 된다.   springboot/web/dto/PostsResponseDto  1 2 3 4 5 6 7 8 9 10 11 12 @Getter @NoArgsConstructor public class PostsUpdateRequestDto {     private String title;     private String content;      @Builder     public PostsUpdateRequestDto(String title, String content) {         this.title = title;         this.content = content;     } }  마찬가지로 이렇게 만든 dto와 함께 id를 받아 Service로 넘긴 뒤 처리해준다.   Service  springboot/service/posts/PostsService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @RequiredArgsConstructor @Service public class PostsService {      private final PostsRepository postsRepository;      @Transactional     public Long save(PostsSaveRequestDto requestDto) {         return postsRepository.save(requestDto.toEntity()).getId();     }          @Transactional     public PostsResponseDto findById (Long id) {         Posts entity = postsRepository.findById(id)                 .orElseThrow(() -&gt; new IllegalArgumentException(\"해당 게시글이 없습니다 id =\" +id));         return new PostsResponseDto(entity);     }          @Transactional     public Long update(Long id, PostsUpdateRequestDto requestDto) {         Posts entity = postsRepository.findById(id)                 .orElseThrow(() -&gt; new IllegalArgumentException());          entity.update(requestDto.getTitle(), requestDto.getContent());          return postsRepository.save(entity).getId();     } }   조회와 마찬가지로 우선 수정할 데이터가 있는지 Repository를 통해 조회 해준다. 만약 해당 id에 해당하는 게시물이 없다면, IllegalArgumentException을 출력한다. 이렇게 조회해온 Entity를 update 함수를 통해 직접 변경해준다. 그리고 변경한 Entity를 다시 Repository를 통해 저장해주면 변경이 완료 된다.   springboot/web/dto/PostsUpdateDto  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Getter @NoArgsConstructor @Entity public class Posts{      @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      @Column(length = 500, nullable = false)     private String title;      @Column(columnDefinition = \"TEXT\", nullable = false)     private String content;      private String author;      @Builder     public Posts(String title, String content, String author) {         this.title = title;         this.content = content;         this.author = author;     }      public void update(String title, String content) {         this.title = title;         this.content = content;     } }  Entity 클래스에 update라는 메서드를 만들어서 새로운 정보로 해당 엔티티를 변경할 수 있도록 해주면, 이제 해당 주소로 Patch 요청을 보내면 이제 id에 해당하는 게시물을 변경할 수 있다.      변경 요청을 Patch로 Json 데이터와 함께 보내면,      변경된 요청이 올바르게 적용된 것을 확인할 수 있다.   게시글 삭제  이번에는 Delete 요청을 보내 서버로부터 작성한 특정 게시물을 삭제하는 API를 만들어보자.   Contoller  springboot/web/PostsController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 @RequiredArgsConstructor @RestController public class PostsApiController {      private final PostsService postsService;      @PostMapping(\"/api/v1/posts\")     public Long save(@RequestBody PostsSaveRequestDto requestDto) {         return postsService.save(requestDto);     }          @GetMapping(\"/api/v1/posts/{id}\")     public PostsResponseDto findById(@PathVariable Long id) {         return postsService.findById(id);     }          @PatchMapping(\"/api/v1/posts/{id}\")     public Long update(@PathVariable Long id, @RequestBody PostsUpdateRequestDto requestDto) {         return postsService.update(id, requestDto);     }          @DeleteMapping(\"/api/v1/posts/{id}\")     public Long delete(@PathVariable Long id) {         return postsService.delete(id);     } }  마찬가지로 @PathVariable 어노테이션을 사용해서 주소의 id 값을 id변수로 받아온 뒤, Service로 넘겨준다.   Service  springboot/service/posts/PostsService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @RequiredArgsConstructor @Service public class PostsService {      private final PostsRepository postsRepository;      @Transactional     public Long save(PostsSaveRequestDto requestDto) {         return postsRepository.save(requestDto.toEntity()).getId();     }          @Transactional     public PostsResponseDto findById (Long id) {         Posts entity = postsRepository.findById(id)                 .orElseThrow(() -&gt; new IllegalArgumentException(\"해당 게시글이 없습니다 id =\" +id));         return new PostsResponseDto(entity);     }          @Transactional     public Long update(Long id, PostsUpdateRequestDto requestDto) {         Posts entity = postsRepository.findById(id)                 .orElseThrow(() -&gt; new IllegalArgumentException());          entity.update(requestDto.getTitle(), requestDto.getContent());          return postsRepository.save(entity).getId();     }          @Transactional     public Long delete(Long id) {         Posts entity = postsRepository.findById(id)                 .orElseThrow(() -&gt; new IllegalArgumentException(\"존재하지 않는 id의 게시글입니다.\"));         postsRepository.deleteById(id);         return entity.getId();      } }  Service에는 delete 메서드를 만들어준다. 먼저 해당 id의 데이터가 데이터 베이스에 존재하는지 Repository의 findById()를 통해서 확인해주고, 만약 해당 id의 데이터가 존재하지 않는다면 예외를 출력한다. 만약 예외를 출력하지 않았다면 Repository는 해당 데이터를 삭제한다.   이제 해당 게시물의 주소로 DELETE 요청을 보내면,      위 게시물과 같이 정상적으로 삭제 응답을 처리한것을 확인 할 수 있다.      h2-console 에서도 데이터가 올바르게 삭제되었다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EA%B2%8C%EC%8B%9C%ED%8C%90-API-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A1%B0%ED%9A%8C-%EC%88%98%EC%A0%95-%EC%82%AD%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[Spring] OAuth2 로그인 후에 js/css 파일이 노출되는 에러",
        "excerpt":"에러     위 사진과 같이 로그인후에 홈으로 가지지 않고 js파일이 노출되는 현상이 발생했다.   원래 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @RequiredArgsConstructor @EnableWebSecurity public class WebSecurityConfigurerAdapter extends org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter {     private final CustomOAuth2UserService customOAuth2UserService;      @Override     protected void configure(HttpSecurity http) throws Exception {         http                 .csrf().disable().headers().frameOptions().disable()                  .and()                     .authorizeRequests()                     .antMatchers(\"/\", \"/js/app\", \"/images/**\", \"/js/**\", \"/h2-console/***\")                     .permitAll()                     .antMatchers(\"/api/v1/**\").hasRole(Role.USER.name())                     .anyRequest().authenticated()                 .and()                     .logout()                     .logoutSuccessUrl(\"/\")                 .and()                     .oauth2Login()                     .userInfoEndpoint()                     .userService(customOAuth2UserService);     } }   해결 과정  구글링 결과 WebSecurityConfigurerAdapter의 configure에 다음과 같은 메서드를 추가하면 된다고 해서 따라해봤는데,  1 2 3 4 @Override public void configure(WebSecurity web) throws Exception {         web.ignoring()                 .requestMatchers(PathRequest.toStaticResources().atCommonLocations());     }  위와 같이 해도 해결이 되지않고 동일한 에러가 발생했다.   그래서 작성한 코드중에 에러를 일으킬만한 부분이 어디인지 찾아보니, configure 부분의 antMatcher() 메서드가 수상해보였다.   antMatcher()는 권한 관리 대상을 지정하는 옵션인데, 디렉토리 권한 허용설정이 제대로 안되고 있는것이 의심이 됐다. 위의 해결방법도, 결국 허용해주지 않은 js나 css폴더에서 발생하지 않는 에러를 해결하기 위해서 web.ignoring()을 사용한 것 같았다. 그래서 노출되는 js 파일의 경로를 antMatcher에 추가해보기로했다.      노출된 주소 :​ http://localhost:8080/static/js/app/index.js    변경된 코드  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15     @Override     protected void configure(HttpSecurity http) throws Exception {         http                 ...                 ...                  .and()                     .authorizeRequests()                     .antMatchers(\"/\", \"/js/app\", ,\"/static/**\", /images/**\", \"/js/**\", \"/h2-console/***\")                     .permitAll()                     .antMatchers(\"/api/v1/**\").hasRole(Role.USER.name())                     .anyRequest().authenticated()                ...                ...     }  antMatchers 부분에 /static의 경로도 추가해 권한을 허용해주었다.   그리고 다시 서버를 재시작하니, 로그인 후에 정상적으로 내가 설정해둔 홈으로 다시 리다이렉션 되는 것을 확인 할 수 있었다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-oauth2-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%ED%9B%84%EC%97%90-js%ED%8C%8C%EC%9D%BC%EC%9D%B4-%EB%85%B8%EC%B6%9C%EB%90%98%EB%8A%94-%EC%97%90%EB%9F%AC/",
        "teaser": null
      },{
        "title": "[Spring] 게시판 만들기 - oauth2.0으로 회원가입/로그인 구현하기",
        "excerpt":"이 게시물은 이동욱님의 “스프링 부트와 AWS로 혼자 구현하는 웹 서비스”를 읽고 공부하며 작성한 게시물입니다.   oauth 프로필 설정  먼저, 구글 클라우드 플랫폼에서 API 및 서비스에 있는 사용자 인증 정보 탭으로 이동한다.      ‘사용자 인증 정보’ 옆에 씽는 +사용자 인증 정보 만들기에서 OAuth 클라이언트 ID를 눌러 이동한다.     애플리케이션을 “웹 애플리케이션”으로 선택한다.     웹 애플리케이션의 이름을 설정해주고, 승인된 리디렉셕 URI에는 로그인에 성공시 리다이렉션할 URL을 적어준다. 이 주소는 AWS 서버 배포시에는 추가로 주소를 추가해야한다.  스프링 부트 2버전의 시큐리티는 기본적으로 {도메인}/login/oauth2/code/{소셜서비스 코드}로 리다이렉트 URL을 지원하고 있기 때문에, 다음과 같이 입력해준다.  1 http://localhost/login/oauth2/code/google      이렇게 까지 완료하면 이제 사용자인증정보 탭에 클라이언트ID와 클라이언트 비밀번호가 생성된 것을 볼 수 있다.      application-oauth.properties 파일 생성  먼저 application.properties가 있는 resources 폴더에 application-oauth.properties 파일을 생성해준다. 그리고 해당파일에 아까 받아온  클라이언트ID와 클라이언트 보안 비밀 코드를 다음과 같이 등록 해준다.   1 2 3 spring.security.oauth2.client.registration.google.client-id = {클라이언트 id} spring.security.oauth2.client.registration.google.client-secret = {클라이언트 비밀번호} spring.security.oauth2.client.registration.google.scope = profile,email   스프링 부트에서는 properties 이름을 application-xxx.properties로 만들면 xxx에 해당하는 이름의 profile이 생성되어 이를 관리할 수 있다.   따라서 이를 호출하기 위해서 application.properties에 가서 다음과 같은 코드를 추가한다.   1 2 spring.profils.include = oauth    주의 할점은 클라이언트 id와 비밀번호가 담긴 이 파일은 깃허브에 그대로 공개하게 되면 개인정보를 가져가는 취약점이 될 수 있기떄문에 .gitignore파일에 등록해서 이 파일이 깃허브로 올라가지 못하도록 해주어야 한다.   .gitignore 파일에 application-oauth.properties를 입력해주면 된다.   이제 본격적으로 User 데이터를 만들고, 구글을 통한 로그인 기능을 구현해보도록 하자.   로그인 기능 구현하기  Domain  먼저 User라는 테이블을 데이터베이스에 만들어주기 위해서 domain 폴더에 user 패키지를 만들고, User클래스를 만들어준다.   springboot/domain/user/User  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Getter @NoArgsConstructor @Entity public class User extends BaseTimeEntity {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      @Column(nullable = false)     private String name;      @Column(nullable = false)     private String email;      @Column     private String picture;      @Enumerated(EnumType.STRING)     @Column(nullable = false)     private Role role;      @Builder     public User(Long id, String name, String email, Role role) {         this.id = id;         this.name = name;         this.email = email;         this.role = role;     }      public User update(String name, String picture) {         this.name = name;         this.picture  = picture;     }      public String getRoleKey() {         return this.role.getKey();     } }  User 테이블을 Entity로 선언해준뒤, 속성으로 id, name, email, picture, role을 갖게 해준다.   role에 쓰인 @Enumerated(EnumType.STRING) 어노테이션은 JPA로 데이터베이스를 저장할때 Enum 값을 어떤 형태로 저장할지를 결정한다.                 기본적으로는 int 숫자가 저장되며, 숫자로 저장되면 우리가 데이터베이스를 볼때 그 값이 어떤 코드를 의미하는지 알 수 가 없기떄문에, String 타입으로 저장될 수 있도록 선언해준다.   Role은 사용자의 권한을 관리할 클래스로, Enum 타입으로 선언해준다.   springboot/domain/user/Role  1 2 3 4 5 6 7 8 9 10 @Getter @RequiredArgsConstructor public enum Role {      GUEST(\"ROLE_GUEST\", \"손님\"),     USER(\"ROLE_USER\", \"일반 사용자\");      private final String key;     private final String title; }  스프링 시큐리티에서는 권한코드에 항상 ROLE_이 앞에 있어야 인식할 수 있기떄문에, 코드별 키값을 ROLE_GUEST, ROLE_USER와 같이 지정한다.   마지막으로 User를 데이터베이스에 접근할 수 있도록 UserRepository도 선언해준다.   springboot/domain/user/UserRepository  1 2 3 public interface UserRepository extends JpaRepository&lt;User, Long&gt; {     Optional&lt;User&gt; findByEmail(String email); }  UserRepository에는 마찬가지로 JpaRepository를 상속해주고, 데이터베이스에 이미 있는 이메일인지 체크하기 위한 메서드인 findByEmail을 만들어준다.   이제 User 엔티티 관련한 코드를 모두 작성했으므로, 스프링 시큐리티 설정을 해보자.   스프링 시큐리티 설정   먼저 build.gradle 파일에 의존성을 하나 추가해준다.   1 implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'   그리고 폴더에 config 폴더를 만들어주고, 그 안에 auth라는 폴더를 또 만들어준다. 시큐리티 관련 클래스는 모두 이곳에서 관리하도록 한다.   그 다음 이곳에 WebSecurityConfigurerAdapter 클래스를 만들어준다.   springboot/config/auth/WebSecurityConfigurerAdapter  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @RequiredArgsConstructor @EnableWebSecurity public class WebSecurityConfigurerAdapter extends org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter {     private final CustomOAuth2UserService customOAuth2UserService;      @Override     protected void configure(HttpSecurity http) throws Exception {         http                 .csrf().disable().headers().frameOptions().disable()                 .and()                 .authorizeRequests()                 .antMatchers(\"/\", \"/css/**\", \"images/**\", \"/js/**\", \"/h2-console/***\").permitAll()                 .antMatchers(\"/api/v1/**\").hasRole(Role.USER.name())                 .anyRequest()                 .authenticated()                 .and()                 .logout().logoutSuccessUrl(\"/\")                 .and()                 .oauth2Login()                 .userInfoEndpoint()                 .userService(customOAuth2UserService);     }  }           EnableWebSecurity  Spring Security 설정을 활성화 한다.            .csrf().disable().headers().frameOptions().disable()  h2 콘솔을 사용하기 위해 해당 옵션들을 disable 해준다            authorizeRequests  URL별 권한 관리를 설정하는 옵션의 시작점으로, authorizeRequests가 선언되어야만 antMatchers 옵션을 사용할 수 있다.            antMatchers  권한 관리 대상을 지정하는 옵션으로, URL, HTTP 메소드별로 관리가 가능하다.   여기서 “/”등 지정된 URL은 permitAll()을 통해 전체 열람권한을 주었고, “/api/v1/**“의 주소는 USER권한을 가진사람만 가능하도록 하였다.            anyRequest   설정된 값들 이외의 나머지 URL을 나타낸다. 여기서는 authenticated()를 추가하여 나머지 URL들은 모두 인증된 사용자만 가능하게 한다.            logout().logoutSuccessUrl(“/”)  로그아웃 기능에 대한 여러 설정의 진입점으로, 로그아웃 성공시 “/”의 주소로 이동한다.            oauth2Login  OAuth 2 로그인 기능에 대한 설정의 진입점            userInfoEndPoint  OAuth 2 로그인 성공 이후 사용자 정보를 가져올 때의 설정등을 담당한다.            userService  소셜 로그인 성공 시 후속 조치를 진행할 UserService 인터페이스의 구현체를 등록한다. 리소스서버에서  사용자 정보를 가져온 상태에서 추가로 진행하고자 하는 기능을 명시할 수 있다.       여기까지 작성했다면, 아직 CustomOAuth2UserService 클래스가 없어 오류가 날것이다. 아래와 같이 작성해주도록 하자.   springboot/config/auth/CustomOAuth2UserService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @RequiredArgsConstructor @Service public class CustomOAuth2UserService implements OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; {     private final UserRepository userRepository;     private final HttpSession httpSession;      @Override     public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {         OAuth2UserService&lt;OAuth2UserRequest, OAuth2User&gt; delegate = new DefaultOAuth2UserService();         OAuth2User oAuth2User = delegate.loadUser(userRequest);          String registrationId = userRequest                 .getClientRegistration()                 .getRegistrationId();          String userNameAttributeName = userRequest                 .getClientRegistration()                 .getProviderDetails()                 .getUserInfoEndpoint()                 .getUserNameAttributeName();          OAuthAttributes attributes = OAuthAttributes.of(registrationId, userNameAttributeName,oAuth2User.getAttributes());          User user = saveOrUpdate(attributes);          httpSession.setAttribute(\"user\", new SessionUser(user));         return new DefaultOAuth2User(                 Collections.singleton(new SimpleGrantedAuthority(user.getRoleKey())),                 attributes.getAttributes(),                 attributes.getNameAttributeKey());       }      private User saveOrUpdate(OAuthAttributes attributes) {         User user = userRepository.findByEmail(attributes.getEmail())                 .map(entity -&gt; entity.update(attributes.getName(), attributes.getPicture()))                 .orElse(attributes.toEntity());         return userRepository.save(user);     } }          registrationId  현재 로그인 진행중인 서비스를 구분하는 코드이다. 지금은 구글만 사용하기 떄문에 없어도 되는 값이지만, 이후 네이버 연동시에 네이버 로그인인지, 구글로그인인지 구분하기 위해 사용한다.            userNameAttributeName  OAuth2 로그인 진행 시 키가 되는 필드값을 이야기한다. Primary Key와 같은 의미이다. 구글의 경우는 기본적으로 코드를 지원하지만, 네이버 카카오등은 기본 지원하지 않는다.  구글의 기본코드는 “sub”이다.       springboot/config/auth/dto/OAuthAttributes  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @Getter public class OAuthAttributes {     private Map&lt;String, Object&gt; attributes;     private String nameAttributeKey;     private String name;     private String email;     private String picture;      @Builder     public OAuthAttributes(Map&lt;String, Object&gt; attributes, String nameAttributeKey, String name, String email, String picture) {         this.attributes = attributes;         this.nameAttributeKey = nameAttributeKey;         this.name = name;         this.email = email;         this.picture = picture;     }      public static OAuthAttributes of(String registrationId, String userNameAttributeName, Map&lt;String, Object&gt; attributes) {         return ofGoogle(userNameAttributeName, attributes);     }      public static OAuthAttributes ofGoogle(String userNameAttributeName, Map&lt;String, Object&gt; attributes) {         return OAuthAttributes.builder()                 .name((String) attributes.get(\"name\"))                 .email((String) attributes.get(\"email\"))                 .picture((String) attributes.get(\"picture\"))                 .attributes(attributes)                 .nameAttributeKey(userNameAttributeName)                 .build();     }      public User toEntity(){         return User.builder()                 .name(name)                 .email(email)                 .picture(picture)                 .role(Role.GUEST)                 .build();     } }           OAuthAttributes  OAuth2UserService를 통해 가져온 OAuth2User의 attribute를 담을 클래스이다. 네이버나 카카오등의 다른 소셜 로그인도 이 클래스를 사용한다.            of()  OAtuh2User가 반환하는 사용자 정보는 Map의 자료형으로 반환되기 때문에 값하나하나를 변환해주어야한다.            toEntity()  User 엔티티를 생성한다. OAuthAttributes에서 엔티티를 생성하는 시점은 처음 가입할때 이며, 가입할때의 기본 권한을 GUEST로 주기 위해서 role값으로 Role.GUEST를 넘겨준다.       springboot/config/auth/dto/OAuthAttributes  1 2 3 4 5 6 7 8 9 10 11 12 @Getter public class SessionUser {     private String name;     private String email;     private String picture;      public SessionUser(User user) {         this.name = user.getName();         this.email = user.getEmail();         this.picture = user.getPicture();     } }      SessionUser  세션에 사용자 정보를 저장하기 위한 Dto 클래스이다.   SessionUser에는 인증된 사용자 정보만 필요한데, 그 외에 필요한 정보들은 없으니 name,email,picture만 가져오도록 한다.  굳이 따로 dot을 만들어주는 이유는, 만약 User그대로 세션에 저장하려고 하면, 직렬화를 구현하지 않았다는 에러가 뜨게된다. 그렇다고해서 User에 직렬화 코드를 넣게되면, 만약 엔티티가 @OneToMany와 @ManyToOne으로 자식 엔티티를 갖고있다면, 직렬화 대상에 너무 많은 것들이 포함되어 성능이 느려질 수 있다. 그래서 직렬화 기능을 가진 세션 Dto를 하나 만드는것이 후에 운영이나 유지보수에 유리하다.   로그인 버튼 추가하기  작성한 글들의 목록을 보여주는 페이지인 index.mustache에 다음과 같은 코드를 추가한다.   springboot/resources/templayes/index.mustache  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15   &lt;div class=\"row\"&gt;         &lt;div class=\"col-md-6\"&gt;             &lt;button type=\"button\" class=\"btn btn-primary\" data-toggle=\"modal\" data-target=\"#savePostsModal\"&gt;글 등록&lt;/button&gt;                              Logged in as: &lt;span id = \"user\"&gt;&lt;/span&gt;             &lt;a href=\"/logout\" class=\"btn btn-info active\" role=\"button\"&gt;Logout&lt;/a&gt;                                           &lt;a href=\"/oauth2/authorization/google\" class=\"btn btn-success active\" role=\"button\"&gt;Google Login&lt;/a&gt;                      &lt;/div&gt;     &lt;/div&gt; ... ... &lt;!---목록 출력 영역---&gt;           a href = “/logout”  스프링 시큐리티에서 기본적으로 제공하는 로그아웃 URL로, 개발자가 별도로 이 URL에 해당하는 컨트롤러를 만들 필요가 없다.            해당 값이 존재할 경우에는 #을 사용하여, userName이 존재하면 로그아웃 버튼이 표시된다.            해당값이 존재하지 않을경우는 ^를 사용하여 userName이 존재하지 않으면 로그인 버튼이 노출된다.            a href=”/oauth2/authorization/google”  마찬가지로 스프링 시큐리티에서 제공하는 로그인 URL로, 개발자가 별도의 컨트롤러를 생성할 필요가 없다.       이제 이 mustache 파일이 인식할 수 있도록 IndexController에서 userName을 받아와 Model을 등록해주도록 하자.   springboot/web/IndexController  1 2 3 4 5 6 7 8 9 10 11 12 @GetMapping(\"/\")     public String index(Model model) {         List&lt;PostsListResponseDto&gt; postsList = postsService.findAllDesc();         model.addAttribute(\"posts\", postsList);          SessionUser user = (SessionUser) httpSession.getAttribute(\"user\");          if (user != null) {             model.addAttribute(\"userName\", user.getName());         }         return \"index\";     }      SessionUser user = (SessionUser) httpSession.getAttribute(“user”)  앞서 작성된 CustomOAuthUserService에서 로그인 성공 시에 세션에 SeesionUser를 저장하도록 했다. 즉, 로그인이 성공하면 httpSession에서 user값을 가져온다.   이제 홈화면에 접속하면, 로그인이 정상적으로 구현 된것을 확인할 수 있다.   웹페이지에서 테스트하기     로그인 버튼이 생성된 것을 볼 수 있는데, 누르면 우리가 자주보던 구글 로그인 화면이 뜨는것을 확인 할 수 있다.      구글 아이디를 선택하면, 정상적으로 로그인이 완료된다.      ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EA%B2%8C%EC%8B%9C%ED%8C%90-API-%EB%A7%8C%EB%93%A4%EA%B8%B0-oauth2%EB%A1%9C-%ED%9A%8C%EC%9B%90%EA%B0%80%EC%9E%85-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] webSocket으로 채팅서버 구현하기 (1)",
        "excerpt":"서론  새로 개발할 앱을 플러터 + 스프링부트로 개발하기로 마음먹고나서, 이번 앱에 가장 중요한 부분이 채팅기능이기 때문에 가장먼저 스프링부트로 채팅서버를 구현해보려고한다.   WebSocket  만약 우리가 채팅이라던가 주식정보를 가져오는등의 실시간으로 서버에 계속 통신을 해야하는 경우를 생각해보자. 2초마다 GET 요청을 보내 http 통신을 요청 할수도 있겠지만,  이렇게 하면 매번 연결을 맺고 끊는 연결과정의 비용이 들어갈 뿐만아니라, 단방향 통신으로 반드시 클라이언트가 요청을 해야만 서버가 정보를 주기 때문에, 양방향 통신이 필요한 기능을 만들기에는 HTTP 통신은 불편한 부분이 있다. 그래서 이러한 비연결성과 단방향 통신의 불편함을 해소하기 위해 만든 통신규약이 바로 webSocket으로, webSocket은 한번 연결을 맺으면 연결을 해제하기 전까지 유지 되기 떄문에, 연결을 맺고 끊는 연결과정을 없앨 수 있을 뿐만아니라, 양방향 통신이 가능하기 때문에 클라이언트가 요청을 하지않아도 서버가 주어야할 데이터를 보내줄 수 있다. 뿐만아니라, HTTP요청에 비해 webSocket은 한번에 주고받는 데이터의 양이 HTTP에 비해 확연히 적기 때문에, 계속 데이터를 주고받아야 하는 서비스에서는 적절하지 않다.   그럼 스프링 부트에서 webSocket을 어떻게 사용해야하는지 알아보고, 이를 이용해서 간단한 채팅 서비스를 만들어보자.   의존성 추가  build.gradle 파일에 아래와 같이 스프링부트에서 webSocket을 사용하기 위한 의존성을 추가해준다.  1 2 3 4 dependencies {     implementation 'org.springframework.boot:spring-boot-starter-websocket' }    WebSocket 기본 설정  스프링 부트에서 webSocket을 활성화 하려면, WebSocketConfig 클래스를 만들어 클라이언트가 보내는 정보를 받아서 처리할 Handler를 만들어주고, 이를 연결할 웹소켓 주소를 설정해 주어야한다.   WebSocketConfig  1 2 3 4 5 6 7 8 9 10 11 @RequiredArgsConstructor @Configuration @EnableWebSocket public class WebSockConfig implements WebSocketConfigurer {     private final WebSocketHandler webSocketHandler;      @Override     public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {         registry.addHandler(webSocketHandler, \"ws/chat\").setAllowedOrigins(\"*\");     } }  @EnableWebSocket을 통해 webSocket을 활성화 해주고, WebSocektConfigurer 인터페이스를 적용하여 WebSocketConfig라는 클래스를 만들어 이를 설정해준다.   우리가 정보를 처리할 Handler와 webSocket 주소를 WebSocketHandlerRegistry에 추가해주면, 해당 주소로 접근하면 웹소켓 연결을 할 수가 있다.   아직 Handler를 만들지 않아 에러가 뜨는데, 그럼 여기서 정보를 받아 처리할 Handler를 만들어보자.   WebSocketHandler  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Slf4j @RequiredArgsConstructor @Component public class WebSocketHandler extends TextWebSocketHandler {     private final ObjectMapper objectMapper;     private final ChatService chatService;      @Override     protected void handleTextMessage(WebSocketSession session, TextMessage message) throws Exception {         String payload = message.getPayload();         log.info(\"{}\", payload);         ChatMessage chatMessage = objectMapper.readValue(payload, ChatMessage.class);                  ChatRoom chatRoom = chatService.findRoomById(chatMessage.getRoomId());         chatRoom.handlerActions(session, chatMessage, chatService);     } }  스프링은 Text 타입과 Binary타입의 핸들러를 지원하는데, 우리는 채팅 서비스를 만들 것 이므로 TextWebSocketHandler를 상속하여 WebSocketHandler를 만들어줄것이다.  우리가 메세지를 json형식을 통해서 웹소켓을 통해 서버로 보내면, Handler는 이를받아 ObjectMapper를 통해서 해당 json 데이터를 chatMessage.class에 맞게 파싱하여 ChatMessage 객체로 변환하고,  이 json 데이터에 들어있는 roomId를 이용해서 해당 채팅방을 찾아 handlerAction() 이라는 메서드를 실행시킬 것이다. 그러면 handlerAction() 메서드는 이 참여자가 현재 이미 채팅방에 접속된 상태인지, 아니면 이미 채팅에 참여해있는 상태인지를 판별하여, 만약 채팅방에 처음 참여하는거라면 session을 연결해줌과 동시에 메시지를 보낼것이고 아니라면 메시지를 해당 채팅방으로 보내게 될 것이다.   아직 ChatMessage와 ChatRoom, ChatService 클래스를 만들지 않아 에러가 뜨지만, 대략적인 웹소켓 구성을 다음과 같이 구상하고 하나씩 만들어보도록 하자.   DTO 만들기  위의 WebSocketHandler에서 사용했던 ChatMessage와 ChatRoom 클래스를 만들어 json데이터로 받아온 정보를 통해 해당 채팅방으로 채팅 메시지를 보낼 수 있도록 해당 json에 맞는 DTO들을 만들어주자.   ChatMessage  1 2 3 4 5 6 7 8 9 10 11 12 @Getter @Setter public class ChatMessage {     public enum MessageType{         ENTER, TALK     }      private MessageType type;     private String roomId;     private String sender;     private String message; }  간단하게 사용자가 ENTER, 처음 채팅방에 들어오는 상태인지 TALK, 이미 session에 연결되어있고 채팅중인 상태인지를 파악하기 위해 ENUM 타입으로 Message 타입을 선언해주고, 이를 type으로 갖게 하도록한다. 그 이외에는 간단하게, 이 메시지를 보낼 채팅방 id인 roomId와, 보내는 사람의 닉네임인 sender, 메시지를 담는 변수 message를 만들어, json 데이터로 채팅 데이터가 들어오면 이를 ChatMessage로 변환해 줄 수 있도록하자.   ChatRoom  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Getter public class ChatRoom {     private String roomId;     private String name;     private Set&lt;WebSocketSession&gt; sessions = new HashSet&lt;&gt;();      @Builder     public ChatRoom(String roomId, String name) {         this.roomId = roomId;         this.name = name;     }      public void handlerActions(WebSocketSession session, ChatMessage chatMessage, ChatService chatService) {         if (chatMessage.getType().equals(ChatMessage.MessageType.ENTER)) {             sessions.add(session);             chatMessage.setMessage(chatMessage.getSender() + \"님이 입장했습니다.\");         }         sendMessage(chatMessage, chatService);      }      private &lt;T&gt; void sendMessage(T message, ChatService chatService) {         sessions.parallelStream()                 .forEach(session -&gt; chatService.sendMessage(session, message));     } }   ChatRoom은 roomId와 name, 그리고 session을 관리할 sessions를 갖는다. json 데이터를 받아 WebSocketHandler에서 해당 데이터에 담긴 roomId를 chatService를 통해서 조회 하여 해당 id의 채팅방을 찾아 json데이터에 담긴 메시지를 해당 채팅방으로 보내게된다. 이 기능을 담당하는 곳이 handlerActions 메서드로, 해당 roomId의 채팅방을 찾아 handlerActions로 메시지와 세션을 보내면 이 메시지의 상태가 ENTER 상태인지 TALK 상태인지 판별하여 만약 ENTER 상태라면 session을 연결한뒤에 해당 sender가 입장했다는 메시지를 해당 채팅방에 보내고, 만약 이미 연결된 TALK 상태라면 해당 메시지를 해당 채팅방에 입장해있는 모든 클라이언트들 (Websocket session)에게 메시지를 보낸다.   그럼 이제 이러한 기능들을 처리할 ChatService와 ChatController를 만들어 본격적으로 클라이언트가 서버에 웹소켓을 열고 이를 통해 메시지를 주고받게 해줄수 있는 로직을 작성해보자.   Service, Controller   ChatService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 @Slf4j @RequiredArgsConstructor @Service public class ChatService {     private final ObjectMapper objectMapper;     private Map&lt;String, ChatRoom&gt; chatRooms;      @PostConstruct     private void init() {         chatRooms = new LinkedHashMap&lt;&gt;();     }      public List&lt;ChatRoom&gt; findAllRoom() {         return new ArrayList&lt;&gt;(chatRooms.values());     }      public ChatRoom findRoomById(String roomId) {         return chatRooms.get(roomId);     }      public ChatRoom createRoom(String name) {         String randomId = UUID.randomUUID().toString();         ChatRoom chatRoom = ChatRoom.builder()                 .roomId(randomId)                 .name(name)                 .build();         chatRooms.put(randomId, chatRoom);         return chatRoom;     }      public &lt;T&gt; void sendMessage(WebSocketSession session, T message) {         try{             session.sendMessage(new TextMessage(objectMapper.writeValueAsString(message)));         } catch (IOException e) {             log.error(e.getMessage(), e);         }     } }  ChatService는 chatRooms를 클래스 변수로 갖는데, chatRooms는 RoomId를 key로 갖고 chatRoom을 value로 갖는 Map으로, createRoom() 메서드가 실행되면 새로 방이 만들어지고 chatRooms에 chatRoom이 추가된다. 방의 아이디는 UUID로 랜덤으로 생성하여 지정되며, roomId를 사용해 findRoomById() 메서드를 통해서 해당 채팅방을 불러올 수 있다.   sendMessage() 메서드는 TALK 상태일 경우 실행되는 메서드로, 메시지를 해당 채팅방의 webSocket 세션에 보내는 메서드이다.   이제 이러한 로직들을 ChatController를 통해 Http요청을 받으면 채팅방을 만들고, roomId를 반환하게 만들어 해당 roomId를 통해서 채팅방에 메시지를 날려보자.   ChatController  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @RequiredArgsConstructor @RestController @RequestMapping(\"/chat\") public class ChatController {     private final ChatService chatService;      @PostMapping     public ChatRoom createRoom(@RequestBody String name) {         return chatService.createRoom(name);     }      @GetMapping     public List&lt;ChatRoom&gt; findAllRoom() {         return chatService.findAllRoom();     } }  @RequestMapping 어노테이션을 통해서 “/chat” 주소로 Post요청이 들어오면 json 데이터에서 name값을 받아 해당 이름으로 된 채팅방을 생성하고, Get요청이 들어오면 현재 열려있는 모든 채팅방을 모두 조회 할 수 있게 해주었다. 그럼 이제 모두 완성 되었으니, 한번 “/chat” 주소로 Post 요청을 보내 방을 생성하고 webSocket 접속을 도와주는 테스트 클라이언트를 열어 채팅을 실행해보자.   테스트  먼저, Post요청을 보내면,      다음과 같이 정상적으로 방을 생성하고 생성된 방의 roomId를 리턴해주는 걸 볼 수 있다.   그럼 이제 이 방으로 접속해서 웹소켓을 이용한 채팅을 진행해보자. 구글 크롬 확장 프로그램인 WebSocketTestClient를 검색해서 추가한뒤 열어준다.   우리가 webSocket을 사용하기 위한 주소로 지정했던 “ws/chat”을 붙여주고 Open 버튼을 눌러 webSocket에 연결한다. “ws://localhost:8080/ws/chat” webSocket 요청이므로 http가 아닌 ws가 들어가야 한다.      이제 그럼 Request 부분에 아래와 같은 json 데이터를 보내보자.   1 2 3 4 5 6 {   \"type\":\"ENTER\",   \"roomId\":\"e4f57c65-0b0f-4972-b20c-4a024a0a4f81\",   \"sender\":\"사용자1\",   \"message\":\"asd\" }  여기서 roomId는 아까 Post 요청을 통해 반환받은, 방금 생성한 채팅방의 roomId를 넣어주면 된다. send를 눌러 해당 데이터를 보내면,      다음과 같이 올바르게 session이 연결되고 ENTER 요청이므로 sender가 입장했다는 message가 전송되는 것을 확인 할 수 있다. 그럼 올바르게 채팅 내용이 채팅방 참여자 모두에게 전해지고 있는 지 확인 하기 위해서 웹페이지를 하나 더 연뒤 ENTER 하여 세션을 연결하고 TALK 속성의 메시지를 보내보도록 하자. 동일하게 페이지 하나를 더 열어 사용자2 라는 sender를 채팅방에 참여시킨다.      다음과 같이 사용자2도 올바르게 채팅방에 입장한 것을 확인할 수 있으며,      사용자 1도 같은 세션에 접속해 있으므로 동일하게 참가했다는 메시지를 확인할 수 있다.   그럼 이제 사용자1이 TALK 메시지를 보내보면,      다음과 같이 올바르게 메시지가 송신되고,      마찬가지로 같은 세션에 연결되어있는 사용자2에게도 동일한 메시지가 보이는 것을 확인 할 수 있다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EA%B2%8C%EC%8B%9C%ED%8C%90-API-%EB%A7%8C%EB%93%A4%EA%B8%B0-webSocket%EC%9C%BC%EB%A1%9C-%EC%B1%84%ED%8C%85%EC%84%9C%EB%B2%84-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "맥북 프로 사다!",
        "excerpt":"2022.02.16  출시때부터 맨날 꿈에도 나오고 너무너무 갖고싶었던 맥북프로를 샀다. 사실 산 지 이틀정도 되었는데, 요즘 새로 어플 만드느라 바빠서 이제야 쓴다. 가격이 너무 쎄고, 솔직히 개발하는데 에어면 충분한 것 같아서 안사려고 했는데, 점점 프로젝트가 커지고 앱개발 하느라 gpu를 잔뜩 잡아먹는 xcode로 ios개발을 하려니 점점 버벅이고 램도 8기가 밖에 안되서 프로그램 한 네개정도를 켜놓으면 좀 많이 버벅이기 시작해서 결국 못 참고 질러버렸다. 16인치를 살짝 고민도 해봤지만, 가격도 가격이지만 16인치 맥북을 들고 다닐 자신이 정말 너무 없어서 14인치 모델로 샀다. ssd 올리는걸 살짝 고민했지만 어차피 외장 ssd가 있기도하고, 개발자라는 직업이 막 용량이 부족한 직업은 아니어서 그냥 14인치 깡통으로 갔다. 그 결과는 정말 대만족…   우선 화면이 너무 쨍하고 좋은건 물론이고, 진짜 지금까지 한번도 버벅인적이 없다. 오늘 작업을 하다가 엑셀이 잠깐 이상해서 끄려고 강제종료를 켰는데, 내가 지금 프로그램을 거의 열개 넘게 켜놓은걸 보고 깜짝 놀랐다. 에어에서는 한 4개 정도 켜면 버벅거려서 강제종료창을 자주 켰었는데 구매한지 3일만에 처음으로 강제종료창을 켜봤다. 이래서 돈이 좋은건가… 사실 좋은 회사 가면 보통 사주니까 그때 사야지 싶었는데, 사고나니까 진작 살걸 그랬다는 생각이 들었다. 너무 쾌적하고 공부하는게 즐겁다…   거기다가 그 동안 듀얼 모니터 세팅이 너무너무 하고싶었었는데, 에어는 외장 모니터 1대 지원이라 모니터를 못사고 있었다. 그래서 맥북프로도 산김에 통크게 모니터도 같이 질렀다 ㅎㅎㅎ 솔직히 맥북도 맥북인데, 진짜 듀얼모니터의 체감과 능률향상이 말이 안된다. 맨처음에는 서브모니터니까 저렴하게 20만원짜리 FHD 모니터를 샀었는데, 난 맥북이 4k모니터 아니면 글자가 그렇게 깨지는지 모르고 있었다… 맨날 4k 보다가 FHD봐서 그런가? 했는데 진짜 보다보다 이건 아닌것 같아서 검색해보니, 맥북은 4k모니터 미만에서는 hidpi설정이 안되서 글자가 다 깨져보인다는걸 그제야 알았다… 그래서 눈이 진짜 너무 아프고 이걸로 코드보면 맨날 스트레스 받을 것 같아서, 바로 반품해버리고 다음 모니터를 찾고있었는데 아니나 다를까 지마켓에서 모니터들을 할인을 오지게 때려가며 팔고 있었다. 운도좋지… 그래서 지금 모니터를 서브로 보내버리고 아예 32인치 4k 모니터로 가버렸다. 할인을 거의 10만원 넘게 해줘서 이건 안 살수가 없었는데, 결과론적으로는 사길 너무 너무 잘했다. 솔직히 모니터가 맥북보다도 만족감이 클수도…?   최근에는 플러터를 시작했는데, 너무 재미있어서 요즘 부쩍 코딩하는 시간이 늘것 같다. 원래는 처음부터 완벽하게 스프링부트 서버랑 ios 안드로이드 이렇게 세개를 개발할까 했었는데, 어쩌면 초기자본도 없다시피하고 인력도 없는 상황에서 그런 네이티브 앱을 사용하면 너무 질질 끌다가 이도저도 아니게 될것 같아서 플러터를 선택해서 빠르게 개발하기로 했다. 지금은 앱의 완벽한 퀄리티보다는 빠르게 시장진입하는게 우선인 것 같아서, 우선 플러터 + 스프링 부트를 생각하고 있는데 만약 스프링 부트가 너무 어려울것 같다면 그냥 미련없이 파이어베이스를 사용할 생각도 하고있다. 처음에는 망해도 스펙이 될 수 있도록 사업이 성공하는 방향이 아니라 그냥 내 공부겸 한다는 생각으로 접근했는데, 아무리 생각해도 아이템이 너무 매력적이고 지금 어느정도 구체화된 시장 진입 방법도 나쁘지 않은 것 같아서 올 한해정도는 빡세게 올인해볼 생각이다.   복학도 있어서 너무 너무 바쁜 일년이 될것 같다는 생각이 든다. 그래도 화이팅 하는 맘으로 열심히 2022년을 보내야지.  ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EB%A7%A5%EB%B6%81-%ED%94%84%EB%A1%9C-%EC%82%AC%EB%8B%A4!/",
        "teaser": null
      },{
        "title": "뉴로퓨전 프로젝트",
        "excerpt":"2022.02.18  작년 이맘때쯤, 한창 주식에 관심이 많아져서 공부도 많이하고 더 나아가서는 업으로 삼고싶다는 생각까지 했었는데, 그때 어떤 커뮤니티에서 누가 트레이딩에 관해서 너무 전문적이고 좋은 글을 올려놨길래 읽고 감탄했었다. 월가아재라는 닉네임을 한 분이 올린 글이었는데, 유튜브 채널을 홍보하기 위해서 자기가 올린 영상을 글로 적어놓은 게시물이었다. 자신은 월가에서 트레이더로 일했었던 사람이며, 현재는 켄쇼에서 데이터과학자로 일하고 있다고 했다. 그래서 관심이 생겨서 유튜브도 따라가 보았는데 정말 너무 깊고 전문적인 내용이어서 ‘아니 유튜브에 이렇게까지 올려도 되나?’ 싶었었다. 그 이후로 월가아재를 구독해 놓고 열심히 올라온 영상들을 시청하고, 쓴 글을 읽고는 했는데, 지금의 경제적이나 주식투자에 대한 지식에 큰 기반이 되었다. 뿐만아니라 행복이나 20대가 가질 수 있는 여러가지 생각들을 자신의 경험에 빗대어 영상을 올리곤 했는데, 사실 사회적 기반도 없고, 무얼해야할 지 모를 혼란스러운 20대에서 떄때로 그 유튜브 영상이 내 이정표가 되어주기도 했었다. 그를 동경해서 한때 내 꿈은 데이터과학자이기도 했으며, 그때는 정말 열심히 주식과 함께 파이썬을 가지고 캐글을 팠던 기억이 난다. 더 나아가서는 그 분이 고등학교때부터 쓰신 일기가 있는 블로그에 가서 거의 모든글을 정독하기도 했는데, 얼마전에는 이 내용들을 유튜브 이벤트를 통해서 책으로 받아 지금은 소중히 내 책상 가장 첫번째 칸에 꽂혀있는 책이 되었다. 사실 이 일기와 이 일기를 쓰고 있는 블로그도, 월가아재님의 블로그를 보고 감명받아 시작했다.      월가아재 블로그 주소    어쨌든 이렇게 내 25살에 나름 큰 영향을 끼친사람이, 켄쇼에서 연봉을 5억이 넘게 받으면서 왜 굳이 인기가 없을만한 너무 전문적인 내용으로 유튜브를 할까 항상 의문이었는데, 항상 그런 질문이 들어오면 자신이 계획하고 있는 사업의 한 단계로써 유튜브를 통해 트레이딩에 관심이 있고 스스로 생각할 수 있는 사람을 찾고있다고 했다. 그리고 그 계획은 2022년 초에 유튜브를 통해 공개 할 것이라고 해서 이렇게 똑똑한 사람은 어떤 걸 계획 하고 있을지 항상 궁금했는데, 어느덧 1년이 지나 그 계획이 공개되었다.   계획하신건 뉴로퓨젼이라는 헤지펀드로, 뇌파데이터를 이용한 헤지펀드를 만드는 것이 그 계획이었다. 인간의 뇌파데이터는 무궁무진한 가치를 갖고있지만, 지금까지는 너무나도 비싼 뇌파 데이터 기계 때문에 데이터가 유의미한 의미성을 가질 정도의 데이터를 확보하는 것이 너무 어려웠다. 이는 물론 지금도 마찬가지로, 뇌파 측정 기계는 많이 가격이 내려왔지만, 이를 측정할 사람을 대규모로 모집하는것이 너무나도 많은 비용을 필요로 하기에 현재도 기술은 완성 단계에 있지만 데이터 부족이 큰 문제로 작용하고 있어 유의미한 성과를 내기 힘든 상황이다. 그래서 이 프로젝트는 이러한 뇌파 데이터들을 수집하여 트레이딩에 있어 유의미한 수익을 내기 위한 세계 최초의 뇌파 데이터 기반 헤지펀드이다. 이러한 뇌파 데이터를 얻기 위해서는 불특정 다수의 뇌파데이터가 아닌 비판적 사고능력이 있는 사람들의 데이터가 필요한데, 그래서 그동안 이 프로젝트에 참여하여 뇌파데이터를 제공하기 위한 사람들을 모으기 위해 유튜브를 했던 것이다.      뉴로퓨젼 소개 영상    이 유튜브 영상을 다 시청하자 마자 난 주저없이 바로 신청서를 넣었다. 사실 이 인지과학에 대한 이해도도 없고, 뇌파 데이터로 정확히 어떻게 헤지펀드를 운용할것 인지 내 머리로는 이해하지 못했지만, 참가자들에게 제공되는 혜택이 너무 파격적이었다. 현역으로 일하고 있는 정말 우수한 퀀트트레이더와 데이터사이언티스트에게 직접 자산배분/가치투자에 대한 강의를 받을 수 있으며, 이 지식을 기반으로 이들이 제작한 인공지능 플랫폼에서 여러가지 자연어 처리, 그래프 데이터베이스, 머신러닝들의 기능을 사용할 수 있다. 그것도 평생! 물론 참가를 위한 비용이 있지만 사실 이정도의 지식과 플랫폼을 사용할 수 있는 권한이 100-200만원 사이라면, 난 주저없이 지불할 의사가 있었다. 이 정도의 지식과 플랫폼을 정액제도 아닌 일시불로 제공한다니, 사실 이 강의와 플랫폼으로 돈을 벌겠다는 목적이라면 정말 달에 200만원 씩을 정액제로 받아도 적은 가격이다. 하지만 그게 아니라 내 뇌파데이터를 제공함과 함께 그 댓가로 얻어지는 혜택이기에, 가능할 수 있는 가격이라고 생각했다.   그래서 영상을 보자마자 신청을 했고, 어제 1순의 그룹에 해당되어있다는 메일을 회신받았다. 3월 15일 정도에 정확한 약관과 금액이 정해지면 다시 메일이 온다고 하는데 사실 이미 돈을 좀 더 지불하더라도 얼마든지 낼 준비가 되어있다.   2022년은 여러모로 여러가지 도전이 많은 해가 될 것 같다. 지금 참가하는 이 프로젝트가 얼마나 내 인생을 바꾸어 놓을지 정말 큰 기대가 되고 너무 설렌다. 2022년도 화이팅.  ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EB%89%B4%EB%A1%9C%ED%93%A8%EC%A0%84/",
        "teaser": null
      },{
        "title": "개강과 창업",
        "excerpt":"2022.03.07  저번주에 드디어 개강을 했다. 진짜 죽기보다 싫었던 복학이지만, 막상 복학하니까 새로운 느낌이 들어서 좀 신선하다. 생각보다도 더 널널하기도 하고, 전공 배우기가 싫어서 싫었던 거였는데 전공과목이 다 프로젝트 위주라 새로운 경험을 할 수 있을 것 같다는 생각을 했다. 지금까지는 소프트웨어적인 사고방식으로만 무엇을 해야겠다, 무엇을 할 수 있겠구나 생각하고 있었는데, 프로젝트를 하면서 직접 회로도 짜보고 하면 하드웨어적으로도 새로운 생각들을 해낼 수 있지 않을까? 프로젝트 하는게 지금 살짝 기대가 된다.   최근에는 창업계획서를 쓰느라 코딩도 잘 못하고 계획서만 생각하면서 보내고있다. 난 사실 창업이라 하면 내가 어떤 서비스를 하겠다! 하고 그걸 열심히 만들어서 해내는 과정이라고 생각했는데, 실제로 해보니까 왜 창업에 경영학적 지식들이 필요한지 절실히 느꼈다. 결국 창업하려면 돈이 필요한데, 이러한 돈을 따내려면 통계를 바탕으로 정말 우리 서비스가 시장에 필요하고, 이에 대한 수요가 있다는걸 증명해내야 투자를 받을 수 있다. 그리고 창업전에 자료조사나 시장에 대한 조사를 별 대수롭지 않게 생각하고 그냥 내가 생각한 아이디어가 딱 들었을 때 매력적이면 만들면 된다고 생각했는데, 대부분의 아이디어가 자료조사, 시장조사 단계에서 누가 이미 하고있다던가, 아니면 굳이 매력이 없는 서비스라는게 밝혀진다던가, 하는 이유로 막히는걸 반복하면서, 진짜 좋은 아이템을 찾는게 어렵구나 싶었다. 사실 창업계획서만 어떻게 잘 내서 지원금 받고 이걸로 스타트업차려서 서로 이사니, 대표니 하는 애들을 얕잡아 보는 마음이 있었는데, 뭐 나름 그 지원금을 받아낸것만 해도 대단하다는 생각도 좀 든다.   또, 투자만 받으면 마치 모든일이 해결될거라고 막연히 생각하던게 있었는데, 생각보다 쉬운 문제가 아니라는 것 도 알게되었다. 만약 내가 지금 기획하고 있는 사업이 잘되서 정부지원금을 받았고, 이를 잘 굴려서 서비스를 진행해서 나름의 성과를 거뒀다고 하자. 만약 내 사업에 투자하겠다는 엔젤투자자나 엑셀러레이터가 나타난다면? 여기서부터는 젊음의 패기로 치부할 수 있는 부분을 넘어서게 된다. 투자자는 기부천사가 아니다. 투자 받은 금액으로 이익을 낼 수 있도록 열심히 일을 해야하고 그때부터는 그만두고 싶어도 그만 둘 수가 없다. 만약 그렇게 해서 성공한다면 엄청난 부를 거머쥐겠지만, 실패한다고 해도 투자자가 폐업을 허락할때까지 계속 의미없는 달리기를 해야함은 물론 그 끝에는 나이는 차고, 회사의 일원으로써 일하기 위한 준비는 안되어 오갈데 없는 모습만이 기다리고 있을 것이다. 너무 과장인가?? 원래는 창업 후 실패 경험도 결국 내 스펙이 되어 도움이 될거라 생각했지만 정말로 그것이 좋은경험으로 보일지 요즘은 의문이든다. 차라리 지원금을 못받아서 시작도 못하는게 낫지않을까 하는 생각도 들고…   어쨌든 취준이면 취준 창업이면 창업 하나를 정해서 에너지를 쏟아야 할 것같은데, 머리가 아픈 요즘이다.  ","categories": ["diary-univ"],
        "tags": [],
        "url": "/diary-univ/%EA%B0%9C%EA%B0%95%EA%B3%BC-%EC%B0%BD%EC%97%85/",
        "teaser": null
      },{
        "title": "효율을 높이는 법",
        "excerpt":"2022.03.11  things 3를 결제했다… 맥용 65000+ ios용 12000 합쳐서 8만원에 가까운 가격을 앱에 지르다니… 사실 다른 선택지가 몇개 있었지만, 광고 뜨는것도 짜증나고 이왕 제대로 쓸거면 돈주고 내가 그 만큼의 가치를 뽕뽑을 만큼 열심히 쓰기로 했다. 사실 투두리스트의 중요성은 예전부터 알고있어서 몇번 todo mate와 같은 앱을 써보곤 했는데 뭔가 귀찮기도 하고 우선 맥에 없으니까 손이 잘 안가서 하루이틀 하다가 말고 했다. 그러다 요즘 옛날에 읽었던 효율적으로 사는 것에 대한 글을 다시 읽게됐는데, 그때도 아 좀더 삶의 효율을 높여야겠다 생각했지만, 이번에는 좀 많이 와닿아서 거기서 추천해주는 things를 바로 결제 하게 됐다…   이 글쓴이는 읽을때마다 너무 감명깊어서, 사파리에 항상 띄워놓고 조금 의지가 약해지거나 계획을 수립할때마다 항상 읽게된다. 글을 읽다보면 이 사람이 얼마나 극한의 효율을 추구하려고 노력하는지가 느껴지는데, 저정도로 살면 돈을 잘 벌 수 밖에 없다는 생각이 들었다. 그래서 요즘 업무자동화나 업무분배에것에 관심이 좀 많아져서 이것더것 시도해보고 있다. things를 하루 기작전에 편집하는것도 그렇고, 여러가지 반복 업무들을 자동화해서 처리하는 방법에 대해 익히고 있다. 결국 시간은 누구에게나 공평하니까, 컴퓨터한테 최대한의 일을 맡겨서 하면 남들보다 몇배나 더 일할 수 있는 사람이 될 수 있다. 당장 이거 일기 쓰는것도 일기 양식을 md파일로 만들어서 안에 쓰는게 너무 귀찮아서 자꾸 일기 쓰는것보다 그거 양식만들 생각에 일기를 자꾸 안쓰고 있었다. 그래서 오늘 생각난김에 파이썬으로 자동화해서 blog diary만 치면 자동으로 양식이 만들어지고, 화면에 뜨도록 했다.블로그를 쓰는것도 나에겐 일중 하나이고 내 자산이니까 블로그부터 자동화해서 블로그 글을 쓰는일이 글을 쓰는일만 할수 있도록 조금 자동화 해볼 생각이다. 배워놓는데 시간이 조금 걸리긴 하지만, 결국 지식이 쌓이기도 하고, 점점 자동화된 일들이 나의 삶의 효율을 계속 높여줄 것이라고 생각한다.   요즘 또 영어에도 관심이 많이 생겼다. 사실 그동안은 영어는 그냥 점수로써만 생각하고 이ㅛ었고, 개발자를 꿈으로 하고 나서는 성적도 그다지 필요없다는 생각에 토스정도먼 졸업수준으로만 맞출 생각이었다. 그런데 생각이 조금 바뀐게, 중요한 정보들은 모두 영어로 되어있다는 사실을 깨닫게 되면서다. 애초의 세상의 모든 정보가 구글에 있는 시대에서, 영어를 잘 사용하지 못한다는건 거의 세상에 있는 지식의 80,90퍼센트는 알아듣지 못하고 배울 수 없다는 것이다. 지식의 습득정도가 결국 내 재산의 크기가 될텐데, 영어를 할 수 없으면 결국 내가 습득할 수 있는 지식에는 한계가 있을 수 밖에 없다. 그래서 요즘 아침에 영어 글도 몇개 읽고, 이동중에도 영어로 된 유튜브를 시청하면서 영어 실력을 늘리려고 노력하고 있다. 원래는 영어공부하는게 죽기보다 싫었는데, 이렇게 생각하고 나니 점수를 습득하는 과정이 아니라 언어를 습득한다는 생각으로 재밌게 하고 있다.   이런 걸 하나씩 할때마다 아 진작 이렇게 좀 할걸… 하는 생각이 들기도 하지만, 그래도 지금부터 꾸준히 하는게 안하는거보다는 나으니까… 이민재 화이팅…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%9A%A8%EC%9C%A8%EC%9D%84%EB%86%92%EC%9D%B4%EB%8A%94%EB%B2%95/",
        "teaser": null
      },{
        "title": "아티클 테스트",
        "excerpt":"2022.03.12    ","categories": ["Java"],
        "tags": [],
        "url": "/java/%EC%95%84%ED%8B%B0%ED%81%B4-%ED%85%8C%EC%8A%A4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "운동",
        "excerpt":"2022.03.12  요즘 운동을 좀 다시 시작해보려고 하는데, 진짜 너무 힘들고 하기가 싫다… 차라리 앉아서 공부하는건 맨날 하겠는데, 운동하는게 너무너무 싫다. 한때는 운동에 재미가 들려서 그게 삶의 낙인적도 있었는데, 뭔가 운동하는 시간이 괜히 아깝고, 저거 하면 또 한시간을 홀랑 날린다는 생각에 하기가 싫다. 사실 지금도 things 정리하다가 운동하기를 보고 너무 하기가 싫어서 일기부터 쓰고있는 중이다…   운동 만큼 정직한게 없다고 하지만, 나는 운동만큼 비효율적인 것도 없다고 생각한다. 물론 여기서 말하는건 몸을 만들기 위한 운동이다. 만들려고 나도 몇번 노력해봤지만, 먹고싶은것도 포기하고 시간도 들어가고 내 체력도 소비하는데 얻는거라고는 벗었을때 나오는 근육…? 옷입으면 왠만한 근육으로는 티도 안나는것 같다. 물론 뭐 옷 뚫고 나올때까지 더 열심히 하면 되겠지만… 그러기 위해서는 너무 너무 과도한 투자비용이 들어간다. 그래도 장점이라면 정직해서 한만큼 좋아지고, 안한만큼 안좋아진다는점?? 생각보다 세상에 내가 한만큼 보상 받을 수 있는게 없는데, 물론 운동도 재능에 따라 다르다고는 하지만 다른 것들에 비하면 노력 대비 보상 비율이 너무나 혜자스럽다. 이정도 노력 대비 보상이 이정도로 혜자스러운 것들 중에는 게임정도가 있을텐데, 이래서 백수들중에 취미로 많이 갖고있는게 게임이나 운동인것 같기도…? 물론 뭐 백수비하하는건 아니고, 그냥 즐거움과 보상을 느끼기 좋은 활동중에 하나가 아닌가 해서 하는 말이다.   성공한 사람들, 몇백억대 부자들이나 어떤 사회적 위치에 오른사람들은 운동을 할까? 내가 그 사람들이 되면 운동에 한시간을 쓰는게 너무 아까울 것 같다. 그 시간에 다른 가치를 창출할 수 있을텐데 말이다. 그래서 그런가 뭔가 부자들이나 똑똑한 사람들은 비리비리 하거나 살이 좀 있는것 같기도 하고…   운동 해야하는데 하기싫어서 그냥 내가 운동 안해도 되는 이유를 어거지로 설명해보려 했는데, 쓰고보니까 너무 억지라서 그냥 운동하러 가야겠다. 건강이 최고니까…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9A%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "커피",
        "excerpt":"2022.03.13  한 2주전에 일리 커피머신이 할인하길래 샀다. 요즘 뭔가 한 2주마다 전자기기를 사는 것 같기도하고?  근데 커피머신도 전자기기로 봐야하나? 암튼 원래는 커피에 대한 별 생각이 없었는데, 자꾸 카페 가서 먹다보니까 점점 커피맛을 알게되서 집에서도 가끔 요앞에 뺵다방에가서 커피를 좀 먹기 시작했다. 근데 나가는게 너무 귀찮기도 해서 먹고싶은 마음이 생겨도 그냥 안먹고 했었는데, 커피머신이 할인 하길래 하루를 종일 고민하다가 결국 질렀다. 근데 해외배송이라 한달가까이 걸린다고 후기가 있어서 별 생각 없이 있었는데 금요일날 택배 송장이 떴다. 근데 조회해보니까 송장만 떴지 배송하려면 또 몇일 걸릴수도?   그래서 원두도 사고, 캡슐로 사 마시자니 비싸기도 하고 (물론 사먹는 것보다는 이미 훨씬 싸다) 여러 원두를 먹어보고 막 해보고 싶은데 그러기 어려워서 찾아보다보니 스테인레스로 된 다회용 캡슐도 구매했다. 근데 원두도 오고 스텐레스 캡슐도 왔는데 정작 커피머신이 안오니까 원두 산것도 먹어보고 싶기도 하고 근질근질해서 어쩌다 보니 핸드드립까지 알아보게 되서, 핸드드리퍼랑 주전자에 그라인더 까지 구매했다. 이럴거면 그냥 캡슐 열심히 먹는게 낫지 않나?   어쨌든 이렇게 강제로? 핸드드립 커피에도 입문하게 됐는데, 뭐 나름 맛도 좋고, 내리는 재미도 있어서 은근히 좋은 취미가 생긴 것 같아서 기분은 좋다. 그냥 맨날 아이스 아메리카노만 먹었었는데, 진짜 핸드드립으로 내려먹으니까 원두따라 맛이 다르고 몇분 물을 어떻게 하고 원두 분쇄도를 어떻게 하냐에 따라 맛이 다르다. 그래서 맛이 균일하지 않고 편차가 큰데 이것도 나름 매력이랄까? 물론 커피머신 오고서는 귀찮아서 캡슐만 먹을지도… 그리고 핸드드립은 뭔가 압력으로 추출한게 아니라서 괜히 좀 덜 진한것 같고 그렇다. 그것도 핸드드립의 매력이라면 매력이겠지만.   어쨌든 요즘 집돌이 생활에다가 닌텐도고 오큘러스고 다 사봤는데 취미로 하기가 좀 시간도 없고 내가 사실 콘솔게임을 앉아서 진득하니 하는것도 못 즐기는 것 같아서 취미랄게 없었는데 좋은 취미가 생긴 것 같아서 좋다. 이렇게 뭔가 새로운 분야를 파고 재미를 들일 때마다 인생의 해상도가 늘어나는 것 같아서 좋다. 원래는 커피에 대해 아무 생각도 없이 먹었는데 이제 카페에 가면 여기는 원두를 뭘쓰고, 어떻게 추출하고 하는지 본달까? 카페에 갔는데 원두를 팔고 있으면 괜히 눈이 가곤 한다. 취향이 생긴다는건 그 제품들에 대한 정보를 알고 내가 구분할 수 있다는 뜻이니까, 취향을 늘려가는게 인생을 재밌게 살게 해주는 원동력이 되어주는 것 같다.   그래서 내 일리 커피머신은 언제오냐고…   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%BB%A4%ED%94%BC/",
        "teaser": null
      },{
        "title": "영어...",
        "excerpt":"2022.03.14  요즘 부쩍 영어에 관심이 많아져서 열심히 해보려고 하는데, 진짜 벽느껴진다… 그냥 고등학교때만 열심히 했어도 이렇게까지 고생 안 했을텐데… 새롭게 뭐 해보려고 하지만 옛날의 업보가 결국 불쑥 불쑥 나타나 앞을 막기 시작한다. 근데 뭐 다른 사람들은 열심히 공부한건데 내가 그걸 하루이틀만에 따라잡는건 무리겠지. 그냥 앞으로 이렇게 후회 안하도록 지금부터 열심히 하면된다.   원래는 토익같은거 점수보다는 스피킹이랑 리딩정도만 됐으면 좋겠어서 뉴욕타임즈 열심히 읽고 유튜브 영어로 된거 열심히 보려 했는데, 너무 이상적인 생각이었다. 뭔가를 도전하고 싶다면 결국 내가 하기 싫은 부분의 한계를 넘어가며 반복해야 이뤄지는것 같다. 그래서 그냥 토익 리딩책을 풀기로 했다. 가만히 비의식적인 듣기와 읽기보다는, 꼼꼼하게 하나하나 찾아가며 번역하고 단어 외우는게 결국에는 영어 실력을 늘리는 방법인것 같다. 토익 800점은 되어야 스피킹과 라이팅 입문 할 수 있다는 영상을 하나 보고, 정신을 차렸다. 결국 리딩을 많이해서 텍스트를 많이 접한 사람이 영어를 더 잘한다는 말이 새삼 와닿았다. 국어도 결국 대한민국 사람들 모두가 읽고 쓰고 말할 수 있지만, 더 높은 수준의 글을 쓰고 높은 수준의 어휘를 구사하는건 텍스트를 많이 접하고, 글을 쓰는 사람들이니까, 영어도 동일하다.   요즘 드는 생각이 매일의 귀찮음과 하기싫음을 조금씩 조금씩 이겨내고 모아야 큰 성취가 이뤄진다는 것이다. 지금은 너무 답답하지만 평생 하루에 한시간씩만 꾸준히 하자…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%98%81%EC%96%B4/",
        "teaser": null
      },{
        "title": "일리 커피머신",
        "excerpt":"2022.03.15     어제 드디어 커피머신이 도착했다.   일단 개이쁘고 그냥 플라스틱 따리일줄 알았는데 좀 질 좋은 고급진 플라스틱에 마감이 너무 깔끔해서 너무 만족스럽다.         핸드드립 해먹다가 이거 해먹으니까 진짜 세상에서 제일 편하다. 핸드드립 내려먹는 사람들은 도대체 저 귀찮은 걸 어떻게 하는겨;;  난 솔직히 핸드드립이랑 머신이고 뭐고 구분잘 못하겠다. 똑같이 내려서 둘다 먹어보면 구분이 갈지도?   어쨌든 기능에도 딱 충실하고 처음에 웰컴 팩으로 오는거 커피 내려먹었는데 진짜 농담아니고 카페보다 맛있다. 근데 오늘 아이스 아메리카노 만든거는 물을 너무 많이 넣은듯하다 좀 밍밍함… 근데 아이스로 먹는 순간 모든 커피가 다 똑같애지는것 같기도하고, 이탈리아에서 커피 아이스로 먹으면 미친놈 소리 듣는 다는데, 커피 향이 다 그냥 비슷비슷해져버리는게 아닐까? 아이스로 먹으면 산미가 쎄냐 안쎄냐 이정도 차이정도만 나는 것 같다. 산미 센거 원두도 한번 먹어봐야지.   일리 커피머신 혹시 고민하는 사람들은 무조건 사세요 솔직히 해외배송으로 사면 8만원인데 이거 커피 20번 정도먹을 돈이면 뽕뽑고도 남음   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%BC%EB%A6%AC-%EC%BB%A4%ED%94%BC%EB%A8%B8%EC%8B%A0/",
        "teaser": null
      },{
        "title": "가능성에 대하여",
        "excerpt":"2022.03.19  요즘 인생의 방향성에 대해 생각이 좀 많다. 원래는 이번년도에 창업을 해보면서 대략 어떤 느낌인지 맛을 보자는 느낌이었는데, 계획서를 써보고 공부해볼 수록 그렇게 1년만 해볼 수 있는 문제가 아니란걸 깨닫는다. 그런식으로 1년만 하려는 마음가짐으로 뭔가를 이뤄내기엔 창업은 그리 만만하지가 않다.   원래는 창업이 노리스크라고 생각했었다. 어차피 창업 경험을 기업에서 더 알아줄거라는 막연한 기대감도 있었고, 창업하면서 얻는 지식들이 내 인생에서 결국엔 도움이 되지 않을까? 하는 생각… 내가 지불할 기회비용이라고는 취업이 늦어져서 잃게 되는 수입정도? 그런데 막상 해보니까 우선 내가 스타트업의 대표가 되면, 생각보다 개발자로써의 실력을 키울 기회가 크지 않다.   대표가 되면 내가 개발할 시간도 압도적으로 줄을 뿐아니라, 극도로 초기의 스타트업에서 개발을 하는 것은 생각보다 커리어를 쌓는데 큰 도움이 되지 않는다. 물론 유능한 CTO를 뽑아서 배워가며 할 수도 있겠지만, 실력이 좋은 사람이 내가 만든 극초기의 스타트업에 합류할 가능성은 아주 적다. 결국 대표가 할일은 열심히 투자를 받아오는 것인데, 이러한 능력은 부족하다고 생각하지 않지만 이렇게 잘안되는 스타트업에서 몇년 시간을 보내다 보면 내 커리어로 인정받을 만한 것들이 몹시 줄어든다. 게다가 초기에 남들이 다 취업하고 돈벌때 나만 스타트업에서 하루에 열시간 넘게 일해가면서 적은돈을 받으며 외로운 시간을 내가 견딜 수 있을까?   그래서 대략 3가지의 선택지가 있는것 같은데      창업을 포트폴리오의 목적으로 지원금 받아서 프로젝트 한번 해보고, 열심히 취준   다 걸고 창업…   열심히 취준 후 창업은 뒤로 미룬다.   선물 시장에서는 옵션이라는 개념이 있다. 옵션은 내가 특정 상품을 살 수 있는 권리 또는 팔 수 있는 권리를 파는 것으로, 만약 지금 1000원인 상품을 1년후에 1100원에 살 수 있는 권리를 샀다면, 콜옵션을 샀다고 할 수 있다.   이 콜옵션의 가격은 얼마일까? 대략 어림잡아 한 100원정도 할 것이다. 만약 1년후에 이 상품의 가격이 1400원이라면, 나는 1100원에 해당 상품을 매수해서 다시 되파는 식으로 300원의 이득을 볼 수 있을 것이고, 가격이 1100원 밑으로 떨어진다면 이 권리를 포기하고 콜옵션을 구매할 때 사용한 100원을 잃으면 된다.   그런데 만약 6개월이 지나고 이 상품의 가격이 여전히 1000원이라면? 이 6개월남은 콜옵션의 가격은 여전히 100원일까? 아마 100원 보다 낮은, 대략 60원정도의 가격일 것이다.    남은기간이 줄어들었으니 이에 따라 이 상품의 가격이 1100원 이상으로 오를 확률도 줄어들었기 때문이다.   또, 만약 같은 가격 1000원의 두가지 상품이 있다고 할때, 첫번째 상품은 히루에 평균 10원씩 왔다갔다하고, 두번째 상품은 하루에 평균 50원씩 왔다갔다 하는 변동성을 갖는다면 1년 후 1200원에 행사 가능한 두가지 상품의 콜옵션은 어느 상품이 더 비쌀까? 당연히 2번째 상품일 것이다.   두번째 상품의 변동성이 1200원에 도달할 확률이 첫번째 상품보다 월등히 높기 때문에, 사람들은 두번째 상품의 콜옵션을 더 높게 사려고 할 것이다. 첫번째 상품이 대략 170원정도라면, 두번째 상품은 대략 한 220원 정도는 줘야 할 것이다. 따라서 결국 옵션은 상품의 변동성을 사고 파는 것이다.   갑자기 뜬금 없이 옵션 이야기를 왜 했냐면, 우리 인생도 비슷하다고 생각하기 때문이다. 나라는 상품을 시장에 판다면, 내 콜옵션의 적정가치는 얼마일까? 우선 내 나이가 어릴수록 동일한 실력대비 더 좋은 가격을 받을 것이다. 남은 시간이 많을수록, 나라는 상품의 가격이 오를 가능성이 높으니까 내가 더 높은 가치를 갖게 팔릴 것이다. 실제로 회사에서는 같은 실력이라면, 더 어린사람을 뽑을 것이다.   두번째로는 마찬가지로 내 자신의 변동성이 높다면 더 높은 가격을 받을 것이다. 내가 더 높은 가격에 도달할 확률이 더 높아보이는 사람이 된다면, 더 높은 가격을 인정 받을 수 있을것이다. 그래서 회사에서는 실력이 더 좋은 사람을 뽑는다.   결론적으로 회사는 사람들의 콜옵션을 사는것이다. 연봉이라는 콜옵션 가격을 제시하고, 사람들은 그걸 판다. 그래서 만약 그 사람이 회사에서 완전 대박을 터뜨려도, 연봉인상이나 승진등의 이득을 누릴 수는 있지만 그 이상의 부를 거머쥐거나 한다는 일은 없다. 이미 자신이 가진 변동성의 가치를 회사에 팔아버린거니까.   당연히 반대로 자신의 가격이 떨어지는경우, 실수를 했다거나 성장이 뒤쳐진다거나 하는 경우에도 자신이 리스크를 감내하지 않는다. 물론 정말 큰 실수를 했다거나 일을 현저히 못하는 경우 잘릴 수 있겠지만, 크게 성장하거나 열심히 하지않아도 그냥저냥 회사를 다닐 수는 있을 것이다. 변동성이 낮거나 대략 회사가 원하는 가격 적정선에 있는 사람들은 오히려 회사에 취업하는게 더 큰 이익을 보는 일일 수도 있다.   물론 변동성이란 개념은 위, 아래 동일하게 열려있기 때문에 변동성이 클수록 위로 오를 가능성 만큼 동일하게 아래로 떨어질 가능성도 함께 커진다. 그래도 다행인건 내가 생각하기에 인간의 변동성이라는 가치는 금융에서의 자산과 다르게 열심히 노력한다면 그래도 리스크의 크기가 위와 아래 둘이 동일하지는 않은 것 같다. 아래 쪽 리스크가 그래도 확실히 적다.   결국 내 변동성이 얼마인지를 파악하는게 중요한것 같다. 내가 그저 그런사람인 것 같다면 난 얼른 회사에 한살이라도 젊을 때 내 콜옵션을 회사에 파는 것이 나을 것이고, 내가 변동성이 큰 사람이라면 내가 갖고있는게 나을 것이다. 인생은 다행히 변동성의 윗부분이 아래보다는 크다고 믿으니까…   올 한해동안 내가 가진 가치를 키우고, 그 가격은 얼만지에 대해 열심히 생각해봐야 겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B0%80%EB%8A%A5%EC%84%B1%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/",
        "teaser": null
      },{
        "title": "[Docker] 도커란 무엇일까?",
        "excerpt":"서론  저는 현재 공부도 할겸 저번 학기에 단장으로 활동했던 봉사동아리의 웹사이트를 AWS에 올려서 만들어보고 있는데요, 그 와중에 도커의 존재에 대해서 알게되었습니다.  사실 지금 프로젝트 단계에서는 굳이 도커 없이도 배포 하는데 아무 문제가 없지만, 항상 새로운 기술을 알게 되고 그게 편리한 것이라면 굳이 나중에 공부하기보다는 바로바로 공부해보며 적용해가는 성격이기에 바로 적용해보려 합니다. 개념이 조금 이해하기 어려워서 애를 먹긴 했지만 막상 이해하고 나니 이게 왜 어려웠을까 싶기도 하는 마음에 제가 이해한 내용을 공유해보려합니다.   Docker란?     도커(Docker)는 리눅스 응용프로그램들을 프로세스 격리 기술들을 사용해서 컨테이너로 실행하고 관리하는 오픈소스입니다.   도커 웹페이지는 다음과 같은 내용이 나와있는데요.      도커 컨테이너는 일종의 소프트웨어를 소프트웨어의 실행에 필요한 모든 것을 포함하는 완전한 파일 시스템 안에 감싼다. 여기에는 코드, 런타임, 시스템 도구, 시스템 라이브러리 등 서버에 설치되는 무엇이든 아우른다. 이는 실행 중인 환경에 관계 없이 언제나 동일하게 실행될 것을 보증한다.    맨 처음 이 내용을 읽은 사람들은 이게 무슨의미인지 이해가 잘 안될 것입니다. 저도 마찬가지로 그랬구요… 하지만 이해하고 나면 크게 어려운 개념은 아니니 함께 알아보도록 합시다.   만약 우리가 집에서 목공일을 한다고 가정해 봅시다.   목공을 하는데는 여러가지 장비들이 필요할 겁니다. 예를들어서 망치, 못, 그라인더등이 필요할거에요. 실제로는 몇십가지의 도구가 필요하겠지만, 여기서는 간단하게 3가지의 도구가 필요하다고 가정해보겠습니다.     그럼 위와같이 작업실에는 3가지의 도구가 위치하게 됩니다. 우리는 지금 망치, 못, 그라인더가 있고 모두 통일해서 A사의 제품을 쓰고있다고 가정하고, 망치-못-그라인더 순으로 항상 놔둔다고 생각해볼게요.   우리는 이미 이 구조에 너무나도 익숙해져서,      모든 제품이 A사의 제품일 것   순서는 망치-못-그라인더 순으로 놓여져 있을 것   위 두가지 조건을 충족시켜야만 최고의 효율로 일을 할 수 있다고 해봅시다. 심지어는 만약 A사의 그라인더가 아니라면, 사용법을 몰라 며칠을 목공 작업을 진행하지 못할 수도 있습니다.   이렇게 익숙해진 상태에서 이제 만약 새로운 작업실을 하나 더 만드려면 어떻게 해야할까요? **이 구조를 동일하게 다음 작업실에도 구성해주어야 원활하게 이전 방식대로 일을 진행 할 수 있을겁니다.   **   하지만, 만약 미리 작업실로 주문을 해놓았는데 주문 실수로 B사의 그라인더가 배송된다거나, 동일한 작업 환경을 재현하지 못해서 망치-못-그라인더 순으로 배치하지 못하고 못-그라인더-망치의 순으로 배치되었다면요??   물론 세가지 물건의 브랜드와 순서를 기억하여 배치하는건 어려운일이 아니지만, 100가지 장비가 있다고 하면 이걸 일일히 기억해서 모든 브랜드를 원래 익숙하던 브랜드로 맞추고, 모든 장비의 배치를 기억해서 동일하게 재현하는 것은 너무나 어려운 일일 것입니다.   하지만 만약 이를 사진으로 찍어서 보내기만 하면 동일한 물건을 모두 대신 구매해주고 배치도 똑같이 해주는 서비스가 존재한다고 가정해봅시다. 그러면 우리는 직접 물건의 브랜드를 알아봐서 일일히 주문하고 배치를 애써 기억하려 하지않아도, 이전 작업실을 카메라로 찍어서 업체에 보내기만 하면 새로운 작업실에서도 이전 작업실과 동일하게 최고의 효율로 일할 수 있게될 것입니다.        그림은 제가 그린거라 조금 조잡합니다…    이것이 바로 ‘도커(Docker)’가 하는 일입니다.   도커는 우리의 작업환경을 카메라로 찍어 도커허브에 업로드하면, 우리는 새로운 컴퓨터나 서버에서 도커허브에서 업로드한 이미지를 내려 받는것 만으로 한치의 오차도 없는 동일한 작업환경을 구성 할 수가 있습니다. 이렇게 찍은 사진을 도커에서는 이미지라고 합니다.   뿐만 아니라, 하나의 작업환경에서 두가지의 아예 다른 작업을 할 수 있게도 해주는데요, 다음과 같이 이해해 봅시다.   우리는 이제 새로 작업실도 차렸으니, 새로운 목수를 채용하려고 합니다. 새로운 목수의 장비는 다음과 같다고 해보겠습니다.      이 목수는 B사의 브랜드들을 애용하고, 도구의 배치도 그라인더-망치-못 순으로 사용합니다. 이 목수가 우리가 새로 꾸린 작업실에 이주해 온다고 가정해볼게요.     그럼 이렇게 복잡한 환경이 완성 될 것입니다. 아무래도 혼자서 일하려다가 이렇게 일하려니까 자꾸 손도 부딪히고, 도구들도 헷갈려서 A브랜드 그라인더인줄 알았는데 B인 그라인더여서 잘못 물건이 만들어지는 경우도 있겠죠??   그래서 이를 방지하기 위해서 또 다시 그 업체에게 의뢰를 합니다. 이 업체는 사진만 있다면 그대로 작업도구들을 구매해서 배치해주는 것 뿐만아니라, 이미지를 두개 따로 보내면 칸막이까지 쳐서 독립된 두개의 공간을 만들어주는 서비스까지 제공하기 때문이죠.   그렇다면 의뢰 후 저희가 입주할 작업실은 어떤 모양일까요?     아마도 이런 모습일 것입니다.   이렇게 하면 서로 동선도 부딪히지 않고 장비도 섞이지 않을 뿐더러, 만약에 다른집으로 한명만 이사를 간다거나, 아님 동일한 작업환경에 한명이 더 온다고 해도, 우리는 이미 각각의 작업실을 사진으로 갖고있기 때문에, 회사에 사진만 보내면 우리가 원하는 작업 환경을 무궁무진하고 정확하게 구현할 수 있을 것입니다. 심지어는 장비 하나씩을 각각 사진을 찍어서 A와 B브랜드를 섞어서 사용하는 작업자가 와도 이를 구성 해줄 수도 있겠죠.   따라서 도커는 위에서 언급한 동일한 작업환경 구성 뿐만 아니라, 작업환경을 나눌수도 있도록 해줍니다. 이것을 도커에서는 컨테이너라고 합니다.   그림이 조잡하긴 했지만, 어떻게 이해가 좀 되셨나요? 그럼 본격적으로 도커에 대해 알아 보겠습니다.   도커의 특징  혹시 m1 맥북에서 ‘페러렐즈’라는 앱을 이용해서 윈도우를 실행해보셨나요? 옛날 인텔 맥북의 경우, 부트캠프를 사용해서 파티션을 두개로 나누어 다른 파티션에는 윈도우를 깔 수 있었지만, m1맥북이 나오면서 arm 아키텍처 기반의 m1은 윈도우를 설치 할 수 없게 되었습니다. 아무래도 증권 프로그램이나 게임의 경우는 윈도우를 사용하는 것이 압도적으로 편리하니까요. 그래서 m1에서도 비슷한 기능으로, 부트캠프를 사용한 인텔맥을 사용하는 만큼의 성능을 내지 못하지만, 패러렐즈를 사용해서 윈도우를 돌릴 수 있습니다. 맥 os안에서 가상 머신을 구성하여, 또 하나의 컴퓨터를 맥 Os위에서 구동하여 윈도우를 사용하게 하는 것이지요.   위의 페러렐즈의 기능, 익숙하지 않으신가요? 바로 도커가 하는 두번째 기능과 같은 일을 하는 것을 알 수 있습니다. 작업 환경을 두개로 나누게 되어, 가상머신(윈도우)라는 작업 환경과 맥북(맥 OS)의 두가지 작업환경이 공존하는 환경이 만들어진 것입니다. 이렇게 하면 밖에서는 이것을 각각의 컴퓨터로 인식하게 됩니다.   그럼 이렇게 사용했을때는 어떠한 단점이 있을까요? 아무래도 맥 OS자체가 컴퓨터를 하나 돌리면서 그 안에서 또 다른 작업을 진행하려고 하니, 맥북의 성능을 윈도우가 어마어마하게 잡아먹게 될 것입니다. 윈도우도 사용할 수 있는 자원이 한정 되어 있으므로 아무래도 제 성능을 못내게 되어, 두 컴퓨터 모두 이도저도 아닌 상태가 될 것입니다.   하지만, 윈도우라는 OS 전체를 설치하는게 아니라, 윈도우 프로그램 하나가 돌아갈 만큼의 구성만큼만을 돌린다면, 훨씬 쾌적하게 사용할 수 있겠죠? 예를 들어 윈도우가 켜지고 실행된 윈도우에서 증권 프로그램을 켜는게 아니라 증권 프로그램이 돌아갈만큼의 구성만 사용해서 증권 프로그램만을 돌리게 된다면, 맥북도 메모리를 덜 윈도우에게 주고, 윈도우도 한정된 자원이지만 프로그램 하나만 돌리게 되는 셈이니, 한정된 자원마저도 차고 넘치게 될 것입니다.   이처럼 도커는 별도의 운영체제(Guest OS)없이  도커엔진(DockerEngine) 위에서 동작하기 때문에, 메모리 용량도 적게 차지하고, 성능적으로 매우 개선되도록 도와줍니다. 우리가 원하는 작업 환경을 내려받아 컨테이너로 구성하여 작동하게 되면, 내 컴퓨터 안에서는 새로운 컴퓨터가 돌아가게 되는 셈인거죠. 그것도 우리가 원하는 작업환경과 100% 일치하는 상태로요.        왼쪽의 기존 가상 머신으로 돌리는 운영체제는 GuestOS라는 짐도들고 있지만, 도커를 사용한 오른쪽에서는 GuestOS 없이 환경과 프로그램이라는 짐만 들고 있는것을 볼 수 있습니다.    그럼 자꾸 이미지니 컨테이너니 어떤의미인지 알아야 도커에 대해서 완벽하게 알 수 있겠죠? 아마 이미지나 컨테이너가 정확히 뭘 가르키는 지는 몰라도, 위의 내용을 통해 기능을 이해했다면 아래 실습을 보기만 해도 도커가 무엇인지 이해할 수 있을겁니다.   그럼 이제 실제로 도커를 어떻게 사용하는지 알아보고, 저는 도커를 어떻게, 왜 사용했는지를 보며  도커에 대해 알아봅시다.   도커 사용법  저는 맥을 사용하고 있기에, 맥 환경에서 설명하도록 하겠습니다. 물론 윈도우에서도 크게 다르지 않아서, 사용하는 명령어나 방식은 동일합니다.      도커 다운로드 주소    위 주소로 가서 각자 OS에 맞는 도커 데스크탑 앱을 다운받아줍니다.  저의 경우는 m1 맥북을 사용하고 있으니, Apple Chip버젼을 다운 받아주면 되겠네요.      물론 Brew로 도커를 받는 방법도 있지만, 아무래도 UI가 있는 도커 데스크탑이 터미널 환경보다 편리하니까 여기서는 도커 데스크탑 기준으로 설명하도록 하겠습니다.   다운 받은 도커 데스크탑을 열면, 다음과 같은 화면이 뜨게 됩니다.     저는 현재 컨테이너를 하나 만들어서 구성해본 상태라 컨테이너가 하나 있지만, 처음 설치했다면 아무것도 없는 상태 일 것입니다.   자 그럼 컨테이너는 나중에 이야기하도록 하고 아까 설명에서 다뤘던,  이미지에 대해 설명해 볼게요. 이미지 탭으로 이동해봅시다.     마찬가지로 새로 도커를 다운받았다면, 아무 이미지가 없는 상태일거겠죠? 저는 이미 제 작업환경을 사진을 찍어서 이미지로 보관해놨기 때문에 이미지가 있는 상태입니다.     여기서 만약, 다음과 같이 해당 이미지에 있는 Run 버튼을 누르게 되면, 이미지를 보고 도커가 그대로 뚝딱 뚝딱 동일한 작업 환경을 만들어 이를 실행하는 컨테이너를 만들어 실행 시키게 되는 것이죠.   그러면 여러분의 컴퓨터 안에는 해당 작업환경으로 구성된 작업 환경만을 구동시킬 정도로 아주 간소화된 또 하나의 컴퓨터가 돌아가게 되는 것입니다.   도커 데스크탑에서는 컨테이너와 이미지를 관리하는 기능, 실행, 중지, 삭제 정도를 지원하고, 결국 터미널에서 어느정도 설정 해주어야 하는 부분이 있기 때문에 나머지는 터미널에서 진행 해보도록 할게요.   먼저 이미지를 다운받기 위해선 DockerHub에 가서 원하는 이미지를 찾아봐야 합니다. 여기에는 해당 환경의 개발사에서 배포한 공식 이미지를 내려받을 수 있고, 또 클라우드 기능을 지원하여 자신의 환경을 그대로 이미지로 저장해놓고 이를 내려 받을 수도 있습니다. 심지어는 다른사람이 올린 환경도 그대로 내려 받을 수 있죠.   그러면 한번 실제로 이미지를 내려받아보고 환경을 구성해볼까요?   도커 실습 1 - 파이썬 이미지 내려 받아보기  먼저, 공식이미지를 내려받아서 환경을 구성해보겠습니다. 여기서는 간단하게 파이썬 이미지를 내려받아서 파이썬 하나만 설치된  컨테이너를 구성함으로써 대략 이미지와 컨테이너가 어떻게 동작하는지 알아봅시다.   DockerHub에 파이썬을 검색해 줍니다.     그러면 Official Image, 파이썬에서 만든 공식이미지가 나오는 것을 볼 수 있습니다.   이를 들어가보면 다음과 같은 화면이 나오는것을 볼 수 있죠.     오른쪽에 보시면 다음과 같은 명령어가 있습니다.  1 docker pull python  이를 터미널에 입력해주면, 우리는 docker에 해당 이미지를 내려받게 되는것이죠.            pull이라는 명령어로 도커는 이미지를 내려받는다는 걸 알 수 있습니다.   그럼 터미널에 해당 명령을 입력해주어 봅시다.        혹시 docker 명령어가 작동하지 않는다면, 환경변수 설정이 제대로 안된 것 이기 때문에 환경변수 설정에 대해 검색해보시고 docker를 환경변수 설정에 추가해주세요.    명령어를 입력하고 잠시 기다리면, Python 이미지가 내려 받아졌습니다. 만약 버젼을 설정하고 싶다면,  1 docker pull python 3.11-rc-bullseye  이런식으로 해당 버젼을 입력해주면 됩니다. 공백으로 두면 도커가 알아서 최신버젼을 다운 받습니다.   그럼 이제 다시 도커 데스크탑으로 가면 Python의 이미지가 다운되어 있는 것을 확인 할 수 있습니다.     간단하게 이 이미지를 실행시켜볼까요? 터미널로 실행시키고 싶다면  1 docker run python  을 사용해주면 됩니다. 하지만 여기서는 데스크탑으로 실행시켜 볼게요.   그냥 파이썬 이미지를 Run 해주기만 하면 됩니다.     그럼 아래와 같이 세부 설정을 해줄 수 있습니다.      지금은 파이썬이 깔린 환경이 구동되는지만 확인할거니까, 간단하게 이름만 설정해주도록 할게요. 만약 이름도 설정 안하고 공백으로 컨테이너를 만들면, 랜덤으로 알아서 이름을 생성해주긴합니다. 그러나 관리를 편하게 하려면 이름을 지정하는게 편하겠죠??   간단하게 Python이라고 이름 붙인 후 컨테이너를 Run 해봅시다.   그러면 아래와 같이 컨테이너가 작동하는 것을 볼 수 있습니다.     우리는 지금 파이썬만 설치되어 돌아가는 아주 간소화 된 컴퓨터를 현재 사용하는 컴퓨터 안에 하나 작동하도록 만들게 된것입니다.   그것도 파이썬을 인터넷에서 찾아서 설치한게 아닌, 전문가가 설치한 파이썬과 동일한 환경으로요!     컨테이너를 클릭해서 들어가보면 위와 같은 화면을 볼 수 있습니다. linux라고 써있죠? 이를 통해 도커는 리눅스 환경에서 실행되고 있다는걸 알 수 있습니다. 도커가 어떤 방식으로 작동하는지에 대해서는 자세히 설명하지는 않도록 할게요.   그럼 여기서 우측 상단에 있는 &gt;_ 모양 버튼을 눌러볼까요? 마우스를 올려보면, CLI라고 적혀있는 걸 볼 수 있습니다.   CLI는 Command Line Interface의 준말로, 말그대로 명령인터페이스 입니다. 이 안에 컴퓨터에서 무슨 작업을 하려면 이 컴퓨터에 접속해야겠죠? 만약 윈도우가 깔려있다면 GUI를 지원해주기 때문에 마우스로 아이콘을 클릭한다던가 파일을 옮기 던가 할 수 있겠지만, 이 컴퓨터는 최소한의 구동환경만 갖추었기 때문에 컴퓨터에게 명령을 커맨드 라인을 통해서 해주어야 하는 것입니다.      다음과 같이 터미널이 하나 열리고 해당 컴퓨터와 연결되었습니다! 이제 여기서부터 내리는 명령은 현재 컴퓨터가 아닌, 도커위에서 돌아가는 작은 컴퓨터에게 보내는 명령입니다.   간단한 파이썬 명령어를 한번 입력해볼까요?   1 pip install numpy  그냥 바로 생각나는 파이썬의 대표기능인 pip로 numpy 라이브러리를 다운받아 보겠습니다.  numpy는 파이썬의 라이브러리로, 기본 계산이 아닌 고성능 수치 계산을 위한 라이브러리 입니다. 지금은 그냥 도커가 올바르게 파이썬을 동작하는지 알아보는 것 이기 때문에 numpy가 뭔지에 대해서는 모르셔도 됩니다.      python 명령어인 pip가 올바르게 동작하여 numpy를 설치완료하였습니다!   만약 python만 사용하는 컴퓨터가 한대가 더 필요하다면, 아까 내려받은 이미지로 컨테이너를 하나 더 만들어 아예 새로운 작업환경을 하나 더 만들 수 도 있고, 만약 아예 다른 환경이 필요하다면 또 **다른 이미지를 내려받아서 다른 환경을 또 만들어 줄 수 있을 것입니다. **   이렇게 하면, 컴퓨터 하나에서 서버를 두개 돌릴 수도 있겠죠? 물론 따로 포트포워딩이 필요하긴 하지만, 하나의 컴퓨터에서 두가지 서버가 돌아가게도 할 수 있습니다. **마찬가지로 AWS같은 클라우드 서비스에서도 **만약 서버 공간이 남는다면 도커로 분리하여 하나의 인스턴스로도 두개의 서버를 운용하는 것이 가능할 것입니다.   이것이 바로 도커를 선호하는 이유입니다. 하나의 인스턴스 비용으로 두개의 서버를 돌릴 수 있을 뿐만 아니라, 이 두 환경이 전혀 간섭되지 않도록 있으며, 심지어는 내 컴퓨터와 서버 컴퓨터의 환경을 완벽히 동일하게 설정해줌으로써, 환경이 달라서 발생하는 오류들을 방지 할 수 있으니까요.   그럼 대략적인 도커 사용법에 대해서 알아봤으니, 다음 게시물에서는 도커를 실제로는 어떻게 사용하는지 알아보기 위해서, 제가 만들고 있는 웹사이트 서버를 도커를 사용해서 이미지로 만들고 해당 이미지를 AWS에서 내려받아 제 컴퓨터 환경과 동일하게 작동하게 해보도록 하겠습니다.      다음게시물 : [Docker] 도커로 스프링부트 서버 AWS에 올리기    ","categories": ["ETC"],
        "tags": [],
        "url": "/etc/Docker-%EB%8F%84%EC%BB%A4%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/",
        "teaser": null
      },{
        "title": "아두이노 라즈베리파이",
        "excerpt":"2022.03.21  올해 듣는 수업이 대부분 프로젝트 수업이라서 사실 수업보다는 그냥 실험하고, 프로젝트 하나 완료하는것들이 전공수업의 전부가 되었다.   전공 공부가 너무 하기싫어서 복학하기가 진짜 너무너무 싫었는데, 막상 복학하니까 이론은 3학년때가 끝이고 4학년때는 실무위주라서 조금 다행인것 같다.        심지어 막상 프로젝트를 할라고 하면 회로 짜는것 보다는 코딩하는게 주가 되는 것 같아서 내가 좀 힘을 쓸 수 있는 부분이 대부분이라서 오히려 좋다고 할까??   이번에 듣는 전자응용설계에서는 실제로 전자제품을 하나 설계해보고 직접 만들어내는 프로젝트가 수업의 전부인데, 아두이노나 라즈베리 파이를 사용해서 만든다.      얘네 둘은 이름만 들어보고 대략 어떤건지만 알았지 이거에 대한 지식이 아예 없는 수준이라 프로젝트를 진행함에 앞서 내가 어떤 수준까지 제작이 가능한지 알아보기 위해 요 몇일 요 두개를 열심히 알아봤는데, 생각보다 너무 재밌어보이는 분야라서 나중에 지원금이 나옴에도 불구하고 그냥 사비로 두개를 모두 구매했다.   전자공학이라는 내 전공이 맘에 안들었던 이유는 너무 이론적으로만 다루기도 하고, 반도체 공정이 주 수업 내용이라 내가 원래 생각했던 전자제품을 제작하는 학과의 이미지가 아니라서 실망했던건데, 4학년이 되서야 뭘 만들게 되어서 좀 재밌는 4학년이 될것 같다는 생각이 들었다. 그런데 나는 그냥 다른 분야로 가기 위해서 따로 공부를 했다지만, 다른 학생들은 전자공학 3년간의 지식으로 전자제품을 제작을 할 수가 있나? 싶은 생각이 들기는 한다. 만약 내가 3년간 배운 지식만을 사용한다고 제한하고 프로젝트를 한다고 생각하면, 아두이노로 간단한 센서 측정 기계정도 만들 수 있을 것 같다.   어쨌든 아직 라즈베리파이는 아직 도착하지 않아서 못 만져봤고, 아두이노는 어제 당근마켓에 있길래 15000원에 가성비 좋은 키트를 구매했다. 근데 지금 반도체 수급이 정말 극악인 상태라 라즈베리파이 가격이 돌아버려서 사는데 좀 애를 먹었다. 신품은 구할 수도 없을 뿐더러 원래 5만원 하던 제품이 지금은 15만원 이상을 줘야 살 수 있으며, 이조차도 중고 매물도 잘 없다. 그래서 도저히 5만원 하는 제품을 10만원 넘게 구매하는건 못하겠어서, 알아보던중 라즈베리파이 400 제품을 구매하는게 더 가성비가 좋을 것같아서 라즈베리파이 400을 65000원에 구매했다. 근데 이것도 웃긴게 원래 라즈베리파이 400은 라즈베리파이 4와 키보드가 합본되어있고 안에 방열설계도 훨씬 월등하게 좋은 제품이라 원래 10만원 가까이 하는 제품인데 라즈베리파이4 가격 폭등으로 인해서 라즈베리파이 4가 라즈베리파이 400보다 비싼 가격이 되었다;   물론 라즈베리 파이 400의 단점이라면 키보드 합본이라서 범용성이 조금 떨어진다는 점이 있긴하다. 센서를 직접 보드에 달지 못하고 usb형태로 꽂아줘야 한다. 근데 지금 생각해놓은건 라즈베리파이에 아두이노를 연결해서 복잡한 연결이랑 api통신은 라즈베리파이에서 하고 센서처리는 아두이노에서 할 예정이라서 크게 상관 없을 듯하다. 아두이노를 어제 구매해서 살짝 뚝딱거려봤는데, 아무래도 아두이노 요거 하나 갖고는 대학생 수준의 전자제품을 설계하는 것에는 성능에 큰 무리가 있지않을까… 싶다. 아직 프로젝트 주제는 정해지지 않았지만, 지금 내가 할 수 있는 최대의 기능을 생각해보면 웹서버를 하나 만들거나 블루투스 모듈을 제품에 연결해서 플러터로 만든 앱이랑 제품이 통신하게 하고, 아두이노의 센서값으로 뭘 처리해서 동작하게 해서 이걸 앱에서 표시하고 조작할 수 있게 하는 정도일 것 같다. 이렇게 하면 이번 프로젝트는 무난하게 A+ 받을 수 있지 않을까 생각한다. 그래도 이정도 수준이면 이 수업 듣는 사람들 중에 내가 제일 잘만들 수 있을지도?   원래는 이런 IOT 제품에 대해 아무런 생각이 없었는데, 이번에 해보면서 나도 생각보다 쉽게 내가 생각해낸 걸 제품화 할 수 있다는 걸 알게되서 새로운 걸 배워볼 생각에 조금 설렌다. 미리 좀 관심 가져볼걸 뭔가 전자공학에 대한 반감때문에 의도적으로 전자관련 이야기면 좀 기피 한것도 있는 것 같기도 하고; 어쨌든 내 기술을 제품화 하는것에 공부하다보면 또 새로운 아이디어들이 생각나지 않을까 싶다.   결국 내가 떠올리는 아이디어들은 내가 실현할수 있고, 알고있는 지식의 한계치내에서 나오는건데, 이 한계치가 좀 눈에 띄게 늘어나는 기회가 되지 않을까 싶다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%95%84%EB%91%90%EC%9D%B4%EB%85%B8-%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[Docker] 스프링부트에 도커 적용하기 + M1맥에서 AWS용 도커파일 빌드하기",
        "excerpt":"서론     이전 게시물 : [Docker] 도커란 무엇일까?    저번 게시물에서는 도커가 무엇이고 어떻게 작동하는지에 대해 알아보았습니다. **그러면 이제 실제로 도커가 실제로 어떤방식으로 사용되는지 알아보기위해서, 제가 도커를 통해 제가 개발중인 **웹사이트의 개발환경과 서버를 이미지로 제작해서 도커허브에 올리고 이를 다시 AWS 서버에서 내려받아 해당 컨테이너를 동작시켜보도록 하겠습니다.   그럼 이번에는 도커허브에 있는 이미지가 아니라, 직접 도커허브에 내 개발환경과 파일을 이미지로 만들어서 업로드 해보도록 하겠습니다.   Dockerfile이란?  우리가 이미지를 직접 만들어 도커허브에 올리기 위해서는, ‘도커 파일’이 필요합니다. 물론 컨테이너안에서 직접 설치 하고 설정한 다음 이를 이미지 파일로 만들어 쓸 수도 있겠지만,   Dockerfile을 만들어주면,  패키지, 소스코드, 명령어, 환경변수를 기록하여 빌드해주기만 하는 것으로도 바로 원하는 환경을 구성할 수 있습니다.   무슨말인지 조금 어려울 수 있겠지만, 한번 해보면 왜 개발자들이 Docker를 선호하는지 알게 될 것입니다.   Dockerfile 만들기  Dockerfile은 이미지를 빌드하기 위한 파일로, 따로 확장자가 없는 텍스트 파일입니다. 기존에 도커 컨테이너 환경을 세팅하려면 베이스 이미지 다운로드 후 컨테이너에 접속해서 수동으로 환경설정을 해주던 방식과 다르게 자동으로 Dockerfile안에 기록한 내용대로 환경을 설정해줍니다.   원하는 디렉토리에 Dockerfile을 만들어줍니다.         이 때 주의할점은 Dockerfile을 빌드 할 때에는 해당 파일 ‘Dockerfile’을 포함한 디렉토리와 그 아래에 있는 서브 디렉토리를 모두 Docker로 보내 이미지화 하기 때문에 반드시 원하는 파일만 들어갈 수 있도록 디렉토리를 설정 해주셔야 합니다. 불필요한 파일이 많아지면 도커 데몬의 성능이 저하될 수 있습니다.    먼저, 간단하게 Dockerfile에서 사용할 문법에 대해서 알아봅시다.      FROM - 컨테이너의 Base Image를 설정합니다.   MAINTAINER - 이미지를 생성한 사람의 이름 및 정보   LABEL - 컨테이너 이미지에 컨테이너의 정보를 저장   RUN - 컨테이너 빌드를 위해 Base Image에서 실행할 명령   COPY - 컨테이너 빌드 시 호스트의 파일을 컨테이너로 복사   ADD - 컨테이너 빌드 시  호스트의 파일 (tar, url 포함) 을 컨테이너로 복사   WORKDIR - 컨테이너 빌드 시 명령어 실행될 작업 디렉터리 설정   ENV - 환경 변수 지정용   ARG - 이미지 빌드를 위해 Dockerfile 내에서 사용하기 위한 값   USER - 명령 및 컨테이너 실행 시 적용할 유저 설정   VOLUME - 파일 또는 디렉토리를 컨테이너의 디렉토리로 마운트   EXPOSE - 컨테이너 동작 시 외부에서 사용할 포트 지정   CMD - 컨테이너 동작 시 자동으로 실행할 서비스나 스크립트 지정   ENTRYPOINT - CMD와 함께 사용하면서 명령어 지정 시 사용   이 명령어가 Dockerfile을 사용하기 위한 전부입니다. 어렵지 않죠??   Dockerfile 작성하기  저는 현재 동아리의 웹사이트를 제작하고 있는데요, 제가 개발하는 환경을 이렇습니다.      자바 8버젼   스프링 부트   Gradle   이 정도를 개발환경으로 소개할 수 있겠네요.   자바의 버젼도 여러가지이고, 스프링부트도 마찬가지죠. Gradle도 버젼이 많습니다. 이들은 서로 버젼간의 호환도 생각해주어야하고, 안에 코드가 해당 버젼과 호환이 안될 수도 있을 것입니다.   그렇다면 AWS에서 인스턴스에 제가 만든 웹서버를 돌린다고 가정하면 결국 AWS도 컴퓨터 하나를 대여하는 것 과 마찬가지인데, 제가 개발한 환경과 동일하게 AWS를 설정해주어야 오류없이 안전하게 제가 제작한 서버를 돌릴 수 있을 것입니다.   만약, 제 컴퓨터에서는 이상이 없었는데 AWS에서만 에러가 발생한다면, 다시 작업환경을 날리고 일일히 버젼을 확인해가며 동일하게 세팅해주어야 할 것입니다.   그럼 저는 이러한 것을 개선하기 위해서, 제 개발환경을 통째로 사진을 찍어 (이미지화 하여) 업체에 넘기고 (도커 허브에 올리고), 이를 AWS에서 다시 내려받아 동일하게 세팅 하게 해보도록 하겠습니다.   제가 설정한 Dockerfile의 내용은 다음과 같습니다.  1 2 3 4 5 6 FROM openjdk:8-alpine RUN sh -c \"$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.1.1/zsh-in-docker.sh)\" ARG JAR_FILE=build/libs/*.jar COPY ${JAR_FILE} app.jar ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"] EXPOSE 8080  생각보다 굉장히 간단하죠?   그러면 한 줄 씩 해석해보겠습니다.  1 FROM openjdk:8-alpine  이 Dockerfile의 베이스 이미지는 openjdk:8-alpine 을 사용합니다. 한마디로 자바 8환경을 만드는 것이죠.   1 2 RUN sh -c \"$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.1.1/zsh-in-docker.sh)\"   이 부분은 꼭 설정하지 않아도 됩니다. 저는 bash 보다는 zsh이 편해서, 컨테이너에서 zsh를 사용해주기 위해 해당 코드를 넣었습니다. RUN은 뒤의 명령어를 컨테이너에 입력합니다.   1 ARG JAR_FILE=build/libs/*.jar  build/libs/ 디렉터리에 있는 .jar 파일을 변수로 저장합니다. ARG로 선언해준 변수는 사용하면 바로 사라집니다. 따라서 밑에서 이 변수를 사용하고 또 사용하기 위해서는 한번 더 선언하고 사용해주어야 합니다.   1 COPY ${JAR_FILE} app.jar  위에서 ARG로 선언해준 변수에 해당하는 파일 .jar 파일을 app.jar 라는 이름으로 컨테이너에 복사합니다.   1 ENTRYPOINT [\"java\",\"-jar\",\"/app.jar\"]  컨테이너 실행 후 변경되지 않을 사항에 대해서는 ENTRYPOINT를 사용합니다.  해당 명령은 “java -jar ./app.jar”의 명령을 컨테이너 시작과 동시에 실행합니다.   1 Expose 8080  외부 포트에서 들어온 포트 연결을 해당 컨테이너의 포트로 연결해줍니다.  어쩌면 이 명령어 중에 가장 헷갈리는 개념일 수 있는데, 이 부분에서는 뒤에서 설명 하도록 하겠습니다.   그럼 이제 이 Dockerfile이 이해가 되셨나요?   도커는  자바8 기반으로 환경을 세팅하고, zsh을 설치 한 뒤,  빌드된 서버인 jar파일을 컨테이너로 옮겨 실행합니다.   이렇게 만들어준 파일을 그럼 빌드해서 이미지로 만들어 보겠습니다. 명령어는 다음과 같습니다.  1 docker build -t lmj938/jamong-sever .     .을 빼먹지 말도록 주의 해주세요.    -t 옵션을 붙이면, 뒤에있는 내용이 이미지의 이름이 됩니다.   이렇게 하면 이미지 파일이 생성되는데 여기서 주의 할 점이 있습니다. 도커허브에 올리기 위해서는 [자신의 도커 허브 아이디] / [원하는 파일명]의 형식으로 이름을 작성해주어야 합니다. 이는 사람들의 도커파일 이름이 중복 되지 않기 위함이니 꼭 주의 해주세요.      그러면 다음과 같이 이미지가 생성 된 것을 볼 수 있습니다. 이를 Run 하여서 컨테이너로 만들어 동작시켜주기만 하면, 제가 만든 웹서버를 제가 기록한 환경 설정 그대로에서 동작 시킬 수 있는 것이죠. 그럼 해당 이미지를 Run 해보도록 하겠습니다.      마찬가지로 실행할 컨테이너의 이름을 설정해주는 창이 뜨는데, 아까는 이름만 정해주고 넘어갔지만, 이번에는 포트를 설정 해주어야 합니다.   ContainerPort를 보시면 8080/tcp라고 써있는걸 볼 수 있습니다. 이것이 바로 아까 EXPOSE 명령어를 통해서 사용할 컨테이너의 포트를 8080으로 설정해준 결과입니다.   그렇다면 Local Host에 해당하는 포트는 무엇일까요? 바로 내가 지금 사용하는 컴퓨터의 포트 겠죠. 계속 설명했듯이, 컨테이너를 실행시킨다는건 컴퓨터 안에서 또다른 컴퓨터를 돌리는 것과 비슷한 일입니다. 그렇다면 컨테이너에게도 컴퓨터가 가진 65535개의 포트가 있을 것 입니다. 만약 이 컴퓨터에 접속 하고 싶은 사람이 있다면, 어떤 포트로 연결 해야 할까요??   이전 게시물에서 사용했던 그림을 가져오겠습니다.     해당 작업실들에 문이 있다고 해봅시다. 실제로는 작업실에는 각각 작업실마다 65535개의 문이 있지만 편의상 간소화 하여 그리도록 하겠습니다. 만약 손님이 밖에 있는 집에 용무가 있어 온게 아니라, 안에 있는 작업실에 방문했다면, 우리는 어떻게 이 손님을 안에있는 작업실로 안내해줄 수 있을까요?   간단합니다. 통로를 이어놓으면 됩니다.      위와 같이 8080 문에는 첫번째 작업실의 8080문을, 8082문에는 두번째 작업실의 8080문을 연결해주면 밖의 손님이 안에있는 작업실의 주소를 모르더라도, 그냥 큰집의 문 번호만 알려주면 알아서 원하는 작업실로 출입할 수 있습니다.   첫번째 작업실로 오라고 하고싶으면 8080번을 알려주면 되고, 두번째 작업실로 오라고 하고싶으면 8082 문을 열고 들어오라고 하면 되겠죠. 지금 우리가 설정해주는 것이 바로 바깥 포트를 안쪽 포트에 연결하여 밖에서 들어온 요청을 해당 컴퓨터로 이어주는 작업입니다. 이를 ‘포트포워딩’이라 합니다.   그럼 우리는 8080포트를 컨테이너의 8080포트와 연결 해주도록 할 것 입니다.      컨테이너 이름을 Server로 해주고, 8080포트를 Local Host 포트에 입력해주면, 밖의 컴퓨터의 8080포트로 들어오는 것은 곧, 컨테이너의 8080 포트로 들어가는 것 입니다.  둘은 연결되어 있으니까요.   그럼 우리의 localhost:8080 포트로 접속 하면, 제가 만든 서버로 접속 할 수 있을 것 입니다.      예상대로 안에 컨테이너에서 실행한 서버에 정상적으로 접속 할 수 있는것을 확인할 수 있습니다.   AWS에 도커를 사용해서 서버 실행하기  그럼 이제 이 서버를 AWS에도 동일하게 구성해볼까요?      도커에 다루는 게시물이니 자세한 AWS까지는 설명하지 않겠습니다.       AWS의 제 인스턴스로 접속한 상태에서, 우선 도커를 먼저 설치해 주겠습니다.   1 sudo yum install docker  그럼 AWS의 인스턴스에도 도커가 설치가 완료됩니다. AWS는 리눅스 기반이기 때문에 여기서는 도커 데스크탑과 같은 GUI를 사용할 수 없기 때문에 터미널로 docker 명령어를 사용해 주어야 합니다.   그럼 이제 우리가 아까 만들었던 이미지를 불러와야합니다. 아까 만든 이미지를 도커허브에 업로드하면, 우리는 pull 명령어 만으로 해당 이미지를 AWS 인스턴스에 설치할 수 있을 것입니다.   방법은 아주 간단합니다.     해당 이미지의 메뉴에서 push to hub를 눌러주면 끝입니다. 이름까지 이미 허브 업로드 양식에 맞추어 바꾸어 놓았으니 누르기만 하면,     위와 같이 업로드가 완료됩니다.   물론 터미널을 사용해도 되지만, GUI에서 하는게 훨씬 간편할 것입니다.   그럼 다시 AWS로 돌아와서,  1 sudo docker pull lmj938/jamong-server  명령어를 해주면 아까 우리가 업로드 한 이미지를 다운 받습니다.   혹시 여기서  아래와 같은 오류가 뜬다면  1 Error response from daemon: pull access denied for lmj938/jamong-sever, repository does not exist or may require 'docker login': denied: requested access to the resource is denied   아래의 명령어를 사용해서 로그인 후 다시 진행 해주세요.  1 sudo docker login       1 sudo docker images  다음 명령으로 이미지가 잘 다운로드 되었는지 확인 할 수 있습니다.     그럼 컨테이너를 실행하려면 어떻게 해야 할까요? 아까는 GUI로 run 버튼을 누르고 나온 창에 포트를 설정 해주었지만, 터미널 환경에서는 다음과 같이 포트를 설정해 주어야 합니다.   1 sudo docker run -d -p 8080:8080 --name Server lmj938/jamong-server  docker container run [옵션] 이미지명[:태그명][인수] 로 사용하면 되는데,   명령어 옵션은 구글링을 통해 찾아보면 여러가지 옵션을 찾아 보실 수 있습니다. 여기서는 가장 많이 다루는 세가지만 다루겠습니다.           -d     컨테이너의 로그가 뜨지 않고 백그라운드에서 작동됩니다. -d 옵션을 사용하지 않고 run하게 되면 바로 컨테이너안에 있는 로그가 나오게 됩니다. 다음 명령을 치기 위해서 저는 -d 옵션을 사용해주겠습니다.            -p     아까 포트를 설정하던 부분입니다. 로컬호스트 포트:컨테이너포트를 입력해주면 됩니다.            –name     컨테이너의 이름을 정하는 옵션입니다.       이렇게 컨테이너를 작동시키고 8080 포트로 가면 접속이 완료될것 입니다.      M1 맥북에서 빌드하기  하지만 M1 프로세서를 사용하시는 분들은 AWS에서 컨테이너를 run하면 다음과 같은 오류가 뜨면서 아마 작동이 안될 것입니다.      이것은 M1은 arm 아키텍쳐를 사용하고 있기 때문에, 이 상태에서 그냥 build 하게 되면 arm용 이미지로 빌드를 하게 되기 때문입니다. 따라서 빌드할때 amd64 버젼을 따로 build한뒤 이를 push해서, AWS에서 pull 해주어야 합니다.   1 sudo docker pull --platform=linux/amd64 lmj938/jamong-server   다음과 같이 platform을 linux/amd64로 설정해주신 이미지를 푸쉬하고, AWS에서 내려받으면, AWS에서도 정상적으로 해당 이미지를 인식할 수 있습니다.  ","categories": ["ETC"],
        "tags": [],
        "url": "/etc/Docker-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8%EC%97%90-%EB%8F%84%EC%BB%A4-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "하기싫은마음",
        "excerpt":"2022.03.24  한 두달 전에만 해도 스프링부트를 하다가, 또 얼마전에는 창업을 하려고 플러터를 배우다가 이번에는 또 학교프로젝트에 좀 호기심이 생겨서 아두이노랑 라즈베리 파이를 해보고 있다.   문득 이렇게 너무 얕게만 여러게 찍어먹기만 해도되나… 하면서도 뭔가 항상 새로운 기술을 배우다 보면, 아 거기서 그게 이거였구나! 싶은 것들이 생기는데, 그 과정이 조금 즐겁다. 여러개의 굴을 파는데 결국 그게 만나는 지점이 자주 생긴다고 해야하나?? 난 사실 깊고 좁게 파는것과 넓고 얇게 중에서 고르라면 무조건 깊고 좁게가 맞다고 생각했는데, 요즘은 넓게 파는것도 중요하다는 생각이 든다.   하지만 그래도 내가 누군가에게 돈을 받고 일하려면 적어도 한구멍 정도는 어느정도 깊이 이상은 되어야 하지 않을까? 솔직히 지금 구멍의 개수는 많다고 생각하지만, 깊이가 다들 너무 얕은것 같다.   그래도 나는 백엔드 관련된 스택이 다른 스택들보다는 그 깊이가 깊었으면 좋겠는데, 다른 스택들보다 깊냐고 물어보면, 또 그다지 많이 깊지도 않은 것 같다.   사실 학문이나 기술이라는게, 일정 깊이 이상 파고들면 당연히 어려운 지점에 맞닿게 되는데, 이 벽을 넘지 않으면 사실 그 지식을 배운 큰 의미가 없다고 생각한다. 적어도 이 벽을 스무댓번은 넘어야 그래도 어디가서 콧방귀좀 뀔 수 있달까…      더닝크루거 효과에 따르면, 어떤 지식을 가진 초보자가 오히려 더 많은 지식을 가진 사람보다 높은 자신감을 갖는다.   초보자는 오히려 처음에는 비교적 쉬운 지식만을 접하기 때문에, 우매함의 봉우리를 만나 즐거움을 느끼게 된다. 그 이후에는 다들 절망의 계곡을 마주하게 될 미래도 모른채…   그래도 상심할 필요 없다. 어떤 도전에 있어 벽을 느낀다는건, 반대로 그만큼 전문가의 길에 들어섰다는거니까.   요즘 나는 너무 우매함의 봉우리의만 찾아 다닌 것 같아서, 반성하는 마음을 좀 가져본다.. 절망 계곡도 좀 걸어댕기자.   하기 싫고 어려워도, 열심히 스프링 부트 공부해야겠다.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%95%98%EA%B8%B0%EC%8B%AB%EC%9D%80%EB%A7%88%EC%9D%8C/",
        "teaser": null
      },{
        "title": "[Spring] JaCoCo 적용하여 테스트 커버리지 체크하기",
        "excerpt":"서론  테스트 코드는 개발 시간을 굉장히 단축시켜주는 강력한 도구입니다. 물론 코드를 작성하는데 시간도 많이 들어갈 뿐더러, 눈에 보이는 성과를 주지 않는 코드이기 때문에, 괜히 작성하는 시간이 아깝고 귀찮아서 잘 작성하지 않는 경우가 대부분입니다. 저도 마찬가지였구요… 기능이 적을때는 서버를 다시 시작해서 눈으로 확인하는게 더 편하다고 생각할 수도 있겠지만, 기능이 많아지거나, 과정이 복잡한 기능의 경우, 일일히 서버를 올린뒤 해당 기능에 에러가 날만한 값을 하나하나 넣으며 테스트하는 것은 몹시 비효율적인 행위입니다.   심지어 테스트 코드가 없다면 기능을 일부분 수정하거나, 기존 코드를 리팩토링 할 때도, 만약 문제가 발생한다면 어느 부분에서 발생한 것인지 알아채기도 어렵고, 아까 서술했던 방식대로 리팩토링을 하고나서 또 일일히 테스트를 해야할 것 입니다.   따라서 테스트 코드 작성을 꼼꼼히 해야하는데, 이를 강제해주는 좋은 라이브러리가 있어 한번 알아보려고 합니다.      라이브러리의 이름은 JaCoCo입니다.   JaCoCo란?  JaCoCo는 자바 코드의 커버리지를 체크하는 라이브러리로, 테스트 코드가 현재 프로덕션코드의 얼마만큼 작성되었는지 퍼센테이지로 확인하도록 해주는 라이브러리 입니다. 만약 커버리지가 100퍼센트라면, 모든 프로덕션 코드에 대해서 테스트 코드가 작성되어 있는 상태라고 할 수 있을 것 입니다.   심지어 JaCoCo는 이렇게 커버리지 결과를 알려줄뿐만 아니라, 해당 커버리지가 사용자가 설정한 퍼센테이지에 미치지 못하면 build자체가 되지않게 설정하여, 테스트코드 작성을 강제합니다.   그럼 한번 JaCoCo를 어떻게 적용하는지 알아보고, 예제를 사용해보며 JaCoCo의 사용법을 알아 보겠습니다.   JaCoCo 추가하기  먼저, build.gradle에 JaCoCo를 설정해 줍니다. plugins부분에 아래와 같은 부분을 추가해주면, Gradle이 알아서 해당 의존성을 추가해줍니다.   1 2 3 plugins { \tid 'jacoco' }   이렇게 JaCoCo의 의존성을 추가하고 나면 별도의 설정이 필요한데요, 아까 말한 커버리지의 퍼센테이지를 설정하고, 해당 리포트를 어떤 형식으로 저장할 지를 설정해주어야 합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 jacocoTestReport {   reports {     html.enabled true     xml.enabled false     csv.enabled false  // 리포트의 저장 경로를 설정합니다. html.destination file(\"jacoco/jacocoHtml\") xml.destination file(\"jacoco/jacoco.xml\")   } }  jacocoTestCoverageVerification {      violationRules { // 커버리지의 범위와 퍼센테이지를 설정합니다.     rule {       element = 'CLASS'        limit {         counter = 'BRANCH'         value = 'COVEREDRATIO'         minimum = 0.90       }     }   } }  이 설정 부분은 지금은 그냥 복사해서 붙여넣으시면 됩니다. 자세한 세팅은 뒤에서 다시 설명하겠습니다.   이렇게 하면 JaCoCo가 추가되는데, 오른쪽에 있는 gradle탭을 눌러 Tasks &gt; Verification에 들어가면 아래와 같은 jcocoTestReport와 jacocoTestCoverageVerification 명령이 생긴 것을 확인 할 수 있습니다.      그럼 이제 JaCoCo를 사용하기에 앞서서 테스트를 위한 간단한 프로덕션 코드를 작성해보고, 이를 테스트 해보겠습니다.   JaCoCo를 사용하여 테스트 코드 작성하기  클래스 이름은 Jacoco로 대략 붙이도록 하겠습니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Jacoco{     public String select(String name) {         switch (name) {             case \"딸기\":                 return \"빨간색입니다.\";             case \"바나나\":                 return \"노란색입니다.\";             default:                 return \"잘 모르겠습니다.\";         }     }      public String giveMeFruit() {         return \"과일주세요!\";     } }  간단한 함수 select()를 하나 추가 해주었는데요. 메서드에 인자로 딸기를 넘기면 딸기의 색깔을, 바나나를 넘기면 바나나의 색깔을 말해주는 메서드입니다. 만약 두 과일 외의 다른 과일이 온다면, ‘잘 모르겠습니다’ 라는 문구를 출력할 것 입니다.   그럼 이 메서드의 테스트 코드를 한번 작성해볼까요?   우선 간단하게 아래처럼 작성해보도록 하겠습니다.   1 2 3 4 5 6 7 8 9 10 class JacocoTest {     private Jacoco jacoco = new Jacoco();      @Test     public void 딸기_색깔을_잘_출력하는지_테스트() {         String actual = jacoco.select(\"딸기\");         String expected = \"빨간색입니다.\";         assertThat(actual).isEqualTo(expected);     } }  테스트 메서드는 알아보기 쉽게 이름을 한글로 지어보았습니다.   이렇게 하면 assertThat이 프로그램의 실제값(actual)과 우리가 기대하는 값(expected)가 같은 지 확인하여, 같다면 이 테스트가 pass될 것이고, 다르다면 fail될 것입니다.   그럼 이렇게 작성한 테스트 코드는 현재, 프로덕션 코드의 몇퍼센트를 커버하고 있을까요? 이를 알아보기 위해서 이제 JaCoCo를 작동시켜, 현재 테스트 코드의 커버리지를 확인해보도록 합시다.   위의 Gradle 탭에서 test,jcocoTestReport와 jacocoTestCoverageVerification 명령을 순서대로 작동시켜 봅시다.  각각의 명령은 테스트 코드를 실행(test)하고, 리포트를 생성(jacocoTestReport)한 다음, 커버리지를 체크(jacocoTestCoverageVerification) 합니다.   근데 아마 jacocoTestCoverageVerification 명령을 실행시키면, 에러가 뜨며 해당 명령이 정상적으로 실행되지 않았다고 나올 것 입니다.      에러를 읽어보면, 우리의 테스트코드는 현재 0.33의 커버리지를 갖고있는데, 커버리지 기댓값은 0.90이라고 나와있습니다.  앞서 말했던대로, JaCoCo는 우리가 설정해둔 커버리지 값에 테스트 코드가 미치지 못하면 빌드 자체를 에러를 띄웁니다.   그럼 아까 build.gradle 파일에서 jcocoTestReport에 설정해준 경로,   1 html.destination file(\"jacoco/jacocoHtml\")  에 생성된 index.html 파일을 열어 자세한 정보를 알아보겠습니다.      index.html 파일을 원하는 브라우저로 열면, 커버리지 퍼센트를 확인 할 수 있습니다. (인텔리제이의 경우 오른쪽 위에 뜨는 팝업에서 브라우저를 누르면 바로 열 수 있습니다.)      보면 Instruction은 55퍼센트의 커버리지를 달성했고, 전체 Branches는 33퍼센트의 커버리지 밖에 달성하지 못했습니다.   자세히 보기 위해서 com.jacoco.example을 눌러 세부정보들을 확인해 봅시다.      위 사진을 보면 실행파일인 JacocoApplication과 우리가 방금 만들어준 Jacoco의 커버리지가 클래스별로 나와 있는 것을 볼 수 있습니다. 우선 제쳐두고 한번 더 Jacoco를 눌러서 들어가 한번 더 세부내용을 확인해 보도록 하겠습니다.      메서드 별로 커버리지가 나와있는걸 확인 할 수 있습니다.   select() 함수의 경우 Missed Branches 의 커버리지가 33퍼센트인데, 여기서 ‘브랜치’는 어떤 범위를 이야기 하는 것 일 까요? index.html에서 select() 메서드를 눌러서 들어가 한번 코드를 확인해 봅시다.      초록색, 노란색, 빨간색이 있는 걸 확인 할 수 있습니다. 빨간색의 경우는 커버하지 못한 부분, 노란색의 부분은 커버되긴 했으나, 100퍼센트 커버되지 못한 부분, 초록색의 부분은 완벽하게 커버된 부분입니다.   그럼, 이 메서드의 경우 결과값이 몇개의 분기로 이루어져 있을까요? 간단하게 return값을 3개 갖고있는 함수이므로, 3개입니다.   아까 우리의 테스트 코드를 보면, “딸기”를 입력하고 “빨간색입니다”의 출력이 나오는 경우만 테스트 코드를 작성했기 때문에, 바나나를 입력했을 때와 그 외의 입력값을 입력했을 때, 이 프로그램이 정상적으로 작동하는지 확신할 수 없는 상태일 것입니다. return 값을 확인해보면, “빨간색입니다.”의 return 값은 초록색으로 커버되었지만, 나머지 두 return값은 빨간색으로 커버되지 못한 것을 확인 할 수 있습니다. 따라서 Branch는, 이 메서드가 가질 수 있는 출력값의 개수임을 알 수 있습니다.   그렇다면 Instruction은 어떤 의미로 범위를 나눈 것인 걸까요?? Instruction은 지나간 바이트 코드를 측정합니다.  만약, 100개의 바이트 코드중에서 20개의 바이트코드를 커버했다면, Instruction은 20퍼센트인 것이지요. 무슨 말인지 모르겠다면, 간단하게 코드 글자 하나하나의 수라고 생각하면 편합니다. (정확한 설명은 아니지만, 대략 이렇게 알아두고 넘어가도 괜찮습니다.)   그럼 한번 select() 함수의 커버리지를 100퍼센트 달성하는 테스트 코드를 작성해볼까요?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class JacocoTest {     private Jacoco jacoco = new Jacoco();      @Test     public void 딸기_색깔을_잘_출력하는지_테스트() {         String actual = jacoco.select(\"딸기\");         String expected = \"빨간색입니다.\";         assertThat(actual).isEqualTo(expected);     }      @Test     public void 바나나_색깔을_잘_출력하는지_테스트() {         String actual = jacoco.select(\"바나나\");         String expected = \"노란색입니다.\";         assertThat(actual).isEqualTo(expected);     }      @Test     public void 그_외의_값을_잘_출력하는지_테스트() {         String actual = jacoco.select(\"키위\");         String expected = \"잘 모르겠습니다.\";         assertThat(actual).isEqualTo(expected);     } }  마찬가지로 간편하게 알아보기 쉽게 메서드 이름을 한글로 지었습니다.   이로써 select() 메서드가 출력할 수 있는 결과인 세가지의 경우의 테스트 코드를 모두 작성하였습니다. 이제 리팩토링을 하거나 다른 함수가 추가 되어도, 우리는 이 테스트 코드가 통과한다면 select() 메서드는 여전히 정상적으로 동작하고 있음을 알 수 있을 것 입니다. 마찬가지로 다시 JaCoCo의 명령을 실행 시킨 후 select() 메서드의 테스트 코드 커버리지를 확인해볼까요?      select() 메서드의 커버리지가 100퍼센트가 된 것을 확인 할 수 있습니다!   그럼 이제 Jacoco 클래스에 있는 또 다른 메서드인 giveMeFruit() 메서드도 테스트 코드를 작성하여, JaCoCo클래스의 커버리지를 100퍼센트로 달성해 볼까요?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class JacocoTest {     private Jacoco jacoco = new Jacoco();      @Test     public void 딸기_색깔을_잘_출력하는지_테스트() {         String actual = jacoco.select(\"딸기\");         String expected = \"빨간색입니다.\";         assertThat(actual).isEqualTo(expected);     }      @Test     public void 바나나_색깔을_잘_출력하는지_테스트() {         String actual = jacoco.select(\"바나나\");         String expected = \"노란색입니다.\";         assertThat(actual).isEqualTo(expected);     }      @Test     public void 그_외의_값을_잘_출력하는지_테스트() {         String actual = jacoco.select(\"키위\");         String expected = \"잘 모르겠습니다.\";         assertThat(actual).isEqualTo(expected);     }      @Test     public void giveMeFruit_테스트() {         String actual = jacoco.giveMeFruit();         String expected = \"과일주세요!\";         assertThat(actual).isEqualTo(expected);     } }     다음과 같이 Jacoo 클래스가 100퍼센트의 커버리지를 달성 한 것을 확인 할 수 있습니다.   그런데, 아직 이 프로젝트 전체의 커버리지를 확인해보면,         위 사진처럼 Branch는 100퍼센트의 커버리지를 달성했지만, Instruction은 100퍼센트가 달성되지 않은 것을 확인 할 수 있습니다. 물론 우리의 목표는 Branch 커버리지의 90퍼센트 이상으로 설정하여 이 상태로도 빌드는 진행될 것 입니다. 그래도 만약 혹여 테스트가 불가능 하거나, 위 JacocoApplication 파일처럼 테스트가 필요하지 않은 부분을 커버리지에서 제외해야 할 경우가 있으니, 이를 커버리지에 포함 시키지 않는 방법도 알아보도록 하겠습니다.   방법은 아주 간단합니다.  1 2 3 4 5 6 7 8 9 10 11 12 13 import lombok.Generated; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication;  @Generated @SpringBootApplication public class JacocoApplication {  \tpublic static void main(String[] args) { \t\tSpringApplication.run(JacocoApplication.class, args); \t}  }  Lombok 라이브러리의 Generated 어노테이션을 붙이면, 해당 클래스를 커버리지에서 제외합니다. 메서드 위에 붙여도 동일하게 작동합니다.      이로써, 해당 프로젝트의 테스트 코드 커버리지 100퍼센트를 달성하였습니다.  ","categories": ["Java"],
        "tags": [],
        "url": "/java/jacoco-%EC%A0%81%EC%9A%A9%ED%95%98%EC%97%AC-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BB%A4%EB%B2%84%EB%A6%AC%EC%A7%80-%EC%B2%B4%ED%81%AC%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "카페인...",
        "excerpt":"2022.03.27  최근에 커피머신도 샀겠다. 맨날 아침마다 한잔씩 내려먹고, 어쩔때는 두잔 씩도 먹을 떄가 있었는데 최근에 자꾸 머리가 아파서 감기가 걸린줄 알았다. 알고보니까 카페인 두통이라고, 커피 맨날 마시면 생기는 카페인 금단 현상 같은 거였다.   해결방법은 커피를 마시면 해결된다고 한다. 대신 맨날 먹어야 한다는게 문제지… 사실 카페인에 내가 민감한 건 알고 있었다. 가끔 한잔 너무 빨리 마시고 하면 가슴 너무 빨리 뛰고 그렇긴 했는데, 아주 가끔 그런거라서 별 신경 안쓰고 있었다. 무슨놈의 몸이 술도 잘 못먹고 카페인에도 약한지…   자주먹고 나서는 유독 소화력이 약해진 느낌이어서 요즘 좀 안마셨었는데, 이상하게 자꾸 피곤하고 산만해졌다 싶었더니 이게 다 카페인 금단현상이었다. 어느덧 커피 맨날 아침마다 투샷씩 내려먹은게 벌써 한달이 넘어서, 카페인 중독이 좀 생긴 것 같다. 괜히 관련 글 읽고 나서부터는 세상 모든게 카페인 탓 같다.   커피 취미로 한번 마셔보겠다고 쓴돈이 지금 한 이십만원이 넘는 것 같은데, 조금 현타가 온다. 진짜 졸릴때만 가끔 마셔야겠다.ㅜ   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%B9%B4%ED%8E%98%EC%9D%B8/",
        "teaser": null
      },{
        "title": "지식의 가치",
        "excerpt":"2022.03.28  오늘 인프런에서 강의를 거진 40만원어치를 결제 했다.   아직 강의에 돈쓰는게 익숙치가 않아서 솔직히 조금 아까운 마음도 들지만, 지식을 구매하는데에는 돈을 아끼지 말아야 한다는 생각이 요즘 들어서 그냥 과감하게 결제 해버렸다.   인터넷이 지금과 같이 발달하기 이전에는 어떠한 지식을 배우려면 직접 해당 지식을 가르쳐주는 학원을 등록하거나, 직접 취업을 해서 관련 기술에 대한 지식을 습득해야 했다. 하지만 이제는 대부분의 지식들이 아주 질 좋은 인터넷강의로 수강 할 수 있게 되었고, 인터넷 강의의 단점인 피드백이 부족하다는 부분도 자체 슬랙채널이나 커뮤니티를 개설해서 질문하고 대답할 수 있게 되면서 어떻게 보면 이제는 거의 오프라인 강의에 준하는 퀄리티를 갖게 되었다. (물론 아직도 오프라인의 실시간 피드백에는 크게 못미치지만, 온라인 강의의 언제든지 어디에서나 들을 수 있다는 장점이 이 부분을 크게 상쇄한다고 생각한다.)   사실 이러한 몇몇 질좋은 온라인 강의들의 가성비는 말이 안되는 수준이라고 생각한다. 만약 저정도 수준의 강의들을 오프라인에서 직접 들으려면 온라인 강의에서 지불한 금액의 몇배를 지불해야할 정도일 뿐더러, 몇년전 까지만 해도 돈이 있어도 오프라인 자리가 없어 예약을 걸어놓아야 들을 수 있을 만한 수준의 강의들이 이제는 곳곳에 널려서 일정 금액만 지불하면 누구나 해당 강의를 수강할 수 있다.   물론 인터넷 검색으로도 얼마든지 정보를 검색하고 찾아가며 들을 수 있겠지만, 해당 정보를 찾는 시간과 비가공된 정보들을 가공하는 과정에서 드는 노력을  하는 것 보다는 실제로 업계에서 인정받고 있는 사람이 정제하고 가공한 지식을 받아들이는게 몇배는 간편하고 빠르게 지식을 습득할 수 있을 것이다.   주식이나 부동산같은 자산에  투자하는 것은 리스크와 리턴이 변동성만큼 동일하지만, 지식에 투자하는 것은 리스크가 0고 리턴은 무한하다.   오늘 40만원 어치 강의를 결제했지만 이 강의가 비싼 가격인지 저렴한 가격인지는 아직 모른다. 내가 열심히 이 정보들을 내걸로 만든다면 겨우 40만원밖에 안하는 저렴한 강의가 될 것이고, 그냥 방치하고 그냥 저냥 듣는다면 무려 40만원 씩이나 하는 돈아까운 비싼 강의가 될 것이다.   거창하게 썼지만… 사실 막상 40만원 나가고 보니까 아까워서 마음을 다잡으려고 한번 써봤다. ㅜ  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%A7%80%EC%8B%9D%EC%9D%98-%EA%B0%80%EC%B9%98/",
        "teaser": null
      },{
        "title": "[AWS] 프리티어 요금 결제되었을 때 - 청구서 부검하기",
        "excerpt":"분명 프리티어 요금제인데 결제가…  저는 두달 전 AWS 공부를 위해서 AWS에 가입하고 프리티어 요금제를 가입하였습니다. 용량이 작고 성능이 제한적이긴 하지만, 1년동안 무료로 사용할 수 있기 때문에 공부를 하기에는 1년이면 뽕을 뽑고도 남았죠.   근데 오늘 아침에, 제 통장에서 AWS가 돈을 출금해 갔습니다…     출금을 보자마자 후다닥 책상에 앉아서 AWS에 들어갔는데, 다음과 같은 청구서를 확인 할 수 있었습니다.     저는 간단한 웹사이트를 만들기 위해서 EC2와 RDS를 사용하고 있었는데 해당 항목들에서 비용이 발생 하였습니다. 전 분명히 프리티어 요금제를 사용중이라 1년간 무료일텐데, 왜 이런일이 발생했을까요?   돈을 지출하게 되어 너무나도 마음이 아프지만 다시는 이런일이 없도록 다짐하고 제 마음을 위로할겸, 제 청구서를 부검해보록 하겠습니다.   프리티어 요금제는 완전한 무료가 아니다  저는 얼마전에 기존에 책을 보고 따라만들던 웹사이트와 별개로 제가 스스로 프로젝트를 하나 해보려고 EC2와 RDS의 인스턴스를 하나씩 늘렸습니다. EC2와 RDS 둘 다 두개의 인스턴스를  사용하고 있었던 것이죠.   프리티어 요금제니까, 단순하게 1년동안은 무료인줄 알았습니다.   하지만 프리티어 요금제는 지정된 한도내에서만 무료로 서비스를 제공합니다     서비스 별 프리티어 요금제 무료 이용량    위 링크에서는 프리티어 요금제의 서비스별 사용량을 확인 할 수 있습니다.   그럼, 제 청구서를 부검해보며 저는 어떤 실수를 했길래 요금을 지불했는지 알아보겠습니다.   EC2와 RDS     EC2의 경우,  750시간은 free tier가 정상적으로 적용되었지만, 추가로 403시간의 비용이 청구 되었습니다. EC2의 인스턴스에서 사용한 EBS에서는 30GB의 용량을 추가로 사용한 비용이 청구 되었습니다. ElasticIP에서도 동일하게 요금이 청구 되었지만, 이는 뒤에서 따로 다루도록 하겠습니다.     RDS를 한번 볼까요? RDS의 경우, 750시간은 프리티어로 처리되었고, 731시간이 청구되었네요. 마찬가지로 RDS에서 사용하는 Storage에서도 기본 프리티어 사용량인 20기가는 프리티어로 처리되었지만, 나머지는 요금이 청구되었습니다.   왜 프리티어인데도 요금이 발생 했을까요?      위 사진을 보면 제가 사용한 EC2와 RDS의 경우, 월당 750시간만큼이 무료로 제공됩니다. 물론 이 시간은 인스턴스 하나당 시간으로 적용되므로, 만약 저처럼 2개의 인스턴스를 사용하면 개당 375시간으로 적용되기 때문에, 보름정도의 시간이 지나고 나면, 남은 보름에 대해서는 요금을 지불해야 합니다.   마찬가지로, EBS와 Storage도 프리티어 당 정해진 시간이 존재하고, 이 둘은 EC2나 RDS의 인스턴스를 만들면 함께 생성되기 때문에, 이 둘도 동일하게 프리티어 이상의 사용 요금을 지불해야 했죠.   저의 경우는 이 사실을 모르고 인스턴스를 2개씩 만들었기 때문에, 프리티어 제공 시간을 초과한 보름 동안의 사용비용이 청구된 것 입니다.   Elastic IP   EC2를 이용해 웹서버를 호스팅 하게 되면, EC2가 항상 같은 ip주소로 동작하게 하기 위해서 고정 아이피를 발급 받고 이를 EC2에 연결하여 사용하게 되는데요. 이를 연결하지 않는경우, 또는 연결된 상태일지라도 EC2가 멈춰 있는 상태라면 요금이 부과됩니다.      위 사진을 보면 첫번째 아이피는 EC2에 할당이 되어있지만, 두번째 아이피는 할당이 되어있지 않습니다. 이 경우에 요금이 부과됩니다. 물론 EC2에 연결되어 있는 상태더라도, EC2인스턴스가 멈춘 상태라면 요금이 부과됩니다.   RDS 인스턴스가 유료 옵션이 선택된 인스턴스로 만들어질 경우  이 항목은 이번에 제가 실수하지는 않은 항목이지만, 이 경우에도 비용이 발생합니다.   RDS 생성 시 멀티 AZ 옵션을 사용하도록 체크하면, 별도의 추가 비용이 발생합니다. 이 옵션은 데이터베이스를 만들때 기본으로 YES로 설정되어 있기 때문에 이 기능이 별도로 필요하시지 않고, 온전히 무료로 프리티어로 사용하고 싶다면 해당 옵션을 꼭 꺼주셔야 합니다.      위의 방법들만 꼼꼼히 체크한다면, 안전하게 프리티어 요금제를 무료로 사용할 수 있습니다. 하지만 더 안전한 방법은, 내가 생각한 요금보다 큰 요금이 발생했을 때, 최대한 빠르게 알아채는 것입니다. 사람은 누구나 실수를 하니까요.   유료옵션을 실수로 설정했을 때는 물론이고 실수로 트래픽이 과도하게 발생하는 코드를 짰거나, 해킹을 당했을때도 이를 바로 알 수 있다면 즉시 인스턴스를 종료하여 요금 폭탄을 피할 수 있을 것입니다. 저도 만약 알림을 설정해놓았다면, 제가 유료옵션을 실수로 선택했다는 것을 훨씬 빠르게 알아채고 대응하여 요금을 지불할 일이 없었겠죠. 그럼 이번에는 AWS의 요금 알림을 설정하는 법에 대해 알아보겠습니다.   가장 좋은 것은 미리 알아 채는 것  AWS는 이러한 일들을 사용자가 겪지 않도록 하기 위해, Budget, 예산을 설정할 수 있습니다. 서비스의 예산을 정해 놓음으로써, 해당 예산의 일정 퍼센테이지 이상 금액이 발생하면, 바로 사용자에게 알림이 가는것이죠.   AWS 오른쪽 위에 아이디를 눌러 결제 대시보드로 이동합시다.     왼쪽에 보면 여러가지 결제 관련 메뉴들이 있습니다. 여기서 Budget으로 이동해 줍시다.     이 곳에서는 예산을 작성하고, 해당 예산의 일정 퍼센테이지 이상의 요금이 발생하면 메일로 알림을 받을 수 있게 됩니다.   오른쪽 위에 예산 작성 을 눌러 예산을 작성해봅시다.     예산을 다양한 옵션으로 작성할 수 있습니다. 저는 프리티어 요금제를 완전히 무료로 사용하기 위해서 1달러만 비용이 발생해도 알림이 오도록 하기위해, 비용 예산을 선택하겠습니다.     예산 이름은 FreeTier로 하고, 예산 금액을 1달러로 하겠습니다. Budget scope는 모든 AWS 서비스를 대상으로 해서, 모든 서비스의 총합 예산을 1달러로 설정합니다.     이제 알림을 설정하는데, 임계값을 절대값으로 하고 0.1달러의 비용만 발생해도 알림이 오도록 해주겠습니다.이메일 수신자에는 제 이메일을 입력하는데, 쉼표로 구분해주면 알림을 여러개의 이메일로 오도록 할 수도 있습니다.   이제 예산을 작성을 완료했으므로, 제 AWS에서 만약 0.1달러의 요금이라도 발생하게되면 저는 이메일로 이를 알고 대응 할 수 있게 되었습니다.   이미 지불한 비용은…?  실수로 발생한 비용이라 수업료로 생각하자는 마음이 들면서도 실수로 결제된 금액이 너무 아까워 인터넷을 찾아보니, AWS는 개인계정에 한해서 1회정도는 실수에 대한 요금을 환불해준다고 합니다.   게다가 학생의 경우는 조금 더 너그럽게 실수를 처리해준다고 하는데, 인터넷 검색을 하다가 어떤 분께서는 거의 천만원이 넘는 비용을 무료로 처리해준 케이스도 있었습니다. 정말 미국 대기업답게 시원 시원하네요…   다만 기업계정의 경우 얄짤 없다고 하니, 직장에서 AWS를 사용한다면 조심 또 조심 해야 할 것 같습니다.   그래서 잠시 고민에 잠겨 이번에는 수업료로 가볍게 지불하고, 혹여나 나중에 해킹을 당하거나, 코드 실수를 해서 한 천만원 이렇게 나왔을 때 환불찬스를 써야하나… 하는 생각이 잠깐 들었지만, 이번에 환불 받고 앞으로는 철저히 AWS 관리를 해서 이런 일이 발생하지 않도록 노력 하기로 했습니다.   AWS 지원센터로 가서 환불요청을 하면 되는데요, 중요한점은 문의하기전 반드시 해당 실수가 일어난 부분들을 정상으로 돌려놓은 뒤에 문의해야 합니다.     저는 다음과 같이 요청했는데요, 학생임을 인증하기 위해서 학생증까지 첨부하였습니다… 부끄러운 실력으로 영어로 한자 한자 적었는데, 나중에 알고보니 한국어로 작성해도 상관없다고 합니다;   문의를 할 때는 제목은 refund request로 간결하게 적고, 카테고리는  Billing, Charge Inquiry로 설정하고 문의를 남기면 됩니다.   이것으로 아마존의 넓은 아량을 믿고 제발 환불이 되기를 바라면서 제 청구서 부검을 마치고, 아직 승인이 나지 않았지만 만약 환불이 된다면 게시물에 추가하도록 하겠습니다.   ","categories": ["ETC"],
        "tags": [],
        "url": "/etc/AWS-%ED%94%84%EB%A6%AC%ED%8B%B0%EC%96%B4-%EC%9A%94%EA%B8%88-%EA%B2%B0%EC%A0%9C%EB%90%98%EC%97%88%EC%9D%84-%EB%95%8C/",
        "teaser": null
      },{
        "title": "코로나 확진되다",
        "excerpt":"2022.04.04  어제부터 목이 아프다 싶어서 오늘 병원에 가서 신속항원검사를 받았는데, 아니나 다를까 코로나에 걸렸다. 사실 어제 여자친구가 목이 아프다고 자가검사 키트를 했다가 두줄이 나와서, 아 나도 코로나겠구나 하고 있었다.   아니 근데 어제도 그렇고 오늘 아침에도 그렇고 나는 키트에서 계속 한줄이 나와서, 아니 아무리 봐도 코로나가 아닐수도 없는 시기에 증상인데 미심쩍다 싶어서 그냥 병원을 갔더니 바로 양성이 나왔다.   증상은 사실 오늘 이틀차라 그런가 원래 경증인건가 코랑 목이 조금 아픈것 빼고는 두통이라던가 아픈건 아직 없다. 어깨 부분에 살짝 통증도 있긴 하지만 이것도 뭐 그냥 버틸만한 수준이다. 사실 내심 아 나는 백신이 잘 작동하고 있나보다~ 했는데 얄짤 없이 걸려버렸다.   어차피 뭐 이제 위드코로나를 정말 정말 코앞에 두고 있는데, 어차피 이렇게 풍토병화 하려면 한번쯤은 무조건 걸리게 되어있으니  뭐, 나름 타이밍이 나쁘지 않게 걸렸다는 생각이다. 증상도 크지도 않고… 근데 귀찮은건 격리인데, 아빠 직장은 동거인 확진이면 그냥 얄짤 없이 일주일 쉰다고 해서 비확진자인 아빠랑 일주일간 불편한 동거를 하게 생겼다;; 방에서만 7일 갖혀있을 생각에 답답하기도 하면서도 별로 안아프니까 평소에 못했던 공부나 열심히 해야겠다고 생각중이다.   근데 사실 생각해보니까 원래 맨날 방에서 격리 하고있었던 것 같기도하고;  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%BD%94%EB%A1%9C%EB%82%98-%ED%99%95%EC%A7%84%EB%90%98%EB%8B%A4/",
        "teaser": null
      },{
        "title": "건강관리",
        "excerpt":"2022.04.05  이틀간 코로나로 일어나면 목이 찢어질듯한 고통과 함께 코가 쓰리고 하루종일 피곤해서 뭘 할 수가 없다..   그나마 토익이라도 간간히 참아가며 풀고있는중인데, 쉬어야지 하면서도 지나가는 시간들이 너무 아깝다…   사람이 건강할 때는 건강이 원래 내게 주어진 무한한 재산인것 처럼 배팅하고 다니다가 항상 건강을 잃고나서야 사실은 건강이 가장 중요한것이 었다는 것을 깨닫는다.   하루 20시간 일해서 일주일을 앓아눕느니, 하루 8시간씩 일주일동안 열심히 하는게 훨씬 효율적이다.   물론 지금 나야 코로나 옮은거라 어쩔 수 없다지만, 앞으로도 건강관리 진짜 열심히 하면서 살아야겠다… 백억있어도 건강하지 못하면 그게 다 무슨 소용이냐.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B1%B4%EA%B0%95%EA%B4%80%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[AWS] 환불 완료 후기",
        "excerpt":"환불 완료  오늘 AWS에서 드디어 환불이 완료되었습니다.   물론 문의 글 하나만에 되지는 않았고, 살짝 몇가지 과정들을 거쳤는데요. 이를 간단하게 적어보려고 합니다.   첫번째 답장     첫번 째 답장은 아래 네가지 질문에 답해 달라고 하셨습니다.      언제 요금이 부과된 사실을 알게 되었는지   요금을 멈추기 위해 어떠한 행동을 취했는지   계속 해당 계정에서 동일한 서비스를 이용할 계획이 있는지   어느 청구서에 요금 조정이 필요한지   아마 요금이 발생한게 정말 실수인 것인지, 알아차린 즉시 요금이 발생하지 않기위한 행동을 취했는지를 확인하려고 물어보는 질문 같았습니다.   그래서 저는 다음과 같이 답장을 보냈습니다.         언제 요금이 부과된 사실을 알게 되었는지   카드 결제가 되고나서야 깨달았습니다. 하지만 이제 AWS의 예산 알람기능에 대해 숙지 했기 때문에, 이런일이 다시 발생하지 않도록 약속하겠습니다.      요금을 멈추기 위해 어떠한 행동을 취했는지   즉시 제 콘솔로가서 요금이 왜 청구되었는지 확인하였고, 웹사이트를 통해서 프리티어 옵션이 하나의 인스턴스당 750시간만을 지원한다는것을 알게되었습니다. 그리고 바로 EC2와 RDS의 인스턴스를 삭제 하였습니다.      계속 해당 계정에서 동일한 서비스를 이용할 계획이 있는지   프리티어가 종료되기전까지 계속 해당 서비스를 이용할 것이나. 무료로 제공되는 기능만 사용하려고 합니다. 그래서 앞으로는 하나의 인스턴스만 사용할것입니다.      어느 청구서에 요금 조정이 필요한지   3월 청구서에 조정이 필요합니다.   이렇게 답장을 보내고, 또 하루정도를 기다렸습니다.   두번째 답장  !   두번째 답장에서는 요금조정을 위해서는 현재 요금이 발생되고있는 DB 스냅샷 삭제가 필요하다는 연락과 함께, DB스냅샷 삭제 방법이 적혀있는 링크를 받았습니다.   저는 요금이 발생하는 것들을 모두 삭제했다고 생각 했는데, 인스턴스는 생성할 때 반드시 함께 이를 복구할 수 있는 스냅샷이 함께 생성됩니다.   인스턴스를 삭제해도 해당 스냅샷은 남아있으니, 사용하지 않는 인스턴스라면 반드시 삭제 후에 해당 인스턴스의 스냅샷도 같이 삭제해주어야합니다.      스냅샷 삭제 방법 링크    따라서 위 링크에 나와있는 방법대로, 제 RDS에 있는 DB스냅샷을 삭제한 후 다시 삭제완료 답장을 보냈습니다.      그리고 하루가 또 지난 후…        답변과 함께 드디어 환불이 완료되었습니다!   후기  너무 안일하게 AWS를 사용하던 것에 후회함과 동시에, 천조국 대기업인 아마존의 넓은 아량에 감사하게되는 기회였습니다… 앞으로는 조심 또 조심하고 알람기능을 항상 활성화 시켜서, 혹시나 발생할 문제들에 대비할 수 있도록 노력해야겠습니다.   ","categories": ["ETC"],
        "tags": [],
        "url": "/etc/AWS-%ED%99%98%EB%B6%88-%EC%99%84%EB%A3%8C-%ED%9B%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 주차요금 계산 (Python3)",
        "excerpt":"문제 설명  주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다.          요금표  |기본 시간(분)|\t기본 요금(원)|\t단위 시간(분)|\t단위 요금(원)|  |—|—|—|—|  |180\t|5000|\t10\t|600|            입/출차 기록                      시각(시:분)       차량 번호       내역                       05:34       5961       입차                 06:00       0000       입차                 06:34       0000       출차                 07:59       5961       출차                 07:59       0148       입차                 18:59       0000       입차                 19:09       0148       출차                 22:59       5961       입차                 23:00       5961       출차              자동차별 주차 요금                                   차량 번호           누적 주차 시간(분)           주차 요금(원)                                           0000           34 + 300 = 334           5000 + ⌈(334 - 180) / 10⌉ x 600 = 14600                             0148           670           5000 +⌈(670 - 180) / 10⌉x 600 = 34400                             5961           145 + 1 = 146           5000                           어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다.            0000번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다.           00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다.   누적 주차 시간이 기본 시간이하라면, 기본 요금을 청구합니다.   누적 주차 시간이 기본 시간을 초과하면, 기본 요금에 더해서, 초과한 시간에 대해서 단위 시간 마다 단위 요금을 청구합니다.            초과한 시간이 단위 시간으로 나누어 떨어지지 않으면, 올림합니다.       ⌈a⌉ : a보다 작지 않은 최소의 정수를 의미합니다. 즉, 올림을 의미합니다.           주차 요금을 나타내는 정수 배열 fees, 자동차의 입/출차 내역을 나타내는 문자열 배열 records가 매개변수로 주어집니다. 차량 번호가 작은 자동차부터 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요.   제한사항     fees의 길이 = 4            fees[0] = 기본 시간(분)       1 ≤ fees[0] ≤ 1,439       fees[1] = 기본 요금(원)       0 ≤ fees[1] ≤ 100,000       fees[2] = 단위 시간(분)       1 ≤ fees[2] ≤ 1,439       fees[3] = 단위 요금(원)       1 ≤ fees[3] ≤ 10,000           1 ≤ records의 길이 ≤ 1,000            records의 각 원소는 “시각 차량번호 내역” 형식의 문자열입니다.       시각, 차량번호, 내역은 하나의 공백으로 구분되어 있습니다.       시각은 차량이 입차되거나 출차된 시각을 나타내며, HH:MM 형식의 길이 5인 문자열입니다.                    HH:MM은 00:00부터 23:59까지 주어집니다.           잘못된 시각(“25:22”, “09:65” 등)은 입력으로 주어지지 않습니다.                       차량번호는 자동차를 구분하기 위한, `0’~’9’로 구성된 길이 4인 문자열입니다.       내역은 길이 2 또는 3인 문자열로, IN 또는 OUT입니다. IN은 입차를, OUT은 출차를 의미합니다.       records의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다.       records는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다.       같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다.       마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다.       아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다.                    주차장에 없는 차량이 출차되는 경우           주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우                           입출력 예                  fees       records       result                       [180, 5000, 10, 600]       [“05:34 5961 IN”, “06:00 0000 IN”, “06:34 0000 OUT”, “07:59 5961 OUT”, “07:59 0148 IN”, “18:59 0000 IN”, “19:09 0148 OUT”, “22:59 5961 IN”, “23:00 5961 OUT”]       [14600, 34400, 5000]                 [120, 0, 60, 591]       [“16:00 3961 IN”,”16:00 0202 IN”,”18:00 3961 OUT”,”18:00 0202 OUT”,”23:58 3961 IN”]       [0, 591]                 [1, 461, 1, 10]       [“00:00 1234 IN”]       [14841]           입출력 예 설명  입출력 예 #1  문제 예시와 같습니다.   입출력 예 #2   요금표                  기본 시간(분)       기본 요금(원)       단위 시간(분)       단위 요금(원)                       120       0       60       591           입/출차 기록                  시각(시:분)       차량 번호       내역                               16:00       3961               입차                 16:00       0202               입차                 18:00       3961               출차                 18:00       0202               출차                 23:58       3961               입차           자동차별 주차 요금                  차량 번호       누적 주차 시간(분)       주차 요금(원)                       0202       120       0                 3961       120 + 1 = 121       0 +⌈(121 - 120) / 60⌉x 591 = 591           3961번 차량은 2번째 입차된 후에는 출차된 내역이 없으므로, 23:59에 출차되었다고 간주합니다.   입출력 예 #3  요금표                  기본 시간(분)       기본 요금(원)       단위 시간(분)       단위 요금(원)                       1       461       1       10           입/출차 기록                  시각(시:분)       차량 번호       내역                       00:00       1234       입차           자동차별 주차 요금                  차량 번호       누적 주차 시간(분)       주차 요금(원)                       1234       1439       461 +⌈(1439 - 1) / 1⌉x 10 = 14841           1234번 차량은 출차 내역이 없으므로, 23:59에 출차되었다고 간주합니다.   구현해야할 기능     시간을 분으로 변경하는 기능   출차 시, 입차한 시간과 출차 시간을 넣으면 요금을 산출하는 기능   만약, 출차되지 않은 차가 남아있다면, 23:59분 출차로 처리하는 기능   1 2 3 4 5 6 7 8 9 10 import math  def get_cost(parking_time, standardTime, standardFee, unitTime, unitFee):     if parking_time &lt;= standardTime:         return standardFee          fee_time = math.ceil((parking_time- standardTime) / unitTime)                  return standardFee + fee_time * unitFee   1 2 3 4 5 6 7 8 def hour_to_minute(first_time, second_time):     hour1, hour2 = first_time[0:2], second_time[0:2]     minute1, minute2 = first_time[3:], second_time[3:]          hour = int(hour2) - int(hour1 )     minute = int(minute2) - int(minute1)          return hour*60 + minute   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def solution(fees, records):     standardTime = fees[0]     standardFee = fees[1]     unitTime = fees[2]     unitFee = fees[3]          time_dic = dict()     total_time_dic = dict()     cost_dic = dict()          answer = []          for record in records:         time, car_num, code = record.split()                  if code == \"IN\":             time_dic[car_num] = time         else:             parking_time = hour_to_minute(time_dic[car_num], time)             del time_dic[car_num]                          if car_num in total_time_dic:                 total_time_dic[car_num] += parking_time             else:                 total_time_dic[car_num] = parking_time          for record in time_dic.items():         time = record[1]         car_num = record[0]                            parking_time = hour_to_minute(time, \"23:59\")                          if car_num in total_time_dic:             total_time_dic[car_num] += parking_time         else:             total_time_dic[car_num] = parking_time               for record in total_time_dic.items():         cost_dic[record[0]] = get_cost(record[1], standardTime, standardFee, unitTime, unitFee)                for cost in sorted(cost_dic.items()):         answer.append(cost[1])     return answer           1 2 fees = [180, 5000, 10, 600] records = [\"05:34 5961 IN\", \"06:00 0000 IN\", \"06:34 0000 OUT\", \"07:59 5961 OUT\", \"07:59 0148 IN\", \"18:59 0000 IN\", \"19:09 0148 OUT\", \"22:59 5961 IN\", \"23:00 5961 OUT\"]   1 solution(fees, records)   1 [14600, 34400, 5000]   데이터를 가공해서 주어진 조건에 맞추어 가공하는 간단한 형식의 문제지만, 조건이 꽤나 까다롭고 헷갈리는 부분이 많아서 어려울 수 있는 문제였다.   이런류의 문제를 풀때는 하나의 함수에다 모든 기능을 때려넣기 보다는, 미리 구현해야할 기능을 생각하고 이를 함수로 나누어 구현하는게 훨씬 덜 헷갈리는 방법인 것 같다.   먼저 시간형식의 데이터를 분으로 가공해주는 함수와, 두개의 시간과, 기본요금, 기본시간, 단위요금, 단위시간의 다섯개의 파라미터를 넣으면 요금을 산출해주는 함수를 만들어주었다.   그리고 딕셔너리를 세개를 만들어주었는데, 먼저 들어온 데이터를 단순하게 [차번호 : 시각] 으로 담는 time_dic(),   출차 시 주차장 체류시간을 [차번호 : 체류시간] 형식으로 담는 total_time_dic(),  마지막으로 total_time_dic()에 있는 데이터들로 최종 요금을 계산하는 [차번호 : 최종요금] cost_dic()을 만들어주었다.   로직은 다음과 같다.   데이터가 들어오면 time_dic으로 저장하고 만약 출차 데이터라면 이를 불러와 해당 출차 시각과 비교하여 체류시간을 계산한 뒤,   이를 total_time_dic에 넣고 이제 해당 차량은 주차장에 없으니 time_dic에서 해당 차번호의 데이터를 삭제 한다.   모든 데이터의 입출입 데이터가 끝나면, 주차장에 남아있는 차들을 모두 꺼내어 “23:59”분 출차로 처리하여 위의 과정을 동일하게 반복한다.   total_time_dic에 있는 최종 체류시간의 총합들을 꺼내어 요금을 계산하여 cost_dic에 저장한뒤 이를 차 번호를 기준으로 오름차순 정렬하여 요금을 출력한다.   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%A3%BC%EC%B0%A8%EC%9A%94%EA%B8%88-%EA%B3%84%EC%82%B0/",
        "teaser": null
      },{
        "title": "[Programmers] 양궁대회 (Python3)",
        "excerpt":"문제 설명  카카오배 양궁대회가 열렸습니다.   라이언은 저번 카카오배 양궁대회 우승자이고 이번 대회에도 결승전까지 올라왔습니다. 결승전 상대는 어피치입니다.   카카오배 양궁대회 운영위원회는 한 선수의 연속 우승보다는 다양한 선수들이 양궁대회에서 우승하기를 원합니다. 따라서, 양궁대회 운영위원회는 결승전 규칙을 전 대회 우승자인 라이언에게 불리하게 다음과 같이 정했습니다.      어피치가 화살 n발을 다 쏜 후에 라이언이 화살 n발을 쏩니다.        점수를 계산합니다.              과녁판은 아래 사진처럼 생겼으며 가장 작은 원의 과녁 점수는 10점이고 가장 큰 원의 바깥쪽은 과녁 점수가 0점입니다.                 만약, k(k는 1~10사이의 자연수)점을 어피치가 a발을 맞혔고 라이언이 b발을 맞혔을 경우 더 많은 화살을 k점에 맞힌 선수가 k 점을 가져갑니다. 단, a = b일 경우는 어피치가 k점을 가져갑니다. k점을 여러 발 맞혀도 k점 보다 많은 점수를 가져가는 게 아니고 k점만 가져가는 것을 유의하세요. 또한 a = b = 0 인 경우, 즉, 라이언과 어피치 모두 k점에 단 하나의 화살도 맞히지 못한 경우는 어느 누구도 k점을 가져가지 않습니다.           예를 들어, 어피치가 10점을 2발 맞혔고 라이언도 10점을 2발 맞혔을 경우 어피치가 10점을 가져갑니다.            다른 예로, 어피치가 10점을 0발 맞혔고 라이언이 10점을 2발 맞혔을 경우 라이언이 10점을 가져갑니다.       1 3. 모든 과녁 점수에 대하여 각 선수의 최종 점수를 계산합니다. 3. 최종 점수가 더 높은 선수를 우승자로 결정합니다. 단, 최종 점수가 같을 경우 어피치를 우승자로 결정합니다.   현재 상황은 어피치가 화살 n발을 다 쏜 후이고 라이언이 화살을 쏠 차례입니다.  라이언은 어피치를 가장 큰 점수 차이로 이기기 위해서 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 구하려고 합니다.   화살의 개수를 담은 자연수 n, 어피치가 맞힌 과녁 점수의 개수를 10점부터 0점까지 순서대로 담은 정수 배열 info가 매개변수로 주어집니다. 이때, 라이언이 가장 큰 점수 차이로 우승하기 위해 n발의 화살을 어떤 과녁 점수에 맞혀야 하는지를 10점부터 0점까지 순서대로 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 만약, 라이언이 우승할 수 없는 경우(무조건 지거나 비기는 경우)는 [-1]을 return 해주세요.   제한사항     1 ≤ n ≤ 10   info의 길이 = 11            0 ≤ info의 원소 ≤ n       info의 원소 총합 = n       info의 i번째 원소는 과녁의 10 - i 점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.)           라이언이 우승할 방법이 있는 경우, return 할 정수 배열의 길이는 11입니다.            0 ≤ return할 정수 배열의 원소 ≤ n       return할 정수 배열의 원소 총합 = n (꼭 n발을 다 쏴야 합니다.)       return할 정수 배열의 i번째 원소는 과녁의 10 - i 점을 맞힌 화살 개수입니다. ( i는 0~10 사이의 정수입니다.)       라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해주세요.                    가장 낮은 점수를 맞힌 개수가 같을 경우 계속해서 그다음으로 낮은 점수를 더 많이 맞힌 경우를 return 해주세요.           예를 들어, [2,3,1,0,0,0,0,1,3,0,0]과 [2,1,0,2,0,0,0,2,3,0,0]를 비교하면 [2,1,0,2,0,0,0,2,3,0,0]를 return 해야 합니다.           다른 예로, [0,0,2,3,4,1,0,0,0,0,0]과 [9,0,0,0,0,0,0,0,1,0,0]를 비교하면[9,0,0,0,0,0,0,0,1,0,0]를 return 해야 합니다.                           라이언이 우승할 방법이 없는 경우, return 할 정수 배열의 길이는 1입니다.            라이언이 어떻게 화살을 쏘든 라이언의 점수가 어피치의 점수보다 낮거나 같으면 [-1]을 return 해야 합니다.           입출력 예                  n       info       result                       5       [2,1,1,1,0,0,0,0,0,0,0]       [0,2,2,0,1,0,0,0,0,0,0]                 1       [1,0,0,0,0,0,0,0,0,0,0]       [-1]                 9       [0,0,1,2,0,1,1,1,1,1,1]       [1,1,2,0,1,2,2,0,0,0,0]                 10       [0,0,0,0,0,0,0,0,3,4,3]       [1,1,1,1,1,1,1,1,0,0,2]           입출력 예 설명  입출력 예 #1   어피치와 라이언이 아래와 같이 화살을 맞힐 경우,                  과녁 점수       어피치가 맞힌 화살 개수       라이언이 맞힌 화살 개수       결과                       10       2       3       라이언이 10점 획득                 9       1       2       라이언이 9점 획득                 8       1       0       어피치가 8점 획득                 7       1       0       어피치가 7점 획득                 6       0       0                         5       0       0                         4       0       0                         3       0       0                         2       0       0                         1       0       0                         0       0       0                   어피치의 최종 점수는 15점, 라이언의 최종 점수는 19점입니다. 4점 차이로 라이언이 우승합니다.  하지만, 라이언이 아래와 같이 화살을 맞힐 경우 더 큰 점수 차로 우승할 수 있습니다.                  과녁 점수       어피치가 맞힌 화살 개수       라이언이 맞힌 화살 개수       결과                       10       2       0       어피치가 10점 획득                 9       1       2       라이언이 9점 획득                 8       1       2       라이언이 8점 획득                 7       1       0       어피치가 7점 획득                 6       0       1       라이언이 6점 획득                 5       0       0                         4       0       0                         3       0       0                         2       0       0                         1       0       0                         0       0       0                   어피치의 최종 점수는 17점, 라이언의 최종 점수는 23점입니다. 6점 차이로 라이언이 우승합니다.   따라서 [0,2,2,0,1,0,0,0,0,0,0]을 return 해야 합니다.   입출력 예 #2  라이언이 10점을 맞혀도 어피치가 10점을 가져가게 됩니다.   따라서, 라이언은 우승할 수 없기 때문에 [-1]을 return 해야 합니다.   입출력 예 #3  어피치와 라이언이 아래와 같이 화살을 맞힐 경우,                  과녁 점수       어피치가 맞힌 화살 개수       라이언이 맞힌 화살 개수       결과                       10       0       1       라이언이 10점 획득                 9       0       1       라이언이 9점 획득                 8       1       2       라이언이 8점 획득                 7       2       3       라이언이 7점 획득                 6       0       0                         5       1       2       라이언이 5점 획득                 4       1       0       어피치가 4점 획득                 3       1       0       어피치가 3점 획득                 2       1       0       어피치가 2점 획득                 1       1       0       어피치가 1점 획득                 0       1       0       어피치가 0점 획득           어피치의 최종 점수는 10점, 라이언의 최종 점수는 39점입니다. 29점 차이로 라이언이 우승합니다.   하지만 라이언이 아래와 같이 화살을 맞힐 경우,                  과녁 점수       어피치가 맞힌 화살 개수       라이언이 맞힌 화살 개수       결과                       10       0       1       라이언이 10점 획득                 9       0       1       라이언이 9점 획득                 8       1       2       라이언이 8점 획득                 7       2       0       어피치가 7점 획득                 6       0       1       라이언이 6점 획득                 5       1       2       라이언이 5점 획득                 4       1       2       라이언이 4점 획득                 3       1       0       어피치가 3점 획득                 2       1       0       어피치가 2점 획득                 1       1       0       어피치가 1점 획득                 0       1       0       어피치가 0점 획득           어피치의 최종 점수는 13점, 라이언의 최종 점수는 42점입니다. 이 경우도 29점 차이로 라이언이 우승합니다.   하지만, 첫 번째 경우와 두 번째 경우를 비교했을 때, 두 번째 경우가 두 경우 중 가장 낮은 점수인 4점을 더 많이 맞혔기 때문에 [1,1,2,3,0,2,0,0,0,0,0]이 아닌 [1,1,2,0,1,2,2,0,0,0,0]을 return 해야 합니다.   입출력 예 #4  가장 큰 점수 차이로 이기는 경우 중에서 가장 낮은 점수를 가장 많이 맞힌, 10~3점을 한 발씩 맞히고 나머지 두 발을 0점에 맞히는 경우인 [1,1,1,1,1,1,1,1,0,0,2]를 return 해야 합니다.   제한시간 안내  정확성 테스트 : 10초   요약     점수는 승자 독식, 해당 칸에 많이 맞춘 사람이 해당점수 만을 가져간다.   같은 개수의 화살을 맞췄을 경우 어피치가 점수를 가져감   둘다 못맞춘 칸에는 누구도 점수를 가져갈 수 없음   두명의 화살쏘기가 끝나고 최종 점수를 계산        최종점수가 같을 경우 어피치가 우승한다.       현재는 어피치가 모든 화살을 쏜 후임.        라이언이 어피치를 가장 큰 점수 차이로 이기기 위해서는 몇개의 화살을 어떤 과녁에 맞춰야 할까?            라이언이 가장 큰 점수 차이로 우승할 수 있는 방법이 여러 가지 일 경우, 가장 낮은 점수를 더 많이 맞힌 경우를 return 해준다.       라이언이 어떻게 화살을 쏘더라도 비기거나 이길 수 없다면 [-1]을 return해야한다.   1 2 n = 10 info = [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 3]   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def solution(n, info):     info = list(reversed(info))               score_board = [0,1,2,3,4,5,6,7,8,9,10]     answer = [0,0,0,0,0,0,0,0,0,0,0]          winning_case = []           for i in range(1,11):         for case in list(combinations(score_board, i)):             score = 0             arrow = n              for index in list(case):                 if (arrow - (info[index] + 1)) &gt;= 0:                     arrow -= (info[index] + 1)                     score += index                 else:                     break             else:                 appeach_score = compareScore(info, case)                  if appeach_score &lt; score:                     winning_case.append(case)                                               if len(winning_case) == 0:         return [-1]                top = -1     score_dif = 0          top_score_case_index = []          for i, case in enumerate(winning_case):                  if score_dif &lt;= sum(case) - compareScore(info, case):             score_dif = sum(case) - compareScore(info, case)          for i, case in enumerate(winning_case):         if score_dif == sum(case) - compareScore(info, case):             top_score_case_index.append(case)                            small = 12     answer_case_num = 0     for i, case in enumerate(top_score_case_index):         if case[0] &lt; small:             small = case[0]             answer_case_num = i                                           for i in top_score_case_index[answer_case_num]:         answer[i] = (info[i] + 1)              if n - sum(answer) &gt; 0:         answer[0] = n - sum(answer)                                                        return list(reversed(answer))   1 2 3 4 5 6 7 8 9 10 11 def compareScore(info, case):     score = 0     for i, n in enumerate(info):         if i in case or n == 0:             pass         else:             score += i     return score                      1 compareScore([0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2], (9,10))   문제풀이  카카오 문제는 너무 복잡하고 어려운 것 같다.   이 문제를 보고 처음에는 너무 복잡해서 생각을 많이 했는데, 결국 화살을 몇개 맞추냐보다는 어느 칸을 먹느냐에 따라 점수가 바뀌기 때문에 화살을 쏜다고 생각하지 않고 주어진 자원을 사용하는 땅따먹기라고 생각해보았다. 어차피 동점일 경우 무조건 어피치가 점수를 가져가므로, 라이언 입장에서는 무조건 어피치가 맞춘 화살보다 하나를 더 소모해야 해당 점수를 가져갈 수 있다.   그래서 score_board라는 점수판 배열을 하나 만들어준 뒤, combination으로 해당 점수판에서 나올 수 있는 모든 점수의 경우의 수를 가져와서 하나씩 처리 해보기로 했다.   예를 들어 점수판이 2점까지만 있는 점수판이라면, combination([0,1,2], i) 를 해서 for문으로 i를 3까지 증가시키며 모든 경우의수를 뽑아낸다.  이 경우에는 (0), (1), (2), (0,1), (0,2), (1,2), (0,1,2)의 7가지 경우의 수가 나올 것이다. 어차피 1만 더 높으면 해당 점수를 모두 가져가므로 이 점수판의 경우의 수를 내가 가져갈 수 있는 경우의 수로 생각하고, 이 점수판에 대한 어피치의 화살개수 + 1을 해서 해당 땅을 가져오는 방식으로 코드를 짜보았다.   그래서 이대로 코드를 짜서 가져온 경우의 수중에 n개의 활을 모두 사용한 케이스와 어피치보다 점수가 높은 케이스를 분류하여 이중에서 가장 작은 점수를 맞춘 케이스를 반환하도록 짰는데, 자꾸 마지막 테스트 케이스에 에러가 나서 확인해보니 이 전략은 무조건 어피치보다 1높게 활을 배분하여 점수를 가져오기 때문에, 어피치와의 점수차가 같은 케이스가 여러개라면 그중에 작은 숫자가 높은 것이 정답이 된다.   그래서 이 코드로는 0에 2개이상의 활을 투자한 케이스가 반환되지가 않아 마지막 테스트 케이스를 계속 실패했다.   그래서 코드를 찬찬히 뜯어보다 보니, 무조건 n개의 활을 모두 사용하게 한 if문이 문제가 된것 같아서, n개의 활을 모두 사용하지 못한 케이스도 가져온 뒤에 마지막부분에서 사용하지 못한 활은 무조건 0에 분배하도록 했더니 문제가 해결되었다.   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%EC%96%91%EA%B6%81%EB%8C%80%ED%9A%8C-(Python3)/",
        "teaser": null
      },{
        "title": "[Programmers] 수식 최대화 (Python3)",
        "excerpt":"문제 설명  IT 벤처 회사를 운영하고 있는 라이언은 매년 사내 해커톤 대회를 개최하여 우승자에게 상금을 지급하고 있습니다.  이번 대회에서는 우승자에게 지급되는 상금을 이전 대회와는 다르게 다음과 같은 방식으로 결정하려고 합니다.  해커톤 대회에 참가하는 모든 참가자들에게는 숫자들과 3가지의 연산문자(+, -, *) 만으로 이루어진 연산 수식이 전달되며, 참가자의 미션은 전달받은 수식에 포함된 연산자의 우선순위를 자유롭게 재정의하여 만들 수 있는 가장 큰 숫자를 제출하는 것입니다.   단, 연산자의 우선순위를 새로 정의할 때, 같은 순위의 연산자는 없어야 합니다.   즉, + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,-처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다. 수식에 포함된 연산자가 2개라면 정의할 수 있는 연산자 우선순위 조합은 2! = 2가지이며, 연산자가 3개라면 3! = 6가지 조합이 가능합니다.   만약 계산된 결과가 음수라면 해당 숫자의 절댓값으로 변환하여 제출하며 제출한 숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자를 우승상금으로 지급하게 됩니다.   예를 들어, 참가자 중 네오가 아래와 같은 수식을 전달받았다고 가정합니다.   “100-200*300-500+20”   일반적으로 수학 및 전산학에서 약속된 연산자 우선순위에 따르면 더하기와 빼기는 서로 동등하며 곱하기는 더하기, 빼기에 비해 우선순위가 높아 * &gt; +,- 로 우선순위가 정의되어 있습니다.  대회 규칙에 따라 + &gt; - &gt; * 또는 - &gt; * &gt; + 등과 같이 연산자 우선순위를 정의할 수 있으나 +,* &gt; - 또는 * &gt; +,- 처럼 2개 이상의 연산자가 동일한 순위를 가지도록 연산자 우선순위를 정의할 수는 없습니다.   수식에 연산자가 3개 주어졌으므로 가능한 연산자 우선순위 조합은 3! = 6가지이며, 그 중 + &gt; - &gt; * 로 연산자 우선순위를 정한다면 결괏값은 22,000원이 됩니다.  반면에 * &gt; + &gt; - 로 연산자 우선순위를 정한다면 수식의 결괏값은 -60,420 이지만, 규칙에 따라 우승 시 상금은 절댓값인 60,420원이 됩니다.   참가자에게 주어진 연산 수식이 담긴 문자열 expression이 매개변수로 주어질 때, 우승 시 받을 수 있는 가장 큰 상금 금액을 return 하도록 solution 함수를 완성해주세요.   제한사항     expression은 길이가 3 이상 100 이하인 문자열입니다.   expression은 공백문자, 괄호문자 없이 오로지 숫자와 3가지의 연산자(+, -, *) 만으로 이루어진 올바른 중위표기법(연산의 두 대상 사이에 연산기호를 사용하는 방식)으로 표현된 연산식입니다. 잘못된 연산식은 입력으로 주어지지 않습니다.            즉, “402+-561*“처럼 잘못된 수식은 올바른 중위표기법이 아니므로 주어지지 않습니다.           expression의 피연산자(operand)는 0 이상 999 이하의 숫자입니다.            즉, “100-2145*458+12”처럼 999를 초과하는 피연산자가 포함된 수식은 입력으로 주어지지 않습니다.       “-56+100”처럼 피연산자가 음수인 수식도 입력으로 주어지지 않습니다.           expression은 적어도 1개 이상의 연산자를 포함하고 있습니다.   연산자 우선순위를 어떻게 적용하더라도, expression의 중간 계산값과 최종 결괏값은 절댓값이 263 - 1 이하가 되도록 입력이 주어집니다.   같은 연산자끼리는 앞에 있는 것의 우선순위가 더 높습니다.   입출력 예                  expression       result                       “100-200*300-500+20”       60420                 “506-32”       300           입출력 예에 대한 설명  입출력 예 #1  * &gt; + &gt; - 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.  연산 순서는 아래와 같습니다.   100-200*300-500+20   = 100-(200*300)-500+20   = 100-60000-(500+20)   = (100-60000)-520   = (-59900-520)   = -60420                  따라서, 우승 시 받을 수 있는 상금은       -60420       = 60420 입니다.           입출력 예 #2  - &gt; * 로 연산자 우선순위를 정했을 때, 가장 큰 절댓값을 얻을 수 있습니다.   연산 순서는 아래와 같습니다.(expression에서 + 연산자는 나타나지 않았으므로, 고려할 필요가 없습니다.)   506-32   = 50(6-3)2   = (503)2   = 150*2   = 300   따라서, 우승 시 받을 수 있는 상금은 300 입니다.   요약     같은 순위의 연산자는 존재하지 않는다.   수식에 포함된 연산자가 n개라면 조합의 경우의 수는 n!이다.   계산결과가 음수라면 해당 숫자를 절댓값으로 변환하여 제출한다.   숫자가 가장 큰 참가자를 우승자로 선정하며, 우승자가 제출한 숫자가 상금이다.   1 expression = \"100-200*300-500+20\"   1 from itertools import permutations   1 2 3 4 5 6 7 8 9 10 11 def check_operator(expression):     operators = [\"*\", \"+\", \"-\"]          used_operators = []          for operator in expression:         if operator in operators:             if operator not in used_operators:                 used_operators.append(operator)          return used_operators   1 2 3 4 5 6 7 8 9 10 11 12 13 14 def separate(expression):     seperate_expression = []          word = \"\"     for i in expression:         if i.isdigit() == True:             word += i         else:             seperate_expression.append(word)             seperate_expression.append(i)             word = \"\"     seperate_expression.append(word)     return seperate_expression        1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 def calculate(case, separated_operator):     calculated_operator = []     is_calculated = False          for operator in case:         for i,component in enumerate(separated_operator):             if component == operator:                                  first = calculated_operator.pop()                 second = separated_operator[i+1]                                  answer = calculated_by_operator(operator,first, second)                 calculated_operator.append(answer)                 is_calculated = True             else:                 if is_calculated == False:                     calculated_operator.append(component)                 else:                     is_calculated = False                          separated_operator = calculated_operator         calculated_operator = []     return separated_operator   1 2 3 4 5 6 7 8 9 10 11 def calculated_by_operator(operator, first, second):     first = int(first)     second = int(second)     if operator == \"-\":         return first - second          if operator == \"*\":         return first * second          if operator == \"+\":         return first + second   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def solution(expression):     operators = check_operator(expression)          operators_case = list(permutations(operators, len(operators)))     # 연산자 경우의 수 순열           answer = []          separated_operator = separate(expression)     # 숫자와 연산자로 나누어 리스트로 변환          for case in operators_case:         answer.append(abs(calculate(case, separated_operator)[0]))          return max(answer)        1 solution(expression)   문제 풀이   먼저 해당 수식에 연산자가 어떤게 있는지 리스트로 뽑아주는 check_operator() 함수를 만들고, 이를 받아 permutations를 사용해 연산자가 가질 수 있는 우선순위의 경우의 수를 출력해주었다. 이 경우의 수를 하나씩 집어넣어 해당 위선순위 순서대로 계산하는 calculate() 함수를 만들어 결과 값을 리스트에 하나로 모아둔뒤 max() 함수를 통해 가장 큰값을 출력하면 된다.   문제를 풀고 프로그래머스로 가보니 너무 쉽게 푼 코드가 있어서 첨부해본다.   1 2 3 4 5 6 7 8 9 10 11 12 def solution(expression):     operations = [('+', '-', '*'),('+', '*', '-'),('-', '+', '*'),('-', '*', '+'),('*', '+', '-'),('*', '-', '+')]     answer = []     for op in operations:         a = op[0]         b = op[1]         temp_list = []         for e in expression.split(a):             temp = [f\"({i})\" for i in e.split(b)]             temp_list.append(f'({b.join(temp)})')         answer.append(abs(eval(a.join(temp_list))))     return max(answer)   내가 짠 긴 코드를 이렇게 풀수가 있었다…   이렇게까지 길이가 차이나는 것은 eval() 함수 때문인데, eval() 함수는 문자열로 들어온 명령을 실행해준다. expression을 정제할 필요 없이 그냥 eval에 넣기만 하면 실행되므로 코드가 확연히 줄어 들 수 밖에 없다.   하지만 eval() 함수는 실제 업무에서는 절대 사용해서는 안되는 함수 중 하나인데, 만약 eval()은 수식 뿐만 아니라 그냥 문자열로 들어온 명령을 그대로 파이썬으로 실행하므로, 시스템의 정보를 불러오는 코드나 프로그램을 망치는 코드를 문자열로 이용자가 넣을 경우 보안에 크게 취약해질 수 있다고 한다. 그래도 코딩테스트에서는 맞추기만 하면 되는 경우가 대부분이니까 꼭 기억해놓도록 해야겠다.   그리고 정규표현식을 사용했다면 훨씬 코드를 깔끔하게 줄일 수 있었을 것 같다. 정규표현식은 맨날 배우고 까먹고 반복인데, 정규표현식을 사용할 줄 알고 모르고가 데이터를 가공하는데에 큰 차이가 나므로 반드시 다시 코테 전에 한번 더 공부해봐야겠다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%88%98%EC%8B%9D-%EC%B5%9C%EB%8C%80%ED%99%94/",
        "teaser": null
      },{
        "title": "[Programmers] 표 편집 (Python3)",
        "excerpt":"문제 설명  업무용 소프트웨어를 개발하는 니니즈웍스의 인턴인 앙몬드는 명령어 기반으로 표의 행을 선택, 삭제, 복구하는 프로그램을 작성하는 과제를 맡았습니다. 세부 요구 사항은 다음과 같습니다                  행번호       이름                       0       무지                 1       콘                 2       어피치 *                 3       제이지                 4       프로도                 5       네오                 6       튜브                 7       라이언           위 그림에서 파란색으로 칠해진 칸은 현재 선택된 행을 나타냅니다. 단, 한 번에 한 행만 선택할 수 있으며, 표의 범위(0행 ~ 마지막 행)를 벗어날 수 없습니다. 이때, 다음과 같은 명령어를 이용하여 표를 편집합니다.      “U X”: 현재 선택된 행에서 X칸 위에 있는 행을 선택합니다.   “D X”: 현재 선택된 행에서 X칸 아래에 있는 행을 선택합니다.   “C” : 현재 선택된 행을 삭제한 후, 바로 아래 행을 선택합니다. 단, 삭제된 행이 가장 마지막 행인 경우 바로 윗 행을 선택합니다.   “Z” : 가장 최근에 삭제된 행을 원래대로 복구합니다. 단, 현재 선택된 행은 바뀌지 않습니다.   예를 들어 위 표에서 “D 2”를 수행할 경우 아래 그림의 왼쪽처럼 4행이 선택되며, “C”를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 “네오”가 적힌 행을 선택합니다(4행이 삭제되면서 아래 있던 행들이 하나씩 밀려 올라오고, 수정된 표에서 다시 4행을 선택하는 것과 동일합니다).                  행번호       이름                       0       무지                 1       콘                 2       어피치                 3       제이지                 4       프로도 *                 5       네오                 6       튜브                 7       라이언                          행번호       이름                       0       무지                 1       콘                 2       어피치                 3       제이지                 4       네오 *                 5       튜브                 6       라이언           다음으로 “U 3”을 수행한 다음 “C”를 수행한 후의 표 상태는 아래 그림과 같습니다.  |행번호| 이름|  |:—:|:—:|  |0| 무지|  |1| 콘 * |  |2| 어피치|  |3| 제이지|  |4| 네오|  |5| 튜브|  |6| 라이언|                  행번호       이름                       0       무지                 1       어피치 *                 2       제이지                 3       네오                 4       튜브                 5       라이언           다음으로 “D 4”를 수행한 다음 “C”를 수행한 후의 표 상태는 아래 그림과 같습니다. 5행이 표의 마지막 행 이므로, 이 경우 바로 윗 행을 선택하는 점에 주의합니다.                  행번호       이름                       0       무지                 1       어피치                 2       제이지                 3       네오                 4       튜브                 5       라이언 *                          행번호       이름                       0       무지                 1       어피치                 2       제이지                 3       네오                 4       튜브 *           다음으로 “U 2”를 수행하면 현재 선택된 행은 2행이 됩니다.                  행번호       이름                       0       무지                 1       어피치                 2       제이지 *                 3       네오                 4       튜브           위 상태에서 “Z”를 수행할 경우 가장 최근에 제거된 “라이언”이 적힌 행이 원래대로 복구됩니다.                  행번호       이름                       0       무지                 1       어피치                 2       제이지 *                 3       네오                 4       튜브                 5       라이언           다시한번 “Z”를 수행하면 그 다음으로 최근에 제거된 “콘”이 적힌 행이 원래대로 복구됩니다. 이때, 현재 선택된 행은 바뀌지 않는 점에 주의하세요.                  행번호       이름                       0       무지                 1       콘                 2       어피치                 3       제이지 *                 4       네오                 5       튜브                 6       라이언           이때, 최종 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 “O”, 삭제된 행은 “X”로 표시하면 다음과 같습니다.                  행번호       이름                               0       무지       O                 1       콘       O                 2       어피치       O                 3       제이지       O                 4       프로도       X                 5       네오       O                 6       튜브       O                 7       라이언       O           처음 표의 행 개수를 나타내는 정수 n, 처음에 선택된 행의 위치를 나타내는 정수 k, 수행한 명령어들이 담긴 문자열 배열 cmd가 매개변수로 주어질 때, 모든 명령어를 수행한 후 표의 상태와 처음 주어진 표의 상태를 비교하여 삭제되지 않은 행은 O, 삭제된 행은 X로 표시하여 문자열 형태로 return 하도록 solution 함수를 완성해주세요.   제한사항     5 ≤ n ≤ 1,000,000   0 ≤ k &lt; n   1 ≤ cmd의 원소 개수 ≤ 200,000            cmd의 각 원소는 “U X”, “D X”, “C”, “Z” 중 하나입니다.       X는 1 이상 300,000 이하인 자연수이며 0으로 시작하지 않습니다.       X가 나타내는 자연수에 ‘,’ 는 주어지지 않습니다. 예를 들어 123,456의 경우 123456으로 주어집니다.       cmd에 등장하는 모든 X들의 값을 합친 결과가 1,000,000 이하인 경우만 입력으로 주어집니다.       표의 모든 행을 제거하여, 행이 하나도 남지 않는 경우는 입력으로 주어지지 않습니다.       본문에서 각 행이 제거되고 복구되는 과정을 보다 자연스럽게 보이기 위해 “이름” 열을 사용하였으나, “이름”열의 내용이 실제 문제를 푸는 과정에 필요하지는 않습니다. “이름”열에는 서로 다른 이름들이 중복없이 채워져 있다고 가정하고 문제를 해결해 주세요.           표의 범위를 벗어나는 이동은 입력으로 주어지지 않습니다.   원래대로 복구할 행이 없을 때(즉, 삭제된 행이 없을 때) “Z”가 명령어로 주어지는 경우는 없습니다.   정답은 표의 0행부터 n - 1행까지에 해당되는 O, X를 순서대로 이어붙인 문자열 형태로 return 해주세요.   정확성 테스트 케이스 제한 사항  5 ≤ n ≤ 1,000  1 ≤ cmd의 원소 개수 ≤ 1,000   효율성 테스트 케이스 제한 사항  주어진 조건 외 추가 제한사항 없습니다.   입출력 예  |n\t|k|\tcmd|\tresult|  |:—:|:—:|:—:|:—:|  |8\t|2|\t[“D 2”,”C”,”U 3”,”C”,”D 4”,”C”,”U 2”,”Z”,”Z”]\t|”OOOOXOOO”|  |8|\t2\t|[“D 2”,”C”,”U 3”,”C”,”D 4”,”C”,”U 2”,”Z”,”Z”,”U 1”,”C”]\t|”OOXOXOOO”|   입출력 예 설명  입출력 예 #1  문제의 예시와 같습니다.   입출력 예 #2  다음은 9번째 명령어까지 수행한 후의 표 상태이며, 이는 입출력 예 #1과 같습니다.                  행번호       이름                       0       무지                 1       콘                 2       어피치                 3       제이지 *                 4       네오                 5       튜브                 6       라이언           10번째 명령어 “U 1”을 수행하면 “어피치”가 적힌 2행이 선택되며, 마지막 명령어 “C”를 수행하면 선택된 행을 삭제하고, 바로 아래 행이었던 “제이지”가 적힌 행을 선택합니다.                  행번호       이름                       0       무지                 1       콘                 2       어피치 *                 3       제이지                 4       네오                 5       튜브                 6       라이언                          행번호       이름                       0       무지                 1       콘                 2       제이지 *                 3       네오                 4       튜브                 5       라이언           따라서 처음 주어진 표의 상태와 최종 표의 상태를 비교하면 다음과 같습니다.                  행번호       이름                               0       무지       O                 1       콘       O                 2       어피치       X                 3       제이지       O                 4       프로도       X                 5       네오       O                 6       튜브       O                 7       라이언       O           제한시간 안내  정확성 테스트 : 10초  효율성 테스트 : 언어별로 작성된 정답 코드의 실행 시간의 적정 배수   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def solution(n, k, cmd):     answer = ''      linked_list = {i: [i - 1, i + 1] for i in range(1, n+1)} #n=8일때 1~8까지     answer = [\"O\" for i in range(1,n+1)]     stack = []      k += 1      for c in cmd:         if c[0] == \"D\":             for _ in range(int(c[2:])):                 k = linked_list[k][1]                      if c[0] == \"U\":              for _ in range(int(c[2:])):                 k = linked_list[k][0]                      if c[0] == \"C\":             prev, next = linked_list[k]             answer[k-1] = \"X\"             stack.append([prev, next, k])                          if next == n+1:                 k = linked_list[k][0]             else:                 k = linked_list[k][1]                              if prev == 0:                 linked_list[next][0] = prev                          elif next == n+1:                 linked_list[prev][1] = next                              else:                 linked_list[prev][1] = next                  linked_list[next][0] = prev                  if c[0] == \"Z\":             prev, next, now = stack.pop()             answer[now-1] = \"O\"             if prev == 0:                 linked_list[next][0] = now                          elif next == n+1:                 linked_list[prev][1] = now                          else:                 linked_list[prev][1] = now                 linked_list[next][0] = now                           return \"\".join(answer)   문제풀이  어제 모의고사에서 정확성만 통과 했던 문제이다.  원래는 리스트로 풀었었는데, 효율성 테스트에서 너무 많이 시간차가 나서 아예 리스트로 풀어서는 효율성을 통과하지 못하는 테스트였다는 것을 알아채고 빠르게 4번으로 넘어갔어야 헀다는 생각이 들었다.   이 문제는 시간 복잡도를 만족시키려면 결국 링크드리스트로 풀이해야하는데, 링크드 리스트는 모든 배열이 연결되어 있어, 만약 3에 접근하고 싶으면 1, 2를 거쳐야만 3으로 갈 수 있다. 따라서 탐색에는 O(N)의 시간이 걸린다. 하지만 삭제와 삽입에는 언제나 O(1)의 시간복잡도를 갖기 때문에 이 문제와 같이 삭제를 하고 이를 기록해두었다가 다시 복구하는 기능에는 링크드리스트가 가장 효율적으로 문제를 해결 할 수 있는 구조였다.   클래스를 사용해서 링크드리스트를 만드는 방식과 내가 푼 풀이처럼 딕셔너리를 이용해서 푸는 방식이 있는데,   아무래도 딕셔너리를 사용하는 편이 코드가 간단해서 딕셔너리 방식으로 풀었다.   링크드 리스트로 해당 데이터 컬럼을 만들어 준뒤, 만약 삭제 요청이 들어오면 해당 데이터를 실제로 삭제하는 것이 아니라, 이전 노드와 다음노드의 관계를 끊어줌으로써 연관관계만 제거해 줄뿐 실제로 해당 데이터를 삭제하지는 않는다. 따라서 Z요청, 되돌리기 요청이 들어오면 해당 노드를 기억해놓다가 불러와서 다시 이전의 노드와 다음 노드의 연관관계를 이어주면 되기 때문에 Z요청을 처리 할때도 따로 탐색을 해서 위치를 바꿀 필요가 없다.   리스트에 시간복잡도를 묻는 문제가 나오면 꼭 링크드리스트로 구현하는게 더 효율적인지는 않는지 확인을 꼭 해봐야겠다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-%ED%91%9C-%ED%8E%B8%EC%A7%91-(Python3)/",
        "teaser": null
      },{
        "title": "산타 토익",
        "excerpt":"2022.04.17  최근에 영어공부의 필요성을 절실히 느껴서 어떻게 하면 영어를 잘 할 수 있을지에 대해서 여러가지를 고민해보았다. 처음에는 토익이나 토플같은 점수를 따는 것 보다는 그냥 혼자서 하고싶은말을 번역 해서 스피킹을 계속 한다던가, 뉴욕타임즈를 하루에 한개씩 읽겠다는 안일한 생각을 했는데 결국 편하게 공부하는 방법은 없었다.   국어도 우리가 같은 국어를 사용하고 있고, 누구나 말하고 읽고 쓸 수 있지만 결국에는 많은 텍스트를 접해보고 읽어본 사람이 더 많은 단어와 용법을 알고, 이는 더 높은수준의 어휘와 쓰기실력을 갖도록 해준다. 아이들이 한국어를 배울때도 읽기는 말하기와 별개로 따로 책을보며 숙달한다.   심지어 어떤 강사분께서는 토익 900점은 넘어야 스피킹과 라이팅을 할 수 있는 최소기준이 충족되었다고 할 수 있다는 것을 보고, 무조건 토익 점수부터 따야겠다는 생각이 들었다.   그래서 어차피 졸업하려면 필요하기도 했어서, 토익 공부를 시작했다. 사실 어학에 대해서 정말 관심이 없기도 했었고, 굳이 해외로 나가서 살것도 아닌데 기초적인 영어 지식만 있으면 되지않나 싶었지만 굳이 내 기회를 국내로 한정해서 사는것도 인생을 살면서 정말 큰 손해라는 생각이 들었다.   그리고 21세기 이후로 인터넷이 그야말로 정보의 바다가 되어 넘치고 있다지만, 사람들이 착각하는게 그 정보의 바다의 모든 것을 누릴 수 있는 사람은 영어를 읽고 들을 수 있는 사람들이다. 한국어만 읽을 줄 아는 사람은 정말 그 바다의 10분의 1만큼도 누리지 못한다. 어쩌면 이게 최근에 내가 영어공부를 시작하게된 가장 큰 계기가 되었다.   토익 점수를 어떻게 하면 올릴 수 있을까에 대해서 고민을 하면서, 우선 국룰인 해커스 토익을 열심히 풀고있었는데 사실 생각보다 너무 지루하고 효율이 잘 안나왔다. 하루에 그래머 파트 하나, 리딩 파트 하나, 이렇게 계속 한 2주일을 내리 풀었는데도 내가 진짜 실력이 늘었는지, 문제를 풀고있는건지 찍고있는건지 헷갈렸다.   그래서 여러가지 해결책을 알아보던 중, 산타 토익에 대해서 알게되었다. 사실 산타토익은 몇년전에 플랫폼에 관심이 있어서 본게 아니라, 산타토익의 핵심 기술인 적은 문제로도 머신러닝 기반으로 토익 점수를 예측하는 시스템에 대해서 CTO분이 설명하는 영상을 본 기억이 있었다. 빡빡이에 좀 특이하게 생기신 분이기도 했고, 정말 머신러닝에 대해 좀 이해도가 높으신 분이었어서 기억에 남기도 했고,   그래서 우선 모의고사를 한번 쳐봤는데, 예측점수가 무슨 500점이 나왔다… 사실 영어 실력이 형편없기도 했지만, 토익시험을 봐본게 2016년에 학교에서 모의토익 본게 다라, 유형들이 너무 낯설었다. 어쨌든 이 점수가 90퍼센트 정확도라고 하니, 받아들이고 대략 산타토익에 대해 알아보니까 120일 중에 80일만 출석과 함께, 500점인 사용자는 700점만 넘어도 100퍼센트 환급이라길래, 손해보는 장사는 아닐까 같아서 바로 결제했다. 그리고 현재는 너무너무 잘 사용하고 있다.   산타 토익의 장점을 꼽아보자면 다음과 같다.   첫번째로 점수 예측 시스템, 사실 이것이 산타토익의 핵심 기술이자 가장 만족도 높은 기능인데, 내가 공부를 하는 도중에 푼 문제들을 기반으로 내 토익 점수를 계속 예측해주어서, 기존에는 2시간 가량의 시험을 봐야만 내 시험점수를 알 수 있는 방식이 아니기 때문에 학습을 마칠때마다 내 예측 점수가 변동된다. 이는 90퍼센트의 정확도를 가진다고 하는데, 나는 아직 시험을 안봐서 정말 이게 내 점수인지는 잘 몰라도, 우선 매 학습마다 계량적인 점수로 피드백을 받을 수 있다는게 학습욕구를 매우 고취시킬 뿐더러, 효율적으로 공부할 수 있다.   두번째로는 AI추천 수업 시스템, 내가 많이 틀린 문제나 어려워하는 문제가 있으면 해당 유형의 강의를 추천해주는데, 이게 정말 기가막히다… 추천 강의를 풀어보면 정말 놀라울 정도로 내가 어려운 부분을 계속 찝어줘서, 단기간내에 점수를 올리는데에 매우 용이할 뿐만 아니라 영어 실력 자체도 빠르게 느는게 느껴진다.   반대로 단점을 몇개 꼽아보자면 적은 단어량과 모의고사 정도? 단어가 좀 더 많아지고 모의고사도 좀 여러개로 늘었으면 좋겠다.   어쨌던 산타토익을 하고나서 현재 예측점수는 한 820점인데, 원래는 한 750점이 목표였지만 생각보다 점수가 빨리올라서 지금은 좀 빡세게 만점을 목표로 공부해보고 있다. 120일 패키지가 끝날때즈음에 몇점일지 모르겠지만, 목표점수까지 120일 안에 끝내는 것을 목표로 하고있다.   쓰다보니까 무슨 돈받고 쓰는 후기글 같아졌는데, 진짜 이거 쓴다고 내가 혜택보는거 1도 없으니까  혹시 산타토익 고민하는 사람있으면 정말 추천하고, 혹시나 토익시험 앞두고 있는 분들은 이왕 돈쓸거 산타토익에 쓰고 열심히해서 환급받는걸 추천한다!   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%82%B0%ED%83%80-%ED%86%A0%EC%9D%B5/",
        "teaser": null
      },{
        "title": "[Programmers] K진수에서 소수 개수 구하기 (Python3)",
        "excerpt":"문제 설명  양의 정수 n이 주어집니다. 이 숫자를 k진수로 바꿨을 때, 변환된 수 안에 아래 조건에 맞는 소수(Prime number)가 몇 개인지 알아보려 합니다.     0P0처럼 소수 양쪽에 0이 있는 경우   P0처럼 소수 오른쪽에만 0이 있고 왼쪽에는 아무것도 없는 경우   0P처럼 소수 왼쪽에만 0이 있고 오른쪽에는 아무것도 없는 경우   P처럼 소수 양쪽에 아무것도 없는 경우            단, P는 각 자릿수에 0을 포함하지 않는 소수입니다.  예를 들어, 101은 P가 될 수 없습니다.  예를 들어, 437674을 3진수로 바꾸면 211020101011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 왼쪽부터 순서대로 211, 2, 11이 있으며, 총 3개입니다. (211, 2, 11을 k진법으로 보았을 때가 아닌, 10진법으로 보았을 때 소수여야 한다는 점에 주의합니다.) 211은 P0 형태에서 찾을 수 있으며, 2는 0P0에서, 11은 0P에서 찾을 수 있습니다.           정수 n과 k가 매개변수로 주어집니다. n을 k진수로 바꿨을 때, 변환된 수 안에서 찾을 수 있는 위 조건에 맞는 소수의 개수를 return 하도록 solution 함수를 완성해 주세요.   제한사항     1 ≤ n ≤ 1,000,000   3 ≤ k ≤ 10   입출력 예                  n       k       result                       437674       3       3                 110011       10       2           입출력 예 설명   입출력 예 #1  문제 예시와 같습니다.   입출력 예 #2  110011을 10진수로 바꾸면 110011입니다. 여기서 찾을 수 있는 조건에 맞는 소수는 11, 11 2개입니다. 이와 같이, 중복되는 소수를 발견하더라도 모두 따로 세어야 합니다.   제한시간 안내  정확성 테스트 : 10초   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def solution(n, k):     tmp = \"\"     answer = 0     while n:         tmp += str(n % k)         n =  n // k     tmp = \"\".join(list(reversed(tmp)))          for i in tmp.split(\"0\"):         if i == \"\":             continue         if is_prime_num(int(i)):             answer += 1                   return answer   1 2 3 4 5 6 7 8 9 10 import math  def is_prime_num(n):     for i in range(2, int(math.sqrt(n))+1): # n의 제곱근을 정수화 시켜준 후 + 1         if n % i == 0:             return False     if n == 1:         return False      return True   문제 풀이  이게 왜 2레벨…?  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/Programmers-K%EC%A7%84%EC%88%98%EC%97%90%EC%84%9C-%EC%86%8C%EC%88%98-%EA%B0%9C%EC%88%98-%EA%B5%AC%ED%95%98%EA%B8%B0(Python3)/",
        "teaser": null
      },{
        "title": "[programmers] 불량사용자  (python3)",
        "excerpt":"문제 설명  개발팀 내에서 이벤트 개발을 담당하고 있는 “무지”는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 “프로도” 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 ‘’ 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 ‘’ 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 ‘*’ 문자를 사용하였습니다.   “무지”와 “프로도”는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다.   예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면                  응모자 아이디                       frodo                 fradi                 crodo                 abc123                 frodoc           다음과 같이 불량 사용자 아이디 목록이 전달된 경우,                  불량 사용자                       frd                 abc1**           불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다.                  제재 아이디                       frodo                 abc123                          제재 아이디                       fradi                 abc123           이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.   제한사항     user_id 배열의 크기는 1 이상 8 이하입니다.   user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.            응모한 사용자 아이디들은 서로 중복되지 않습니다.       응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.           banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다.   banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.            불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 ‘*’ 로만 이루어져 있습니다.       불량 사용자 아이디는 ‘*’ 문자를 하나 이상 포함하고 있습니다.       불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.           제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.   입출력 예                  user_id       banned_id       result                       [“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]       [“frd”, “abc1**”]       2                 [“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]       [“rodo”, “rodo”, “**”]       2                 [“frodo”, “fradi”, “crodo”, “abc123”, “frodoc”]       [“frd”, “rodo”, “**”, “***”]       3           입출력 예에 대한 설명  입출력 예 #1  문제 설명과 같습니다.   입출력 예 #2  다음과 같이 두 가지 경우가 있습니다.                  제재 아이디                       frodo                 crodo                 abc123                          제재 아이디                       frodo                 crodo                 frodoc           입출력 예 #3  다음과 같이 세 가지 경우가 있습니다.                  제재 아이디                       frodo                 crodo                 abc123                 frodoc                          제재 아이디                       fradi                 crodo                 abc123                 frodoc                          제재 아이디                       fradi                 frodo                 abc123                 frodoc           1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import re from itertools import permutations def solution(user_id, banned_id):     num = [[] for i in range(0,len(banned_id))]          rule = []      for id in banned_id:         fomular = \"\"         for i in id:             if i == \"*\":                 fomular += \".\"             else:                 fomular += i         rule.append(fomular)     comb = list(permutations(user_id, len(banned_id)))          answer = []           for case in comb:         for i, c in enumerate(case):             p = re.compile(rule[i])             if not p.match(c) or len(c) != len(rule[i]):                 break         else:             answer.append(set(case))                   new = []     for i in answer:         if i not in new:             new.append(i)     answer = new     return len(answer)   정규 표현식을 사용한 문제이다.   불량 사용자들의 아이디를 정규표현식에 맞추어 * 를 . 으로 바꿔준 뒤, 리스트에 넣어서 저장해준다.   그리고 유저아이디중에서 banned_id 개수만큼 뽑는 모든 경우의 수를 순열로 뽑아준다. 이렇게 뽑은 경우의 수를 위에서 만든 정규표현식 리스트와 비교해주는데, 해당 자리에 맞는 정규표현식을 불러와서 비교해준다. 만약 하나라도 자신의 자리의 정규표현식과 매치되지 않는다면, break된다.   break되지 않은 경우의 수는 answer에 저장한다.   마지막으로 answer에 있는 경우의 수 중에서 중복된 값들을 제거해주면, banned_id에 해당하는 아이디 조합의 경우의 수를 모두 구할 수 있다.  ","categories": [],
        "tags": [],
        "url": "/Programmers-%EB%B6%88%EB%9F%89%EC%82%AC%EC%9A%A9%EC%9E%90-(Python3)/",
        "teaser": null
      },{
        "title": "[JPA] 영속성 컨텍스트 (1)",
        "excerpt":"영속성 컨텍스트란?  영속성 컨텍스트는 쉽게 풀이하면 “엔티티를 영구 저장하는 환경” 이라는 뜻입니다.   이렇게 정의로만 놓고보면, DB에 엔티티를 저장하는데, DB가 바로 영속성 컨텍스트 아닌가? 하는 생각도 드실 겁니다.   이처럼 영속성 컨텍스트는 JPA에서 가장 중요한 개념이자 헷갈리기 쉬운 개념일 수 있는데요. 아무래도 눈에 보이지 않아서 헷갈리는 부분이 큽니다. 그렇다면 영속성 컨텍스트에 대해서 알아봅시다.   EntityManagerFactory 와 EntityManager  JPA는 데이터 베이스에 접근하기 위해서 EntityManager를 사용합니다. 말그대로 Entity관리자인 셈이죠. JPA는 우리가 데이터베이스를 객체지향적으로 사용할 수 있도록 도와주기 때문에, JPA에서 Entity는 곧 테이블입니다. 따라서 이에 접근하기 위해 도와줄 매니저가 한 명 필요한 것인데요, 이 Entity매니저는 저장, 수정, 삭제, 조회등 Enity에서의 관련된 모든일을 처리합니다.   이러한 매니저들을 만드는 공장이 바로 EntityManagerFactory입니다. 고객의 요청이 들어올때 마다 EntityManager를 한명씩 붙여주고, 이들이 테이블을 관리하게 해주는 것이죠.   공장은 말그대로 공장이니, 규모가 크고  지으려면 오래 걸릴 것입니다. 그래서 반드시 하나의 데이터베이스에는 하나의 공장만을 지어주어야 합니다. 공장을 여러개 짓게 되면 프로그램의 속도가 크게 저하 될 수 있습니다.   그럼 공장을 생성하는 방법을 한번 코드로 작성해볼까요?   1 EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");  이렇게 하면 우리는 EntityManager들을 생산할 공장을 아주 쉽게 만들 수 있습니다.   여기서 createEntityManagerFactory의 파라미터로 들어오는 값은 JPA를 설정할 때 했던 설정파일인persistence.xml 파일에 있는 persistenceUnitName을 적어주면 됩니다.   그럼 데이터베이스에 접근하기 위해서는 여기 공장에서 매니저를 생산해서 데리고 와야 접근이 가능하다고 했던 내용이 기억나실 것 입니다. 이 공장에서 매니저를 생산하려면 어떻게 하면 될까요?   아래와 같이 생산하시면 됩니다.   1 EntityManager em = emf.createEntityManager();  우리는 이제 EntityManager 라는 클래스를 갖는 em이라는 이름의 매니저를 한명 생산한 것 입니다. 이제 이 매니저의 도움으로 우리는 우리의 데이터베이스에 접근 할 수 있게 되었습니다.   자 그럼 어떻게 하면 우리가 만든 객체를 데이터베이스에 넣을 수 있을까요? 한번 Member라는 클래스를 만들고 이를 Entity로 지정하여 데이터베이스에 넣어 봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Entity public class Member {     @Id     private Long id;          String name;          String age;            public Long getId() {         return id;     }      public void setId(Long id) {         this.id = id;     }      public String getName() {         return name;     }      public void setName(String name) {         this.name = name;     }      public String getAge() {         return age;     }      public void setAge(String age) {         this.age = age;     } }   간단하게 id와 이름, 나이 정도만 있는 Member라는 클래스를 만들어주어 봅시다.  간편하게 값을 가져오고 세팅하기 위해 Getter와 Setter도 모두 만들어 주도록 하겠습니다.   이제 이 상태로 main 함수를 실행 시켜 볼까요??      아까 Entity는 곧 데이터베이스에서 테이블이라고 했습니다. 그런데 Entity로 분명 Member를 지정해주었는데, 아무런 테이블도 생성되지 않았네요. 왜일까요?   그럼 이번에는 EntityManagerFactory를 하나 한번 만들어볼까요?   1 2 3 4 5 6 public class JpaMain {     public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         emf.close()     } }  다시 한번 위 코드로 main 함수를 실행 시켜 봅시다.   참고로 emf 공장은 프로그램이 종료가 되기 전 반드시 close()를 통해서 공장의 문을 닫아주셔야 합니다. 그렇지 않으면 프로그램이 데이터베이스에 접근 후에도 계속 실행된 상태로 지속됩니다.      로그 창만 봐도 쿼리가 날아간게 보이네요!      혹시 쿼리가 날아가는게 보이지 않는 분들은 persistence.xml 옵션에서 sql이 보이도록 하는 옵션들을 true로 바꿔주세요    그럼 h2 데이터베이스를 확인해 볼까요?      정상적으로 Member 테이블이 생성된 것을 확인할 수 있습니다.   위 코드를 통해서 공장이 생성되야 본격적으로 테이블을 생성하게 됨을 알 수 있습니다.   그럼 이제 매니저를 만들어서 본격적으로 Member라는 클래스의 객체를 만들어서 해당 테이블의 컬럼을 채워보도록 합시다.   먼저, 매니저를 만들어 줍니다.   1 2 3 4 5 6 7 8 9 10 public class JpaMain {     public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();                  em.close()         emf.close()     } }   아까 배운대로 동일하게 매니저를 만들어주면, 이제 em이라는 매니저가 우리의 데이터베이스 접근을 도와줄 것입니다. 데이터 베이스에 접근하려면 매니저에게 다음과 같은 명령을 해주어야 합니다.   매니저도 마찬가지로 사용이 완료되었다면, 반드시 close()를 사용해서 종료시켜주어야 합니다.   그럼 이제 매니저를 사용하기 위해 트랜잭션을 열어줄 것 입니다. 여기서 또 트랜잭션이라는 새로운 개념이 나옵니다.   트랜잭션  트랜잭션은 “쪼갤 수 없는 업무 처리의 최소 단위”를 말하는데요. 이해가 쉽도록 다음과 같은 과정을 생각해봅시다.   만약 Member1과 Member2를 기록한다고 해봅시다. Member1과 Member2는 커플이라서 무조건 함께 기록되어야 합니다. 우리는 이 커플들을 (1,2), (3,4)와 같이 2의 단위로 묶어서 기록 하기로 했기 때문에, 1,2는 무조건 커플이어야 합니다.      물론 실제에서 이렇게 데이터베이스를 관리하지는 않지만, 이해를 쉽게  하기 위해 이렇게 가정해보겠습니다.    그렇다면 만약 Member1은 정상적으로 기록되었는데, Member2에서 오류가 발생하여 데이터베이스에 접근하지 못하게 되었다면 어떻게 될까요?   그렇다면 데이터베이스에 Member1만 기록될테니, 후에 만약 Member3와 Member4가 온다면 Member1과 Member3가 커플이 되고, Member4는 짝이 없어진 채로 데이터베이스에 기록될 것입니다.   그래서 우리는 이러한 일을 방지하기 위해서, 트랜잭션을 사용합니다.   트랜잭션은 아까 쪼갤 수 없는 업무 처리의 최소 단위라고 했습니다.   따라서 트랜잭션 단위 안에 Member1 과 Member2를 쓰는 코드를 넣어주게 되면, 트랜잭션 안에서 예외가 발생하면 트랜잭션 단위를 통째로 취소합니다. 따라서 Member2에서 에러나 예외가 발생했다면, 트랜잭션 하나가 전부 취소되어 Member1도 기록이 되지 않게 되는 것입니다.   그러면 혹여나 Member2에서 에러가 발생해도 우리가 원하는 작업 단위가 통째로 취소되므로, 후에 들어올 Member3와 Member4는 안전하게 기록될 수 있는 것이죠.   코드로 한번 살펴 볼까요?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public static void main(String[] args)  {  \tEntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();                  tx.begin(); \t         try {          \t\ttx.commit(); \t\t         } catch (Exception e) {                        tx.rollback();         } finally {             em.close();         }         emf.close();  }  트랜잭션은 위 코드와 같이 사용합니다. 매니저로부터 트랜잭션을 얻어온 뒤, begin()을 통해서 트랜잭션의 시작을 알려주고, try-catch 구문을 사용해서 혹시나 예외가 발생한다면 rollback() 함수를 통해서 트랜잭션의 단위 통째로 취소해버리게 되는 것이죠.   만약 에러가 발생하지 않는다면 commit()을 통해서 트랜잭션을 종료해주면 됩니다.   따라서 우리가 트랜잭션 단위로 처리하고 싶은 작업을 try 구문 안에 넣어주면 됩니다.   그럼 이제 다시 Member 클래스의 객체를 만들어줌으로써 컬럼을 채워봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22     public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();          tx.begin();          try {                      Member member = new Member();             member.setId(1L);             member.setName(\"이민재\");             member.setAge(\"26\");                          tx.commit()         } catch (Exception e) {             tx.rollback();         } finally {             em.close();         }         emf.close();     }   main을 실행 시키면 어떻게 될까요?      이상하게도 객체를 만들어주는 작업을 트랜잭션에 넣어 오류없이 완료했음에도 불구하고 테이블에 컬럼이 그대로 비워져있습니다. 왜일까요?   여기서 필요한 것이 바로 영속성 컨텍스트입니다.   영속성 컨텍스트  방금 코드를 사용해서 데이터 베이스에 접근 하려면 어떻게 해야할까요?   이를 영속성 컨텍스트가 관리하도록 해주면 됩니다.   아직 코드를 살펴보면 객체를 만들기만 했지, 이 객체에 대해서 매니저가 어떠한 행동도 취하지 않은 것을 볼 수 있습니다.   다음과 같은 코드를 추가해보겠습니다.   1 em.persist(member)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();          tx.begin();          try {              Member member = new Member();             member.setId(1L);             member.setName(\"이민재\");             member.setAge(\"26\");              em.persist(member);              tx.commit();                      } catch (Exception e) {             tx.rollback();         } finally {             em.close();         }         emf.close();     }  이제 위에서 만든 객체를 em 매니저가 영속성 컨텍스트에 추가하게 됩니다. 그럼 이 상태로 main 함수를 한번 실행시켜 볼까요?      이제 정상적으로 만들어준 객체가 컬럼으로 등록되었습니다!   방금 코드에서 em.persist()를 추가하니까 컬럼에 올라갔지만, 사실 persist()를 했을 때 데이터베이스에 접근한 것을 아닙니다. persist는 말그대로 영속성(Persist) 이므로, member라는 객체를 영속성 컨텍스트가 관리하게 해준것이고, 이를 commit() 함수가 실행되었을 때 데이터베이스에 등록하게 됩니다.   따라서 commit()은 영속성 컨텍스트에 의해서 관리 받는 엔티티만을 데이터 베이스에 등록하는 것을 알 수 있습니다.   그렇다면 영속성 컨텍스트란 무엇일까요??   JPA에서 엔티티는 아래와 같은 생명주기를 갖습니다.      위 그림에서 적혀 있는 상태를 4가지로 구분해보자면 다음과 같습니다.      비영속 (New)   영속 (Managed)   준영속 (Detached)   삭제 (Removed)   하나씩 설명해 보자면,   비영속이 바로 우리가 아까 객체를 생성한 상태입니다. 아까 코드에서 persist() 를 쓰지않았을때의 객체가 바로 이 상태로, 객체는 생성되었지만 이를 아직 영속상태에 놓지 않았기 때문에 commit()이 되어도 데이터베이스에 기록되지 않습니다.   영속은 persist()를 사용해서 해당 엔티티를 영속성 컨텍스트가 관리 하도록 만든 상태입니다. 이 상태에서 commit()이 되면 데이터 베이스에 해당 변경 사항을 기록하게 되는 것이죠.   영속은 쉽게 말하면 예비 출전 상태라고 생각하면 쉽습니다. 만약 전쟁이 일어났다면, 바로 집에서 전쟁터로 직행하지 않겠죠? 정해진 장소로 우선 모아서 다 모였는지, 아픈 사람은 없는지, 전략은 완벽한지를 모두 체크하고 한번에 모아서 전쟁터로 출전하게 됩니다. 굳이 집에서 한명씩 비효율적으로 전쟁터로 직행 할 필요가 없죠.   준영속은 detach() 함수를 사용해서 만드는 상태입니다. 사실 이 상태는 개발자가 직접 준영속을 만들 경우는 거의 없습니다. 말그대로 영속 컨텍스트에 올라간 엔티티를 다시 떼내어서 영속 상태가 아니도록 만드는 것입니다.   삭제는 말그대로 삭제 상태입니다. 영속컨텍스트에서 떼어내서 commit()에서만 제외하여 DB에 반영하지 않는 준영속과 달리, 실제 DB에서의 삭제를 요청한 상태입니다.   그럼 이제 영속성 컨텍스트를 알게 되었으니, JPA를 사용해서 객체를 만들고 이를 영속상태로 만들어 준 뒤 트랜잭션을 커밋해주면, 우리가 원하는 데이터를 객체지향스럽게 데이터베이스에 기록 할 수 있음을 알게 되었습니다.   그런데 왜 굳이 바로 데이터베이스에 접근하지 않고 영속성 컨텍스트에 올린 뒤에 데이터베이스에 접근 하는 것일까요?   그것은 바로 영속성 컨텍스트를 사용하면 여러가지 데이터를 효율적으로 관리할 수 있는 이점들이 있기 때문입니다.   그러면 어떠한 이점들이 있길래 굳이 한번의 과정을 추가한 것일까요?   이러한 이점들은 다음 게시물에서 알아보도록 하겠습니다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/JPA-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[Programmers] 보석쇼핑 (Python3)",
        "excerpt":"문제설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]   개발자 출신으로 세계 최고의 갑부가 된 어피치는 스트레스를 받을 때면 이를 풀기 위해 오프라인 매장에 쇼핑을 하러 가곤 합니다.  어피치는 쇼핑을 할 때면 매장 진열대의 특정 범위의 물건들을 모두 싹쓸이 구매하는 습관이 있습니다.  어느 날 스트레스를 풀기 위해 보석 매장에 쇼핑을 하러 간 어피치는 이전처럼 진열대의 특정 범위의 보석을 모두 구매하되 특별히 아래 목적을 달성하고 싶었습니다.  진열된 모든 종류의 보석을 적어도 1개 이상 포함하는 가장 짧은 구간을 찾아서 구매   예를 들어 아래 진열대는 4종류의 보석(RUBY, DIA, EMERALD, SAPPHIRE) 8개가 진열된 예시입니다.   진열대 번호12345678  보석 이름DIA RUBY RUBY DIA DIA EMERALD SAPPHIRE DIA  진열대의 3번부터 7번까지 5개의 보석을 구매하면 모든 종류의 보석을 적어도 하나 이상씩 포함하게 됩니다.   진열대의 3, 4, 6, 7번의 보석만 구매하는 것은 중간에 특정 구간(5번)이 빠지게 되므로 어피치의 쇼핑 습관에 맞지 않습니다.   진열대 번호 순서대로 보석들의 이름이 저장된 배열 gems가 매개변수로 주어집니다. 이때 모든 보석을 하나 이상 포함하는 가장 짧은 구간을 찾아서 return 하도록 solution 함수를 완성해주세요.  가장 짧은 구간의 시작 진열대 번호와 끝 진열대 번호를 차례대로 배열에 담아서 return 하도록 하며, 만약 가장 짧은 구간이 여러 개라면 시작 진열대 번호가 가장 작은 구간을 return 합니다.   [제한사항]     gems 배열의 크기는 1 이상 100,000 이하입니다.   gems 배열의 각 원소는 진열대에 나열된 보석을 나타냅니다.   gems 배열에는 1번 진열대부터 진열대 번호 순서대로 보석이름이 차례대로 저장되어 있습니다.   gems 배열의 각 원소는 길이가 1 이상 10 이하인 알파벳 대문자로만 구성된 문자열입니다.   입출력 예                  gems       result                       [“DIA”, “RUBY”, “RUBY”, “DIA”, “DIA”, “EMERALD”, “SAPPHIRE”, “DIA”]       [3, 7]                 [“AA”, “AB”, “AC”, “AA”, “AC”]       [1, 3]                 [“XYZ”, “XYZ”, “XYZ”]       [1, 1]                 [“ZZZ”, “YYY”, “NNNN”, “YYY”, “BBB”]       [1, 5]           입출력 예에 대한 설명   입출력 예 #1  문제 예시와 같습니다.   입출력 예 #2  3종류의 보석(AA, AB, AC)을 모두 포함하는 가장 짧은 구간은 [1, 3], [2, 4]가 있습니다.  시작 진열대 번호가 더 작은 [1, 3]을 return 해주어야 합니다.   입출력 예 #3  1종류의 보석(XYZ)을 포함하는 가장 짧은 구간은 [1, 1], [2, 2], [3, 3]이 있습니다.  시작 진열대 번호가 가장 작은 [1, 1]을 return 해주어야 합니다.   입출력 예 #4  4종류의 보석(ZZZ, YYY, NNNN, BBB)을 모두 포함하는 구간은 [1, 5]가 유일합니다.  그러므로 [1, 5]를 return 해주어야 합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from collections import Counter def solution(gems):     num = len(set(gems))     ret = []          left = 0     counter = Counter()          for right in range(len(gems)):         counter[gems[right]] += 1         print(right, counter)         right += 1         while len(counter) == num:             counter[gems[left]] -= 1             if counter[gems[left]] == 0:                 del counter[gems[left]]             left += 1             ret.append([left, right])     return sorted(ret, key = lambda x: (x[1]-x[0], x[0]))[0]   문제설명  이 문제는 이중 for문 으로도 풀 수 있지만 효율성을 통과하려면 투포인터를 사용해주어야한다.  이처럼 어떤 범위나 구간내의 정보를 바탕으로 문제를 해결하는 문제는 반드시 투포인터로 left와 right를 점차 변경시켜가며 구간안에 있는 값들을 판별하거나 처리해주면 반드시 O(N) 시간내로 문제를 해결 할 수 있기 때문에 이러한 문제에 효율성 조건이 있다면 반드시 투포인터 문제로 풀이한다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%B3%B4%EC%84%9D-%EC%87%BC%ED%95%91(Python3)/",
        "teaser": null
      },{
        "title": "[Programmers] 셔틀버스 (Python3)",
        "excerpt":"문제설명  셔틀버스   카카오에서는 무료 셔틀버스를 운행하기 때문에 판교역에서 편하게 사무실로 올 수 있다. 카카오의 직원은 서로를 ‘크루’라고 부르는데, 아침마다 많은 크루들이 이 셔틀을 이용하여 출근한다.   이 문제에서는 편의를 위해 셔틀은 다음과 같은 규칙으로 운행한다고 가정하자.   셔틀은 09:00부터 총 n회 t분 간격으로 역에 도착하며, 하나의 셔틀에는 최대 m명의 승객이 탈 수 있다.  셔틀은 도착했을 때 도착한 순간에 대기열에 선 크루까지 포함해서 대기 순서대로 태우고 바로 출발한다. 예를 들어 09:00에 도착한 셔틀은 자리가 있다면 09:00에 줄을 선 크루도 탈 수 있다.  일찍 나와서 셔틀을 기다리는 것이 귀찮았던 콘은, 일주일간의 집요한 관찰 끝에 어떤 크루가 몇 시에 셔틀 대기열에 도착하는지 알아냈다. 콘이 셔틀을 타고 사무실로 갈 수 있는 도착 시각 중 제일 늦은 시각을 구하여라.   단, 콘은 게으르기 때문에 같은 시각에 도착한 크루 중 대기열에서 제일 뒤에 선다. 또한, 모든 크루는 잠을 자야 하므로 23:59에 집에 돌아간다. 따라서 어떤 크루도 다음날 셔틀을 타는 일은 없다.   입력 형식  셔틀 운행 횟수 n, 셔틀 운행 간격 t, 한 셔틀에 탈 수 있는 최대 크루 수 m, 크루가 대기열에 도착하는 시각을 모은 배열 timetable이 입력으로 주어진다.      0 ＜ n ≦ 10   0 ＜ t ≦ 60   0 ＜ m ≦ 45   timetable은 최소 길이 1이고 최대 길이 2000인 배열로, 하루 동안 크루가 대기열에 도착하는 시각이 HH:MM 형식으로 이루어져 있다.   크루의 도착 시각 HH:MM은 00:01에서 23:59 사이이다.   출력 형식  콘이 무사히 셔틀을 타고 사무실로 갈 수 있는 제일 늦은 도착 시각을 출력한다. 도착 시각은 HH:MM 형식이며, 00:00에서 23:59 사이의 값이 될 수 있다.   입출력 예제  |n|t|m|timetable|answer|  |:—:|:—:|:—:|:—:|:—:|  |1|1|5|[“08:00”, “08:01”, “08:02”, “08:03”]|”09:00”|  |2|0|2|[“09:10”, “09:09”, “08:00”]|”09:09”|  |2|1|2|[“09:00”, “09:00”, “09:00”, “09:00”]|”08:59”|  |1|1|5|[“00:01”, “00:01”, “00:01”, “00:01”, “00:01”]|”00:00”|  |1|1|1|[“23:59”]|”09:00”|  |10|60|45|[“23:59”,”23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”, “23:59”|”18:00”|   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from collections import deque  def solution(n, t, m, timetable):     bus_arrive = [540]     timetable = deque(sorted(timetable))                                                   for i in range(n-1):         bus_arrive.append(bus_arrive[-1] + t)          buses = {}          for i in bus_arrive:         buses[i] = []              time = 0     for bus in buses:         if not timetable:             break         while len(buses[bus]) &lt; m and time &lt;= bus:             if not timetable:                 break             else:                 time = time_parser(timetable.popleft())                 if time &lt;= bus:                     buses[bus].append(time)                 else:                     timetable.appendleft(time_re_parser(time))          last_bus = is_empty_bus(buses, m)[-1]          if len(last_bus[1]) == m:         return time_re_parser(last_bus[1][-1] - 1)     else:         return time_re_parser(last_bus[0])                             1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def time_parser(time):     return int(time[0:2]) * 60 + int(time[3:])  def time_re_parser(time):     hour = str(time//60)      minute = str(time%60)     if len(hour) == 1:         hour = \"0\" + hour              if len(minute) == 1:         minute = \"0\" + minute     return hour + \":\" + minute  def is_empty_bus(buses, m):      return list(buses.items())   1 2 3 4 test_case = [[1,1,5, [\"08:00\", \"08:01\", \"08:02\", \"08:03\"]], [2,10,2, [\"09:10\", \"09:09\", \"08:00\"]], [2,1,2,[\"09:00\", \"09:00\", \"09:00\", \"09:00\"]], [1,1,5,[\"00:01\", \"00:01\", \"00:01\", \"00:01\", \"00:01\"]], [1,1,1,\t[\"23:59\"]], [10, 60, 45, [\"23:59\",\"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\", \"23:59\"]]] for case in test_case:     print(\"case\")     print(solution(case[0], case[1], case[2], case[3]))   1 2 3 4 5 6 7 8 9 10 11 12 case 09:00 case 09:09 case 08:59 case 00:00 case 09:00 case 18:00   문제설명  이 문제는 언뜻보면 복잡해보이지만, 가장 늦게 탑승하는 시간을 구하면 되기 때문에 마지막 버스만 생각해주면 된다. 만약 마지막 버스에 빈자리가 있다면 해당 버스가 출발하는 시간에 탑승하면 되고, 마지막 버스에 빈자리가 없다면 그 버스에 마지막으로 탑승한 크루보다 1분 먼저 오면 버스를 탑승할 수 있다.   타임테이블을 정렬해준뒤, 버스 시간표를 딕셔너리로 만들어 딕셔너리 테이블을 하나의 버스로 놓고 크루들을 먼저 다 탑승시킨다. 그리고 마지막 버스만을 판별해서 위에 설명했던 것처럼 탑승 시간을 구해주면 된다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%85%94%ED%8B%80-%EB%B2%84%EC%8A%A4(Python3)/",
        "teaser": null
      },{
        "title": "마이크로 서비스 아키텍쳐 - MSA",
        "excerpt":"MSA란?  기존의 서비스는 모노리식(Monolithic ) 아키텍쳐였습니다. 하나의 애플리케이션안에 모든 비즈니스 로직이 들어가있는 구조인 것이죠.      이렇게 모든 비즈니스 로직이 하나로 되어있었기 때문에, 모노리식 아키텍쳐는 여러가지 단점을 갖고있었습니다.      개발 유연성의 한계   요구사항 대처 시간 소요   장애 격리 / 신뢰성   배포 / 롤백 리스크   리소스 낭비   아무래도 하나의 커다란 애플리케이션이다보니 개발하는데에 있어서 부분을 수정하려 해도 반드시 모든 비즈니스 로직을 가져와야 해서 개발 유연성도 떨어지고, 만약 에러가 발생하면 일정 부분의 문제인데도 사이트 전체가 마비된다던지, 배포나 롤백을 할때도 하나의 기능을 배포하고 롤백하기 위해서 모두가 대기해야 하는 일까지 발생했습니다.   이 모든 문제점은 바로 여러 기능이 뭉쳐서 강하게 결합 되었기 떄문에 발생하는 문제들이었죠.   그래서 개발자들은 이 기능들을 쪼개보기로 했습니다.   이것이 바로 마이크로 서비스 아키텍쳐 (Micro Service Architecture) 입니다.      마이크로 서비스 아키텍쳐를 그림으로 나타내면 위의 그림과 같은데요. 하나의 서비스가 아닌 여러개의 마이크로 서비스로 나누어, 심지어는 DB조차 각자의 DB를 갖고있는 것을 확인할 수 있습니다. 이들은 각각의 서비스로 독립되어 있으며, 서로 API를 통해서 통신하며 전체의 서비스가 동작하도록 합니다.   만약 우리가 프로그램을 개발할 때, 로직을 하나의 메인함수에 모두 구현하게 된다면 어떨까요?  유지보수가 어려울 뿐더러, 하나의 기능에서만 문제가 발생해도 프로그램 전체가 다운될 것입니다. 그래서 프로그램을 개발할때도 좋은 프로그램은 최대한 클래스가 분리되어있고 함수가 분리되어있는 프로그램이죠.   그래서 마이크로 서비스 아키텍쳐도 이와 같이 하나의 큰 서비스를 유지보수하고 배포하기 편리 하도록 여러개의 어플리케이션으로 나누어 조금 더 효율적인 개발을 할 수 있도록 한 것입니다.   그렇다면, 마이크로 서비스 아키텍쳐가 기존의 모노리식 아키텍쳐에 비해 어떤 장점들이 있는지 자세하게 알아보겠습니다.   MSA의 장점     기존 방식에 비해 새로운 기능 추가 및 업데이트가 간편하다.   모노리식 방식은 소프트웨어의 모든 구성 요소가 한 프로젝트에 합쳐져 있어서 큰 변화에 대응이 어렵고, 새로운 기능 추가 및 업데이트를 할 때마다 프로젝트 전체를 배포하고 업데이트해야해서 어려움이 있었습니다.   하지만 마이크로 서비스 아키텍쳐는 요소들이 나뉘어져 있기때문에, 하나의 서비스만 유지보수하고 업데이트가 가능합니다.      하나의 서비스가 문제가 있다면, 하나의 서버에만 장애가 발생한다.   기존의 서비스는 하나의 장애가 전체 서버의 장애을 일으키지만, 마이크로 서비스 아키텍쳐는 해당 기능의 서버에만 장애가 발생하기 때문에 서비스가 비교적 안정합니다.      필요한 자원만 Scale-Out할 수있다.   AWS등의 클라우드 서비스를 이용하면 간단하게 서버의 리소스를 늘릴 수 있습니다. 하지만 모노리식의 경우는 모든 프로젝트가 하나이기 때문에, 한 기능에서의 리소스를 증가시키고 싶다면 서버전체의 리소스를 올려야 합니다.   하지만 마이크로 서비스 아키텍쳐는 해당 기능을 담당하는 서버의 리소스만 증가시켜주면 되기 때문에, 조금 더 효율적으로 자원을 사용할 수 있습니다.      민첩하고 손쉬운 배포 및 업데이트   기존 방식은 프로젝트가 하나로 되어있기 때문에, 배포와 업데이트를 할 때 항상 모든 파일 전체를 배포하고 업데이트 합니다. 이것은 개발자 입장에서 굉장히 리스크가 있는 방식입니다.   하지만 마이크로 서비스 아키텍쳐는 Blue-Green 배포 방식을 사용합니다. 이 배포방식은 Blue와 Green 두개의 인스턴스를 만들어놓고, 예를 들어 Green에서 현재 버젼의 서비스가 동작하고 있다면, Blue에 먼저 새로운 버젼의 서비스를 올려 테스트 해봅니다. 만약 Blue의 새로운 버젼의 서비스가 잘 동작한다면, Green으로 오던 트래픽을 Blue로 옮겨주는 것입니다. 이렇게 한다면 만약에 새로운 버젼에서 오류가 발생한다 해도, 바로 원래의 Green으로 트래픽을 옮겨주면 서비스가 정상적으로 동작하게 될 것입니다.   기존방식과 달리 롤백이 가능하기 때문에, 배포에서 발생가능한 위험을 최소화 할 수 있습니다.   이렇게 마이크로 서비스는 다양한 장점을 갖고있습니다. 하지만 모든 방법들이 그렇듯, 한가지의 방법이 압도적으로 좋아서 무조건 이 방법만을 사용하면 되는 것은 아닙니다.   그렇다면 MSA는 어떤 상황에서 적용해야하고, 적용했을 때 어떤점에 주의해야 할까요?   MSA를 적용하기 전  먼저, 빠르고 잦은 배포가 필요하며, 성능에 어느정도 민감한 서비스인지 생각해봐야합니다.   아무래도 MSA는 여러가지의 서비스로 이루어져있기 때문에, 서비스간의 통신이 잦아집니다. 하나의 서비스가 작동할 때보다는 여러개의 서비스가 통신해야 하기 때문에 퍼포먼스가 감소할 수 밖에 없게 됩니다. 그래서 성능에 매우 민감한 서비스라면, MSA를 적용하기 전에 충분히 고려해보아야 합니다.   또, 트랜잭션 유지가 어렵기 때문에, 이에 각별히 신경써야 합니다.   기존에는 하나의 단일 DB를 사용하기 때문에 DB가 기본적으로 제공하는 트랜잭션 기능, 커밋 롤백등을 사용해 데이터를 안정적으로 관리할 수 있었지만, MSA는 DB가 분산되어 있기 때문에 단일 DB의 트랜잭션으로는 이를 해결할 수 없습니다.   마지막으로, 서비스가 많기 때문에 반드시 배포와 릴리즈를 자동화 해야합니다.   만약 자동화 되지 않은 상태로 배포와 릴리즈를 한다면, 하나하나의 서비스들을 일일히 수작업으로 배포하고 릴리즈 해주어야 하는데, 이는 몹시 비효율적입니다.   마무리하며…  이처럼 마이크로 서비스 아키텍쳐는 많은 장점을 갖고있음과 동시에 고려해보아야할 여러가지 사항을 갖고있습니다. 그리고 아직 여러곳에서 적용하기 시작한지 얼마 되지않았기 때문에 레퍼런스도 부족하고, 이러한 경험이 있는 사람들이 잘 없기 때문에 바로 적용하기에는 쉽지 않은 방식입니다.   심지어 MSA로 전환하는 것은 개발의 기술을 바꾸는 것을 넘어 일하는 방식이 아예 바뀌는 큰 변화입니다. 따라서 손바닥 뒤집듯이 오늘부터 MSA 방식으로 가자! 할 수는 없는거죠.   하지만 그럼에도 요즘 대부분의 기업들이 MSA 방식을 점차 적용하는 것은, 분명히 MSA가 가진 장점이 현재의 비즈니스를 더 나은 방식으로 바꿔준다는 증거일 것입니다.   아마도 앞으로 더욱 더 모든 기업들이 점차 MSA 방식을 채택할 가능성이 커보이니, 원하는 기업에 가고싶다면 적어도 이러한 방식이 어떠한 장점과 단점이 있는지는 알아 두는 것이 좋을 것 같습니다.   자료출처     네이버 클라우드 플랫폼 유튜브   ","categories": ["CS"],
        "tags": [],
        "url": "/cs/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90-MSA/",
        "teaser": null
      },{
        "title": "파도 파도 끝이없는...",
        "excerpt":"2022.04.29  오늘 여러 인턴 후기들을 좀 보다가 면접 과정에서의 질문들을 봤는데, 좀 멘붕이 왔다.   나름 이제 어느정도 지식들이 있다고 생각했는데, 솔직히 거기 있는 면접 질문중에 완벽하게 대답할 수 있는게 하나도 없었다.   나름 여러가지 기술도 만져보고 요즘은 스프링이랑 JPA강의도 열심히 듣고 있다고 생각했는데…   애초에 컴공갔으면은 그래도 여러가지 CS지식을 학교에서 공부했을텐데, 내가 좀 관심이 많다고 한들 내가 비전공자라는 사실을 잊고 너무 기술을 배우는데에만 집중 했던것 같다.   그래서 오늘부터는 하루에 한개씩 CS 지식을 공부하고 이를 블로그에 적어보려고 한다.   요즘 점점 하루에 필수로 해야할것 들이 늘어나는 것같다…   지금만 해도 운동하고 체중 기록하기, 하루에 토익 두챕터 풀기, 영어로 된 글하나 읽기, 코딩테스트 한문제 풀기 등등 …   그래도 하다보니까 반드시 하루에 해야할 나와의 약속을 지켜놓고 지켜가는게 재미있기도하고, 하루에 하나 한다는게 지키기 쉬우면서도 1달, 1년씩 쌓여가면 어마어마한 성취가 되는 것 같아서 나한테 가장 맞는 방법인 것 같기도하다.   눈앞의 작은 것들만 치워버리면 되니, 책상에 앉아서 뭘 할지 고민한다거나 계획하는 시간이 없어져서 좋다. 그냥 눈앞에 있는 할일들을 하나하나 지워가며 무작정 할 뿐이다.   하루의 작은 성취들이 모이고 모여 결국 큰 성과가 되는 것 같다.   물론 일기 쓰는게 제일 귀찮아서 잘 안쓰기는 하는데, 열심히 또 써봐야지…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%8C%8C%EB%8F%84-%ED%8C%8C%EB%8F%84-%EB%81%9D%EC%9D%B4%EC%97%86%EB%8A%94/",
        "teaser": null
      },{
        "title": "OSI 7 Layer Model",
        "excerpt":"OSI 7 계층이란?  OSI 7 계층은 네트워크에서 통신이 일어나느 과정을 7단계로 나누어 표현한 모델입니다. 우리가 데이터를 보내는것이 정확히 어떻게 진행되는지 알도록 할 수 있게 나눈 것이죠.   이러한 계층 모델을 표준으로 사용하고 있기 때문에, 제조사가 다른 장비끼리도 이러한 표준화된 규약하에 통신이 가능한 것입니다.   또, 이렇게 계층으로 나눠놓으면 통신이 일어나는 과정을 단계별로 파악할 수 있어 편리 합니다. 문제가 생기면 해당 문제가 어느 계층에서 일어난 것인지 판별하여 해당 계층만 고치면 되니까요.   물론 지금의 실제적인 통신들은 대부분 TCP/IP 프로토콜로 동작하고 있지만, 장비개발과 통신 자체를 어떻게 표준으 로 잡을지 사용하는 것은 OSI 7 Layer이기 때문에 중요합니다. 또, 어차피 둘은 비슷한 방식이기 때문에 OSI 7을 이해하면 TCP/IP를 이해하는 것도 어렵지 않습니다.   OSI 7 레이어는 이름에 맞게  아래와 같은 7개의 계층을 가집니다.      Application   Presentation   Session   Transport   Network   Data Link   Physical   그럼 아까 현재는 대부분이 TCP/IP 모델을 사용하고 있다고 했죠? 그럼 TCP/IP은 어떤 계층을 갖고 있을까요? 아래와 같습니다.      Application   Transport   Internet   Network Access   OSI 7 모델과 비슷한데, 밑의 Network 부분과 Application 부분으로 통합되어 있는 것이 다른걸 알 수 있죠.   그림으로 살펴 보겠습니다.      같은 모습인데, Presentation과 Session 레이어가 Application 레이어 하나로 통합되었고, Network Layer가 Internet Layer로 바뀌었으며, Data Link Layer와 Physical Layer가 통합되었습니다.   둘의 차이점은 OSI 7 레이어는 개념적이고 이론적인 표준이라면, TCP/IP는 실무적 표준이라는 것입니다. OSI는 개념적인 모델로 우리가 데이터를 보낼때는 이러한 과정들을 거쳐서 통신을 하자! 라고 이론적으로 설명하기위한 모델이고, TCP/IP는 실제적으로 우리가 사용하는 클라이언트-서버 모델인 것입니다.   이게 사실 무슨말인지 이해가 어렵습니다. 저도 이 내용을 공부하며 든 생각이, 아니  OSI 7 레이어가 표준이라면서 왜 TCP/IP를 대부분 쓰고 있는것이며, 그렇다면 우리가 OSI 7레이어를 공부해야할 필요가 뭐가 있는거지? 그냥 TCP/IP만을 알면 되잖아?   그래서 이 둘이 무슨 차이가 있는지 찾아보았습니다.   OSI 7 과 TCP/IP의 차이점  OSI 7과 TCP/IP 중에서 먼저나온 것은 TCP/IP 입니다. OSI 7을 표준으로 정하기 전에 이미 TCP/IP를 적용한 여러 통신 제품들이 나오고 있었죠. 그러다 보니 모두 TCP/IP라는 기술은 사용하지만 디테일한 부분이 달라서 회사가 다른 제품끼리는 호환이 안되는 문제들이 하나 둘 생기기 시작합니다.   이에 ISO(국제 표준화 기구)는 이를 통일하기 위해 국제 표준인 OSI 7을 발표하게 됩니다. 하지만 이미 대부분의 장비들은 TCP/IP를 기준으로 만들어졌기 때문에, 이를 갑자기 OSI 7 모델로 바꾸는 것은 너무나 복잡하고 어려운 일이기도 하고, 이미 어느정도 실제로 사용되며 신뢰성 있는 TCP/IP 모델을 하루아침에 OSI 7 모델로 바꾸는것도 너무 리스크가 컸습니다.   그래서 기업들은 그대로 TCP/IP 모델을 사용하되, 국제 표준인 OSI 7 모델을 참고하며 조금씩 TCP/IP 모델을 수정하여 표준에는 호환 될 수 있도록 수정하기 시작합니다. 이것이 현재의 TCP/IP가 되어 널리 사용되고 있는 것이죠.   따라서 실제로는 TCP/IP를 사용하고 있지만, 국제적인 표준은 OSI 7 모델이기 때문에 OSI 7 모델에 대해서도 알아야 하는 것입니다. 결국 TCP/IP도 OSI 7 모델을 참고하여 수정한 모델이니까요.   그럼 이제 왜 OSI 7 모델을 공부해야하는지 알았으니, OSI 7 모델의 계층을 하나하나 알아보도록 합시다.   영어로 되어있어서 어렵지만 내용은 단순합니다. 우리가 어떤 데이터를 우리 컴퓨터에서 다른 컴퓨터로 보내면, 위의 7계층을 위에서부터 데이터를 보내고, 다른 컴퓨터에서는 아래에서부터 위로 데이터를 받는 것이죠.   그러면 이 계층에 대해서 하나씩 위에서부터 설명 해보겠습니다..   Application  이 계층은 통신을 위해 실행하는 응용프로그램의 계층입니다. 우리가 메시지를 보내려면, 어떤 프로그램을 통해서 보내야겠죠? 예를 들어 보통은 카카오톡이나 라인 등의 메신저 프로글매을 사용할것입니다.   만약 카카오톡에서 우리가 “안녕”이라는 메시지를 보내면, 카카오톡 프로그램이 HTTP, FTP, DHCP, POP3등의 프로토콜을 사용해서 사용해서 네트워크에 접근을 시작할 것입니다.   이 부분에서는 사용자를 위한 인터페이스를 지원합니다. 카카오톡을 키면 우리가 사용할 수 있도록 예쁘게 대화창과 보내기 버튼이 있죠? 이처럼 이 부분에서는 사용자가 눈으로 볼 수 있는 부분으로, 직접 우리가 원하는 작업을 수행하기 위한 부분입니다.   이 상태에서의 메시지는 이러한 모양일 것입니다.      Presentation  이 계층에서는 데이터의 변환, 압축, 암호화가 이루어집니다. 기기 간에 다른 표현 방식을 모두가 이해할 수 있는 하나의 통일된 방식으로 변경하는것이죠.   응용프로그램에서 보낸 메시지를 네트워크를 위해 변환하거나, 반대로 네트워크에서 받아 어플리케이션이 이해할 수 있도록 우리가 자주 사용하는 JPEG, TIFF, GIF등등으로 형식을 맞춰주는 것입니다.   그렇다면 이 부분에서는 메시지가 이렇게 송신에 유리하도록 변환될 것입니다.   또, 데이터 유형과 전송길이등 작업 정보가 담긴 헤더가 메시지에 추가됩니다.      Session  세션 게층은 네트워크상에서의 양쪽 연결을 관리하고 연결을 지속시켜주는 계층입니다.   응용 프로그램 간 연결을 해주고 연결이 안정될 수 있도록 유지하고, 혹시나 데이터 교환에 에러가 발생한다면 다시 재연결 및 복구를 담당합니다. 변환한 메시지에 동기점을 삽입하여, 만약 누락된 정보가 있다면 동기점을 통해 판별하여 해당 부분부터 다시 전송할 수 있는 것이죠.   이 부분에서도 마찬가지로 작업에 대한 정보가 담긴 헤더가 추가됩니다.      Transport  여기서는 Port 번호를 사용하여 도착지 컴퓨터의 어떤 포트로 해당 데이터를 보내야 할지 포트정보를 추가합니다.   컴퓨터가 데이터를 받으면 이 데이터를 어떤 프로세스 (프로그램)에 전달해야할지 모르는 상태입니다. 데이터가 들어왔지만, 이걸 컴퓨터 안에있는 어느 어플리케이션에 보낼지 모르는 상태입니다. 따라서 프로세스들마다 하나씩 고유의 포트번호를 겹치지 않도록 컴퓨터는 갖고있죠.   보통 우리가 웹페이지에 접속한다고 하면, 웹페이지의 웰노운 포트인 80포트로 접속하게 됩니다. 그래서 만약 웹으로 우리의 데이터를 보내는거라면, 80이라는 번호가 여기서 포함되는 것이죠. 서버 컴퓨터의 80 번호로 온 데이터는, 해당 웹페이지 프로세스의 데이터가 되는 것입니다.      마찬가지로 헤더가 하나 붙고, 이 헤더에는 포트의 정보가 담기게 될 것 입니다.   여기서부터의 전송 단위를 “세그먼트“라고 합니다.   Network  네트워크 계층에서는 컴퓨터의 주소인 IP를 데이터에 붙이게 됩니다. 출발 IP와 도착 IP가 헤더에 포함되어 전송 되는 것이죠.   이러한 IP를 기반으로 복잡한 인터넷 망에서 데이터 전송을 위한 최적의 경로를 선택합니다. 이를 찾기 위해서 보통 라우터가 이 계층에 자리잡습니다. 라우터는 라우팅 프로토콜을 통해 가장 빠른 경로를 찾아 안전하게 전달하는 기능을 수행합니다.   하지만 보통 우리는 해당 도착 컴퓨터의 IP를 알고있지 않습니다. 대신 도메인을 알고있는데요, www.naver.com과 같은 도메인을 입력하게 되면 컴퓨터는 연결된 DNS 서버에 도메인에 해당하는 IP를 찾아서 보내려는 데이터에 적용합니다. 숫자는 외우기 힘드니, 이러한 방식으로 주소를 정하게 된것이죠.   그렇게 DNS 서버에서 우리가 입력한 도메인의 해당하는 IP를 도착지 IP로, 우리의 컴퓨터 IP를 출발지 IP로 헤더에 담습니다.      이렇게 네트워크 단에서 포장된 데이터를 “패킷”이라고 합니다.   DataLink  데이터 링크에서는 장치간 신호를 전달하는 물리 계층을 이용하여 연결된 네트워크 노드간에 데이터를 전송합니다.   여기서는 프레이밍을 하는데요, 프레임이라는 1111과 0000으로 이루어진 프레임으로 감쌉니다. 이렇게 감싸주게 되면 1111이 데이터의 시작, 0000이 끝인걸 나타내게됨으로, 여러개의 컴퓨터에서 한번에 데이터가 들어와도 이 데이터들이 섞이지 않고 구분될 수 있을 것입니다.   이렇게 데이터의 시작을 트레일러 에 담아서 데이터가 시작되는 부분을 구분합니다.   또한 헤더에는 전송되는 다음 노드의 물리적 주소(MAC) 주소를 담게 됩니다. 랜선 안에 있는 컴퓨터끼리는 IP대신 이러한 MAC 주소로 통신이 가능하기 때문에, 이러한 MAC 주소를 통해서  가장 가까운 라우터로      여기서부터의 계층 단위를 프레임이라고 합니다   Physical  이제 여기서부터는 데이터를 포장하고 오류를 확인하는 것이 아닌, 실제로 물리적으로 데이터를 전송하는 과정입니다. 앞에서 여러 정보를 담고 보내기 위해서 암호화 및 인코딩한 데이터를 아날로그 신호로 바꾸어 전선을 통해서 전송하는 것이죠.   프레임에 담긴 101010101010… 등의 디지털 신호를 아날로그 신호로 바꾸어 보내는 것입니다.   아날로그 신호로 인코딩한 정보를 전선을 통해서 보낸 뒤, 이를 받은 컴퓨터는 다시 Pysical로 받아 이를 다시 디지털 신호로 디코딩 하는 것이죠.   정리  따라서 위의 과정을 통해서 Application 단에서 Physical로 우리가 데이터를 보내면, 이 아날로그 신호가 전선을 타고 이동하여 다시 Physical 에서 Application 단으로 아까의 데이터 패키징을 역순으로 진행하면서 데이터를 다시 Application 단에서 확인할 수 있게 되는 것입니다.   마무리  이렇게 OSI 7 Layer에 대해 알아보았는데요. 실제로는 TCP/IP를 대부분 사용하기 때문에 조금 다를 수 있지만, 기본적으로 네트워크를 통한 데이터 교환은 위에서 설명한 OSI 7 Layer를 지향합니다. 실제로도 TCP/IP도 대부분의 과정을 위와 같이 진행하고 있기도 하구요.   이렇게 계층을 나누어 놓음으로써, 만약 네트워크에 장애가 생긴다면 1번의 Physical 레이어 부터 해당하는 기기들이 제대로 작동하는지 하나씩 확인하면 어디가 문제여서 장애가 발생하고 있는지 확인하기 편할 것입니다.   ","categories": ["CS"],
        "tags": [],
        "url": "/cs/OSI-7-Layer-Model/",
        "teaser": null
      },{
        "title": "TCP/IP",
        "excerpt":"   저번 게시물 : https://learnote-dev.com/cs/OSI-7-Layer-Model/    서론  저번 게시물에서는 OSI 7 Layer에 대해서 알아봤습니다. OSI 7 모델이 개념적 표준이고, 실질적으로 사용되고있는 표준은 TCP/IP라고 했었습니다.   그렇다면 아무래도 실제로 사용하는 TCP/IP 프로토콜에 대해서도 잘 알아야겠죠? 그럼 TCP/IP란 무엇이고, 어떻게 동작하는지에 대해 알아보도록 합시다.   인터넷  먼저, 인터넷에 대해 알아야 합니다. 결국 TCP/IP는 인터넷을 통해 정보를 통신하기 위한 기술이므로, 이를 먼저 알아야 이해하기 쉽습니다.   인터넷에 대해 들어보지 못한 사람은 없겠지만, 막상 인터넷이 뭔지 설명하라고 하면 정확히 설명하라고 하면 애매하죠?   인터넷은 전 세계에 걸쳐 파일 전송 등의 데이터 통신 서비스를 받을 수 있는 컴퓨터 네트워크의 시스템입니다.   우리가 인터넷을 사용할 때는 반드시 인터넷 사업자들에게 비용을 지불해야 사용할 수 있습니다. 사업자가 깔아놓은 인프라를 이용해야 하기 때문이죠.   우리나라에는 KT, SKT, LG가 있는걸 알고 계실 겁니다. 이 회사들이 전국에 깔아놓은 인터넷 망에 우리가 접속함으로써 인터넷에 연결 되는 것이죠.   해외와는 해저케이블을 통해 연결되어, 우리는 우리나라뿐만 아니라 전세계와 파일을 전송하고 데이터를 통신할 수 있습니다.   그런데 데이터 통신을 하려면, 하나의 공통된 규약이 있어야 이들이 서로 통신할 수 있을 것입니다. 만약 각자의 기준을 하나씩 만들기 시작하면, 서로  사용하는 규약에 따라 통신이 되었다가 되지 않았다가 하게 되겠죠.   그래서 이러한 통신을 위해 만든 매뉴얼이 바로 TCP/IP입니다.   TCP/IP  OSI 7 레이어와 다르게 TCP/IP는 4개의 레이어를 갖습니다.      Application   Transport   Internet   Network Access   OSI 레이어에 비해서 레이어가 적습니다.   그렇다면 우리가 다른 서버에 접속해서 정보를 받아올 때 어떤 방식으로 TCP/IP 프로토콜에 따라서 통신이 일어나는 것일까요?   그러면 한번 네이버에 접속하는 것을 예시로 한번 TCP/IP의 통신방식을 알아보겠습니다.   우리가 www.naver.com을 주소창에 치면, 어떻게 되나요? 네이버 서버가 갖고있는 html 파일을 받아오겠죠. 지금 주소창에 치면 순식간에 파일을 받아와 브라우저로 확인 할 수 있겠지만, 실제로는 여러과정을 거칩니다.   한번 레이어를 하나씩 보며 어떻게 통신을 하는지 알아봅시다.   Applicaiton  여기서는 특정 서비스를 제공하기 위해서 애플리케이션끼리 정보를 주고 받습니다.   주로 FTP, HTTP, SSH, Telnet, DNS, SMTP가 사용됩니다.   **통신에 대한 내용도 포함되있지만, 어떤 행동을 하고 싶은지, 어떤데이터를 받고, 보내고 싶은지에 대한 내용이 포함되어있습니다. **   우리가 주로 사용하는 HTTP를 보면,      이렇게 GET 요청과 함께 받고싶은 data인 1.html의 정보와 요청하고 싶은 서버의 주소등이 담겨있죠?   이처럼 Application는 통신에 대한 정보와 함께 어떤데이터를 받고 싶은지를 어플리케이션 단에서 담아서 보내는 정보입니다.   Transport  Transport 레이어에서는 포트에 대한 정보가담깁니다. 포트란 무엇일까요?   컴퓨터에는 65535개의 포트를 갖고있습니다. 컴퓨터가 아파트라면, 포트는 호수인 셈입니다. 만약, 정보가 성공적으로 컴퓨터에 도착했다하더라도, 이 정보를 사용할 프로그램의 주소를 모른다면 컴퓨터에 도착한 정보는 갈 곳을 잃을 것입니다. 이를 해결하기 위해, 컴퓨터는 이러한 포트를 어플리케이션별로 할당함으로써 컴퓨터에 도착한 요청을 해당 어플리케이션으로 보내 처리합니다.   만약 우리가 www.naver.com을 주소창에 입력하면, 네이버의 서버 컴퓨터로 우리가 보낸 정보가 해당 컴퓨터의 서버 애플리케이션으로 전달됩니다. 우리는 포트 번호를 명시해준적이 없는데, 어떻게 우리의 요청이 알아서 네이버의 서버 애플리케이션으로 전달되는걸까요?   사실 우리가 브라우저 주소창에 http://www.naver.com을 친다는 것은 사실 http://www.naver.com:80 을 치는 것과 같습니다.      요즘은 보안을 위해서 대부분 https를 사용하지만 설명을 위해 http로 설명 하겠습니다.    만약 http://www.naver.com:81 과 같은 주소를 치게되면 접속이 되지 않는 것을 확인할 수 있는데요, 웹서버를 사용하는 포트는 80포트로 하기로 미리 약속해놓았기 때문에 모든 웹서버 어플리케이션을 사용하는 서버 컴퓨터는 서버 어플리케이션을 80포트에 할당해 놓습니다. 이 때문에 브라우저 프로그램에서는 주소를 치면 :80이라는 포트번호 명시를 우리가 해주지 않아도 웹서버는 모두 80포트이니, 알아서 :80을 대신 입력해주는 것입니다.   그래서 Transport 레이어에서는 이러한 도착 포트 번호와, 내 컴퓨터의 출발 포트 번호의 데이터를 추가합니다.   Transport 레이어에서는 TCP 혹은 UDP가 사용됩니다.   Internet  Internet 레이어에서는 Internet Protocol, IP의 정보를 추가합니다. 포트와 마찬가지로 요청을 보내는 컴퓨터의 IP와 요청의 도착지의 IP를 포함하는데요. 포트번호와 마찬가지로 우리는 도착할 컴퓨터의 IP를 명시해준 적도 없으며, 심지어는 머리로도 알지 못합니다. 브라우저는 또 그러면 이 IP는 어떻게 찾아서 보내는걸까요?   또 다시 우리가 www.naver.com을 주소창에 입력한다고 해봅시다. 그러면 우리는 123.123.123.123 이런 형식으로 되어있어야할 IP주소를 모르고도 해당 웹서버에 접속할 수 있을 것입니다.   우리가 www.naver.com을 주소창에 입력하게 되면, OS는 DNS서버로 요청을 보내게됩니다. DNS 서버는 Domain Name Server로, 우리가 입력한 도메인인 www.naver.com과 같은 도메인 주소에 해당하는 IP주소를 갖고있는 서버이죠. 이 DNS 서버도 마찬가지로 서버를 가진 컴퓨터이기 때문에 우리가 데이터를 보내려면 DNS서버의 IP주소도 알아야만 데이터를 보낼 수 있습니다. 그러면 또 DNS 서버의 IP는 어떻게 알고있는걸까요?   아래 사진은 제 맥북의 네트워크 설정입니다.      DNS서버 주소는 이미 컴퓨터의 위와같이 등록이 되어있습니다. 이미 DNS서버의 IP 주소를 알고 있기 때문에, 도메인이 필요하면 해당 IP의 DNS서버로 접속해서 해당 도메인에 해당하는 IP 주소를 가져오는 것이죠.   그럼 이제 우리가 네트워크로 보내야할 패킷에 우리 컴퓨터의 IP주소와 도착 컴퓨터의 IP주소가 패킷에 추가되었습니다.   Network Access  이제 IP주소까지 패킷에 포함되었으니, 네트워크에 접속하기 위한 정보가 필요합니다.   지금까지는 모두 어떤 정보들이었나요? 대부분 도착 서버 컴퓨터의 www.naver.com에 대한 정보였습니다.   하지만 Network Access 레이어에서는 도착 정보가 아닌, 내가 네트워크에 접근하기 위한 정보가 필요합니다.   즉, 내 컴퓨터가 현재 물리적으로 연결되어있는 공유기의 정보가 필요한 것이죠.   이러한 기기의 물리적 주소를 MAC 주소라고 합니다.   우리가 보통 IP를 이용한 통신이라함은, 각자가 연결되어있는 공유기까지의 과정을 말합니다. 보통 공유기 하나에 기기들이 연결되어있는 환경을 LAN(Local Area Network)환경이라고 하는데, 이 환경들은 외부에 공개되지 않은 private IP로 연결되어있습니다. 공유기의 Public IP만이 공개되어있고, 나머지 기기들의 IP는 private IP로 되어있는 것이죠.  Public IP에 데이터를 보내면, 공유기가 이 IP를 받아서 자신과 연결되어있는 기기의 MAC주소를 통해서 이 데이터를 넘겨주게 됩니다.   그렇다면 MAC 주소는 무엇이며, 또 어떻게 알 수 있을까요?   MAC 주소는 네트워크 장비 혹은 컴퓨터라면 갖게되는 고유 주소입니다. 논리적인 IP주소와 달리 MAC주소는 물리적인 주소이기 때문에, 물론 변경하려면 변경이 가능하지만, 논리적으로 계속 값이 바뀌는 IP주소와 다르게 정말 그 기기의 주소를 명확하게 나타내주죠.   예를들어, 행정주소를 생각해봅시다. 예전에는 지번을 기준으로 주소를 했지만 요즘은 모두 도로명 주소를 사용하죠? 이처럼 행정적인 주소의 기준은 바뀔수가 있습니다. 갑자기 우리집의 주소가 000-00 번지에서 00로 00길로 바뀐 것 처럼 말이죠.   하지만 우리집이 한강이 시작되는 곳 옆에 있다고 생각해봅시다. 행정적 주소가 변경된다고 해도 우리집의 물리적인 위치는 항상 한강이 시작되는 곳 옆입니다. 물리적으로 그 자리에 존재 하기 때문이죠.   이처럼 MAC 주소는 물리적인 주소를 사용함으로써 공유기의 도착한 정보를 해당기기에 확실하게 보내줍니다.   그럼 우리는 이러한 MAC 주소를 어떻게 알 수 있을까요??   바로 ARP(Address Resolution Protocol)프로토콜을 사용해서 알아냅니다. 이 ARP 프로토콜은 IP 주소와 MAC 주소를 일대일 매칭하여 LAN 환경에서 목적지 IP에 맞는 MAC 주소로 해당 데이터를 전달합니다.   그럼 만약에 우리가 원하는 목적지에 해당하는 IP가 LAN환경 안에 있다면 해당 기기의 MAC주소로 바로 정보를 보낼것이고, 만약 같은 LAN환경에 도착지 IP가 없다면 공유기를 통해 private IP가 public IP로 변환되어 네트워크로 나가게 되는 것입니다.   그럼 라우터가 계속 자신과 연결된 라우터에게 도착지에 해당하는 IP와 매칭되는 MAC 주소를 가진 라우터가 있는지를 찾아내게 되고, 만약 응답을 받게 된다면 해당 라우터로 데이터를 전달한 뒤, 이를 전달받은 라우터가 해당 기기의 MAC 주소로 데이터를 전달하게 되는것이죠.   자 이렇게 되면 대략 TCP/IP 프로토콜이 어떠한 정보들 담아서 네트워크와 통신하는지 알아봤는데요, 하나 더 알아두어야 할것이 있습니다. TCP는 연결지향형 프로토콜이라는 것이죠.   TCP/IP 3-Way-HandShacking  연결 지향형 프로토콜이란, 상대방과 통신할 준비과 되었는지를 확인하고 통신하는 프로토콜입니다. 연결 되는 과정이 따로 필요한 것이죠. 이러한 연결을 위해서 TCP/IP 프로토콜은 3-Way-HandShacking을 사용합니다.   아까 설명했던 Transport 레이어에서 사용하는 TCP 헤더에는, 플래그가 있습니다. 이러한 플래그하나 하나들을 컨트롤 비트라고 하는데, 이것을 사용하여 통신하기전의 확인 작업을 거친 후 연결이 안정한 것을 확인하면 그때부터 통신을 시작합니다.   이러한 연결 과정이 있기 때문에 TCP/IP 가 신뢰성 연결 지향 방식으로 불리는 것이죠.      위 그림이 TCP 헤더의 플래그인데요, 여기서 3-Way-HandShaking을 위해서는 2개의 플래그, SYN과 ACK을 사용합니다.      위 과정을 보시면 3번의 통신을 보내는데요, 먼저 client가 SYN이 설정된 플래그를 보내고 이것이 서버에 잘 도착되었다면 서버에서는 SYN과 ACK을 설정한 플래그를 보냅니다. 마지막으로 Client가 이를 잘 받았음을 확인하면, 마지막으로 ACK이 설정된 플래그를 보냄으로써 두 개의 기기가 통신할 준비가 완료되었음을 확인하는 것입니다.   이렇게 연결을 먼저 확인하고 통신을 시작하면 한쪽이 꺼져있다거나 문제가 있어서 데이터가 제대로 도착하지 못하는 오류를 방지 할 수 있을것입니다.   마무리하며…  이렇게 TCP/IP 프로토콜에 대해 알아봤는데요. 조금 디테일한 부분이 생략되긴 했지만 대략적으로 어떻게 TCP/IP를 사용한 통신이 이루어지는지 알아보았습니다.   물론 이것이 네트워크의 전부는 아닐 것입니다. 디테일한 부분들도 공부할게 무척 많으니, 하나 하나 천천히 다른 게시물에서 다뤄보도록 하겠습니다.   ","categories": ["CS"],
        "tags": [],
        "url": "/cs/TCP-IP/",
        "teaser": null
      },{
        "title": "[JPA] 영속성 컨텍스트(2)",
        "excerpt":"영속성 컨텍스트는 왜 사용하는 걸까?  저번 게시물에서는 영속성 컨텍스트를 어떻게 사용하며, 무엇인지에 대해 배워보았습니다.   그럼 바로 데이터베이스에 저장을 하면 되지, 왜 굳이 영속성이라는 개념을 만들어서 모아뒀다가 commit()을 만나면 한번에 처리할까요?   영속성을 사용하면, 바로 데이터베이스에 저장하는것 보다 훨씬 안전하고 유용한 기능들을 사용할 수 있기 때문입니다.   그럼 한번 어떤 장점들이 생기는지 알아봅시다.   영속성 컨텍스트의 장점  1차 캐시  영속성 컨텍스트에 올라간 객체는 1차캐시 상태가 되기 때문에 우리가 만약 이 객체를 다시 조회한다면, 데이터베이스에 접근하지 않고 캐시를 사용해서 가져올 수 있습니다.   아래와 같이 코드를 작성해보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();          tx.begin();          try {               Member member = new Member();             member.setId(1L);             member.setName(\"이민재\");             member.setAge(\"26\");               em.persist(member);             Member member1 = em.find(Member.class, 1L);             System.out.println(\"member1 = \" + member1.getId());             System.out.println(\"member1 = \" + member1.getName());              tx.commit();         } catch (Exception e) {             tx.rollback();         } finally {             em.close();         }         emf.close();     }  코드를 실행시키고 로그를 확인해 봅시다.      쿼리가 날아갔는데, member1을 조회할 때 SELECT 쿼리가 날아가지 않은걸 확인 할 수 있습니다.   이처럼 영속성 컨텍스트는 1차 캐싱을 지원하여, 영속상태인 객체를 조회 할때는 굳이 DB에 접근하지 않고도 해당 값을 가져옵니다.   또, 만약 이미 데이터베이스에서 데이터를 찾아올때도 1차캐시를 사용할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();          tx.begin();          try {               Member member1 = em.find(Member.class, 1L);             System.out.println(\"member1 = \" + member1.getId());             System.out.println(\"member1 = \" + member1.getName());              Member member2 = em.find(Member.class, 1L);             System.out.println(\"member2 = \" + member2.getId());             System.out.println(\"member2 = \" + member2.getName());              tx.commit();         } catch (Exception e) {             tx.rollback();         } finally {             em.close();         }         emf.close();     }  위 코드를 실행 하면 어떻게 될까요?   실행 시킨 뒤 로그를 확인해보면,      member1을 조회할 때는 SELECT 쿼리가 날아갔지만, member2를 조회 할때는 1차 캐시에 있는 member를 가져온 것을 확인 할 수가 있습니다. member1이 이미 접근해서 데이터를 가져온 상태이니, member2를 조회 할때는 그냥 캐시에 있는 데이터를 가져온 것이죠.   하지만 사실 대부분 트랜잭션을 사용해서 작업을 하기 때문에 이 기능이 성능에 있어 큰 메리트가 되지는 않습니다. 어차피 트랜잭션이 끝나면 캐시도 사라지기 때문에, 트랜잭션안에서 조회하지 않고서야 이러한 1차 캐시에서의 기능을 사용할 일이 크게 없기 때문이죠.   그래도 성능에 정말 민감한 시스템이라면 이것이 이점이 될 수도 있을것입니다.   하지만 성능을 위해서 사용한다기보다는 더 객체지향적인 코드를 작성하는데에 있어 큰 이점을 줍니다. 이 이점은 뒤에서 마저 설명하도록 하겠습니다.   영속 엔티티의 동일성 보장  영속 컨텍스트에 올라간 엔티티들은 동일성이 보장됩니다. 무슨 말일까요?   다시 위의 코드를 가져와 조금 수정해봅시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21     public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();          tx.begin();          try {              Member member1 = em.find(Member.class, 1L);             Member member2 = em.find(Member.class, 1L);             System.out.println(\"result = \" + (member1 == member2));              tx.commit();         } catch (Exception e) {             tx.rollback();         } finally {             em.close();         }         emf.close();     }  member1 과 member2는 객체는 다르지만 데이터베이스에서 가져온 값이기 때문에 둘은 같아야합니다. 그럼 이 코드를 실행해 볼까요?      member1과 member2가 같다는걸 알 수 있습니다. member1을 데이터 베이스에서 가져오면서 member1이 영속상태가 되었으므로, member2를 찾아오는 요청에는 그냥 1차캐시에 있었던 member의 값을 그대로 member2에 넣어주면 되겠죠?   이렇게 1차캐시의 기능은 영속엔티티의 동일성을 보장해주어, 우리가 객체 지향으로 코딩하는것을 더 편리하게 도와줍니다.   따라서, 1차캐시로 반복가능한 읽기 등급의 트랜잭션 격리수준은, 굳이 데이터베이스까지 사용하지 않고 애플리케이션 차원에서 제공 받을 수 있는 것이죠.   트랜잭션을 지원하는 쓰기지연  앞에서 부터 영속상태인 객체들은 persist()할 때 데이터 베이스에 쓰여지는게 아니라, 해당 정보들을 모두 영속성 컨텍스트에 쌓아뒀다가 commit()을 만나면 그때 쿼리를 날려 데이터 베이스에 쓰기작업을 한다고 했었습니다.   한번 코드로 확인해 볼까요?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23     public static void main(String[] args) {         EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\");         EntityManager em = emf.createEntityManager();         EntityTransaction tx = em.getTransaction();          tx.begin();          try {             Member member1 = new Member(1L, \"이민재\", \"26\");             Member member2 = new Member(2L, \"김아무개\", \"26\");                          em.persist(member1);             em.persist(member2);             System.out.println(\"===================\");                           tx.commit();         } catch (Exception e) {             tx.rollback();         } finally {             em.close();         }         emf.close();     }  보면 두개의 컬럼을 만들어준뒤, 이를 persist()를 이용해 영속성 컨텍스트에 올려봅시다. 그리고 commit()과 persist() 사이에 구분선을 하나 출력해줌으로써 쿼리가 언제 나가는지 확인해보도록 하죠.      역시 앞서 이야기 한대로 persist()가 아니라 commit()이 이뤄져야 쿼리가 날아가 데이터 베이스에 쓰기 작업을 하는 것을 확인 할 수 있습니다.   그럼 이렇게 굳이 느리게 영속성 컨텍스트에 모아놨다가 한번에 데이터베이스에 쓰는 것에는 어떤 이점이 있는 걸까요?   네트워크를 호출 하는 것은 애플리케이션 안에서 단순 메소드를 수만번 호출하는 것 보다 더 큰 비용이 듭니다.  따라서 데이터베이스에 변경점이 있다면, 최대한 모아두었다가 한번 네트워크를 호출할때 모두 처리해버리는 것이 비용이 저렴할 것입니다.   위에서만 해도 쓰기 지연이 되지 않았다면 두번의 네트워크 호출이 필요했던 것을, 모아서 한번에 처리 함으로써 한번의 네트워크 호출로 마무리 한 것을 알 수 있습니다. 모아서 한번에 처리함으로써 네트워크 호출을 최대한 줄이게 되는 것이죠.   엔티티 변경 감지  JPA의 목적은 데이터베이스를 객체지향적으로 마치 자바 컬렉션을 다루듯이 사용할 수 있도록 하는 것입니다. 그렇기 때문에 데이터를 바꾸는 쿼리를 따로 날리지 않고, 그냥 데이터베이스에서 데이터를 불러와 이 객체의 값을 바꿔주면, 알아서 UPDATE 쿼리가 날아가게 됩니다. 코드로 한번 확인해보겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public static void main(String[] args) { \t    EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"hello\"); \t    EntityManager em = emf.createEntityManager(); \t    EntityTransaction tx = em.getTransaction(); \t \t    tx.begin(); \t \t    try { \t        Member member1 = em.find(Member.class, 1L); \t        member1.setName(\"이름변경\"); \t \t        tx.commit(); \t    } catch (Exception e) { \t        tx.rollback(); \t    } finally { \t        em.close(); \t    } \t    emf.close(); }  위 코드를 보면, 데이터베이스로 부터 Member 테이블의 1번 id값을 가져와 객체 member1로 저장한뒤, setName()을 통해서 해당 값을 변경해주었습니다. 코드로만 봐서는 데이터베이스의 값이 바뀌지 않을 것 같다는 생각이 듭니다.   하지만 로그를 확인해보면,      UPDATE 쿼리가 데이터베이스로 날아간 것을 확인 할 수 있습니다.      h2 콘솔로 들어가보니 데이터베이스에서도 올바르게 변경 사항이 적용된 것을 확인 할 수 있습니다.   이것이 바로 변경 감지입니다. 이렇게 하면 벌써 훨씬 객체지향으로 코딩 할 수 있을 것 같이 느껴지지 않으신가요?   그럼 이러한 변경은 어떻게 동작하는걸까요?? 아래 그림을 보도록 합시다.      우리가 member의 데이터를 찾아와 memberA라는 객체에 저장하게 되면, JPA는 1차캐시에 이를 저장함과 동시에 이에 대한 스냅샷을 만듭니다. 스냅샷은 데이터를 받아왔을 때의 데이터를 그대로 담아놓은 것이죠.   그래서 commit()명령을 만나게 되면, 이 스냅샷과 현재 객체의 데이터를 비교한 뒤 다른 부분에 대해서 UPDATE 쿼리를 쓰기 지연 저장소에 모은 뒤, 앞서 말했던 것 처럼 네트워크와 접촉해 데이터 베이스에 반영해주는것이죠.      그림에 보면 flush()라는 명령어가 있는데, 사실 영속성 컨텍스트의 내용을 DB에 반영하는 것은 commit()이 아니고 flush()입니다. commit() 내부에서 flush()를 호출하기 때문에 commit()이 이루어지면 DB에 컨텍스트가 반영 되는 것이죠. commit() 메소드는 flush()를 호출한 뒤 영속성 컨텍스트의 내용과 1차캐시를 모두 제거합니다.    마무리…  이렇게 JPA의 영속성 컨텍스트가 무엇이고, 이로써 얻는 장점이 무엇인지 알아보았습니다.   영속성 컨텍스트가 어떤일을 하는지 알고나니, 왜 JPA가 객체지향적으로 코드를 작성할 수 있게 해준다는건지 조금은 와닿으셨으리라 생각됩니다.   이제 기존의 방식처럼 SQL과 DB에 의존하지 않고 마치 컬렉션을 사용하듯이 값을 저장하고 수정하고, 삭제 할 수 있겠죠?   다음게시물에서는 JPA를 사용하기 위한 테이블 매핑과 연관관계 매핑에 대해 다뤄 보겠습니다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/JPA-%EC%98%81%EC%86%8D%EC%84%B1%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8(2)/",
        "teaser": null
      },{
        "title": "TCP와 UDP",
        "excerpt":"서론  저번 게시물에서는 TCP/IP 프토로콜의 4가지 레이어가 어떤 일을 하며, 어떻게 동작하는지에 대해 알아봤었습니다.   그 중에서 Transport Layer는 데이터의 순차적이고 안정적인 전달을 담당하며, 출발지의 포트번호와 도착지의 포트번호를 헤더에 담아 도착지 컴퓨터에 데이터가 도착하면, 도착 포트를 읽어와 해당 포트에 있는 프로세스로 데이터를 전달합니다.   이러한 Transport Layer에서 사용하는 프로토콜은 대표적으로 두가지가 있는데요, 바로 TCP와 UDP입니다.   그럼 이 둘은 어떤 차이가 있는지 알아보도록 하겠습니다.   TCP  TCP 프로토콜은 Transmission Control Protocol의 약자로써, 신뢰성있고 순차적인 데이터를 보장합니다. 쉽게 풀어서 표현하면, TCP 프로토콜을 사용하면 데이터가 유실되지 않고, 섞일 일도 없이 안전하게 전달 될 수 있다는 것이죠.   그럼 어떠한 방식을 사용하길래 데이터를 안전하게 전달 할 수 있도록 도와준다는 것일까요?   먼저, Transport Layer가 TCP 프로토콜을 사용하게 되면 세그먼트에 TCP 헤더가 추가되는데, 이 헤더에 대해서 알아 봅시다.   TCP 헤더      위 사진이 바로 TCP 헤더의 모습인데요. 뭔가 여러가지의 정보가 있는 것을 확인 할 수 있습니다.   이중에서 먼저 Source port 와 Destination port가 눈에 띕니다.   Source Port, Destination Port      앞서 Transport Layer에서는 목적지 포트에 데이터를 전달한다고 했었습니다. 이 부분이 바로 출발지 포트와 목적지 포트의 번호가 저장되어있는 부분입니다. 데이터가 도착하면 이 포트 번호에 할당된 프로세스로 이 데이터를 전송합니다.   Sequence Number      다음은 Sequence Number입니다. 이 숫자는 데이터의 순서를 보장하기 위한 부분으로, 데이터가 클 경우에는 데이터를 쪼개서 보내기 때문에 이 데이터가 섞이지 않도록 순서를 Sequence Number에 적어서 보내게 됩니다.   Sequence Nubmer는 최초 데이터 전송시에 랜덤한 수로 초기화 되며, 이후 자신이 보내게 될 데이터 1bytes당 시퀀스 번호가 1씩 증가하면서 보내집니다.   예를들어 5바이트의 데이터를 전송한다고 가정해봅시다.   그렇다면 랜덤으로 먼저 첫번째 데이터의 Sequence Number를 초기화 하겠죠? 랜덤으로 0으로 초기화 됐다면, 첫번째 데이터는 0, 두번째는 1, 세번째는 2… 이와같이 랜덤으로 초기화 된 번호에서 1바이트당 1씩 증가합니다.   Acknowledgement Number      Acknowledgemnt Number는 수신자가 다음으로 받기로 예상되는 번호를 의미합니다.   예를 들어보겠습니다. 마찬가지로 5바이트의 데이터를 보낸다고 가정하면, Sequence Numbers는 앞서 설명한대로 0,1,2,3,4의 순차적인 숫자를 갖게 될 것입니다. 그럼 송신 쪽에서는 Acknowlegement Number에 5를 보냄으로써 다음으로 받아야 할 Sequence Number의 번호를 보냄으로써 다음으로 보내야할 데이터의 시작점을 알려줍니다.   따라서 Acknowledgement Number는 상대방이 처음 보낸 시퀀스 번호 + 자신이 받은 데이터의 Bytes가 된다는 것을 알 수 있습니다.   Data Offset      이 부분은 세그먼트중에서 헤더가 아닌 데이터가 시작되는 부분을 표현해주는 부분입니다.   예를들어 (실제로는 이렇지 않지만 이해를 쉽게 하기 위해 간략화 해서 표현하겠습니다.) 00001111 의 데이터가 있고, 0000이 헤더고 1111이 데이터라면, Data Offset에 5가 적혀있다면 이 세그먼트의 데이터는 5번째 데이터 부터구나~ 라고 컴퓨터가 알 수 있게 되는 것이죠.   Reserved      Reserved는 미래를 위해 예약된 필드로, 모두 0으로 채워져야합니다.   Flags  이 비트들은 현재 세그먼트의 속성을 나타내는 부분입니다. 여러가지 비트 플래그가 채워지고 비워진 상태를 확인 함으로써 이 데이터가 현재 어떤 요청을 보내고 있는지 확인 할 수 있습니다.                  필드       의미                       URG       Urgent Pointer(긴급 포인터) 필드에 값이 채워져있음을 알리는 플래그. 이 포인터가 가리키는 긴급한 데이터는 높게 처리되어 먼저 처리된다. 요즘에는 많이 사용되지 않는다.                 ACK       Acknowledgment(승인 번호) 필드에 값이 채워져있음을 알리는 플래그. 이 플래그가 0이라면 승인 번호 필드 자체가 무시된다.                 PSH       Push 플래그. 수신 측에게 이 데이터를 최대한 빠르게 응용프로그램에게 전달해달라는 플래그이다. 이 플래그가 0이라면 수신 측은 자신의 버퍼가 다 채워질 때까지 기다린다. 즉, 이 플래그가 1이라면 이 세그먼트 이후에 더 이상 연결된 세그먼트가 없음을 의미하기도 한다.                 RST       Reset 플래그. 이미 연결이 확립되어 ESTABLISHED 상태인 상대방에게 연결을 강제로 리셋해달라는 요청의 의미이다.                 SYN       Synchronize 플래그. 상대방과 연결을 생성할 때, 시퀀스 번호의 동기화를 맞추기 위한 세그먼트임을 의미한다.                 FIN       Finish 플래그. 상대방과 연결을 종료하고 싶다는 요청인 세그먼트임을 의미한다.           위 6개의 플래그는 기존에 사용하던 6개의 비트 플래그이며, 후에 혼잡제어 기능의 향상을 위해서 3개의 플래그 비트가 더 추가되었습니다.   이를 ECN(Explicit Congestion Notification)이라 하며, 네트워크의 혼잡 상태를 알리기 위한 방식입니다.   기존에는 타임아웃을 이용한 방식을 통해서 일정 시간이상 응답이 없으면 이를 네트워크 혼잡 상태로 판별하여 처리했지만, 처리속도가 아주 민감한 어플리케이션에서는 이러한 대기시간을 줄이는 것이 더 좋기 때문에, 이러한 3개의 플래그비트를 추가하여 네트워크의 혼잡도를 명시적으로 표시하여 알립니다.                  필드       의미                       NS       ECN에서 사용하는 CWR, ECE 필드가 실수나 악의적으로 은폐되는 경우를 방어하기 위해 RFC 3540에서 추가된 필드                 ECE       ECN Echo 플래그. 해당 필드가 1이면서, SYN 플래그가 1일 때는 ECN을 사용한다고 상대방에게 알리는 의미. SYN 플래그가 0이라면 네트워크가 혼잡하니 세그먼트 윈도우의 크기를 줄여달라는 요청의 의미이다.                 CWR       이미 ECE 플래그를 받아서, 전송하는 세그먼트 윈도우의 크기를 줄였다는 의미이다.           ECN은 따로 다룰 정도로 많은 내용이 있기 때문에, 알아두기만 하고 자세한 설명은 따로 다루도록 하겠습니다.   Window Size     Window Size 필드에는 한번에 전송할 수 있는 데이터의 양을 의미하는 값을 담습니다.   예를 들어, 한번에 10비트의 파일을 10개로 나누어 sequence number를 0,1,2…10까지 보낸다면 이 데이터들은 각각 10이라는 window size를 갖게 되는 것이죠.   Checksum     Checksum은 데이터를 송신하는 중에 발생할 수 있는 오류를 검출하기 위한 값입니다.   TCP의 Checksum은 전송한 데이터를 16Bits씩 나누어 모두 더한 후, 이를 1의 보수를 취해주어 나온값을 사용하여 전송된 데이터에 오류가 있는지를 확인합니다.   예를 들어, 11011011 이라는 데이터가 있다면 (실제로는 16비트씩 나누어 계산하지만, 예시에서는 4비트로 간단하게 생각해보겠습니다.)   4비트씩 나누어 (실제로는 16비트) 모두 더해줍니다.   1101 + 1011  = 11000   근데 이렇게 하면 4비트(실제로는 16비트)를 넘어서서 Checksum의 길이를 초과하게 됩니다. 이럴때는 앞에있는 캐리(두개의 수를 더했을때 자리수가 올라간 부분)을 떼어내어 다시 이 값에 더해줍니다.   1000 + 0001 = 1001   이러한 방법을 Wrap Around라고 합니다.   이제 이 값의 1의 보수를 취해주면 됩니다. 1의보수는 쉽게 말하면 2진수값을 모두 반전 시킨 값으로, 1001 의 경우는 0110이 됩니다.   따라서 이 데이터의 Checksum은 0110이 됩니다. 이 Checksum과 데이터의 총합인 1001을 더하면 어떻게 될까요?   당연히 1의 보수를 취한값이니 모두가 1로이루어진 수가 나올 것입니다. 따라서 송신측에서는 위 과정을 통해 Checksum을 만들어 송신하고, 수신측에서는 받은 데이터를 위 과정을 거쳐 값을 만든 뒤 Checksum과 더해봄으로써 정상적인 1로만 이루어진 값이 나오는지 확인합니다.   이런 방식을 쓰면 데이터가 중간에 손상되었는지 알 수 있을 것입니다. 전달받은 데이터를 더한 뒤, 이를 Checksum과 더해서 0이 있는지를 확인하면 됩니다.   Urgent Pointer      말그대로 urgent한 pointer, 긴급한 포인터입니다. 먼저 처리가 필요한 데이터를 표시합니다. 만약 5바이트의 데이터가 있고 Urgent Pointer가 1이라면, 두번째 데이터를 먼저 처리할 것입니다.   정리  TCP는 위와 같은 기능등을 통해서 안전한 연결을 보장합니다.   Sequence Number를 통해서 들어온 데이터의 순서도 보장하며, 플래그 비트를 통해서 통신을 하기전에 올바르게 통신이 가능한 상태인지 확인하는 3-Way-HandShake를 통해 데이터가 올바르게 수신되었는지도 확인합니다. 게다가 마지막에 Checksum을 통해서 데이터가 혹여나 손상되었는지 확인하니, 안전하게 데이터를 송수신 할 수 있겠죠?   그럼 UDP는 어떨까요?   UDP  UDP는 User Datagram Protocol로, 이도 마찬가지로 Transport Layer에서 사용하는 프로토콜입니다.   UDP는 위에서 말한 TCP와 같은 역할을 하지만, TCP가 제공하는 기능들 중에 단 두가지만 지원합니다.   바로 포트번호와 Checksum입니다. 따라서 출발지와 도착지 포트를 갖고 해당 포트에 도착한 뒤,  Checksum을 사용해서 데이터가 손상되었는지만을 확인합니다.   그럼 기능이 TCP가 압도적으로 많은데, UDP는 왜 필요할까요?   TCP와 UDP의 차이  TCP와 UDP의 가장 큰 차이점은 무엇일까요? 바로 TCP는 연결 지향 프로토콜 임에 반해, UDP는 비연결 지향 프로토콜이라는 것입니다.   이것이 무슨 뜻일까요?   TCP의 경우는 데이터를 송신하기전에, SYN과 ACK 플래그 비트를 통해서 현재 통신이 가능한 상태인지 확인하는 3-Way-Handshake과정을 거친다고 했습니다.      위처럼 통신전에 클라이언트는 SYN 비트가 1인 데이터를 보내고, Server가 이를 받으면 ACK과 SYN이 1인 데이터를 또 보낸뒤, 이것이 만약 클라이언트측이 정상적으로 수신했다면 마지막으로 ACK을 보내면서 현재 통신이 원활한 상태, 연결되었다는 것을 확인하는 것이죠.   심지어 데이터의 Sequence Number를 통해서 순서까지 보장해주니, 통신의 신뢰성이 보장됩니다.   하지만 TCP의 단점은 무엇일까요?   아무래도 데이터 통신을 보낼때마다 3번의 확인을 통해 연결을 확인하니, 속도가 떨어질 것입니다.   반면 UDP의 경우는 여러 확인과정이 없으니 속도는 TCP에 비해서 매우 빠르겠죠?? 하지만 역시 확인과정을 거치지 않는 UDP는 통신의 신뢰성이 보장되지 않습니다. 연결이 안된상태라도 이를 데이터 송신자가 알수도없고, 순서가 잘못되도 이것이 잘못된 것인지 알 수 없죠. 평균적으로 7퍼센트의 데이터가 유실된다고 합니다.   따라서 데이터의 신뢰성보다는 속도가 중요하다면 UDP를, 데이터의 신뢰성이 중요하다면 TCP를 사용하게 되는 것입니다.   마무리…  이처럼 TCP와 UDP는 어떤 차이점을 갖고있고, 어떤 상황에 따라 어떤 프로토콜을 써야하는지 알아봤습니다.   공부해보니 왜 TCP가 주류 프로토콜로 사용되는지 잘 알 수 있었습니다. 다음 게시물에서는 TCP에 대해서 자세히 알아보도록 하겠습니다.   ","categories": ["CS"],
        "tags": [],
        "url": "/cs/TCP%EC%99%80-UDP/",
        "teaser": null
      },{
        "title": "5월초의 이것저것",
        "excerpt":"2022.05.10  지난 주 토요일에 카카오 코딩테스트를 봤다. 일요일은 어버이날이라 집에 친척들이 오셔서 회좀 먹고, 월요일은 여자친구랑 데이트를 했다.   월요일에는 집앞에 산책을 좀 다녀왔는데, 우리집앞이 이렇게 예쁜줄 몰랐다. 사실 이사온지 거의 1년이 다되가는데 아파트 앞에 상가말고는 가본적이 없어서… 단독주택들이 이렇게 많이 예쁘게 지어지고 새로운 카페가 많이 생긴줄 몰랐었다.   집앞에 있는 새로 생긴(물론 생긴지 꽤 됐는데 내가 몰랐던) 카페에서 날라리디스코(?) 라는 이름의 원두로 내린 커피도 한잔시켰는데, 나는 원래 강배전 커피를 좋아해서 산미가 거의 없는 커피를 마시다가 이번에는 한번 산미가 있는 커피로 시켜봤는데 그것도 나름대로 맛이 있어서 좋았다. 물론 과일향이 난다고 하는데 그런건 하나도 모르겠고…   요즘은 맨날 먹던것 보다 새로운 걸 먹는게 더 재밌는 것 같다.   최근에 방구석에서 공부만 하느라 학교가는거 외에는 밖에 잘 안나갔었는데, 어제 날씨가 너무 좋아서 진작 밖에 산책이라도 좀 다닐걸 하는 생각을 좀 했다.   5월 이즈음의 날씨가 1년중에 가장 선선하고 좋은것 같다.   카카오 코딩테스트는 2.5솔을 했다. 안정권은 아니고, 정말정말 운이좋다면 면접을 볼 수 있을 정도? 기대는 안하려고 한다. 최근에 나름 하루에 한문제씩 코딩테스트를 풀려고 다짐하고나서 몇일을 그렇게 풀다가, 그게 너무 괴로워서 흐지부지 되었는데, 코테가 끝나고는 또 열심히 하지 못한 내 자신이 너무 슬펐다.   그래서 씁쓸하기도 하고… 생각도 정리할겸 요 이틀간에는 책상에 한번도 안 앉았었는데, 이 잠깐의 휴식이 뭐라고 그래도 좀 마음도 편해지고, 재충전이 된 것 같다는 생각이 좀 든다.   최근에 공부를 너무 억지로 사로잡혀서 강박적으로 한 느낌이 없지 않아 있는데, 매일 매일 시간을 측정하다 보니까 자꾸 시간으로만 내 지표를 평가하려고 해서 그게 좀 나를 괴롭혔던 것 같다. 반성한다.   그렇다고 이제는 시간을 측정안하겠다 이런건 아니고 시간도 시간인데 그래도 시간을 채우는 것 그 자체가 본질을 흐려버린 느낌이라서, 다시 생각을 좀 정리해보자는 말이다.   눈깜짝하니 또 5월, 1년의 반을 코앞에 두고 있다. 문득 작년 12월쯤 우테코를 떨어지고 맘아팠던 2020년의 말이 생각난다. 난 그때보다 얼만큼 더 나은 사람이 되었을까…   최근에는 운동을 다시 시작했다. 운동하는게 너무너무 싫어서 하다가 포기하고, 또 다시 하다가 흐지부지되고의 반복이었는데, 이제는 좀 궤도에 올라서 지난 2주간은 거의 매일같이 헬스장에 가서 운동을 했다.   사실 취준만큼 사람의 자존감이 깎여나가는 시기가 있나 싶다. 내 노력이 점수로 딱 나오는것도 아니고, 떨어져도 뭐가 부족한지 잘 감도 안오고, 누가 알려주지도 않으니 나 혼자서 망망대해에서 길을 찾는 기분이랄까.   친구가 차를 샀다거나, 취업을 좋은데에 했거나, 예쁜데를 놀러갔다거나… 특히나 나보다 먼저 취업한 여자애들을 보면 조금 속이 상하곤 한다. 열등감이라고 하면 뭐 할말 없다.   친구들도 만날 여유가 다들 없어서, 최근에 거리두기가 해제됐는데, 뭐 나는 바뀐게 하나없다. 나 혼자만 사회에서 거리두기를 아직 하는 느낌이 들 정도로 최근에 나는 혼자 집에서 컴퓨터에다 이렇게 글을 쓰는 것 말고는 누구랑 만난 적이 잘 없다.   그래서 좀 자존감도 깎이고 맨날 컴퓨터만 뚜들기도 좀 지쳐서, 자존감도 좀 올리고 취미도 가질 겸 운동이라도 열심히 해보자 싶어서… 다시 운동시작한 이유를 주저리 주저리 써봤다.   어쨌든 그냥 생각나는대로, 사실 어디다 말할데도 마땅히 없어서 여기다가 여러가지 써봤는데… 5월에는 좀 산책도 자주하고, 운동도 열심히 하고, 좋은 소식도 좀 많았으면 좋겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%B9%B4%EC%B9%B4%EC%98%A4%EC%9D%B8%ED%84%B4-%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[Spring] 프로젝트 준비",
        "excerpt":"서론  최근에 인프런 강의를 듣거나 책을 읽으며 공부를 하는 중이었는데, 아무래도 이론만 배우다보니 숙달하고 적용하기가 어려울 뿐더러 직접적인 개발 실력이 오르지 않는 느낌이 들었다. 그래서 프로젝트를 하나 진행하며, 그 진행 상황을 블로그에 공유해보려 한다.   프로젝트 내용은 내가 작년에 단장을 맡았던 동아리 자몽의 봉사 신청관리 웹페이지를 만들어 보는 것이다. 이 프로젝트를 선정한 이유는 우선 내가 가장 원했던 프로젝트의 조건은 사용자가 있을 것 이었는데, 기존에 사용하던 방식보다 편리하게 만들기만 하면 따로 사용자 모집이 필요없이 100명 가량의 접속자가 생긴다는 것이 첫 번째 이유였고, 단장을 할 때도 봉사 신청을 받고 이것을 관리하는 것이 매우 번거롭고 귀찮았어서 이 과정을 웹페이지로 만들어서 봉사 등록과 신청을 받고 알림까지 하게 하면 후임 단장들한테도 도움이 될 것 같아 이 아이디어로 프로젝트를 제작해보기로 했다.   기능 사항  만들고자 하는 기능은 추후에 변경될 수도 있겠지만 지금 계획중인 것들은 다음과 같다.      봉사 관리            봉사를 등록하는 기능                    봉사 내용, 장소, 일시, 인원등을 포함하여 게시글로 등록           봉사 등록 시, 전원에게 봉사 등록 알림 메일 or 카톡 발송           봉사 인원이 제한이 있어서 선착순 등록이 필요하다면, 봉사 기획자가 설정한 신청 가능 시간에만 신청가능                       봉사 삭제 기능                    봉사 등록자만 삭제 가능                       봉사 완료기능                    봉사 등록자만 완료 처리 가능           완료된 봉사는 완료된 봉사 탭에서 조회 가능                       봉사를 신청하는 기능                    봉사를 신청하게 되면 확정 알림 메일 or 카톡이 발송           선착순 봉사에 대기순위로 등록되었다면, 대기 순위 알림 메일 or 카톡 발송           선착순 봉사에 결원 발생 시 자동으로 대기자 우선순위 순서대로 메일 or 카톡 발송                       봉사를 취소하는 기능                    신청 사유 제출과 함께 봉사를 취소 가능                           회원 관리            회원 등급 기능 (게스트, 신입, 운영진, OB)                    게스트                            신청서 작성이나 게시물 열람만 가능                                   신입                            봉사 신청, 등록, 취소 가능                                   운영진                            봉사 신청, 등록, 취소 가능               멤버 등급 조정 기능               자신이 작성한 게시물 외에도 삭제 가능                                                   신입 모집            날짜를 설정 후 모집기능을 활성화 하면 해당 탭에서 지원서를 작성 가능       운영진들은 해당 지원서들을 웹에서 열람 가능       합격인원에 대해서 자동 메일 발송           패키지 구조  크게 패키지 구조는 도메인형 패키지 구조와 레이어형 패키지 구조로 나눌 수 있다.   도메인형 패키지 구조  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 com  ㄴ dsm      ㄴ clematis          ㄴ domain          |   ㄴ account          |   |   ㄴ controller          |   |   |   ㄴ request          |   |   |   ㄴ response          |   |   ㄴ service          |   |   |   ㄴ provider          |   |   ㄴ repository          |   ㄴ project          |   |   ㄴ controller          |   |   |   ㄴ request          |   |   |   ㄴ response          |   |   ㄴ service          |   |   |   ㄴ provider          |   |   ㄴ repository          ㄴ Application  위처럼 도메인형 구조는 해당 도메인별로 패키지를 중심으로 구성하여, 계정에 관한 컨트롤러와 서비스등이 모두 account에 모여있는 구조이다.   레이어형 패키지 구조  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 com  ㄴ example      ㄴ jamong          ㄴ configuration          ㄴ controller          |   ㄴ request          |   ㄴ response          |   ㄴ filter          ㄴ domain          ㄴ exception          |   ㄴ entrypoint          |   ㄴ handler          ㄴ repository          ㄴ service          |   ㄴ attribute          |   ㄴ provider          ㄴ Application  레이어형 패키지 구조는 레이어를 중심으로 패키지를 구성하는 것으로, controller는 controller끼리, service는 service끼리 모아 놓는 식으로 패키지를 구성한다.   이 둘은 각각의 장단점이 있는데, 사실 기존에 책이나 강의에서 기본적으로 레이어형 패키지 구조를 사용해서 나도 자연스럽게 레이어형으로 패키지 구조를 설계하곤 했었는데, 쓸 때 마다 도메인형 구조가 더 효율적으로 느껴지는 상황이 자주 나왔었다.   아무래도 레이어형 구조는 도메인형에 비해 비직관적인 부분이 있어서, 내가 해당 기능에 맞는 부분을 찾을때 직관적으로 느껴지지 않아서 조금 불편했다. 예를들어 회원에 대한 기능을 찾으려면 도메인형 패키지 구조에서는 해당 도메인 폴더로 가서 기능을 수정하면 되는데, 레이어형 패키지 구조에서는 controller나 service 폴더로 가서 내가 수정하려하는 도메인에 해당하는 클래스를 찾기 번거로운 부분이 있었다.   그리고 요즘은 마이크로서비스아키텍쳐가 대세기 때문에 대부분의 기업에서도 도메인으로 구분하는 경우가 늘었다고 해서, 이번 프로젝트는 도메인형 패키지 구조를 선택해서 진행해보기로 했다.   자바 8 &amp; 자바 11  지금까지는 그냥 책에서 자바 8쓰면 자바 8 쓰고, 자바 11쓰면 자바 11쓰곤 했는데, 막상 프로젝트에서 사용하려니까 조금 고민이 되서 정보를 조금 찾아봤다.   11에서 변경된 점들이 따로 게시물 하나로 다룰만큼의 양이라서, 굳이 모든 변경사항을 쓰지 않고, 내가 체감할만한 변경점을 정리해보았다.                  Java 8       Java 11                       String 문자열 관련 메소드가 적음       isBlank(), line(), repeat(n), stripLeading(), stripTrailing(), strip()와 같은 새로운 String 문자열 방법이 도입됨                 람다식에 특수 변수 사용 불가       람다식에 var 변수 사용가능                 로컬 파일에 접근하여 작업 수행 불가       writeString(), readString(), isSamFile()과 같은 다양한 메소드로 파일에 접근하여 작업 수행 가능                 Parallel GC       G1 GC           사실 자바 8에서 이미 자바에서 사용가능한 stream이라던가 람다식, Optional등의 주요 편의기능이 추가된 상태이기 때문에, 11에서의 변경점이 크지 않았다.   그래서 자바 8을 그냥 사용하려다가도, 자바 11의 GC가 개선되어 좀 더 성능이 좋다고 하여 조금 고민이 되었다.   하지만 결국 자바 8로 선택했는데, 이유는 다음과 같다.      외부 라이브러리나 프레임워크들과의 연동성   프로젝트를 진행하다보면 자바 어플리케이션만을 사용하는게 아니라 여러가지 다른 외부 툴들을 사용해야한는데, 아무래도 자바 8이 나온지도 오래되었고, 자바 11에서는 요금 정책변경으로 인해서 Open JDK를 사용할때만 무료로 사용가능 하기 때문에 툴과의 연동성에서 생기는 이슈들이 종종 있다고 한다.      변경사항이 크게 메리트가 없음   아까 언급했다 싶이 개발의 효용성을 가시적으로 높여줄만한 메서드가 추가된 것도 아니고, 성능 문제도 사실 내가 만드는 프로젝트가 성능에 민감한 프로젝트가 아니다보니, 오히려 연동성도 좋은 자바 8을 사용하는게 더 맞다고 생각했다.      버젼 변경이 크게 어렵지 않음   자바 8 -&gt; 자바 11로 프로젝트의 자바 버젼을 변경하는게 크게 어렵지 않아서, 사용하다가 자바 11로 변경해야하는 상황이 생기면 그때 변경하는게 낫다는 생각이 들었다.   마무리하며…  이번 프로젝트는 구현을 빨리하는것보다 하나하나 고민하고 기록해가면서 진행해 볼 생각이다.  최대한 실제 서비스를 제작한다는 생각으로 꼼꼼한 커밋과 테스트 코드 작성을 하며 실력을 더 키울 수 있는 기회가 되었으면 좋겠다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%A4%80%EB%B9%84/",
        "teaser": null
      },{
        "title": "[Spring] API 문서작성 툴 고르기",
        "excerpt":"서론  먼저 실제적인 개발전에 대략적인 준비를 마치고, 먼저 API를 설계해보기로 했다. 또한 설계뿐만 아니라, 프론트엔드 개발자에게 이 정보를 공유해야 하기 때문에 API를 문서화 하여 남겨 간편하게 내가 업데이트한 내용을 문서에서 확인 할 수 있도록 해보기로 했다.   어떤 툴을 사용할까  API를 문서화 하기 위한 여러 툴들이 있어서, 하나씩 알아보며 이번 프로젝트에는 어떤 툴이 적합할지 알아보았다.   Swagger        Swagger API 문서 예시 (링크)    Swagger는 무료로 제공되고, 문서자체에서 바로 해당 API를 테스트해 볼 수 있다는 점이 마음에 들었다. 그러나 API를 카테고리 별로 나누는 기능이 없어서 모든 API가 한페이지에 나타나기 때문에 후에 원하는 API를 한번에 찾을 수 없다는게 단점으로 느껴졌다.   Postman        Postman API 문서 예시 (링크)    Swagger보다 훨씬 문서의 느낌이 나고 UI가 깔끔해서 좋았다. 마크다운 형식으로 간단하게 문서를 작성 가능해서 Swagger보다는 훨씬 원하는 API를 찾기 쉬워서 좋아보였다.   게다가 실제로 날린 API 기반으로 자동으로 문서 부분을 생성해주고, 사용 예시까지 알려주기 때문에, 해당 API에 대한 코멘트만 추가해주면 알아서 자동으로 API 문서를 만들어주었다.   GitBook        GitBook API 문서 예시 (링크)    GitBook은 아주 깔끔한 UI가 장점이었다. Postman이나 Swagger처럼 웹에서 바로 해당 API를 테스트 해보는 기능은 없었지만, 해당 API를 굳이 날려보지 않아도 될 만큼 깔끔한 UI가 있어서 문서로써의 기능을 가장 잘하고 있는 것 같았다.   해당 API에 대한 파라미터와 응답까지 모두 기록하기 편하게 UI가 되어있어서 해당 API에 대한 세부사항 까지를 볼 수 있었다.   하지만 앞서 말했듯이 페이지에서 바로 해당 API에 요청을 날려볼 수는 없는 점이 너무 아쉬웠다.   결론  Swagger는 UI가 너무 맘에 안들기도 하고 직관적이지 않아서 문서의 느낌이 덜한 것 같아 Postman과 GitBook사이에서 고민했는데, Postman보다는 GitBook의 UI가 훨씬 직관적이고 디테일했지만, 온라인에서 바로 테스트 해볼 수 있는 기능이 없다는게 아쉬웠다.   하지만 자세하게 API 문서를 작성해놓으면 굳이 사용자가 해당 API를 테스트해 볼 필요가 있을까라는 생각이 들기도 했고, API 문서라는건 결국 문서이므로 직관적이고 깔끔하게 사용자가 보는것이 중요하다고 생각되서 GitBook으로 결정하기로 했다. Github와 연동이 가능하다는 점도 GitBook의 큰 장점으로 느껴졌다.   그럼 이제 작성 툴도 정했으니, API를 설계해서 문서의 초안을 대략 짜놓고 개발해가며 변경점을 적용해가며 문서와 함께 프로젝트를 시작해볼 것 이다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-A-%EB%AC%B8%EC%84%9C-%EC%9E%91%EC%84%B1%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] API 초안 설계하기",
        "excerpt":"서론  그 동안은 개발하면서 필요할때마다 그때 그때 필요한 API를 만들곤 했는데, 그렇게 진행하면 나중에 API가 서로 중복되서 꼬이는 상황도 발생하기도 하고, 프론트엔드 개발자도 미리 이러한 API를 만들 것이다~ 라는 가이드라인이 있으면 개발이 훨씬 수월하다고 해서,   이번에는 대략적인 API 설계를 초기에 진행하여 문서로써 초안을 제작한 뒤, 이에 맞춰 개발해보려한다.   문서작성 툴은 앞서 게시물에서 다뤘듯이 GitBook을 사용하기로 했다.   API 설계  대략적으로 필요한 도메인은 다음과 같다.      Volunteer (봉사 활동)   User (유저)   Post (게시물)   Comment (댓글)   Application (지원서)   Volunteer  GET  1 /volunteers  현재 데이터 베이스에 있는 모든 봉사들을 받아온다.   1 /volunteers?pageno = {pageNumber}  현재 데이터베이스에 있는 페이지를 10개씩 가져온다.  예를들어, pageNumber가 1이라면, 1번 부터 10번까지의 게시물을 가져온다.   1 /volunteers/{id}  해당 아이디에 해당하는 봉사 활동을 가져온다.   POST  1 /volunteers  봉사 활동을 생성한다.   PATCH  1 /volunteers/{id}  해당 아이디에 해당하는 봉사 활동을 업데이트한다.   DELETE  1 /volunteers/{id}  해당 아이디에 해당하는 봉사 활동을 삭제한다.   User  GET  1 /users  전체 유저들을 가져온다.   1 /users?pageno = {pagaNumber}  현재 데이터베이스에 있는 유저들을 10개씩 가져온다.  예를들어, pageNumber가 1이라면, 1번 부터 10번까지의 게시물을 가져온다.   1 users/{id}  해당 아이디에 해당하는 유저를 가져온다.   POST  1 /users  새로운 유저를 생성한다.   PATCH  1 users/{id}  해당 아이디의 유저의 정보를 업데이트 한다.   DELETE  1 /users/{id}  해당 아이디에 해당하는 유저를 삭제한다.   Post  GET  1 /posts  전체 게시물을 가져온다.   1 /posts?pageno = {pagaNumber}  현재 데이터베이스에 있는 게시물들을 10개씩 가져온다.  예를들어, pageNumber가 1이라면, 1번 부터 10번까지의 게시물을 가져온다.   1 posts/{id}  해당 아이디에 해당하는 게시물을 가져온다.   POST  1 /posts  새로운 게시물을 생성한다.   PATCH  1 posts/{id}  해당 아이디의 게시물의 정보를 업데이트 한다.   DELETE  1 /posts/{id}  해당 아이디에 해당하는 게시물을 삭제한다.   Application  GET  1 /applications  전체 신청서를 가져온다.   1 /applications?pageno = {pagaNumber}  현재 데이터베이스에 있는 신청서들을 10개씩 가져온다.  예를들어, pageNumber가 1이라면, 1번 부터 10번까지의 게시물을 가져온다.   1 applications/{id}  해당 아이디에 해당하는 신청서를 가져온다.   POST  1 /applications  새로운 신청서를 등록한다.   PATCH  1 applications/{id}  해당 아이디의 게시물의 신청서를 업데이트 한다.   DELETE  1 /applications/{id}  해당 아이디에 해당하는 신청서를 삭제한다.   이렇게 간단하게 작성한 문서를 바탕으로 GitBook으로 옮겨 작성해 보도록 하자.   GitBook에 문서 만들기   GitBook의 양식에 맞게 위의 내용을 정리해보자.   GitBook은 별다른 설정 없이도 간단하게 API 문서를 만들도록 도와 준다.   아래 링크로 가면 이 내용에 관한 API 문서 초안을 확인 할 수 있다.   https://lee-min-jae.gitbook.io/api/   마무리하며…  이렇게 간단하게 본격적인 개발 전 API 설계를 끝마쳤다. 개발하며 세세하게 json 응답 예시도 추가해주고, 디테일한 부분도 수정해가면서 문서와 함께 개발을 진행하다보면 문서가 더욱 더 풍성해 질 것 같다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-API-%EC%B4%88%EC%95%88-%EC%84%A4%EA%B3%84%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 14499 주사위 굴리기 (Python3)",
        "excerpt":"문제  크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다.  1 2 3 4   2 4 1 3   5   6   주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.   지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.   주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.   주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.   입력  첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20), 주사위를 놓은 곳의 좌표 x, y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.   둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 지도의 각 칸에 쓰여 있는 수는 10 미만의 자연수 또는 0이다.   마지막 줄에는 이동하는 명령이 순서대로 주어진다. 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.   출력  이동할 때마다 주사위의 윗 면에 쓰여 있는 수를 출력한다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import sys   N, M, x, y, K = map(int, input().split())  dx = [0, 0, -1, 1]  dy = [1, -1, 0, 0]  dice = [0 for _ in range(7)]  arr = [list(map(int, input().split())) for _ in range(N)]  order = list(map(int, input().split()))   def move(direction):      if direction == 1:          dice[1], dice[3], dice[4], dice[6] = dice[3], dice[6], dice[1], dice[4]      elif direction == 2:          dice[1], dice[3], dice[4], dice[6] = dice[4], dice[1], dice[6], dice[3]      elif direction == 3:          dice[1], dice[2], dice[5], dice[6] = dice[2], dice[6], dice[1], dice[5]      elif direction == 4:          dice[1], dice[2], dice[5], dice[6] = dice[5], dice[1], dice[6], dice[2]   for i in order:      nx = x+dx[i-1]      ny = y+dy[i-1]      if not 0 &lt;= nx &lt; N or not 0 &lt;= ny &lt; M:          continue      x, y = nx, ny      move(i)      print(\"dice: \", dice)          if arr[x][y]:          dice[1] = arr[x][y]          arr[x][y] = 0      else:          arr[x][y] = dice[1]      print(dice[6])     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  4 2 0 0 8  0 2  3 5  5 6  7 8   4 4 4 1 3 3 3 2   dice:  [0, 0, 0, 0, 0, 0, 0] 0 dice:  [0, 0, 3, 0, 0, 0, 0] 0 dice:  [0, 0, 5, 0, 0, 0, 3] 3 dice:  [0, 0, 5, 3, 7, 0, 0] 0 dice:  [0, 5, 0, 3, 7, 8, 0] 0 dice:  [0, 0, 0, 3, 7, 6, 8] 8 dice:  [0, 0, 8, 3, 7, 5, 6] 6 dice:  [0, 7, 8, 2, 6, 5, 3] 3   이 문제는 구현 문제로, 주사위를 굴리는 함수를 만드는것이 핵심인 문제이다.   주사위가 굴려지는 방향에 따라 변하는 함수를 다음과 같이   1 2 3 4 5 6 7 8 9 10 def move(direction):      if direction == 1:          dice[1], dice[3], dice[4], dice[6] = dice[3], dice[6], dice[1], dice[4]      elif direction == 2:          dice[1], dice[3], dice[4], dice[6] = dice[4], dice[1], dice[6], dice[3]      elif direction == 3:          dice[1], dice[2], dice[5], dice[6] = dice[2], dice[6], dice[1], dice[5]      elif direction == 4:          dice[1], dice[2], dice[5], dice[6] = dice[5], dice[1], dice[6], dice[2]     이렇게 패턴을 갖고 움직인다. 이 패턴으로 주사위가 움직이는 것을 구현하면 나머지는 쉽게 해결된다.   ","categories": ["baekjoon"],
        "tags": [],
        "url": "/baekjoon/BOJ-14499-%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B5%B4%EB%A6%AC%EA%B8%B0-(Python3)/",
        "teaser": null
      },{
        "title": "[BOJ] 2644 촌수계산 (Python3)",
        "excerpt":"문제  우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.   여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.   입력  사람들은 1, 2, 3, …, n (1 ≤ n ≤ 100)의 연속된 번호로 각각 표시된다. 입력 파일의 첫째 줄에는 전체 사람의 수 n이 주어지고, 둘째 줄에는 촌수를 계산해야 하는 서로 다른 두 사람의 번호가 주어진다. 그리고 셋째 줄에는 부모 자식들 간의 관계의 개수 m이 주어진다. 넷째 줄부터는 부모 자식간의 관계를 나타내는 두 번호 x,y가 각 줄에 나온다. 이때 앞에 나오는 번호 x는 뒤에 나오는 정수 y의 부모 번호를 나타낸다.   각 사람의 부모는 최대 한 명만 주어진다.   출력  입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 n = int(input()) first, second = map(int, input().split()) m = int(input())  graph = [[] for _ in range(n + 1)]  for i in range(m):     parent, son = map(int, input().split())     graph[parent].append(son)     graph[son].append(parent)      visited = [-1 for _ in range(n + 1)]  def dfs(v):      for i in graph[v]:         if visited[i] == -1:             visited[i] = visited[v] + 1             dfs(i)                           visited[first] = 0 dfs(first) print(visited[second])              1 2 3 4 5 6 7 8 9 10 11 12 13  9  7 3  7  1 2  1 3  2 7  2 8  2 9  4 5  4 6   3   bfs나 dfs로 풀이가능한 탐색 문제였다. 나는 dfs를 사용해서 풀었는데, 하나의 촌수가 올라갈때마다 이를 기록하는게 조금 헷갈려서 처음에는 dfs 함수의 파라미터로 chon이라는 변수를 넘겨서 내부함수마다 chon + 1을 넘겨주며 촌수를 기록하려 했는데, 이 방식으로 하니까 계속 정답이 틀렸다.   그래서 이번에는 visted를 True False가 아닌 숫자 -1의 배열로 선언하여 방문과 동시에 + 1을 하여 촌수를 계산해보았더니 문제를 통과할 수 있었다.   dfs를 사용할때 그 depth를 계산하고자 한다면, visited를 숫자로 선언해서 기록하는 방법이 가장 깔끔한 것 같다.  ","categories": ["baekjoon"],
        "tags": ["백준 알고리즘 BFS"],
        "url": "/baekjoon/BOJ-2644-%EC%B4%8C%EC%88%98%EA%B3%84%EC%82%B0/",
        "teaser": null
      },{
        "title": "[BOJ] 7569 토마토 (Python3)",
        "excerpt":"문제  철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.   창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.   토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.   입력  첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.   토마토가 하나 이상 있는 경우만 입력으로 주어진다.   #출력  여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from collections import deque import sys input = sys.stdin.readline  m, n, h = map(int, input().split())  box = [[] for _ in range(h)]  for i in box:     for j in range(n):         i.append(list(map(int, input().split())))  queue = deque()  for k in range(len(box)):     for i in range(len(box[0])):         for j in range(len(box[0][0])):             if box[k][i][j] == 1:                 queue.append((k, i, j))  dx = [-1, 1, 0, 0, 0, 0] dy = [0, 0, -1, 1, 0, 0] dz = [0, 0, 0, 0, -1, 1]  day = 0  while queue:     z, x, y = queue.popleft()          for i in range(6):         nx = x + dx[i]         ny = y + dy[i]         nz = z + dz[i]                  if 0&lt;= nx &lt;= (n - 1) and 0 &lt;= ny &lt;= (m - 1) and 0 &lt;= nz &lt;= (h - 1) and box[nz][nx][ny] == 0:             if box[nz][nx][ny] == 0:                 box[nz][nx][ny] = box[z][x][y] + 1                 queue.append((nz, nx, ny))  isTrue = True isZero = True  for i in box:     for j in i:         for num in j:             if num == 0:                 print(-1)                 exit(0)         day = max(day, max(j))  print(day-1)                   1 2 3 4 5 6 7 8 9 10  5 3 2  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 0 0   4   이 문제는 복잡해보이지만 사실 bfs의 개념을 3차원으로만 옮겨서 생각해주면 되는 문제이다.   3차원 배열을 구성해서 동일하게 bfs의 코드를 작성해주고, dz를 만들어 3차원 방향인 위, 아래까지 탐색하게 해준 뒤,  익어가는 토마토 위치에 날짜를 기록해주면 된다.   input()대신에 sys.stdin.readline()을 쓰고 pypy3로 제출해야 효율성을 통과할 수 있다.   ","categories": ["baekjoon"],
        "tags": ["백준 알고리즘 BFS"],
        "url": "/baekjoon/BOJ-7569-%ED%86%A0%EB%A7%88%ED%86%A0/",
        "teaser": null
      },{
        "title": "[Spring] CORS 설정하기",
        "excerpt":"서론  저는 지금 간단한 토이 프로젝트를 하나 진행중인데요.   프로젝트를 진행하면서 API를 대략 만들고 AWS에 배포를 완료했는데, 프론트엔드 개발자로부터 CORS를 해결해달라는 요청을 받았습니다.   그동안에는 그냥 혼자 웹페이지의 전부를 만들어봐서 해당 이슈에 대해 접해본적이 없기 때문에, 이러한 설정을 따로 해주어야하는지 전혀 몰랐습니다.   그래서 이 게시물에서는 CORS는 무엇이고, 스프링에서 이러한 설정을 어떻게 해주어야 하는지 알아보도록 하겠습니다.   SOP  사실 CORS에 대해 알기 위해서는 SOP에 대해 먼저 알아야합니다. 둘다 영어로 되어있어서 딱 듣고 알기는 어렵죠? SOP는 Same-Origin Policy의 준말입니다. 한글로 번역하면 동일 출처 정책이 되겠네요.   이는 어떤 출처(origin)에서 불러온 문서나 스크립트가 다른 출처에서 가져온 리소스와 상호작용을 하는것을 제한하는 보안방식입니다.   여기서 출처가 같다는 것은, 두 URL의 프로토콜, 호스트, 포트 세개가 모두 같다는 것을 의미합니다.   예를들어 http://domain/page1.html이 있다면,   프로토콜은 http, 호스트는 domain, 포트는 http에서는 생략되어 보이지는 않지만 8080이겠죠.   만약 이렇게 3개가 같은 주소에서 들어온 요청이 아니라면, SOP에 의해서 요청이 거절되는 것입니다.   왜 이런 보안방식을 사용할까요?   SOP의 필요성  만약 SOP가 없다고 가정해봅시다.   여러분이 페이스북에 로그인을 하면 어떻게 되나요? 세션이 유지되기 때문에 일정 시간동안은 다시 로그인하지 않고도 페이스북에 로그인 된 상태일 것입니다.   만약 이때 메일에서 어떤 해커가 페이스북에다가 “나는 바보입니다” 라고 게시물을 작성하는 자바스크립트 코드를 메일에 담아 여러분에게 전송했다면 어떻게 할까요? SOP가 없다면 여러분은 속수무책으로 이러한 공격에 당하기 쉽게 됩니다.   따라서 이를 막기위해서 SOP와 같은 정책으로, 우리의 정보를 더 안전하게 지키는 것이죠.   참고로 이런 SOP의 주체는 웹브라우저로, 여러분이 사용하는 크롬이나 엣지등의 웹 브라우저들이 해당 보안정책을 토대로 다른 출처의 요청을 제한합니다.   CORS  자 이제 드디어 CORS가 등장합니다.   원래는 이러한 SOP에 의해서 무조건 같은 출처, Sam-Origin에서의 요청만 허락되었다고 배웠습니다. 하지만 개발을 하다보니, 오픈 API를 사용하기 위해서나, 여러가지 더 좋은 기능들의 개발을 위해 서로 다른 도메인간에도 통신이 필요한일이 생기게 되었습니다.   한마디로, 다른 출처, Cross-Origin의 요청도 처리할 필요성이 대두되기 시작한것이죠.   이를 위한 스펙이 바로 CORS, Cross-Origin Resource Sharing입니다.   CORS는 웹브라우저에서 외부 도메인과 통신을 가능하게 하기위해서 만들어진 방식을 표준화 한 것으로, 서버와 클라이언트가 정해진 헤더를 통해 서로 요청에 응답할지 말지를 결정하게 됩니다.   CORS의 동작 방식  CORS는 아래 3가지의 동작 방식을 갖습니다.      간단한 요청 (Simple Requests)   사전 요청 (Preflight Requests)   인증을 이용하는 요청 (Credential Requests)   간단한 요청  간단한 요청, Simple Requests는 기존 데이터를 손상시키지 않을 요청들에 의해서만 가능합니다.   만약, DELETE나 PATCH요청과 같은 요청을 누구나 간단하게 요청해서 처리할 수 있다면, 요청하나만으로도 서버에 있는 데이터를 모두 지운다던가 이상하게 변경 할 수 있을 것입니다.   따라서 Simple Requests는 아래의 조건을 만족할때만 가능합니다.      GET, HEAD, POST중 한가지 요청일 것   Custom Header가 존재하지 않을 것   POST일 경우, Conent-Type이 application/x-www-form-urlencoded, mutipart/form-data. text/plain 중 하나일 것   사실상 요즘은 대부분 API요청을 application/json을 통해서 보내기 떄문에 Simple Requests는 잘 사용되지 않습니다.   예를들어 https://foo.example에서 서버로 Simple Requests로 요청을 보내게 되면,   1 2 3 4 5 6 7 8 GET /resources/public-data/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Origin: https://foo.example  이렇게 요청이 가게 됩니다.   Origin을 보면, 이 요청이 https://foo.example에서 왔음을 알 수 있죠.   이 부분을 확인하고 서버에서는 이에 대한 응답으로 Access-Control-Allow-Origin 헤더를 다시 전송하게 됩니다.   예를들어 이러한 응답을 전송합니다.   1 2 3 4 5 6 7 8 9 10 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 00:23:53 GMT Server: Apache/2 Access-Control-Allow-Origin: * Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: application/xml  […XML Data…]  응답을 보면, 현재 Acces-Control-Allow-Origin이 *으로 설정되어 있기 때문에 모든 도메인에서 접근이 가능한 상태입니다. 따라서 https://foo.example외의 모든 도메인에서도 요청이 허용됩니다.   하지만 아래의 요청을 볼까요?   1 2 3 4 5 6 7 8 9 10 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 00:23:53 GMT Server: Apache/2 Access-Control-Allow-Origin:  https://foo.example Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Transfer-Encoding: chunked Content-Type: application/xml  […XML Data…]  Acces-Control-Allow-Origin이 https://foo.example로 설정되어 있습니다. 이렇게 되면, https://foo.example의 도메인만 요청이 허락되는 것입니다. 따라서 이 도메인 외의 다른 도메인은 해당 리소스에 접근이 불가능 합니다.   따라서, Origin 헤더에 전송된 값이 Access-Control-Allow-Origin 헤더에 포함되어 있을 때만, 해당 리소스에 대한 접근이 허용되는 것이죠.   사전 요청 (Preflight Requests)  사전요청은 본 요청을 보내기전에 사전 요청을 보내서 서버가 이에 대해서 응답이 가능한지를 확인하는 방법입니다.   위의 간단한 요청외의 요청들은 서버에 있는 데이터를 손상시키거나 변조시킬 위험이 있는 코드를 보내는 것이 가능함으로, 사전요청으로 먼저 서버에게 해당 요청을 진행가능한지 확인 후, 해당 요청을 처리하게됩니다.      위 그림을 보면, https://foo.example에서 예비요청을 보내고, 이에 대해서 Access-Control-Allow-Origin와 서버에서 현재 어떤것들을 허용하고 금지하는지에 대한 정보를 응답헤더에 담아 브라우저에게 다시 보내줍니다.   여기서 서버가 허용하고 있는 요청만이 포함된 상태라면, 그제서야 본 요청을 서버에 보낼 수 있게 되는 것이죠.   아래는 preflight요청의 예제입니다.  1 2 3 4 5 6 7 8 9 10 OPTIONS /resources/post-here/ HTTP/1.1 Host: bar.other User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:71.0) Gecko/20100101 Firefox/71.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Connection: keep-alive Origin: http://foo.example Access-Control-Request-Method: POST Access-Control-Request-Headers: X-PINGOTHER, Content-Type   밑에 세줄을 보면 Origin, Access-Control-Request-Method와 Access-Control-Request-Headers가 있는 것을 볼 수 있습니다.   그럼 응답에 대한 예제를 봅시다.   1 2 3 4 5 6 7 8 9 10 HTTP/1.1 204 No Content Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2 Access-Control-Allow-Origin: https://foo.example Access-Control-Allow-Methods: POST, GET, OPTIONS Access-Control-Allow-Headers: X-PINGOTHER, Content-Type Access-Control-Max-Age: 86400 Vary: Accept-Encoding, Origin Keep-Alive: timeout=2, max=100 Connection: Keep-Alive   중간에 보면 Access-Control-Allow-Origin,   Access-Control-Allow-Methods, Access-Control-Allow-Headers  가 있는 걸 볼 수 있습니다.   이들은 각각 서버 측 허가 출처, 허가 메서드, 허가 헤더, preflight 응답 캐시 기간인데요. 이러한 예비 요청을 통해서 위 네가지의 서버 허용 정책을 통과 해야만 다음 본요청을 보내는것이 가능한 것입니다.   따라서 Preflight 요청을 사용함으로써, 브라우저 단에서 미리 Allow-Origin에 없는 origin의 요청을 거절함으로써 서버를 안전하게 보호하는 것이죠.   인증을 이용하는 요청 (Credential Requests)  Credential Requests는 좀 더 보안을 강화시킨 요청으로, 인증 정보들을 추가로 쿠키등으로 요청에 담아서 보내는 방식입니다.   서버는 이 사용자가 보낸 요청에 포함된 인증정보들로 한번 더 검증하여 인증이 된 사용자에게만 응답을 줍니다.   Credentila Requests에서는 Access-Control-Allow-Origin을 *로 설정할 수 없으며, 반드시 명시적인 URL들로 설정해주어야 합니다. 또, 반드시 응답 헤더에는 Access-Control-Allow-Credentails: true가 포함되어야만 Credentila Requests의 자격요건을 갖게됩니다.   그럼 이제 세가지 방식에 대해서도 알아봤으니, 스프링에서는 어떻게 하면 CORS를 서버에 적용하여 우리가 허락한 주소에만 응답을 줄 수 있는지 알아봅시다.   스프링에서 CORS 적용하기  스프링에서 CORS를 설정하는 방법은 크게 Annotation을 사용하는 방법과 Configuration을 사용하는 방법이 있습니다.   Annotation을 사용하여 설정  Controller  또는 메소드에 @CrossOrigin 어노테이션을 달아주면 됩니다.   1 2 3 4 5 @GetMapping(\"/v1/volunteers\") @CrossOrigin(origins = \"*\", allowHeaders = \"*\") public List&lt;VolunteerResponseDto&gt; findAll() {         return volunteerService.findAll();    }  위 예시는 findAll()이라는 메소드에 CORS를 설정한 코드입니다.   v1/volunteers로 요청이 들어오면, CrossOrigin에 설정해준 Origin에서 들어온 요청만 본응답을 받게 됩니다. 위 코드에서는 *로 와일드카드를 사용해주었으므로, 모든 출처에서의 요청에 대한 응답을 해주게 됩니다.   마찬가지로, 메소드뿐만 아니라 컨트롤러에도 적용할 수 있습니다.   1 2 3 4 5 6 7 8 9 10 11 @RequiredArgsConstructor @RestController @CrossOrigin(origins = \"*\") public class VolunteerController {     \tprivate final VolunteerService volunteerService;  \t@GetMapping(\"/v1/volunteers\") \tpublic List&lt;VolunteerResponseDto&gt; findAll() { \t    return volunteerService.findAll(); \t} }   Configuration을 사용하여 설정  스프링의 Configuration을 통해서 프로젝트 전체에 적용하는 방식입니다.   config 패키지에 WebConfig 클래스를 만들어준 뒤, WebMvcConfigurer를 implements 해줍니다.   1 2 3 4 @Configuration public class WebConfig implements WebMvcConfigurer {      }  여기서 CORS 설정을 위해서 필요한 메소드인 addCorsMappings 메소드를 오버라이딩 해줍니다.   1 2 3 4 5 6 7 @Configuration public class WebConfig implements WebMvcConfigurer {     @Override     public void addCorsMappings(final CorsRegistry registry) {     } }   이렇게 하면 CoreRegistry 클래스에 있는 addMapping을 이용해서 CORS를 적용해줄 URL 패턴을 정의 해줄 수 있습니다.   1 2 3 4 5 6 7 8 9 @Configuration public class WebConfig implements WebMvcConfigurer {     @Override     public void addCorsMappings(final CorsRegistry registry) {         registry.addMapping(\"/**\")      } }   현재는 /**로 와일드카드를 사용하여 모든 URL 패턴에 대해 허용해준 상태입니다.   addMapping() default 값은 다음과 같습니다.      Allow all origins.   Allow “simple” methods GET, HEAD and POST.   Allow all headers.   Set max age to 1800 seconds (30 minutes).   이 옵션들은 addMapping() 과 마찬가지로 뒤에 추가해줌으로써 설정할 수 있습니다.   예를들어,   1 2 3 4 5 6 7 8 9 10 11 @Configuration public class WebConfig implements WebMvcConfigurer {     @Override     public void addCorsMappings(final CorsRegistry registry) {         registry.addMapping(\"/**\")                 .allowedOrigins(\"http://localhost:8080\")                 .allowedMethods(\"GET\", \"POST\")                 .maxAge(3000);     } }   위 코드처럼 설정함으로써, Origin은 http://localhost:8080, 허용할 메서드는 GET, POST, 그리고 최대 캐싱 시간은 3000초로 설정할 수 있습니다.   제 프로젝트에서는 메소드에 따라 CORS의 origin을 다르게 할 필요는 없기 때문에, 전체에 적용가능한 Configuration 방식을 사용해서 CORS를 적용해주기로 했습니다.   이렇게 CORS에 대해 알아보고, 이를 스프링에서 어떻게 설정하는지 알아보았습니다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-CORS%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] 스프링부트 젠킨스 + 도커로 배포하기",
        "excerpt":"서론  프로젝트를 진행하며, 매번 마스터 브랜치에 머지 할때마다 직접 EC2에 접속해서 배포를 수동으로 계속 하고있었습니다. 근데 이렇게 하다보니, 시간도 너무 많이 잡아먹을 뿐만 아니라, 배포중에 사람의 손이 들어가다 보니 중간에 과정 하나를 빼먹는다거나 테스트코드를 돌려보는것을 깜빡한 상태로 배포하거나 하는 일 때문에 생산성이 저하되는 걸 체감했습니다.   프로그래머로써 이러한 반복작업을 계속 하는건 너무나 비효율적이라고 생각해서 개발을 잠시 후순위로 미루고 CI/CD를 먼저 적용하기로 했습니다.   저는 현재 AWS 프리티어만을 사용해서 프로젝트를 제작 중이기에, EC2하나 만으로 이러한 CI/CD 환경을 세팅해주어야 했는데요. 생각보다 EC2하나만으로 이러한 환경을 구축한 자료가 많이 없어서 고생을 많이했는데, 혹시나 저 같이 프리티어를 사용해서 자원이 한정적인 분들을 위해서 해결한 경험을 공유해보려 합니다.   배포 방식  우선 제가 구현한 배포 과정은 이렇습니다.      먼저 깃허브 마스터 브랜치에 푸쉬하면, 이를 젠킨스가 webhook으로 인식하여 해당 레포지토리를 pull한뒤 이를 그래들을 사용해 빌드합니다.   jar 파일이 완성되면, Docker는 기존 컨테이너를 종료시키고, 컨테이너와 이미지를 삭제한뒤, DokcerFile을 통해 새로운 컨테이너를 생성하여 이를 실행시켜 8080포트에 연결합니다.   보통은 젠킨스를 사용하는 EC2 인스턴스를 하나 더 두어서, 젠킨스와 도커 컨테이너가 돌아가는 인스턴스를 분리하는 방식을 많이 사용합니다. 하지만 프리티어에서는 인스턴스 하나만이 무료로 사용가능하므로 (정확히는 750시간의 사용량이 제공되기 때문에 2개의 인스턴스를 사용하면 사용량이 375시간으로 줄어들게 됩니다.) 하나의 인스턴스를 통해 이 배포과정을 구현해보도록 하겠습니다.   Docker 설치  먼저, EC2에 젠킨스 컨테이너와 서버 컨테이너를 만들어서 하나의 인스턴스로 두개의 인스턴스를 사용하는것 처럼 사용할 것이기 때문에, EC2인스턴스 접속해서 Docker를 설치해주겠습니다.   1 2 sudo yum -y upgrade sudo yum -y install docker  위 명령으로 도커를 설치한 뒤,   1 2 docker -v Docker version 20.10.13, build a224086  위와 같이 버젼이 확인되면 올바르게 도커가 설치된것 입니다.   젠킨스 컨테이너 설치  젠킨스 공식 이미지를 먼저 도커에 Pull 해주겠습니다.   1 docker pull jenkins/jenkins:lts  lts 버젼을 사용하면 가장 최신의 안전한 버젼을 받아옵니다.   1 2 3 4 docker run \\  -p 9080:8080 \\   -v /var/run/docker.sock:/var/run/docker.sock \\   --name jenkins \\   getintodevops/jenkins-withdocker:lts  -v 옵션이 붙어있습니다. 무엇일까요?   사실 위 옵션 없이 하나의 인스턴스로 도커 파일을 배포하려면, 젠킨스도 컨테이너이기 때문에 젠킨스 안에서 컨테이너를 실행해야 합니다. 하지만 젠킨스 컨테이너 안에서 또 도커를 설치하여 Java안에서 또 컨테이너를 동작시킨다면, 성능이 심각하게 많이 떨어질 것입니다.   이를 해결하기 위해서 docker.sock 파일을 마운트한채로 컨테이너를 동작시켜줘야 합니다. 이렇게 하면 젠킨스 컨테이너 안의 도커가 바깥의 EC2 인스턴스의 도커와 연결되어 젠킨스 컨테이너 안에서 외부 도커에 명령을 내릴 수 있게됩니다.      혹시 접속이 안된다면 EC2 인스턴스 보안그룹의 인바운드 규칙 설정에서 9090 포트를 올바르게 열어두었는지 확인합니다. 젠킨스는 따로 아이디와 비밀번호를 설정하기 때문에 0.0.0.0으로 열어두어도 괜찮습니다.       접속하면 위와 같은 창이 나오게 되는데요. 젠킨스는 초기설정으로 아이디와 비밀번호를 설정해주어야 합니다.   젠킨스 내부로 들어가서 해당 파일을 열어 초기 비밀번호를 가져오겠습니다.   아래 명령을 통해 젠킨스 컨테이너에 접근합니다.  1 docker exec -it jenkins /bin/bash   젠킨스 초기페이지에 적혀있는 위치로 가서 해당파일을 열어 초기 비밀번호를 얻어 옵니다.  1 2 cat /var/jenkins_home/secrets/initialAdminPassword 47asdu8382575878dej98989fgd      그럼 위와같이 플러그인을 설치하는 화면이 나오는데요. sugeested 플러그인을 설치하는게 가장 간편합니다.      해당 플러그인을 모두 설치 후,      아이디와 비밀번호를 설정해주면 젠킨스 초기 설정이 완료됩니다.   젠킨스 빌드 설정하기     메인 화면에서 왼쪽에 있는 새로운 Item을 눌러 새로운 프로젝트를 만들어줍니다.      설정은 Freestyle project로 해줍니다.   저는 메인서버에 푸쉬하기전 테스트 하는 develop 서버를 하나 만들려고 하기 때문에, 이름을 jamong-develop으로 설정하겠습니다.     소스코드에 Git을 선택하고 현재 배포에 필요한 레포지토리의 주소를 적어줍니다. Branch Specifier에는 푸쉬됐을때 배포할 브랜치를 입력합니다. 저는 develop 브랜치 서버 배포를 위해서 develop으로 만들어주겠습니다.   이제 Credential을 설정해야 합니다. 간단하게 개인서버라면 깃허브 아이디와 비밀번호로도 설정할 수는 있지만, 보안을 위해서는 ssh연동 방식을 사용하는것이 안전합니다.   다시 젠킨스로 가서 ssh키를 발급 받겠습니다.  1 sudo -u jenkins /bin/bash  전환이 됐다면 ssh키가 들어갈 수 있는 폴더를 만들어주고 이동한 뒤, ssh키를 하나 생성하도록 하겠습니다.   1 2 mkdir /var/lib/jenkins/.ssh cd /var/lib/jenkins/.ssh  1 ssh-keygen -t rsa -f /var/lib/jenkins/.ssh/github_ansible-in-action    비밀 번호는 모두 입력하지 않고 Enter로 스킵해줍니다.   ls -al 을 사용해서 비밀키와 공개키가 잘 생성되었는지 확인해 줍니다.      이제 GitHub로 가서 Deploy Key를 등록해줍시다.     Add deploy Key를 눌러 ssh키를 설정해 줍시다. 저는 이미 발급받은 키를 등록해 놓은 상태입니다.      젠킨스에서 아까 만들어준 공개키를 받아와 입력해줍시다. 아래의 명령어로 공개키를 확인 할 수 있습니다.   1 cat /var/lib/jenkins/.ssh/github_ansible-in-action.pub       다시 젠킨스 관리로 가서 Jenkins 관리 - Manage Credentials로 이동해줍니다.      Stores scoped to Jenkins에 있는  global을 눌러 이동합니다.     Add Credenials를 눌러 키를 추가해 줍니다.      Kind를 SSH Username with private Key로 바꾸고 privateKey의 Enter directly를 활성화한뒤 Add를 통해 이번에는 젠킨스의 비밀키를 추가해줍시다.   1 cat /var/lib/jenkins/.ssh/github_ansible-in-action     비밀키를 복사해주고 저장해줍니다. Username은 원하는 이름으로 설정해주면 됩니다. 저는 deploy key로 정하겠습니다.      이제 아까 Credentials에 아까 만들어준 ssh키를 설정해줍니다.   빌드 유발에는 깃허브 webhook 설정을 위해 GitHub hook trigger for GITScm polling을 체크해줍니다.   이제 Build 설정을 해주겠습니다. Build 항목에서 Execute shell을 선택해주고 Github에 푸쉬가 되었을때 어떻게 작동할지를 적어주도록 하겠습니다.   1 2 3 4 5 6 7 8 ./gradlew clean build sudo docker rmi lmj938/jamong-serverdevelop  sudo docker build --no-cache=true -t lmj938/jamong-serverdevelop .        sudo docker rm jamong-serverdevelop   sudo docker run -d -p 8081:8080 --name jamong-serverdevelop lmj938/jamong-servertest   이대로 돌리게 되면 sudo를 사용할 수 없다는 에러가 뜹니다. root 계정이 아니면 sudo를 사용할 수가 없기 때문입니다. 이를 해결하기 위해 젠킨스 계정이 sudo를 사용할 수 있도록 설정 해주어야 합니다.   1 2 cd /etc vim sudoers  vim 에디터로 sudoers 파일을 열어줍시다.   1 jenkins ALL=(ALL) NOPASSWD: ALL  위 명령어를 추가합니다. jenkins에게 sudo 접근권한을 주는 명령어입니다.      완료 됐으면 저장합니다.   깃 Webhook 설정하기  레포지토리의 세팅에 들어가 Webhooks를 선택해줍니다.      payload URL에 해당 젠킨스 주소를 적어주고, Content type을 application/json으로 설정해주면 됩니다.   이때, 꼭 보안그룹의 인바운드 규칙에 젠킨스 포트를  0.0.0.0으로 퍼블릭으로 열어두어야 깃허브가 보낸 Webhook 요청을 받을 수 있습니다.   이제 푸쉬요청을 보내면, 젠킨스가 알아서 깃에서 푸쉬된 내용을 가져와 파일을 빌드하고 이를 도커 컨테이너로 빌드하여 실행하는 것을 확인할 수 있습니다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EC%A0%A0%ED%82%A8%EC%8A%A4-%EB%B0%B0%ED%8F%AC/",
        "teaser": null
      },{
        "title": "이민재 직장인 메이커",
        "excerpt":"2022.06.16     프린세스 메이커에서는 한달마다 스케줄을 설정하면 한 행동에 따라서 스탯이 증가하거나 돈이 벌린다. 물론 내 세대 게임은 아니라 해본적은 없고, 워낙 유명한 게임이다 보니 방송에서 많이해서 몇번 봤다.   요즘 나는 이민재 직장인메이커를 하는 기분이 든다. 물론 프린세스 메이커는 위에 사진처럼 1주일마다 뭘할지 고른다면, 나는 하루의 스케줄을 짠다. 하루에 영어를 한시간씩 넣어놓고 매일하면 한달 후에 영어 스탯이 늘어나있고, 또 운동을 한시간 추가해볼까? 싶어서 추가하니 한달 뒤에 체력 스탯이 늘어나있는 그런 느낌이다.   한창 치열하게 하나의 목표를 정하는 것보다 꾸준히 정진하는 방법이 좋은 것 같다는 생각이 든다. 사실 고시를 준비한다거나 한다고 하면, 마치 치열하게 피와 땀을 쏟아가며 모든걸 거기에 건다는 이미지가 큰데, 실제로는 매일의 스케줄을 어떻게 세팅하고 보내냐에 달려있는것 같다.   너무 자신을 그 치열하고 열렬한 이미지에 몰입시키면, 쉽게 지치고 오래 지속하기가 힘든 것 같아서, 조금 힘을 빼되 정해진 스케줄을 수행하는데에 목표를 두고 하루하루 해내다보면 어느새 좀 실력이 늘어나있는 걸 즐기는게 훨씬 마음도 편하고, 효율적인 것 같다.   4월에 토익 강의를 결제하고 하루에 두 챕터씩 푼다고 다짐한지 어언 두개월이 다되어가는데, 맨 처음에는 실력이 너무 형편없어서 맨날 화가나고 하기가 싫었는데 요즘은 부쩍 늘어난 실력에 뿌듯하기도 하고, 내가 한거라고는 하루에 한시간 - 한시간 반 내지를 매일 두챕터씩 푼것 뿐인데 스트레스 대비 성과가 너무 만족스러워서 일기를 적어봤다.   그래서 요즘은 하루에 한시간 프로젝트를 여러개로 늘리고 있다. 지금은 영어랑 운동정도가 포함되어 있는데, 최근에 코테랑 cs지식 정리도 포함시키려다가 이러니까 하루에 한시간 프로젝트가 총합 4시간이 되버리다 보니까 너무 버거워서 영어랑 운동만 하고 있는데, 이걸 아침이랑 저녁으로 나눠서 두시간씩으로 나눠서 하면 좀 덜 부담스럽지 않을까? 하는 생각이 들어서 아침에는 영어 + 운동, 저녁에는 코테 + cs지식 정리로 해서 부지런하게 살아보려고 한다.   이번주는 종강한지 얼마 안됐으니까 좀 쉬고 담주부터…   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%9D%B4%EB%AF%BC%EC%9E%AC-%EB%A9%94%EC%9D%B4%EC%BB%A4/",
        "teaser": null
      },{
        "title": "프로세스와 스레드의 차이",
        "excerpt":"서론  프로세스와 스레드의 차이를 설명해보라고 하는건 면접에서 자주 등장하는 단골 문제입니다. 둘 다 비슷한 개념이고 어찌보면 하는일이 비슷하기 때문에 이를 확실하게 구분하여 알고있는지 면접관 입장에서는 물어보기 좋은 질문 중 하나여서 그런 것 같기도 합니다.   그럼 이렇게 혼동하기 쉬운 개념인 프로세스와 스레드는 뭐가 다른걸까요??   프로그램의 동작 방식  우리가 컴퓨터를 사용할 때, 당연히 하나의 프로그램을 사용하지 않습니다. 노래도 좀 틀어놓고, 브라우저로 웹서핑도 하면서 다른 프로그램 다운 받을게 있으면 다운받고, 이런식으로 여러개의 프로그램을 한번에 사용할 것입니다.   컴퓨터가 상용화되고나서는 이게 아주 당연한 일이고, 이게 불가능 하다면 애초에 컴퓨터가 상용화 됐을지가 의문일 정도로 중요한 기능인데요, 우리가 당연하다고 생각하는 이 기능은 사실, 초기의 컴퓨터에서는 불가능 한 기능이었습니다.   명령어 입력이 끝나야만 다른 작업을 할 수 있고, 프로그램을 다운로드 하면 다운로드가 끝나야만 다음 작업을 할 수 있고 이런 식이었죠. 지금 처럼 여러개의 프로그램을 한번에 컴퓨터가 수행 할 수 있는 것은 바로 멀티태스킹 덕분 입니다.   하나의 프로그램이 동작할때의 컴퓨터가 수행하는 작업의 단위를 프로세스라고 하는데요. 윈도우를 기준으로 .exe 확장자의 파일을 실행시키게 되면 컴퓨터는 해당 프로그램의 프로세스를 실행합니다.         윈도우의 작업관리자를 실행시켜보면, 현재 컴퓨터가 어떤 프로세스들을 실행하고 있는지 확인 할 수 있습니다.    하지만 멀티태스킹을 사용한다고 해서, 프로세서가 여러개의 프로세스를 동시에 실행하고 있는 것은 아닙니다. 하나의 프로세서는 반드시 하나의 프로세스만을 실행 할 수 있기 때문이죠.   그렇다면 컴퓨터는 어떠한 방식을 사용하길래 여러개의 프로세스를 동시에 실행하는 멀티태스킹이 가능한 걸까요??   프로세스  멀티 태스킹을 한다는 것은, 병렬적 혹은 동시적으로 이 프로세스를 실행하는 것을 뜻합니다. 기존에는 프로세스를 순서대로 하나씩 처리했다면, 여러개를 처리 할 수 있도록 하는 것이죠. 이 두 방법은 아래와 같이 프로세스를 처리합니다.   동시성 프로세스  먼저 동시성 프로세스는 프로세서 하나가 우리가 마치 동시에 움직이는 것으로 느낄 정도로 아주 빠르게 1번 프로세스 조금, 2번 프로세스 조금 이런식으로 마치 동시에 보이는 것처럼 여러 프로세스를 바꿔가면 조금씩 처리합니다. 이렇게 프로그램을 바꾸는 것 을 컨텍스트 스위칭 (Context Switching)이라고 하는데, 이 개념은 프로세스와 스레드를 설명하는 중요한 키워드이기 때문에, 따로 한번 더 자세히 설명하도록 하겠습니다.         작업 1과 작업 2가 있다면, 동시성 프로세스에서는 위 그림처럼 두 작업을 아주 빠르게 번갈아가면서  프로세스를 처리합니다.    병렬성 프로세스  병렬성 프로세스는 동시에 여러 프로세스들을 처리합니다. 우리가 cpu를 구매 할때 듀얼코어, 쿼드코어등의 제품들을 들어 본적이 있을 것입니다. 이는 말그대로 프로세스를 처리 하는 프로세서에 이를 처리하는 코어가 여러개 붙어있어서, 여러 프로세스를 코어마다 맡아서 조금씩 처리 할 수 있게 되는 것이죠.         위 그림을 보면 여러개의 코어가 하나의 프로세스 씩을 맡아 동시에 처리하고 있습니다. 어쩌면 실제로는 병렬성 프로세스가 동시성이란 말에 더 가깝다는 생각도 조금 드네요.    그럼 프로세스를 이해했으니, 이제 스레드에 대해서 이해해보록 합시다. 스레드가 왜 다른 개념으로 프로세스와 구분되어 있는지를 이해하기 위해서는 먼저 아까 등장했던 컨텍스트 스위칭에 대해서 알아야 합니다.   컨텍스트 스위칭  앞서서 프로세스가 엄청난 속도로 작업을 바꿔가며 마치 동시에 작업을 실행하는 것처럼 보이게 할때, 이 프로세스에서 다른 프로세스로 작업을 변경하는 것을 컨텍스트 스위칭이라고 한다고 했습니다.   우리가 프로그램을 실행하게되면, 프로세스에 필요한 요소들이 메모리에 올라가 공간을 차지하게 됩니다.   메모리는 4가지 영역으로 나누어져 있는데, 아래와 같습니다.                  Code       Data       Heap       Stack                       실행 명령을 포함하는 코드들       Static 변수 혹은 Global 변수       동적 메모리 영역       지역변수, 매개변수, 반환 값 등등 일시적인 데이터           어떤 프로세스가 실행 되려면 해당 프로그램의 정보들이 위에서 설명한 메모리의 영역들을 차지해야만 프로세스가 실행 가능합니다.   또, 프로세스를 여러개 바꿔가면서 실행하려면, 작업 1에서 작업 2를 진행하고 다시 작업 1로 갈때, 아까 전 작업때 어느정도 작업을 처리 했는지, 정보를 기록해놔야 다시 이어서 작업을 할 수 있을 것입니다. 따라서 프로세스 컨트롤 블럭 (Process Contorl Block), PCB라는 특정한 프로세스를 관리하기 위해 필요한 정보를 담아 저장합니다.         Pointer   프로세스의 현재 위치를 저장하는 포인터 정보입니다.      Process State   프로세스의 각 상태 (생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated))를 저장합니다.      Process Number (PID)   모든 프로세스에는 프로세스 식별자를 저장하는 프로세스 ID 또는 PID라는 고유 한 ID가 할당됩니다.      Program Counter   프로세스를 위해 실행될 다음 명령어의 주소를 포함하는 카운터를 저장합니다.      Registers   누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터에 있는 정보입니다.      Memory Limits   이 필드에는 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보가 포함됩니다. 여기에는 페이지 테이블, 세그먼트 테이블 등이 포함될 수 있습니다.      List of open files  이 정보에는 프로세스를 위해 열린 파일 목록이 포함됩니다.   따라서 컨텍스트 스위칭을 한번 하기 위해서는, 이전 작업의 PCB를 불러오고, 메모리 공간을 비운 뒤 새로 작업할 프로세스가 필요한 정보를 다시 메모리 공간에 할당하는 작업들이 필요한 것입니다.   그렇기 때문에 당연히 컨텍스트 스위칭이 많으면 많을수록, 시간과 비용이 많이 소모됩니다.   만약 이 과정을 줄일 수 있다면, 훨씬 효율적으로 멀티태스킹이 가능 할 것입니다. 이러하니 비효율을 줄이기 위해 등장한 것이 바로 스레드입니다.   스레드  만약 프로세스 내에서 로그인을 처리한다고 가정해봅시다.   하나의 로그인을 처리하는 건 하나의 프로세스로 가능 하겠지만, 로그인이 만약 여러개가 한번에 들어온다면 어떻게 될까요??   프로그램을 하나 실행시키면 무조건 해당 프로그램에서의 작업은 하나의 프로세스가 모두 처리 하는 것이 아닙니다. 프로세스 안에서도 처리해야할 일이 여러개라면, 프로세스가 자신과 똑같은 프로세스를 fork()하여 (복제하여) 자식 프로세스를 만들어서 또 다시 컨텍스트 스위칭을 해가며 일을 처리합니다.      이렇게 만들어서 처리한다면 어떻게 될까요?   같은 로그인 작업인데도, 다른 프로세스로 처리되기 떄문에 어차피 같은 작업을 해야하는데 또 메모리를 정리하고 새로운 PCB를 가져오게 되기 때문에 컨텍스트 스위칭 때마다 많은 자원과 시간이 소모됩니다.   이러한 비효율을 개선하기 위해 사용하는 것이 바로 스레드입니다.   스레드는 한 프로세스 내에서 일어나는 작업들이 공통으로 필요로하는 부분은 컨텍스트 스위칭할때 굳이 바꾸지 않습니다. 예를들어 책상에서 공부를 하다가 다른 과목으로 바꾸려고 한다면, 기존의 프로세스는 책뿐만 아니라 연필 지우개 독서대등을 모두 다시 갖다놓고 다시 가져왔다면, 스레드는 책만을 바꾸고 어차피 또 사용할 연필이나 지우개, 독서대등은 그대로 냅두고 책만 바꾸는 것이죠   아래 그림을 보면, Code와 Data, Heap 공간은 어차피 모두 공통으로 사용하기 때문에 다 함께 공유하고, Stack만을 바꿔가면서 컨텍스트 스위칭을 하고 있는 것을 볼 수 있습니다.      이렇게 하면 훨씬 효율적으로 작업을 수행할 수 있기 떄문에, 기존 멀티 프로세스 방식에서 낭비 되던 자원과 시간을 절약할 수 있을 것 입니다.   마무리하며…  이렇게 간단하게 프로세스와 스레드의 차이점에 대해서 공부해 보았습니다. 언뜻보면 비슷한 개념이지만, 왜 스레드가 필요하게 되었는지를 알고나면 보다 명확하게 이 두 개념을 구분할 수 있을 것입니다.   면접 단골 질문인 만큼, 잘알아두고 혹여나 면접에서 물어본다면 기쁜 마음으로 설명해보도록 합시다.   ","categories": ["CS"],
        "tags": [],
        "url": "/cs/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80%EC%8A%A4%EB%A0%88%EB%93%9C%EC%9D%98-%EC%B0%A8%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[Programmers] 게임 맵 최단거리 (Python3)",
        "excerpt":"문제 설명  ROR 게임은 두 팀으로 나누어서 진행하며, 상대 팀 진영을 먼저 파괴하면 이기는 게임입니다. 따라서, 각 팀은 상대 팀 진영에 최대한 빨리 도착하는 것이 유리합니다.   지금부터 당신은 한 팀의 팀원이 되어 게임을 진행하려고 합니다. 다음은 5 x 5 크기의 맵에, 당신의 캐릭터가 (행: 1, 열: 1) 위치에 있고, 상대 팀 진영은 (행: 5, 열: 5) 위치에 있는 경우의 예시입니다.   최단거리1_sxuruo.png   위 그림에서 검은색 부분은 벽으로 막혀있어 갈 수 없는 길이며, 흰색 부분은 갈 수 있는 길입니다. 캐릭터가 움직일 때는 동, 서, 남, 북 방향으로 한 칸씩 이동하며, 게임 맵을 벗어난 길은 갈 수 없습니다.  아래 예시는 캐릭터가 상대 팀 진영으로 가는 두 가지 방법을 나타내고 있습니다.   첫 번째 방법은 11개의 칸을 지나서 상대 팀 진영에 도착했습니다.  최단거리2_hnjd3b.png   두 번째 방법은 15개의 칸을 지나서 상대팀 진영에 도착했습니다.  최단거리3_ntxygd.png   위 예시에서는 첫 번째 방법보다 더 빠르게 상대팀 진영에 도착하는 방법은 없으므로, 이 방법이 상대 팀 진영으로 가는 가장 빠른 방법입니다.   만약, 상대 팀이 자신의 팀 진영 주위에 벽을 세워두었다면 상대 팀 진영에 도착하지 못할 수도 있습니다. 예를 들어, 다음과 같은 경우에 당신의 캐릭터는 상대 팀 진영에 도착할 수 없습니다.   최단거리4_of9xfg.png   게임 맵의 상태 maps가 매개변수로 주어질 때, 캐릭터가 상대 팀 진영에 도착하기 위해서 지나가야 하는 칸의 개수의 최솟값을 return 하도록 solution 함수를 완성해주세요. 단, 상대 팀 진영에 도착할 수 없을 때는 -1을 return 해주세요.   제한사항     maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.            n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.           maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.   처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.   입출력 예                  maps       answer                       [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]]       11                 [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]]       -1           1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from collections import deque  def solution(maps):     n = len(maps)       m = len(maps[0])                queue = deque()      queue.append((0,0))           dx = [-1,1,0,0]      dy = [0,0,-1,1]          while queue:         x, y = queue.popleft()           for i in range(4):             nx = x+ dx[i]              ny = y+ dy[i]               if nx &lt; 0 or ny &lt; 0 or nx &gt;=n or ny &gt;= m:                  continue              if maps[nx][ny] == 0:                 continue               if maps[nx][ny] == 1:                  maps[nx][ny] = maps[x][y] + 1                  queue.append((nx,ny))      if maps[n-1][m-1] == 1:         return -1     return maps[n-1][m-1]    1 2 for case in [[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]], [[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]]]:     print(solution(case))   1 2 11 -1   맨 처음에는 다익스트라로 풀려고 했는데, 하나씩 더해가면서 BFS만 사용해도, 어차피 출발과 도착 지점이 정해져있기 때문에 답을 구할 수 있을 것 같아서 BFS를 적용 시켰다. 가장 기본적인 BFS 문제인 것 같다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EA%B2%8C%EC%9E%84-%EB%A7%B5-%EC%B5%9C%EB%8B%A8%EA%B1%B0%EB%A6%AC-(Python3)/",
        "teaser": null
      },{
        "title": "커넥션 풀",
        "excerpt":"커넥션 풀은 왜 필요할까?  웹 서버가 DB와 연결을 하는것에는 생각보다 많은 비용이 들어갑니다.   만약 JDBC를 통해 DBMS와 연결을 할떄는 , 다음과 같은 과정을 거칩니다.      DB벤더에 맞는 드라이버 로드   DB서버의 IP, ID, PW등을 DriverManager 클래스의 getConnection 메소드를 사용하여 Connection 객체 생성   Connection으로 부터 PreparedStatement 객체를 받음   executeQurey를 수행하고 ResultSet객체를 받아 데이터를 처리   사용했던 ResultSet, PreparedStatement, Connection을 close   이 과정중에서 2번에서 커넥션 객체를 생성하고 얻어오는 부분은 DB서버와 애플리케이션과의 통신이 필요하기 때문에  위 과정중에서 가장 무겁고 오래 걸리는 작업입니다.   따라서 만약 매 요청마다 이 과정을 반복한다면, 당연히 훨씬 더 많은 시간과 자원을 소모하게 될 것입니다.   누구도 요청을 보낼때마다 몇초씩 걸리는 느린 웹서버를 사용하고 싶지는 않겠죠?   그래서 나온 방법이 바로 커넥션 풀 (Connection Pool)입니다.   커넥션 풀      커넥션 풀은 말그대로 커넥션들이 있는 공간입니다. WAS가 실행되면서 DB와 미리 커넥션 해놓은 객체를 커넥션 풀에 저장해놨다가, 클라이언트에서 요청이 들어오면 커넥션을 빌려주고, 처리가 끝나면 다시 커넥션을 받아서 커넥션 풀에 다시 저장해 놓습니다.   이렇게 미리 WAS가 실행될때 미리 커넥션 객체를 생성하고 이를 받아오기만 한다면, 위 과정에서의 2번에 드는 자원과 시간을 매우 효율적으로 사용할 수 있을 것입니다.   따라서 커넥션 풀은 아래와 같은 특징을 갖습니다.      WAS가 실행되면, 커넥션 객체를 미리 커넥션풀에 생성   HTTP 요청으로 커넥션 풀에서 커넥션 객체를 받아 사용한다.   사용이 끝나면 다시 해당 커넥션 객체를 커넥션 풀에 반환한다.   이때, 커넥션 객체들은 이미 연결을 마친 채로 커넥션 풀에 저장되어 있는 것이기 때문에, 커넥션을  연결하는 시간이 소요되지 않는다.   커넥션을 계속해서 재사용하기 때문에 생성되는 커넥션 수는 제한적이다.   여기서 마지막 줄을 보면, 커넥션 수는 제한적인 특징을 갖습니다.   따라서 커넥션 개수보다 많은 요청이 한꺼번에 들어온다면,  커넥션이 풀에서 모두 동나는 상황이 발생하게 될 것입니다. 이럴 때 커넥션 풀은 어떻게 동작할까요?   커넥션이 없는 상태에서 요청이 들어오면, 해당요청에 번호를 매긴 상태로 대기하도록 합니다. 빌려간 커넥션이 다시 반환되면, 대기하고 있는 클라이언트에게 순서대로 다시 커넥션을 제공 하는 것이죠.   우리가 가끔 정각에 쿠폰을 제공하는 이벤트나 티켓팅을 할 때 홈페이지가 느리게 뜨거나 요청이 느려지는 것도, 이러한 커넥션이 부족하기 때문에 발생하는 현상 중 하나입니다.   그럼 이러한 의문점이 들 수 있습니다.      커넥션을 무조건 많이 만들면 좋은거 아니야?    물론 커넥션 풀을 크게 하면 그만큼 줄 수 있는 커넥션의 수가 늘어남으로, 더 많은 요청을 처리하는 것이 가능해집니다. 하지만 커넥션 풀이 커질 수록 메모리 소모가 커지기 때문에, 자신이 가진 서버의 스펙등을 고려하여 알맞게 설정해 주어야 합니다.   또한, WAS에서 사용하는 커넥션을 사용하는 주체는 결국 스레드 (Thread)이기 떄문에, WAS가 가진 스레드 풀보다 커넥션풀의 크기가 크다면, 남는 커넥션들은 생성되어 메모리를 소모하면서, 정작 사용되지도 못하여 성능만 잡아 먹는 경우가 발생합니다.      그럼 스레드 풀의 크기와 커넥션 풀의 크기를 둘다 늘려준다면???    이 경우에도 스레드는 컨텍스트 스위칭을 하기 때문에 결국 한계가 존재하고, 데이터베이스 입장에서도 커넥션이 단순히 많기만 한다고 성능이 비약적으로 올라가는 것도 아니기 때문에, 이상적인 스레드와 커넥션의 수는 해당 애플리케이션과 DB의 스레드, 커넥션의 수가 CPU의 코어 수가 동일할때 라고 할 수 있습니다.   물론 실제로는 CPU의 성능이 많이 좋아졌기 때문에 코어 개수보다 더 여유있게 커넥션풀의 크기를 설정합니다.   그렇다면 이상적인  커넥션풀의 크기는?  스프링에서는 Hikari CP (Hikari Connection Pool) 사용하여 커넥션풀을 관리합니다. HikariCP는 매우 적은 130kb의 용량으로 압도적은 빠른 속도를 제공하는 JDBC의 커넥션 풀 프레임 워크입니다.      Hikari CP에서 제공하는 벤치마크를 보면, 따른 커넥션풀 프레임워크들에 비해 압도적인 최적화 성능을 자랑합니다. 따라서 스프링부트도 2.0버젼부터는 기존에 사용하던 Tomcat을 HikariCP로 변경했습니다. 따라서 의존성에 기본적으로 spring-boot-starter-data-jpa나 spring-boot-starter-jdbc 의존성을 포함할 경우, 자동으로 HikariCP가 포함됩니다.   그렇다면 HikariCP에서 공식문서에서 추천하는 이상적인 커넥션 풀의 크기는 얼마일까요??   ikari CP의 공식문서에 따르면 connections = ((core_count * 2) + effective_spindle_count)라고 명시되어 있습니다.   여기서 말하는 core_count는 서버의 논리 CPU개수를 말합니다. 위에서 말했듯이 컨텍스트 스위칭으로 인한 한계를 고려하더라도, 데이터베이스의 디스크 읽기 쓰기나 DRAM이 데이터를 처리하는 속도보다 CPU의 속도가 월등히 빠르기 때문에, 데이터베이스가 필요한 데이터를 찾는동안 갖는 대기시간에 CPU는 작업 스레드를 변경해 더 많은 요청을 수행할 수 있습니다.   effective_spindle_count는 하드 디스크와 관련이 있습니다. 하드 디스크 하나는 spindle 하나를 가집니다.   이에 따라 spindle의 수는 기본적으로 DB 서버가 관리할 수 있는 동시 I/O 요청 수를 말합니다. 디스크가 16 개가 있는 경우 시스템은 동시에 16 개의 I/O 요청을 처리할 수 있습니다. 물론 RAID 구성 방식에 따라서 달라질 수 있습니다. 해당 공식에서 디스크의 효율을 고려하여 spindle_count를 더해준 것으로 보입니다.   최종적으로 CPU의 처리 효율과 디스크 처리 효율을 고려한 결과, **((core_count * 2) + effective_spindle_count) **공식을 통해 Connection의 개수를 추정할 수 있다고 알게 되었습니다.   당연히 이러한 공식이 무조건 모든 상황에서 딱 들어맞아 성립하진 않지만, 대략적인 서버의 최초 커넥션 풀 크기를 선정하는 기준으로써 사용한다면, 기본적으로 이렇게 세팅해놓고 서버의 성능과 부하에 따라 변경하면 매우 유용할 것입니다.   가장 좋은 방법은 실제로 성능 테스트를 진행해가며 자신의 서버에 맞는 커넥션 풀을 정하는 것이겠죠?   ","categories": ["CS"],
        "tags": [],
        "url": "/cs/%EC%BB%A4%EB%84%A5%EC%85%98-%ED%92%80/",
        "teaser": null
      },{
        "title": "[Programmers] 입국심사 (Python3)",
        "excerpt":"문제 설명  n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.   처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.   모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.   입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.   제한사항     입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.   각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.   심사관은 1명 이상 100,000명 이하입니다.   입출력 예                  n       times       return                       6       [7,10]       28           입출력 예 설명  가장 첫 두 사람은 바로 심사를 받으러 갑니다.   7분이 되었을 때, 첫 번째 심사대가 비고 3번째 사람이 심사를 받습니다.   10분이 되었을 때, 두 번째 심사대가 비고 4번째 사람이 심사를 받습니다.   14분이 되었을 때, 첫 번째 심사대가 비고 5번째 사람이 심사를 받습니다.   20분이 되었을 때, 두 번째 심사대가 비지만 6번째 사람이 그곳에서 심사를 받지 않고 1분을 더 기다린 후에 첫 번째 심사대에서 심사를 받으면 28분에 모든 사람의 심사가 끝납니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def solution(n, times):     left = 1     right = n * max(times)     answer = 0     while left &lt;= right:         mid = (left + right) // 2         people = 0                  for time in times:             people += mid // time                          if people &gt;= n:                 break                  if people &gt;= n:             answer = mid             right = mid - 1         else:             left = mid + 1     return answer   1 solution(6, [7,10])   1 28   이 문제는 이분탐색을 사용하여 풀이하여야 하는 문제이다.   맨처음에는 단순 구현으로 풀어보려고 했는데, 제한사항의 최댓값이 너무 크고 복잡해서 이분탐색으로 풀이하여야 최고의 효율성으로 간단하게 풀 수 있다.   사람을 기준이 아닌 시간을 기준으로, 주어진 시간동안 심사원이 처리할 수 있는 사람의 수를 기준으로 생각하면 된다.   만약 50분의 시간이 주어진다면, 1번심사대에서는 50 // 7 = 7명, 2번 심사대에서는 50 // 10 = 5 5명이므로 50분의 시간에서는 7 + 5 = 12명을 처리 할 수 있다.   이런식으로 시간을 기준으로 만약 n보다 크다면 이분탐색의 오른쪽부분, n보다 작다면 이분탐색의 왼쪽부분을 다시 반으로 나누어 탐색해가며 최적의 시간을 찾는다.   예제의 경우, 경우의 수 중에서 가장 긴 시간은 2번심사대가 6명을 처리하는 시간으로, 6 * 10 60분의 시간이고, 가장 짧은 시간은 1분의 시간이다.   따라서 1, 60을 이분탐색의 첫 범위로 잡고 시간당 처리 가능한 사람을 계속 구하며 범위를 줄여나간다.   첫번째 예제의 경우 28분의 시간이 되면 28 // 7 = 4, 28 // 2 = 2, 4 + 2 = 6으로 28분의 시간이 주어지면 6명을 처리할수 있는 최적의 시간이 된다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC/",
        "teaser": null
      },{
        "title": "[Programmers] 파괴되지 않은 건물(Python3)",
        "excerpt":"문제 설명  [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]  N x M 크기의 행렬 모양의 게임 맵이 있습니다. 이 맵에는 내구도를 가진 건물이 각 칸마다 하나씩 있습니다. 적은 이 건물들을 공격하여 파괴하려고 합니다. 건물은 적의 공격을 받으면 내구도가 감소하고 내구도가 0이하가 되면 파괴됩니다. 반대로, 아군은 회복 스킬을 사용하여 건물들의 내구도를 높이려고 합니다.  적의 공격과 아군의 회복 스킬은 항상 직사각형 모양입니다.  예를 들어, 아래 사진은 크기가 4 x 5인 맵에 내구도가 5인 건물들이 있는 상태입니다.      첫 번째로 적이 맵의 (0,0)부터 (3,4)까지 공격하여 4만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.      두 번째로 적이 맵의 (2,0)부터 (2,3)까지 공격하여2만큼 건물의 내구도를 낮추면 아래와 같이 4개의 건물이 파괴되는 상태가 됩니다.      세 번째로 아군이 맵의 (1,0)부터 (3,1)까지 회복하여 2만큼 건물의 내구도를 높이면 아래와 같이 2개의 건물이 파괴되었다가 복구되고 2개의 건물만 파괴되어있는 상태가 됩니다.      마지막으로 적이 맵의 (0,1)부터 (3,3)까지 공격하여 1만큼 건물의 내구도를 낮추면 아래와 같이 8개의 건물이 더 파괴되어 총 10개의 건물이 파괴된 상태가 됩니다. (내구도가 0 이하가 된 이미 파괴된 건물도, 공격을 받으면 계속해서 내구도가 하락하는 것에 유의해주세요.)      최종적으로 총 10개의 건물이 파괴되지 않았습니다.  건물의 내구도를 나타내는 2차원 정수 배열 board와 적의 공격 혹은 아군의 회복 스킬을 나타내는 2차원 정수 배열 skill이 매개변수로 주어집니다. 적의 공격 혹은 아군의 회복 스킬이 모두 끝난 뒤 파괴되지 않은 건물의 개수를 return하는 solution함수를 완성해 주세요.   제한사항     1 ≤ board의 행의 길이 (= N) ≤ 1,000   1 ≤ board의 열의 길이 (= M) ≤ 1,000   1 ≤ board의 원소 (각 건물의 내구도) ≤ 1,000   1 ≤ skill의 행의 길이 ≤ 250,000   skill의 열의 길이 = 6   skill의 각 행은 [type, r1, c1, r2, c2, degree]형태를 가지고 있습니다.            type은 1 혹은 2입니다.                    type이 1일 경우는 적의 공격을 의미합니다. 건물의 내구도를 낮춥니다.           type이 2일 경우는 아군의 회복 스킬을 의미합니다. 건물의 내구도를 높입니다.                       (r1, c1)부터 (r2, c2)까지 직사각형 모양의 범위 안에 있는 건물의 내구도를 degree 만큼 낮추거나 높인다는 뜻입니다.                    0 ≤ r1 ≤ r2 &lt; board의 행의 길이           0 ≤ c1 ≤ c2 &lt; board의 열의 길이           1 ≤ degree ≤ 500           type이 1이면 degree만큼 건물의 내구도를 낮춥니다.           type이 2이면 degree만큼 건물의 내구도를 높입니다.                           건물은 파괴되었다가 회복 스킬을 받아 내구도가 1이상이 되면 파괴되지 않은 상태가 됩니다. 즉, 최종적으로 건물의 내구도가 1이상이면 파괴되지 않은 건물입니다.   입출력 예                  board       skill       result                       [[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]]       [[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]]       10                 [[1,2,3],[4,5,6],[7,8,9]]       [[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]]       6           입출력 예 설명   입출력 예 #1  문제 예시와 같습니다.   입출력 예 #2   초기 맵 상태      첫 번째로 적이 맵의 (1,1)부터 (2,2)까지 공격하여 4만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.      두 번째로 적이 맵의 (0,0)부터 (1,1)까지 공격하여 2만큼 건물의 내구도를 낮추면 아래와 같은 상태가 됩니다.      마지막으로 아군이 맵의 (2,0)부터 (2,0)까지 회복하여 100만큼 건물의 내구도를 높이면 아래와 같은 상황이 됩니다.      총, 6개의 건물이 파괴되지 않았습니다. 따라서 6을 return 해야 합니다.   첫번째 풀이   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 from itertools import product  def solution(board, skills):     alive = len(board) * len(board[0])     for skill in skills:         attack_type = skill[0]         start = [skill[1], skill[2]]         end = [skill[3], skill[4]]         amount = skill[5]                  print(attack_type, start, end, amount)         print(get_coverage(start, end))                  coverage = get_coverage(start, end)                  for cover in coverage:             prev_target = board[cover[0]][cover[1]]                          if attack_type == 1:                 board[cover[0]][cover[1]] -= amount                 target = board[cover[0]][cover[1]]                 if prev_target &gt; 0 and target &lt;= 0:                     alive -= 1             else:                 board[cover[0]][cover[1]] += amount                 target = board[cover[0]][cover[1]]                 if prev_target &lt;= 0 and target &gt; 0:                     alive += 1     print(alive)            def get_coverage(start, end):     start_x, start_y = start[0], start[1]     end_x, end_y = end[0], end[1]     x_list = []     y_list = []     for i in range(start_x, end_x + 1):         x_list.append(i)     for i in range(start_y, end_y + 1):         y_list.append(i)     return list(product(x_list, y_list))                1 2 3 cases = [[[[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]], [[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]]], [[[1,2,3],[4,5,6],[7,8,9]], [[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]]]] for case in cases:     solution(case[0], case[1])   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1 [0, 0] [3, 4] 4 [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4)] 1 [2, 0] [2, 3] 2 [(2, 0), (2, 1), (2, 2), (2, 3)] 2 [1, 0] [3, 1] 2 [(1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] 1 [0, 1] [3, 3] 1 [(0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3)] 10 1 [1, 1] [2, 2] 4 [(1, 1), (1, 2), (2, 1), (2, 2)] 1 [0, 0] [1, 1] 2 [(0, 0), (0, 1), (1, 0), (1, 1)] 2 [2, 0] [2, 0] 100 [(2, 0)] 6   효율성 문제가 있는 문제답게 역시 혼자 풀이한 풀이로는 정확성 테스트만을 통과할 수 있었습니다.   이 문제의 효율성 테스트까지 통과하도록 풀기 위해서는 배열의 ‘누적합’을 사용해야 합니다.   누적합을 사용하면 배열의 특정 부분만큼을 감소시키거나 증가시키는 것을 시간 복잡도 O(N*M)에서 O(1)으로 처리할 수 있습니다.   먼저, 1차원 배열로 누적합을 설명해보겠습니다.   1 [0,0,0,0,0,0]   만약, 0~2번째 배열까이 N만큼을 감소시키고 싶은 경우에는, 다음과 같은 새로운 배열을 만듭니다.   1 [-N, 0, 0, N, 0, 0]  여기서, N의 위치가 2번째가 아닌 3번째 인덱스에 위치한것을 주의하셔야합니다.   편의상 N을 2라고 가정해봅시다.   1 [-2, 0, 0, 2, 0, 0]      위 그림처럼 차례대로 왼쪽값을 오른쪽에 더합니다.   1 [-2, -2, -2, 0, 0, 0]  그럼 다음과 같이 0에서 2인덱스 까지 2씩 감소시킬 수 있습니다.   그럼 만약 반대로 0에서 2인덱스 까지 2씩 증가시키려면 어떻게 해야할까요?   1 [2, 0, 0, -2, 0, 0]  당연히 위처럼 반대로 해당 인덱스의 값을 변경해주면 됩니다.   그렇다면 이차원 배열의 경우는 어떻게 하면 될까요?      위 그림처럼 누적합 배열에 다음과 같이 범위의 시작과 끝은 -N, 나머지 범위는 N으로 마킹해주고 행방향으로 한번 누적합, 열 기준으로 한번 누적합을 진행해주면 됩니다.   정확성, 효율성 모두 통과하는 코드   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def solution(board, skills):     answer = 0     record = [[0] * (len(board[0]) + 1) for _ in range(len(board) + 1)]          for skill in skills:         attack_type = skill[0]         start = [skill[1], skill[2]]         end = [skill[3], skill[4]]         amount = skill[5]                  if attack_type == 2:             amount = -amount                  record[start[0]][start[1]] += -amount         record[end[0] + 1][end[1] + 1] += -amount         record[start[0]][end[1] + 1] += amount         record[end[0] + 1][start[1]] += amount                  for i in range(len(record) - 1):         for j in range(len(record[0]) - 1):             record[i][j + 1] += record[i][j]          for j in range(len(record[0]) - 1):         for i in range(len(record) - 1):             record[i + 1][j] += record[i][j]                  for i in range(len(board)):         for j in range(len(board[i])):             board[i][j] += record[i][j]                          if board[i][j] &gt; 0:                  answer += 1                      return answer   1 2 3 cases = [[[[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5],[5,5,5,5,5]], [[1,0,0,3,4,4],[1,2,0,2,3,2],[2,1,0,3,1,2],[1,0,1,3,3,1]]], [[[1,2,3],[4,5,6],[7,8,9]], [[1,1,1,2,2,4],[1,0,0,1,1,2],[2,2,0,2,0,100]]]] for case in cases:     print(solution(case[0], case[1]))   1 2 3 4 [[1, 0, 0, 0, 1], [3, 2, 0, 0, 1], [1, 0, -2, -2, 1], [3, 2, 0, 0, 1]] 10 [[-1, 0, 3], [2, -1, 2], [107, 4, 5]] 6   다음과 같이 record라는 누적합을 사용하기 위한 배열을 만들어 준뒤, 여기에 해당 범위에 더하고 빼줄 수를 마킹 해준뒤, 누적합을 실행하고 이를 원래 board와 함께 더해주면 해당 스킬들이 사용되고 난 후의 건물들의 모습을 O(N)의 시간으로 구할 수 있다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%ED%8C%8C%EA%B4%B4%EB%90%98%EC%A7%80-%EC%95%8A%EC%9D%80-%EA%B1%B4%EB%AC%BC/",
        "teaser": null
      },{
        "title": "[Programmers] 네트워크 (Python3)",
        "excerpt":"문제 설명  네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.  컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.   제한사항     컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.   각 컴퓨터는 0부터 n-1인 정수로 표현합니다.   i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.   computer[i][i]는 항상 1입니다.   입출력 예                  n       computers       return                       3       [[1, 1, 0], [1, 1, 0], [0, 0, 1]]       2                 3       [[1, 1, 0], [1, 1, 1], [0, 1, 1]]       1           입출력 예 설명   입출력 예 #1  2개의 네트워크가 있습니다.   입출력 예 #2  1개의 네트워크가 있습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 global visit visit = []  def solution(n, computers):     global visit     answer = 0     visited = [False for _ in range(n )]     graph = [[] for _ in range(n)]     for i, computer in enumerate(computers):         for index, j in enumerate(computer):             if i != index and j == 1:                 graph[index].append(i)                 visited[index] = True          for i in range(n):         if i not in visit:             dfs(graph, i)             answer += 1     return answer            def dfs(graph, start_node):     global visit          stack = []     stack.append(start_node)          while stack:         node = stack.pop()                  for i in graph[node]:             if i not in visit:                 stack.append(i)                 visit.append(i)       1 2 solution(3, [[1, 1, 0], [1, 1, 1], [0, 1, 1]])    1 1   이 문제는 기존의 DFS 문제를 살짝 꼬아서 낸 문제이다.   처음에는 재귀 DFS로 해서 풀려고 했으나, 풀다 보니까 너무 헷갈려서 그냥 global을 사용해서 풀었다.   몇몇 DFS문제의 경우 global을 통해 변수를 공유하면 풀이가 조금 쉬워지는 경향이 있다.   먼저, 노드끼리 이어진 방식을 주로 사용하던 방식으로 변환한다.   [[1, 1, 0], [1, 1, 1], [0, 1, 1]] 의 경우는 [[1], [0, 2], [1]]가 된다.   이렇게 익숙한 graph의 형태로 바꾸고 나면, 평소에 사용하던 dfs를 사용해서 방문처리를 해주면 된다. 단, 한 노드에서 이어진 곳까지 모두 방문처리를 할때마다 하나의 네트워크를 카운팅 해주어야 하므로, visit를 global로 선언해서 방문 처리된 노드에서 dfs를 실행할때는 카운팅 되지 않도록 한다.   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/",
        "teaser": null
      },{
        "title": "[Spring] 다대다 관계 맵핑",
        "excerpt":"서론  JPA 를 사용하다 보면, 여러가지 복잡한 테이블 관계를 만나게 됩니다.  특히, 다대다 관계는 서로가 서로를 맵핑하기 때문에 단순하게 서로가 서로를 갖도록 구현하면 여러가지 에러를 만날 수 밖에 없게 됩니다.   제가 개발을 하다가 맞닥뜨린 문제를 함께 해결해보면서, JPA에서의 다대다 관계는 어떻게 구현하는게 가장 안전하고 효율적인 방법인지 함께 알아보도록 합시다.   @ManyToMany  제가 만드는 웹페이지는 봉사 동아리의 봉사 신청을 주 기능으로 갖고 있는데요, 봉사를 신청한 유저가 해당 봉사 페이지에 보이는 동시에, 해당 유저의 정보 페이지에서는 유저가 그동안 신청했던 봉사 내역을 출력하도록 하고 싶었습니다.   봉사라는 객체도 유저를 일대다 관계로 갖고, 유저라는 객체도 봉사를 다대일로 갖게되는 상황이 된것입니다.   만약 단순하게 이 둘을 다이렉트로 다대다 관계로 맵핑하고, 이를 데이터베이스에서 호출 한다면 어떻게 될까요?   봉사를 호출한다고 가정하면, 봉사를 호출하면 그 안에있는 유저들을 호출하고, 그 유저들안에 있는 봉사를 또 호출하고, 또 다시 그 유저안에 있는 봉사를 호출하고….   이런식으로 무한 호출이 발생할 것입니다.   그래서 스프링의 @ManyToMany 어노테이션을 사용할때는, 반드시 @JoinTable을 사용해서 중간 테이블을 하나 만들도록 해야합니다.   예를 들어, 위에서 제가 구현하려고 한 봉사와 유저를 다대다로 맵핑한다면, 아래와 같이 연결 테이블을 생성해서 다대다로 맵핑하게됩니다.      하지만 이렇게 @ManyToMany로 맵핑하는것은 지양해야합니다. 왜냐하면 연결테이블이 생기면 대부분의 상황에서 이 연결테이블의 생성시간이라던가, 변경시간, 혹은 여러가지 추가 데이터를 추가 해야할일이 생기는데, @ManyToMany의 연결 테이블에서는 이러한 것들을 추가할 수가 없습니다.   게다가 중간 테이블의 id값이 어디에 종속적으로 된다는 것은, 유지보수에 있어 좋지 않습니다. 모든 테이블은 각자의 고유한 아이디를 갖는 것이 효율적입니다.   따라서 @ManyToMany는 아예 사용하지 않는것이 가장 좋습니다.   그렇다면 이러한 다대다 관계는 JPA에서 어떻게 구현하는 것이 가장 효율적일까요?   다대다 한계 극복하기  이러한 문제들을 해결하기 위해서는, 중간테이블을 @ManyToMany가 생성하게해서 다대다 맵핑 하는 것이아니라, 직접 테이블을 만들고 이를 @OneToMany와 @ManyToOne 으로 맵핑해주는 것이 안전하고 효율적입니다.      이렇게 중간 테이블인 ARRAY_LIST를 JPA에서 자동 생성해서 다대다 맵핑하는것이 아니라, 직접 PK가 있는 테이블로 만들어 이를 각각 테이블에 다대일 관계로 맵핑해주는 것입니다.   코드로 한번 보도록 합시다. 실제 제가 구현한 코드를 알아보기 쉽게 간소화해서 작성했습니다.   @ManyToMany를 사용한 코드      Volunteer  1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Getter @NoArgsConstructor @Entity public class Volunteer extends BaseTimeEntity {     @Id     @GeneratedValue(strategy = IDENTITY)     private Long id;      private String title;          @ManyToMany     @JoinTable(\"APPLY_LIST\")     private List&lt;User&gt; users = new ArrayList&lt;&gt;();  }   User  1 2 3 4 5 6 7 8 9 10 11 12 13 @Getter @NoArgsConstructor @Entity public class User extends BaseTimeEntity { \t    @Id \t    @GeneratedValue(strategy = GenerationType.IDENTITY) \t    private Long id; \t\t \t    private String name; \t     \t    @ManyToMany(mappedBy = \"users\") \t    private List&lt;Volunteers&gt; volunteers = new ArrayList&lt;&gt;();  }  위처럼 하면 @ManyToMany를 사용해서 다대다 맵핑을 완료할 수 있습니다.   하지만 위에서 @ManyToMany를 사용하는 것은 지양해야한다고 했습니다. 그럼 이번에는 중간테이블을 직접 엔티티로 승격시켜 @ManyToMany를 사용하지 않고 코드를 작성해봅시다.   Volunteer  1 2 3 4 5 6 7 8 9 10 @Getter @NoArgsConstructor @Entity public class Volunteer extends BaseTimeEntity {     @Id     @GeneratedValue(strategy = IDENTITY)     private Long id;      private String title; }   User  1 2 3 4 5 6 7 8 9 10 @Getter @NoArgsConstructor @Entity public class User extends BaseTimeEntity { \t    @Id \t    @GeneratedValue(strategy = GenerationType.IDENTITY) \t    private Long id; \t\t \t    private String name; }   ApplyList  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Getter @NoArgsConstructor @Entity public class ApplyList extends BaseTimeEntity {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      @ManyToOne     @JoinColumn     private User user;      @ManyToOne     @JoinColumn     private Volunteer volunteer; }  이렇게 다대다 연관관계를 지워주고, 중간테이블을 Entity로 승격시켜 각각 ManyToOne으로 다대일 연관관계로 맵핑하면 됩니다. 양방향으로 맵핑이 굳이 필요하지 않다면, 단방향으만 맵핑해주는게 좋습니다.   Service 레이어 코드 작성하기  그렇다면 이 상태에서 User를 조회했을때 해당 User가 신청한 봉사가 나오고, Volunteer를 조회했을 때 해당 봉사를 신청한 유저가 나오게 하려면 서비스 레이어를 어떻게 작성해야 할까요??   두가지 방법이 있습니다.      양방향으로 맵핑하기   단방향으로 직접 ApplyList를 조회하여 DTO로 반환하기   하지만 1번의 경우, 위 코드에서 양방향 맵핑을 하게되면 ApplyList에는 User와 Volunteer가 모두 있으므로 자신이 자신을 계속 참조하는 순환 참조에 빠져 스택 오버플로우가 일어나게됩니다.   아니면 @JsonManagedReference와  @JsonBackReference를 사용해서 직렬화를 하지 않도록 설정 해주어서 순환 참조를 막는 방법이 있습니다.   하지만 굳이 양방향 맵핑을 사용해서 DB를 복잡하게 하고 순환 참조의 위험을 감수하는것 보다는, 단방향 맵핑 그대로 DTO를 사용해서 처리하는게 가장 바람직합니다.   한번 코드로 보도록 합시다.   VolunteerService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class VolunteerService {     private final VolunteerRepository volunteerRepository;     private final ApplyListRepository applyListRepository;      @Transactional     public VolunteerArticleDto findById(Long id) {         Volunteer entity = volunteerRepository.findById(id)                 .orElseThrow(                         () -&gt; new NoExistVolunteerException()                 );         List&lt;ApplyList&gt; applyLists = applyListRepository.findByVolunteer(entity);          List&lt;User&gt; applicants = applyLists.stream()                 .map(ApplyList::getUser)                 .collect(Collectors.toList());          return VolunteerArticleDto.builder()                 .entity(entity)                 .applicants(applicants)                 .build();     } }   UserService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class UserService {     private final UserRepository userRepository;     private final ApplyListRepository applyListRepository;          @Transactional     public UserResponseDto findById(Long id) {         Optional&lt;User&gt; user = userRepository.findById(id);          if (!user.isPresent()) {             throw new NoExistUserException();         }          List&lt;ApplyList&gt; applyLists = applyListRepository.findByUser(user.get());         List&lt;Volunteer&gt; volunteers = new ArrayList&lt;&gt;();          for (ApplyList apply : applyLists) {             volunteers.add(apply.getVolunteer());         }          return UserResponseDto.builder()                 .entity(user.get())                 .volunteers(volunteers)                 .build();     } }   UserResponseDto와 VolunteerArticleDto를 만들어줌으로써, 필요한 데이터만을 담는 DTO를 생성해주고, applyListRepository에서 직접 조인해서 해당 id에 맞는 봉사와 유저정보를 가져와 Dto에 담아주면 됩니다.   이렇게 하면 다대다 관계를 @ManyToMany 없이 순환참조를 없앤 상태로 구현할 수 있습니다. 또한, 굳이 양방향 맵핑을 해주지 않음으로써 테이블의 복잡도도 낮출 수 있죠.   마무리  오늘은 이렇게 @ManyToMany를 사용하지 않고 중간테이블을 만들어 줌으로써 양방향 맵핑을 각각의 단방향 맵핑으로 구현하여 해결해보았습니다.   JPA는 객체지향적으로 데이터베이스와 객체를 맵핑하도록 도와주지만, 여러가지 알아야 할 것들이 참 많은 것 같습니다. 존재는 하지만 실무에서 절대 사용해야할 주의사항도 많아서, 스프링 문서만 읽어보고 아 이런기능이 있구나~ 하고 사용하다가는 큰 문제를 만날 수 있으니, 꼭 자세하게 배워 사용할 수 있는 능력이 필요할 것 같습니다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%EB%8B%A4%EB%8C%80%EB%8B%A4-%EA%B4%80%EA%B3%84-%EB%A7%B5%ED%95%91/",
        "teaser": null
      },{
        "title": "2022년도 상반기 결산",
        "excerpt":"2022.07.02  어느덧 2022년이 찾아온지가 엊그제 같은데, 벌써 반이나 훌쩍 지나가 버렸다. 2021년 마무리 결산을 한것도 진짜 진짜 얼마 안된 것 같은데, 벌써 반만 지나면 또 2023년이라니…   오늘은 네이버 코테를 봤다. 그냥 딱 평균정도 풀었다. 코테가 끝나고 나서 이번에는 진짜 열심히 준비한 것같은데 아쉬운 마음이 너무 컸다. 나는 언제까지 항상 평균치만 하면서 운에 자꾸 기대를 걸어야 하는걸까… 열심히 했어도 잘하지 못했다면 열심히 하지 않은 것이다. 열심히 한다는 것은, 어떻게 열심히 잘 하느냐도 포함된거니까.   실력이 없을 때는 항상 운에 모든걸 맡길 수 밖에 없다.  이번 제발 한번만… 이번에는 혹시 될 수도 있지 않을까…? 하는 마음들. 하지만 언제나 그렇듯 운이라는 건 남들에게만 일어나고 나에게는 일어나지 않는다. 그래서 결국 내가 할 수 있는 건 다시는 운에 기대지 않도록 실력을 키우는 것 밖에 없지 않나 싶다. 최근에 코딩테스트를 푸는게 덜괴로웠던 것 같다. 괴로울 수록 실력이 느는건데, 어느 순간 편안한 난이도에 머무르기만 한게 아닌지 반성해본다.   그래서 아쉬운 마음도 크고, 제대로 해내지 못한 내 자신에게 너무 실망이 크고 내 자신이 미워서 계속 누워서 질책을 하다가 어차피 또 이민재라는 사람이랑 계속 평생 살아야하는건데, 미워해서 뭐하나… 질책해서 뭐하나… 하는 마음이 들어 더 열심히 잘해보자고 화해하기로 했다. 그나마 남들보다 좌절에서 빨리 벗어나는게 썡판 아무것도 없는 내 유일한 장점인데, 그것마저 없어지면 너무 슬프니까…   그래도 오늘 공부하는 건 좀 선넘지 않나? 싶다가도 내가 지금 시험 좀 못봤다고 누워서 하루 버리고 있을 군번인가…하는 마음에  하는 마음이 들어서 우선 6개월 결산 글이라도 써서 마음을 다잡고 프로젝트 개발이나 좀 하려고 책상에 앉았다.   목표한 바를 얼마나 이뤄가고 있는가?  작년 12월에 작성한 1년 결산은 아래의 링크에서 볼수 있다.     2021년 결산 + 우테코 탈락    원래 이 항목은 얼마나 이뤘는가? 지만 내 계획은 1년 단위이므로 반년 회고에서는 작년에 계획한 것들을 잘 이루고 있는지, 안되고 있다면 채찍질도 하는 겸 이뤄가고 있는 것들로 다뤄보도록 하려고 한다.   작년말에 쓴글을 읽다보니, 작년에도 어째 실패들만 잔뜩 적혀있는데, 이번 회고에도 실패만 잔뜩이다. 사실 취업이라는 과정이 성공은 한번밖에 없는거니까 실패가 늘어난것에 만족하도록 하려고 한다.   또, 읽다보니까 토스 100만원 받았던게 있어서, 운이 가끔은 좋은 놈이기도 했다는 것도 좀 심심치 않은 위로가 됐다…   그래서 작년말에 계획한 2022년의 계획은 무엇이었느냐           스타트업 창업해보기            코딩 시간 지표 개선            자바 실력 늘리기            4개 이상의 웹페이지 만들기            우테코 합격       위와 같다. 하나하나 점검해보자.   스타트업 창업해보기  이건 사실 이미 했다고 하기도 뭐하고 안했다고 하기도 뭐하고…   올해 초에 예비 창업패키지 제안서를 내고 광탈했다. 뭐 나름 이걸 준비하면서 플러터도 다뤄보고, 채팅관련 기능을 자바로 구현해보기도 하면서 여러가지 배우긴 했지만, 가장 값진건 내가 별로 사업이랑 안맞는 사람이라는 걸 깨닫게 됐다는거다.   우선 내가 원했던건 주커버그나 래리 페이지와 같은 개발자로써 창업을 하는 것이었는데, 이게 이 사람들이 정말 어마어마하게 특출나고 똑똑해서 그렇지 (심지어 래리페이지 같은 경우도 잘되고부터는 전문 경영인에게 거의 경영은 모두 맡겼다.) 개발자로 창업하는건 정말 비효율 적이라는 것을 깨달았다.   특히 결국 창업을 하려면 개발보다는 투자를 받는 것이 우선인데, 그러려면 사업계획서에 모든 걸 쏟아붓고 이를 기반으로 투자를 받아 그때 부터 개발을 시작해야한다. 솔직히 여기부터는 내가 개발하는 것도 비효율 적일 수 있다. 결국 대표라는 사람은 회사의 모든 것을 책임져야 하기에, 대표가 개발까지 굳이 해가며 회사를 경영하는 것은 너무나도 비효율 적이라는 것을 깨달았다.   그렇다고 해서 내가 개발을 포기하고 창업자로써 뛰어들기에는, 나는 개발을 너무나도 사랑하고 개발자가 되고싶다.   거기다가 사업계획서를 쓰는 과정은 진짜 너무 괴롭고 하기 싫고.. 얼른 개발이나 하고싶었다. 결과물이 안나오는 행위를 하루종일 토론하고 고민하고 있다 보니까, 이래서 성공하지 못한 창업가들이 굶어죽나 싶었다. 난 개발처럼 하루하루 결과물이 나오고 성장하는 직업을 해야한다. 물론 실제로 창업에 들어가면 그 무엇보다 도전하고 매일 매일 결과물이 나오겠지만, 거기까지 갈만한 재능과 열정이 내게는 없었다.   심지어 얼마전 인플레이션 우려가 가속화됨에따라 미국에서 긴축의 속도를 더 빠르게 하기위해서 금리를 아주 크게 올릴 것을 시사하고, 결국 지난달에는 기준금리 0.75포인트 인상을 해버리며 VC 시장에 거대한 폭탄을 날려버렸다. 그동안 우선 무작정 투자를 받아 무지막지한 적자를 감내해가며 덩치를 키운 다음에 이를 매각해버리는 방식으로 투자가 호황이던 VC 시장은 당분간 얼어 붙을 듯 하다.   뭐 어차피 이미 하지도 않을 거였지만, 경제 상황까지 나를 말려준다면야 시원하게 이 목표는 삭제 하기로 했다.   물론 나중에 정말 멋진 시니어 개발자가 되서 성장하는 스타트업에 들어가 열일 하고픈 마음은 있다. 그건 나중으로 제쳐두고 우선 멋진 시니어 개발자가 되는걸로.   코딩시간 지표개선  이건 2022년 상반기 지표에서 다루도록 하자   자바 실력 늘리기  이건 상반기에 열심히 해본다고 했는데 지지 부진하다가, 최근 한달전부터 프로젝트를 시작하면서 좀 급속도로 실력이 늘어가는 기분이다. 역시 프로젝트를 해야 내가 만족할만한 공부 시간과 실력 상승이 따라온다. 이번 프로젝트를 하면서 다짐했다. 취업을 해도 언제나 평생 토이 프로젝트를 항상 최소 한개 씩은 진행하자! 물론 취업 안해봐서 얼마나 힘든지는 모르겠지만, 그런 방향을 추구하도록 할 생각이다.   솔직히 지난 5개월 보다 프로젝트를 시작하고의 한달이 실력이 상승하는데 있어 압도적이었다고 생각한다.   4개이상의 웹페이지 만들기  이거 진짜 진짜 코알못이라 작년에 이렇게 계획을 짠것 같다. 지금 수정한다. 올해 내 목표는 2개의 웹페이지다. 대신 엄청 정성들이고 테스트 코드도 잘 작성되어있고 고민이 잔뜩 담긴 프로젝트로!   현재는 1개 진행중이며, 하반기에도 하나 예정된게 있기는 한데, 변경될 수도 있다. 이것도 잘해내고 있는걸로~~   우테코 합격  이 부분도 살짝 수정이 필요하지 싶다. 작년에는 우테코 떨어지고 분한마음에 이렇게 했는데, 우테코를 진행하면 10개월 짜리 코스인데, 내가 내년 10개월을 또 취업을 위해서 투자하기에 조금 부담스럽다는 생각이 많이 든다. 그래서 우선 취준을 하반기에 하는걸 목표로 하고, 우테코를 10개월을 투자하는 것에 대해서는 좀 남은 6개월동안 고심해봐야겠다.   어쨌든 비스무리하게 요즘 취준 열심히 하고 있으니 잘하고 있는걸로~   뭐 쓰다보니까 우리 금쪽이 참잘하고 있어요~ 가 된것 같기도 한데, 또 나름 돌아보다보니까 이정도면 열심히 살고 있는거 아닌가 싶다.   실패를 만나고 힘들어도 계속 이대로 쭉 더 나은 사람이 되도록 정진해보자. 수정한 목표를 이번년도에 모두 이룰 수 있도록…   추가로 작년 목표에 왜 안넣었는지 모르겠는데, 영어 실력 향상이 있다. 사실 작년 상반기에 영어 실력 늘려보자고 하고 제대로 한게 없고 영어 너무 어려워서 나도 모르게 슬그머니 뺀것 같은데, 최근에 졸업을 위해서 토익을 하다가 이게 또 재미가 들려서 토익 고득점을 목표로 공부하고 있다. 지금 시험 보면 800점대 후반 나오지 않을까? 토익 확 만점 맞아버리는게 목표다. 물론 한번봐서 900점 넘으면 굳이 굳이 다시 보지는 않겠지만.   사실 영어는 뭐 굳이 목표로 할게 아니라, 토이 프로젝트 처럼 평생 하루에 한시간씩이라도 공부하기로 다짐했다.   지표로 알아보는 2022년 상반기  2021년 하반기 기록표     2022년 상반기 기록표     솔직히 저때는 한창 클레이 앱 개발하느라 무슨 하루에 9시간 이렇게 코딩할때도 많아서 조금 딸리긴 하지만, 그래도 저때는 필사의 각오로 막 한거에 비해서 이번에는 매일 매일 꾸준히 잘하고 있는 것 같다. 1월달에는 2022년 시작한다고 좀 소홀히 하기도 했지만…   어쨋든 최근에는 프로젝트 시작하기도 했고, 영어 공부도 꾸준히 하면서 공부시간도 늘고 좀 규칙적인 하루 생활이 몸에 배었다. 하반기에도 매달 최소 100시간 내지 110시간은 넘기도록 꾸준히 공부하도록 할 예정이다.   작년에는 뭐 가장많이 코딩한달 가장 적게 코딩한 달 이런거 했는데, 굳이 의미 있나 싶어서 이제 안하겠다… 다시보니까 좀 호들갑같아서..   2022년 상반기 회고  카카오 코딩 테스트  카카오의 벽을 느꼈다. 카카오는 진짜 코딩테스트를 만드는 사람이 존경스러울정도로 고심해서 내는 것 같다. 그렇게 퀄리티 좋은 문제를 만들려면 진짜 어려울 텐데, 그만큼 코딩테스트를 채용하는데 중요하게 보는 것 같다. 2.5솔 했지만 뭐 서류에 아무것도 없어서 기대도 안했다.   광탈…   라인 코딩테스트  라인은 카카오보다는 조금 난이도가 낮았지만, 그래도 어려운 편에 속할 정도로 생각보다 어려웠다. 카카오 코테 끝나고는 코테 공부를 잘 안해서 이때 너무 후회스러웠다. 라인 코테 이후로 꾸준히 하루에 한개씩은 풀자고 다짐하고 아직까지는 계속 잘 해오고 있다.   네이버 코딩테스트  위에 썼으니까 뭐 별말 안쓰겠지만… 코테 편안한 난이도에 머무르려고 하지말고 진짜 좀 괴롭도록 열심히 하자.   토익  토익 맨처음에 무슨 500점 이렇게 나와서 평생 영어 공부를 안한 나를 저주하고 또 저주하면서 열심히 했는데, 생각보다 점수가 되게 빠르게 오르고 재밌어서 하루에 한시간씩 열심히 하고 있다. 사실 내가 원래 학창시절에도 국어는 맨날 1등급 맞았어서 언어에는 살짝 자신감이 있으면서도 영어를 그지같이 못해서 뭔가 영어가 거의 컴플렉스 급이었는데, 그걸 극복하고 나니 영어 푸는게 재밌다. 특히 산타토익 결제한거는 토익 공부하는데 큰 도움을 줬다. 토익 하시는 분들은 산타토익 무료체험이라도 한번 해보시길!   프로젝트  작년에 단장했었던 자몽 홈페이지를 만드는 프로젝트를 뭐 누구한테 말도안하고 혼자 계속 승환이랑 만들고 있는데, 이게 진짜 너무 도움도 많이 되고 만드는게 재밌어서 요즘 개발이 즐겁다. 뭔가를 항상 개발하고 있어야겠다는 생각이 들게 해줬다. 특히 상반기 초에 그냥 인프런강의만 계속 봤는데, 역시 개발하면서 필요할때마다 가서 찾아보고 공부하는게 훨씬 도움이 된다. 개발 공부는 인강본다고 1도 안느는 것 같다. 무조건 해보면서 필요한 부분 자세하게 공부하기 방식이 최고다.   운동  지난 상반기 일기를 보다보니까 운동하기 싫어 죽겠다는 글이 있는데, 지금은 한 한달 반정도 운동에 다시 재미를 붙이는데 성공했다. 보충제 먹으면서 빡시게 하니까 어느정도 좀 좋아지는게 보이는 것같아서, 그 이후로는 재미로 한다. 지금은 또 어느정도 정체기 같기도 하지만, 그래도 운동도 평생 해야 또 재밌게 사는 발판이 되는거니까… 참 인생 힘든데 평생 해야하는 것들이 산더미다. 그래도 난 공부고 운동이고 뭐가 됐든 다 열심히 잘하고 싶어서, 좀 힘들어도 운동도 시간내서 열심히 하고있다.   주식  사실 공부 하고 부터는 손도 안댔는데, 최근에 뭐 다 알다시피 코스피고 나스닥이고 작살이 나버렸다. 거의 반토막 났는데, 뭐 별로 기분이 그렇지는 않다. 어차피 남들 다 떨어지는데 같이 떨어지는데 뭐… 물론 한 30퍼센트때 손절 쳤으면 좀 더 행복하지 않았을까? 하고 가끔 후회도 하고 있지만 그래도 아직 까지는 내가 투자한 회사에 믿음을 갖는다.   추가로 이제 9월부터 결제했던 뉴로퓨젼 프로젝트가 시작 될텐데, 주에 몇시간씩 할애해서 트레이딩 공부도 해야한다. 또 얘기해서 민망하기는 한데 주식도 평생해야하는 거니까… 이왕 하는거 잘해보고 싶은 마음이다. 경제적 풍요를 누리기 위해서, 9월부터는 또 열심히 공부해볼 예정이다.   마무리  우울한 차에 상반기 결산이나 좀 해봤는데, 그래도 나름 상반기에 열심히 했다고 느껴지는 부분들이 많아서 좀 기분이 나아진 것 같기도 하다. 하지만 결국 무작정 열심히 하는것보다는 어떻게 열심히 하느냐도 열심히에 포함이니까, 생각 없이 열심히 하지말고 남은 6개월도 항상 안주하지 말고 괴롭고 어려운걸 해가며 편안한 부분에서 벗어나려 노력해보자. 의식하지 않은 노력은 무의미한거니까…   지난 6개월 전보다 나아진 나를 보며 뿌듯한 나 자신을, 6개월 후에는 또 오늘보다 더 나아졌다고 느끼도록. 이민재 화이팅…   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/2022%EB%85%84%EB%8F%84-%EC%83%81%EB%B0%98%EA%B8%B0-%EA%B2%B0%EC%82%B0/",
        "teaser": null
      },{
        "title": "토익 후기",
        "excerpt":"2022.07.24  오늘 드디어 토익을 마무리 했다. 공부는 4월달에 시작했는데, 뭣도 모르고 120일짜리를 끊어버려서 700점만 해서 졸업하려고 했는데 이왕보는거 잘 보자는 생각이 들어 돈 환급도 받을겸 하루에 두챕터씩 꾸준히 산타 토익을 풀었다. 900점을 넘기는게 목표였는데, 갑자기 과사에서 아직 졸업인증 안됐다고 전화가 와서 8월 둘째주까지는 영어 인증 왠만하면 하라고 말하는 바람에 급하게 그냥 목요일에 일요일 시험을 잡아버렸다.   아무생각없이 잡아서 아침에 보나보다~ 하고 아침에 등명중에서 시험을 잡아버렸는데, 꽤 시간이 걸려서 6시반에 일어나서 아침을 챙겨 먹고 좀 일찍 도착하도록 나갔다. 예상보다 너무 일찍도착해서, 스타벅스에서 커피 한잔 마시면서 마지막으로 파트2랑 파트5를 오지게 풀고 아홉시에 나와 등명중학교에 도착했다. 오랜만에 중학교에 오니까 감회가 새롭기도 하면서, 책상이 너무 없길래 요즘 저출산이 심각한게 새삼 몸으로 느껴졌다;   나름 스피커 좋다는데 찾아간건데도 리스닝할때 너무 안들려서 놀랐다. 좀 울리고 웅얼댄다고 해야하나… 끝나고 또 후기를 보니까 리스닝이 어려웠다고 해서 차라리 잘 안들려서 못봤는데 어려웠다니 뭐 다행이라는 생각이 들었다. 토익 처음부터 풀어주는거는 또 보기가 귀찮아서 방금 5분 보다가 그냥 알아서 채점해주는거 다음주까지 맘편하게 기다리기로 했다.   체감상 뭐 한 800점 초중반 나오지 않을까 싶다. 뭐 900점은 못넘었지만 애초에 700만 넘기려다 초과 달성한 만큼 별로 미련은 없다. 굳이 또 볼필요까지야… 이제는 맨날 한시간씩 스피킹을 좀 공부해보려 한다. 원래 영어 혐오자였던 나에게 그래도 이번 토익 시험이 좋은 영어 자극제가 된것 같다. 스피킹 꼭 열심히 해서 나중에 해외에서 무언가를 해볼만한 실력을 만들어보는게 목표다. 하루에 한시간씩 맨날 하다보면 또 금방 실력이 늘어있겠지. 나름 4개월동안 도전하던 하나의 목표를 이룬것 같아 마음이 뿌듯하다. 이제 또 다음 목표를 향해서 열심히 해봐야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%86%A0%EC%9D%B5-%ED%9B%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] 호스팅 업체 비교하기",
        "excerpt":"서론  요즘 휴가철이라 여행이다 뭐다 정신이 없어서, 프로젝트 개발을 조금 쉬고 있었습니다. 일정들이 대부분 끝나서 오랜만에 개발을 하려고 프로젝트를 확인했는데, ec2 인스턴스가 문제가 있어서 서버에 요청이 보내지지 않았습니다. 프리티어 서버라서 간혹 이런적이 많아서 항상 그랬듯이 서버를 다시 껐다 켜주려고 ec2에 들어가 인스턴스를 중지 하려고 했는데…   ‘중지’를 한다는게 ‘종료’를 눌렀습니다…   ec2 인스턴스에서 인스턴스 ‘중지’와 인스턴스 ‘종료’는 얼핏보면 비슷한 말 같지만, 전자인 ‘중지’는 잠시 인스턴스의 활동을 중지하는 것이고, 후자인 ‘종료’는 인스턴스를 사용하기로 한 계약을 종료한다고 이해해야 합니다.      영어로 접속하게 되면 중지는 stop, 종료는 terminate로, 영어로 보면 그 의미가 좀 더 정화가게 와닿습니다. 개인적으로 종료라는 말보다는 다른 말로 번역해줬으면 좋겠습니다. 인스턴스 ‘삭제’ 정도가 적당하지 않을까요? 물론 그렇게 되면 terminate와는 의미가 좀 많이 달라지긴 하지만, 그래도 ‘삭제’가 적당하다고 생각합니다.      이 글을 보시는 분이라면 꼭! 인스턴스 설정에 있는 종료 방지 기능을 활성화 시키거나, 종료동작 변경을 중지로 변경하여서 혹시나 발생할 수 있는 실수를 방지 하시는게 좋습니다. 물론 저같은 바보짓을 안하시는 분들이 더 많겠지만… 항상 자신을 믿지말고 실수를 안해야지 마음만 먹기보다는, 실수를 하려고 해도 못하도록 방지 해놓는게 좋다고 생각합니다… 개발로 지친 심신미약의 여러분은 언제든 실수 할 수 있습니다.          어쨌든 이미 삭제가 되버렸고, 저 같은 경우는 인스턴스를 복구 할 수 있는 인스턴스 스냅샷도 프리티어에서는 무료로 제공되지 않기 때문에 삭제한 상태라 이를 복구 할 수 있는 방법이 없었습니다.   그래서 이미 삭제된 김에, 저렴한 서버로 마이그레이션 하기로 했습니다. 사실 aws의 경우 현재 프리티어로 사용중이어서 특별히 요금이 청구되지는 않지만, 기간이 얼마 남지 않아서 기간이 끝난다면 굳이 금액이 비싼 편에 속하는 aws를 사용할 이유가 없었습니다. aws는 기업들 입장에서는 언제든지 서버의 성능을 조절할 수 있기 때문에 경제적이지만, 개인이 사용하기에는 크게 저렴하지 않기 때문입니다.   원래도 애초에 서버를 국내 서버에 호스팅할까 고민했지만, 대부분의 기업의 표준이 aws인 만큼 이에 대해서 공부해보고 싶은 마음에 aws를 사용해서 공부해보고, 후에 프리티어 기간이 끝나갈 때쯤에 저렴한 국내 호스팅 사이트로 옮길 예정이었습니다.   이제 슬슬 프리티어 기간이 끝나가는 시점이라서 마이그레이션을 해야한다는 생각은 한채로 차일피일 미루고 있었는데, 인스턴스 삭제로 인해 강제 마이그레이션을 결심하게 되었습니다.   호스팅 업체 찾기  그래서 국내에 있는 호스팅 업체중에 제 조건에 맞는 업체를 찾아보았습니다. 제 조건은 아래와 같았습니다      저렴할 것   공유 호스팅이아니고, 내가 루트권한을 갖고 모든걸 컨트롤 할 수 있는 호스팅일 것   애초에 토이프로젝트 정도의 작은 웹페이지이고 , 동아리원 한 50여명이 봉사를 신청하거나 가끔 관심있는 지원자들이 방문해서 구글 폼 지원서로 가도록 링크를 제공해주는게 다였기 때문에, 웬만한 작은 램과 용량을 가진 서버여도 문제가 전혀 없다고 생각해서, 무조건 저렴한 서버가 필요했습니다.   그리고, 웹호스팅의 경우 굉장히 저렴하고 운영도 간편하지만, 하나의 서버를 여러 웹사이트가 공용으로 사용하기 때문에 운영에 제약이 너무 많습니다. 특히나 운영이 간편하다는 장점이 저에게는 오히려 단점으로 다가왔습니다. 저는 웹페이지가 잘 구동되는 것도 중요하지만, 배우는 목적도 있기 때문에 서버 자체를 제가 다룰 수 있어야 합니다.   이러한 조건을 갖고 어떤 호스팅 방식이 적합한지 찾아보고, 업체를 선택해보도록 하겠습니다.   호스팅 방식의 종류  호스팅은 크게 네가지 방식으로 구분됩니다.      웹 호스팅   서버 호스팅   가상 서버 호스팅   클라우드 호스팅   물론 사실상 세가지 모두 같은 방식이지만, 호스팅 업체에서 판매를 위해서 구분해놓은 것이라고 생각하면 편합니다. 기본적으로는 모두 컴퓨터 하나를 대여하는 방식이고, 이를 판매자와 구매자의 편의를 위해 구분해놓은 것입니다.   그럼 하나씩 알아보면서 어떤 용도로 주로 사용되는지, 장점과 단점은 어떤지 알아보도록 합시다.   웹 호스팅  웹 호스팅은 호스팅 업체의 서버 일부를 임대해서 사용합니다. 서버하나에 여러개의 웹페이지가 입주하기 때문에, 아파트라고 생각하면 편합니다. 한 건물을 조금씩 나누어서 많은 사람들이 입주합니다   장점           가격이 매우 저렴합니다. 카페 24의 경우 가장 저렴한 서버는 설치비를 제외한 한달 이용료가 500원입니다.            관리가 용이합니다. 리눅스에 대한 지식이 없어도 간단하게 내 웹페이지를 호스팅 할 수 있습니다. 심지어는 템플릿마저 제공해서 간편하게 웹사이트를 제작할 수 있습니다.       단점           자유도가 낮습니다. 서버의 일부를 임대하는만큼 서버에서의 루트 권한을 갖고 내 맘대로 설정이 불가합니다.            속도가 느립니다. 하나의 서버를 여러명이 사용하기 때문에 성능이 낮으며, 다른 웹사이트 트래픽에 영향을 받습니다.       서버 호스팅  서버 호스팅은 하나의 서버를 온전히 대여해서 사용하는 방식입니다. 비유를 하자면 아파트 하나를 모두 사용하는 방식이죠.   장점           나 혼자만 서버 전체를 사용하기 때문에, 다른 웹페이지에 영향을 받지 않습니다.            넓은 공간을 혼자서 사용하기 때문에 성능도 웹 호스팅에 비해 뛰어납니다.       단점           혼자서 서버하나의 비용을 모두 부담하기 때문에 비쌉니다.            호스팅 업체에서 따로 관리해주지 않기 때문에 사용자가 어느정도 수준의 지식을 알아야 합니다.       가상서버 (VPS) 호스팅  가상 서버 호스팅은 하나의 서버를 가상으로 나누어 사용자들이 마치 하나의 서버를 임대한 것 처럼 사용가능 합니다. 아파트에 주민들이 한 층씩을 나눠서 층마다 다른사람이 있다고 생각하면 됩니다.   장점           서버 호스팅과 마찬가지로 다른웹페이지의 영향을 받지 않습니다.            웹 호스팅에 비해서 독립적인 공간을 사용하기 때문에 성능도 우수합니다.       단점           웹호스팅보다 넓은 공간을 대여하기 때문에 웹호스팅에 비해 가격이 높습니다.            웹호스팅과 마찬가지로 사용자가 어느정도 서버에 대한 지식이 있어야합니다.       클라우드 호스팅  클라우드 호스팅은 여러개의 서버를 임대하여 그 안에서 순간적으로 내가 사용하고 싶은 만큼만 늘렸다가 줄일 수 있습니다. 아파트 여러개를 나누어 쓰면서, 원할때마다 다른 부분을 임대했다가 줄였다가 할 수 있다고 생각하면 됩니다.   장점           갑자기 트래픽이 많아지면, 그에따라서 서버의 크기도 늘리면 됩니다. 반대로 트래픽이 적을때는 서버의 크기를 작게 유지하면 되기 때문에 경제적입니다.            독립적인 공간을 사용하기 때문에 성능도 우수합니다.       단점           서버에 대한 지식이 있는 사람이 필요합니다.            하나의 프로그램에 문제 가 생기면, 연결된 프로그램도 함께 영향을 받습니다.       어떤 방식이 적합할까?   이렇게 네종류의 호스팅 방식에 대해 알아봤습니다.   그럼 위의 조건을 따져보았을 때, 저에게는 어떤 호스팅 방식이 가장 적합할까요?   저는 “가상 서버 호스팅”을 선택했는데, 이유는 다음과 같습니다.      가격이 저렴하다.   웹 호스팅보다는 비싸지만, 다른 방식들중에서는 두번째로 저렴합니다.      자유도가 높다.   가상으로 분리한 서버 하나를 갖게 되기 때문에, 루트 권한을 갖고 내가 직접 서버를 사용할 수 있습니다.   가상 서버 호스팅은 두가지 조건을 만족했습니다. 다른 서버의 경우는 어떤지 볼까요?   웹 호스팅  가격은 가장 저렴하지만, 2번 조건에 위배됩니다. 웹 호스팅은 제한된 기능만을 사용할 수 있습니다.   서버 호스팅  가격이 개인이 사용할 정도의 가격이 아닙니다.   클라우드 호스팅  aws가 클라우드 호스팅에 속하는데, 개인의 경우는 종량제를 사용하는게 더욱 경제적 입니다.   따라서 가격이 가장 저렴하고 성능도 괜찮으며, 무엇보다 루트 권한을 갖고 서버를 사용할 수 있는 가상 서버 방식을 선택했습니다.   호스팅 업체 고르기  그럼 어떤 호스팅 업체를 고를지를 골랐으니, 성능과 가격을 비교해서 가장 적합한 곳을 골라 보겠습니다.   아래는 제가 비교해본 호스팅 사이트의 금액 및 사양 비교표입니다.      나름 다양한 사양과 가격을 갖고있는데요. 국내 1위 호스팅 업체는 카페24입니다.   하지만 제가 이 중에서 추천드릴 호스팅 사이트는 iwinv입니다.      실제 사용해보지 않아서 실제 성능에 대해서는 써봐야 알겠지만, 제원상으로는 가격대비 트래픽이나 램, CPU등이 적절한 가격에 제공되는 것 같습니다.   그래서 저는 iwinv로 호스팅 업체를 변경하고, 하루정도 시간을 투자해 서버 마이그레이션을 마쳤습니다. iwinv의 사용방법은 aws와 동일하게 ssh 접속을 통해서 서버를 세팅해주면 됩니다. 저는 도커를 사용해서 어플리케이션을 배포중이었는데, iwinv에서는 기본적으로 도커를 지원하는 점이 좋았습니다.   결론  개발을 하다보면 그냥 단순하게 “거의 모든 회사가 aws쓰니까 aws로 서버 호스팅해야지~” 하고 사용하는 경우가 많습니다. 다른 기술이나 서비스를 적용함에 있어서도 마찬가지입니다. 항상 남들이 많이 쓰고 다들 이거 쓰니까 쓰는 개발자 보다는, 자신의 상황과 여건에 맞추어 유연하게 문제해결을 하는 개발자가 되도록 합시다.   추가로… 어떤 기능이던간에 삭제 방지 기능이 있는지 반드시 확인하고, 있다면 삭제방지 기능부터 적용하고, 없다면 삭제되었을 때 복구 할 수 있도록 백업과 같은 대처 방법을 항상 준비해 두도록 합시다.   ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-%ED%98%B8%EC%8A%A4%ED%8C%85-%EC%97%85%EC%B2%B4-%EB%B9%84%EA%B5%90%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Spring] delete요청 보내도 삭제 안될때",
        "excerpt":"서론  프로젝트를 진행 중에, delete요청을 보냈는데도, 데이터베이스에서 해당 컬럼이 삭제되지 않는 걸 발견 했습니다.   봉사를 불러오면, 해당 봉사의 참가자를 함께 불러오게 하기 위해서  참가자리스트의 엔티티인 ApplyList에 봉사의 엔티티인 Volunteer와 유저의 엔티티인 User를 각각 다대일 맵핑해주고, Volunteer에 일대다로 ApplyList를 맵핑해주었습니다.   Volunteer  1 2 3 4 5 6 7 8 9 public class Volunteer {     @Id     @GeneratedValue(strategy = IDENTITY)     private Long id;      @JsonBackReference     @OneToMany(mappedBy = \"volunteer\", cascade = CascadeType.ALL, orphanRemoval = true)     private List&lt;Comment&gt; comments = new ArrayList&lt;&gt;(); }   ApplyList  1 2 3 4 5 6 7 8 9 10 11 12 13 public class ApplyList extends BaseTimeEntity {     @Id     @GeneratedValue(strategy = GenerationType.IDENTITY)     private Long id;      @ManyToOne     @JoinColumn     private User user;      @ManyToOne     @JoinColumn     private Volunteer volunteer; }   이 상태에서 서비스레이어에서 유저와 봉사를 파라미터로 받아 해당 조건에 맞는 데이터를 삭제하는 deleteByUserAndVolunteer가 제대로 데이터를 삭제하지 못하였습니다.   VolunteerService  1   applyListRepository.deleteByUserAndVolunteer(user.get(0), volunteer);   해결 방법  Volunteer에서 applyList에 있는 cascade 옵션을 삭제해주면 됩니다.   cascade 옵션을 사용할때에는 반드시 등록과 삭제등 두 엔티티의 라이프 사이클이 동일하고, 여러 엔티티가 아닌 단일 엔티티에 종속적일때만 사용해야 합니다.   지금은 Volunteer에서 ApplyList에 영속성 전이 옵션인 cascade를 설정해주었기 때문에, 부모객체인 Volunteer가 전적으로 ApplyList의 생명주기를 관리하게 됩니다.   따라서 ApplyList에 Delete요청을 보내도, 이 객체의 생명주기는 온전히 Volunteer가 관리하기 때문에 삭제가 되지 않았던 것 입니다.   이렇게 cascade 옵션을 사용할때에는 이 두 객체가 같은 생명주기를 갖는것이 서비스 로직상 맞는지 꼭 확인 후 사용해야겠습니다.  ","categories": ["java"],
        "tags": [],
        "url": "/java/Spring-delete%EC%9A%94%EC%B2%AD-%EB%B3%B4%EB%82%B4%EB%8F%84-%EC%82%AD%EC%A0%9C-%EC%95%88%EB%90%A0%EB%95%8C/",
        "teaser": null
      },{
        "title": "어느새 2학기",
        "excerpt":"2022.08.29  오랜만에 일기를 쓴다. 일기를 잘쓰겠다고 다짐하고 안쓰고 다짐하고 안쓰고 무한반복의 굴레…   자몽 프로젝트가 막바지에 이르고 좀 개발할게 없기도 하고, 무엇보다 최근에 영상편집에 빠져서 근 한달간은 영상관련된걸 열심히 하며 보냈다. 아무래도 일기도 개발블로그다 보니 개발을 안하니까 잘 안썼다;; 그래도 일기가 없다고 해서 게으르게 산것은 아니었으니 봐주기로한다.   개발자라는 직업은 아주 재밌기도 하고 적성에 잘맞지만, 뭔가 살짝 부족한 느낌이 있었는데 영상편집에서 그 부족한 느낌을 채워주는 무언가를 발견했다. 나름 예술적인 감각이 필요하기도 해서 재밌기도 하고, 어렴풋이 디지털 노마드의 꿈을 살짝 꾸는 나에게는 코딩과 함께 돈이 될만한 무언가가 필요했는데 영상이 그걸 충족시키는 것 같아서 흥미가 생겨 한달간을 영상에 빠져지냈다.   그래서 솔직히 개발 장비에도 돈을 많이 쓴편인데, 장비병 어디 안간다고 영상도 입문 부터 좀 장비에 꽂혀서 지금은 어느정도 괜찮은 퀄리티의 영상을 만들만한 장비는 대략 갖췄다. 한 200만원정도의 셋팅?? 괜찮은 퀄리티의 영상을 만드는데 필요한것들을 꼽아보자면 대략 카메라, 렌즈, 짐벌 정도라고 생각하는데, 카메라는 중고로 소니 a6400을 번들렌즈와 함께 구매했고, 렌즈도 마찬가지로 중고로 16mm화각 하나를 구매했다. 짐벌을 중국 기업 제품으로 저렴하게 마찬가지로 중고로 10만원에 구매완료. 거기다 파이널컷을 학생라이센스로 구매해서 기본적인 영상편집 장비 수준을 갖췄다.   솔직히 아이폰으로도 괜찮은 영상 충분히 만들 수 있어서 시작부터 이렇게 안사고 우선 만들어보고 결정해도 되는데, 나는 심성이 그냥 시작부터 내가 원하던 퀄리티의 결과물이 안나오면 너무 만족이 안되는 스타일인것 같다. 편집이 입문자 수준인것은 참아도, 장비에서오는 입문자스러움은 참을 수 없다. 좀 큰돈을 투자하긴 했어도, 우선 카메라 장비들은 짐벌을 제외하고는 감가가 굉장히 적기도 하고, 무엇보다 이 장비들이 결국 내게 돈을 벌어줄거라는 확신이 있어서 과감하게 투자했다. 요즘은 그래서 영상편집이 가장 재밌는 취미이자 공부였다.   사실 원래도 영화를 보고나서 그에 대한 해석이나 연출을 찾아보는 것을 좋아했는데, 영상을 공부하다보니 이 영화라는 작품들이 얼마나 디테일하게 카메라 연출을 하는지 알게되니까 더 재밌어졌다. 유튜브 skim on west라는 채널을 이전에도 재밌어서 몇개 영상을 본적이 있었는데, (아마 아케인 리뷰를 찾다가 봤던 것 같다) 영상을 공부하기 시작하고 보니 그 채널이 리뷰 수준이 아니라 영상 편집과 촬영의 기본기를 너무나 잘 설명 해주는 채널이어서 큰 도움이 되었다. 혹시나 영상편집 공부하거나 관심있는 사람들은 skim on west 채널 꼭 보시길 바란다.   그래서 이렇게 구매한 장비와 공부한 지식들로 첫 공모전에 도전중이다. 대충 서울을 홍보하는 공모전인데, 친구 한명이랑 저번주 이번주를 서울 곳곳을 땡볕에 다니며 촬영을 하고 어느새 편집 마무리 작업 중에 있다. 막상 직접 찍어보니 차가 없으니까 장비 다 들고 지하철 타고 다니는것도 힘들고 날씨는 또 어찌나 덥고 촬영할거는 얼마나 많은지 피곤해서 쓰러지는 줄 알았지만, 그래도 최근에 했던 일중에 가장 즐거웠다. 근데 이렇게 힘들었는데 장려상도 못타면 조금 마음이 아플것 같기는 하지만…   추가로 최근에 전동 스케이트보드를 하나 구매했는데, 요즘 밤이되면 보드 때문에 몸이 근질근질한다. 굳이 보드를 들고가서 청라역에서 집까지 타고오기도 하며 라이딩을 하곤하는데, 정말 바람을 맞으며 타다보면 스트레스가 풀리는 기분이다. 그래서 요즘 가장 재밌는 취미중에 하나가 보드 라이딩인데, 대신 뒤지게 위험하다. 타면서도 항상 삐끗하면 뒤질수도 있다는 불안한 마음이 드는데, 사실 이 기분때문에 재밌는게 아닌가 싶다. 어쨌든 넓디넓은 청라에서 한 2키로 내지를 다닐일이 꽤 많은데, 매번 버스타기도 뭐했어서 근거리 이동수단으로 잘 사용하고 있다. 청라역에서도 한 20분이면 집에 도착해서, 버스 끊길때까지 놀고 와도 된다. (물론 최근 2-3년간 버스끊길때까지 논적 한번도 없다. 사실 앞으로도 없을것 같다) 뭐 이것저것 말이 많았는데 전동보드 짱짱이라는 소리다.   하지만 이렇게 뭐 이것저것 해보고 놀던  좋은 시절은 끝나버리고 오늘 드디어 개강을 해버렸다. 막학기라 뭐 학점도 얼마 없고 학교도 일주일에 한두번 가겠지만, 그래도 마지막 학기를 잘 마무리 하는 마음으로 다시 개발도 좀 시작하고, 새로운 공부인 영상도 잘 해가면서 2022년을 또 달려보도록 하려고 한다. 이민재 화이팅!   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B0%9C%EA%B0%95%EA%B3%BC-%EC%9A%94%EC%A6%98/",
        "teaser": null
      },{
        "title": "하반기 채용시작",
        "excerpt":"2022.09.09  비교적 상반기 채용이 끝나고 잠잠했던 기간이 끝나 다시 기업들이 하나둘씩 하반기 채용공고를 내기 시작했다. 나도 다시 템포를 맞춰 더 바쁘게 달려갈 마음가짐을 갖추기위해 올라온 공고의 회사들의 채용설명회를 찾아보고 정보를 찾아보기 시작했다. 이렇게 하나둘 기업들의 회사들의 정보를 찾다보면 괜스레 무대에 오르기 전 기분처럼 긴장이되고 가슴이 설렌다. 정보를 찾다보면 자연스레 접하게되는 합격 후기들을 보면 잠시나마 내가 이 회사에 합격한 미래를 상상하게되며 가슴한켠이 간질간질하다. 하지만 이런 설렘은 사실 너무 큰 기대이기도 하기 때문에 기대를 하지않으려 애써 노력하곤한다… 기대가 크면 실망도 큰 법이니까 ㅜ   모두 취업을 하다보면 어느정도 자신의 가치와 비전을 조금씩 손해보면서 회사에 맞춰가기 마련인데, 나는 아직까지는 세상한테 덜 혼나봐서 그런가 벌써 양보하고싶지는 않은 마음이다. 이 회사가 추구하는 방향이 정말 나와 같아서 정말 여기서 일하는 상상을 하면 가슴이 뛰고 설레는, 그런 회사에서 일하고싶은다. 물론 그만큼 내가 더 노력해서 회사쪽에서도 나를 볼때 가슴이 뛰고 설레서 이 사람과 일하고 싶다는 생각이 들수 있도록 더 멋진 사람이 되어야겠지만…   네이버웹툰 채용설명회를 보다가 괜스레 생각이 많아지기도 하고, 상반기에 서류랑 코테광탈로 너무 많이 얻어맞아서 개발이 조금 미워지기도 하고 너무 서운해서 살짝 매너리즘에 빠졌었는데, 오랜만에 자극이 좀 되기도 하고 내가 왜 개발자가 되고싶어했는지 다시금 생각이 나서 오랜만에 글을 좀 써봤다. 다시 블로그도 열심히 하고 좀 더 열정적으로 살아봐야겠다.  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%ED%95%98%EB%B0%98%EA%B8%B0-%EC%B1%84%EC%9A%A9%EC%8B%9C%EC%9E%91/",
        "teaser": null
      },{
        "title": "[Programmers] 야근지수 (Python3)",
        "excerpt":"문제 설명  회사원 Demi는 가끔은 야근을 하는데요, 야근을 하면 야근 피로도가 쌓입니다. 야근 피로도는 야근을 시작한 시점에서 남은 일의 작업량을 제곱하여 더한 값입니다. Demi는 N시간 동안 야근 피로도를 최소화하도록 일할 겁니다.Demi가 1시간 동안 작업량 1만큼을 처리할 수 있다고 할 때, 퇴근까지 남은 N 시간과 각 일에 대한 작업량 works에 대해 야근 피로도를 최소화한 값을 리턴하는 함수 solution을 완성해주세요.   제한사항     works는 길이 1 이상, 20,000 이하인 배열입니다.   works의 원소는 50000 이하인 자연수입니다.   n은 1,000,000 이하인 자연수입니다.   입출력 예  |works|n|result|  |:—:|:—:|:—:|  |[4, 3, 3]|4|12|  |[2, 1, 2]|1|6|  |[1, 1]|3|0|   입출력 예 #1  n=4 일 때, 남은 일의 작업량이 [4, 3, 3] 이라면 야근 지수를 최소화하기 위해 4시간동안 일을 한 결과는 [2, 2, 2]입니다. 이 때 야근 지수는 22 + 22 + 22 = 12 입니다.   입출력 예 #2  n=1일 때, 남은 일의 작업량이 [2,1,2]라면 야근 지수를 최소화하기 위해 1시간동안 일을 한 결과는 [1,1,2]입니다. 야근지수는 12 + 12 + 22 = 6입니다.   입출력 예 #3  남은 작업량이 없으므로 피로도는 0입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 def solution(n, works):          if sum(works) &lt;= n:         return 0          time = sum(works) - n     baseTime = time // len(works)      remainTime = time % len(works)     timeList = [baseTime for _ in range(len(works))]          if 1 in works:         for i in range(works.count(1)):             timeList[i % len(works)] -= 1             remainTime += 1             baseTime -= 1                  if remainTime &gt; 0:         i = 0         while remainTime &gt; 0:             remainTime -= 1             timeList[i % len(works)] += 1             i += 1          answer = 0          print(timeList)     for w in timeList:         answer += w * w              return answer   1    1 solution(4, [1, 1, 1, 10])   1 2 3 4 5 6 7 [2, 2, 2, 3]      21   1 5 // 3   1 1   1 2 3 a = [1, 2, 3]  a[3 % 3]   1 1   1 4 // 3   1 1   1   ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%95%BC%EA%B7%BC%EC%A7%80%EC%88%98/",
        "teaser": null
      },{
        "title": "[Programmers] 전화번호 목록 (Python3)",
        "excerpt":"문제 설명  전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.  전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.  구조대 : 119  박준영 : 97 674 223  지영석 : 11 9552 4421  전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.   제한사항     phone_book의 길이는 1 이상 1,000,000 이하입니다.            각 전화번호의 길이는 1 이상 20 이하입니다.       같은 전화번호가 중복해서 들어있지 않습니다.           입출력 예                  phone_book       return                       [“119”, “97674223”, “1195524421”]       false                 [“123”,”456”,”789”]       true                 [“12”,”123”,”1235”,”567”,”88”]       false           입출력 예 설명  앞에서 설명한 예와 같습니다.   입출력 예 #1  한 번호가 다른 번호의 접두사인 경우가 없으므로, 답은 true입니다.   입출력 예 #2  첫 번째 전화번호, “12”가 두 번째 전화번호 “123”의 접두사입니다. 따라서 답은 false입니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 def solution(phone_book):     phone_book = sorted(phone_book)          for i in range(len(phone_book) - 1):         print(i)         if phone_book[i] in phone_book[i + 1][0 : len(phone_book[i])]:             return False     return True                                            1 solution([\"1\",\"231\",\"789\"])   1 2 3 4 5 6 7 8 0 1      True   문제풀이   이 문제는 얼핏보면 for문 두개 돌려서 풀면 될것처럼 보이지만 코테가 다 그렇듯이 for문 두개를 돌리면 무조건 시간초과가 난다. 그래서 어차피 전화번호가 다른 전화번호에 포함된 경우가 아닌 접두어인지를 묻는 문제이기 때문에, 더 긴 번호가 짧은 번호의 접두어가 될 수 없다. 따라서 정렬을 통해 접두어의 가능성이 있는 번호들을 모아주고, 이를 다음 하나의 번호에만 체크해봄으로써 반복문의 횟수를 줄여 해결할 수 있다.  ","categories": ["programmers"],
        "tags": [],
        "url": "/programmers/%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D/",
        "teaser": null
      },{
        "title": "공모전 우수상!",
        "excerpt":"2022.10.07   처음에는 나도 나중에 개발자로써 좀 알게된 지식을 강의 플랫폼등에서 판매해보고 싶다는 생각이 들어서, 나도 영상 편집 정도는 익혀보는게 좋겠다는 마음으로 무턱대고 카메라를 구매해서 영상을 촬영해보고 편집해보기를 여러번,  처음에는 간단한 컷편집만 배운다는 마음으로 시작했는데, 자꾸 편집관련 유튜브를 보다보니 어느덧 영상관련 유튜버들이 내 알고리즘을 점령해버렸고, 또 타고타고 여러개를 보다보니 영상제작 자체에 흥미가 생기고 관심이 생겼다.   컴퓨터 사양이 높아짐에따라 영상 편집이 웬만한 컴퓨터들에서 가능해지고, 핸드폰의 카메라 기술발달로 영상 촬영의 진입 장벽이 매우 떨어진 2022년, 이제 1인 크리에이터들이 공영방송사가 가지는 영향력과 얼추 맞먹는 시대를 살아가고 있는 나에게 있어서, 나를 표현하고 내가 가진 생각을 표출할 수 있는 가장 효과적인 방법인 영상 촬영과 편집을 배우는 것이 큰 도움이 될 것 같았다. 물론 기본적으로 뭘 시작하던 재미가 있어야 시작하는 사람이라서, 당연히 영상 촬영과 편집이 재밌었다.   어쨌든 영상 촬영과 편집을 공부하다보니 나도 나만의 영상을 만들어보고 싶어졌는데, 유튜브를 올려보자니 피드백도 느리기도 하고 뭘 주제로 영상을 만들어 올려야 할지 감도 안잡히고, 무엇보다 공부하느라 바빠서 조금 강제성이나 제한시간이 있어야 영상을 만들 동력이 생길 것 같았다.   그래서 눈을 돌린 것이 공모전이었다. 주제도 다 정해주기도 해서 주제 선정에 대한 고민도 없고, 제한날짜도 있으며 잘하면 상금도 주니 나를 움직일 동력까지 충분했다. 그래서 당장 공모전 사이트를 가서 괜찮은 공모전을 뒤져보았고, 친구를 불러서 같이 VisitSeoul 59초 영상 공모전에 참가하게 됐다.   사실 본격적으로 남에게 보여줄 내 영상작품으로는 첫작품인지라, 처음에는 촬영하는 방법도 어색하고 편집에 대한 감도 너무 없어서 59초 영상 뽑는데 3일이나 걸렸다. 게다가 야외 촬영이 많은데 날씨까지 더워서 정말 개고생을 하면서 찍었던 기억이 난다. 촬영을 하면서 든 생각은, 아 영상촬영자는 진짜 차가 필수구나… 아침마다 카메라와 삼각대 짐벌, 조명등 갖가지 촬영장비를 넣은 군장과도 같은 가방을 메고 뜨거운 서울을 여기저기 이동하다보면 정말 체력이 하나도 남아나지를 않았다.   근데 인간이 왜 그런지는 모르겠는데, 힘들어 죽겠는데 그만큼 재밌었다.   촬영 하는날만 해도 진짜 다시는 안찍는다 다시는 안찍는다를 다짐해놓고, 집에 오면 몸이 근질 근질한 현상… “아 내일 재촬영 한번 더 할까?”   어쩄든 결국, 영상 촬영의 ㅇ자도 모르던 놈들이 그 무거운 가방과 소품을 들쳐메고 서울을 헤집고 다니며 촬영한 영상은 고맙게도 상을 타냈다.   발표가 언제나나 하루종일 홈페이지를 들락날락 거리다가 2시쯤에 뜬 결과 발표 게시물을 보고 두근거리는 마음으로 들어가서, 당연히 입상했다면 장려상이겠거니~ 하고 장려상을 보는데 내 이름이 없었다. 아쉬운 마음으로 “첫 작품이니까 뭐 그럴수 있지…” 하는 찰나,      우수상에 내 이름이 있었다…   흥분되는 마음으로 바로 같이 고생한 친구에게 전화를 걸어서 스터디 카페인데도 큰 소리로 우수상을 받았노라를 외쳐댔다. (스터디 카페에 나밖에 없었음)   첫 작품부터 과분한 운을 받아 입상을 해서 너무나 즐거웠고, 사실 영상 찍고 편집하는 과정 자체가 너무 재밌었어서 상금은 기대 많이 안했는데, (물론 사람인지라 사람이라면 할 수 밖에 없는 기대정도는 했다) 장려상도 아닌 우수상을 받아 너무 너무 행복했다.   면접준비한다고 맨날 하루종일 공부만 하느라 마음이 피폐(?) 해졌었는데, 덕분에 조금 더 열심히 해야겠다는 생각이 들기도 하면서, 누군가에게 상을 받는게 참 큰 기쁘이라는 생각이 들었다.   이 기세로 면접도 꼭 열심히 준비해서 좋은 결과가 있었으면…   사실 공모전 하나를 면접때문에 해야하나 말아야 하나 고민중이었는데, 잠을 극단적으로 줄여서라도 참가해봐야겠다는 생각이 들었다.   어쨌든 오랜만에 공모전 상타기도 했고, 사실 상탄 것 떄문에 너무 흥분상태라 그런가 공부가 좀 안되서 잠깐 마음도 정리할겸 글을 써본다.   앞으로도 열심히 하는만큼 내 인생에 좋은 결과들이 좀 있었으면!      혹시나 영상이 궁금한 분들을 위한 링크 https://www.youtube.com/watch?v=P8d6fBPvhyE    ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B3%B5%EB%AA%A8%EC%9A%B0%EC%88%98%EC%83%81!/",
        "teaser": null
      },{
        "title": "겨울냄새",
        "excerpt":"2022.11.05  안경 렌즈를 맞출일이 있어서, 이왕 밖에 나온김에 다 해결해버리자는 마음에 노트북도 들고나와서 안경점 앞에 카페에서 시간을 보내기로 했다.   어느덧 추워져서 두꺼운 외투를 입고 밖을 나섰는데, 정말 겨울이 온게 체감이 됐다. 나는 겨울이 오면 뭔가 센치해지는데, 날씨가 추워지면 작년 이맘때 겨울의 기억이 떠오르면서, 문득 어느새 또다시 1년의 마지막에 와있다는 생각이 들곤한다. 어릴 때는 1년이라는 시간이 길고도 길었던 것 같은데, 나이가 들수록 1년이라는 시간이 왜이리 짧은지 모르겠다.   이번주 화요일에는 2차 면접을 봤다. 운이 좋게도 1차와 2차 사이의 준비기간이 조금 길었는데, 사실 면접준비라는게 뭔가 멘탈적으로나 체력적으로나 에너지가 많이 들어가는 작업이라, 면접이 끝나고는 뭔가 너무나도 후련한 마음이 들어 너무나 뿌듯했다. 잘봤는지는 모르겠지만, 정말 최선을 다해서 그런지 후회가 많이 남던 1차면접과 다르게 잘 마무리했다는 후련함이 더 커서, 면접 끝난 하루치고 너무 기쁘게 하루를 마무리 했던 것 같다. 마음에 있는 커다란 짐덩이가 하나 사라진 느낌…   면접은 정해진 틀이 없고 뭘 물어볼지 정답이 없는 것 같아서 유독 준비에 에너지가 많이 들어가는 것 같다. 그리고 정신적인 스트레스도 조금 유독 컸는데, 준비를 하면 할수록 뭔가 내가 진짜 진짜로 저 회사에 갈 수 있을까? 하는 생각이 들어서 힘들었던 것 같다. 나라는 사람에 대한 자신감과는 별개로, 사회에 내던져진 내 모습이 생각보다 너무 초라한 것 같은 느낌이 계속 들어서 면접 준비할 동안 틈틈히 내가 썼던 블로그 글을 읽거나 공부시간 기록표를 보며 내가 노력한 시간들에 대해 자신감과 믿음을 가지려고 노력했다. 그래서 그런가 면접이 끝나고도 나름 면접에서의 내 모습이 만족스러워서, 여기서 붙건 떨어진건간에 그래도 내가 노력해온 길이 헛되지 않았구나하는 생각이 들어 속이 좀 후련했던 것 같다.   그리고 좀 웃긴이야기지만 면접 과정에서 가장 자신감이 떨어졌을때 도움이 됐던게 롤드컵이었는데, DRX가 결승에 가는걸 보고 큰 마음의 위로를 받았다. 스프링 부터 서머내내 하위팀을 전전하던 DRX가 정말 처절하고 치열하게 포기할법도 한 경기들을 포기하지않으며 하나하나씩 이겨내며 가는 모습을 보고 뭔가 가슴이 뜨거워졌다. 아직 애인가 나도…   DRX도 하나하나 관문을 거쳐가며, 아마 롤드컵 결승을 생각하면 아마 ‘그게 가능하다고?’ ‘우리가 진짜 갈 수 있을까?’ 하는 고뇌와 생각들을 수도없이 했을 것이다. DRX는 롤드컵 결승에 오는 경기내내 모두 언더독이었고 한번도 승리예측 우위를 점한적이 없었으니까… 하지만 그런 것들에 신경쓰지 않고, 눈앞에 있는 당장 한경기에만 집중하고 포기하지 않았기 때문에 그런 결과를 이뤄냈다고 생각한다. 나도 그래서 미래에 어떤 결과가 있는지를 너무 걱정하고 고민하기보다는 현재를 치열하고 처절하게 열심히 하다보면 어느새 저기에 가있을 거라는 믿음으로 현재를 열심히 살기로 다짐하며 면접을 열심히 준비 했던 것 같다. 붙을지 떨어질지는 몰라도, 2차면접을 준비하는 과정에서의 후회는 없다.   그래서 이제는 조금 편안 마음으로 결과를 기다리며 살짝 여유로워진 마음으로 하루 하루를 보내고 있는중이다. 내일은 DRX의 결승전이 있는 날이다. 물론 DRX는 이번 결승마저 언더독으로 대부분의 전문가들은 상대편의 우승을 예측하고 있지만, 내일 우승해서 내 마음에 한번 더 감동을 주었으면 좋겠는 마음이다.   조금 오글거릴 수 있는 말이지만 데프트가 ‘중요한 것은 결국 꺾이지 않는 마음’이라는 말을 한게 요즘 자꾸 머릿속을 맴돈다. 나이 26살 먹고 프로게이머가 한말이 가슴을 울리다니…   나도 혹여나 이번에 떨어진다고 해도 다시 또 일어나서 다른 도전을 하면 되는 거니까 , 너무 가슴졸이며 기다리지는 말자는 말고 지금을 준비하자는 말을 스스로에게  계속 되뇌인다. 중요한 것은 결국 꺾이지 않는 마음이니까.   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EA%B2%A8%EC%9A%B8%EB%83%84%EC%83%88/",
        "teaser": null
      },{
        "title": "면접과 탈락",
        "excerpt":"2022.11.09  어제 네이버웹툰 2차 결과가 나왔다.   결과는 탈락…   사실 건방진 생각이지만 면접을 괜찮게 잘 봤다고 생각했고, 3차는 그래도 가지 않을까? 라는 생각에 기대를 많이 하고 있었는데, 예상과 달리 탈락이라는 글자가 써있어서 진짜 잠시동안 눈앞이 깜깜해졌다. 떨어져도 괜찮을거라는 생각과 달리 생각보다도 너무 실망이크고 멘탈이 깨져서 좀 힘들었었다. 솔직히 여자친구랑 같이 안있었다면 울었을것 같다.   그래서 어제 하루를 하루종일 뭐가 문제였지? 라는 생각을 하며 하루를 보내다가, 결국 마지막에는 여러 생각을 정리하고 괜찮아졌다고 생각하며 잠자리에 들었는데, 오늘 일어나서도 그 생각이 계속나고 머리가 아프고 너무 슬퍼서… 일기를 쓰며 마음을 좀 정리해보려고 책상에 앉았다.   면접이 어렵고 힘든것은 내가 어디서 실수했고 어떤게 부족했는지 알 수 가 없어서인 것 같다. 심지어 내가 못봤다고 생각했다면 덜했겠지만, 내 입장에서는 만족스럽게 봤다고 생각해서 더더욱… 어제 하루를 온통 그날로 돌아갔을때 더 잘볼 수 있는 경우의 수에 대해서 생각해봤는데, 사실 대답 못한 질문이 하나 있는 것 만으로도 걱정해야 됐던게 아닌가 하는 생각이 들었다. 모르는 질문이더라도 내가 아는 지식내에서 논리적으로 답을 도출하면 좋은 인상을 받을 수 있다고 해서, 모르는 질문을 잘 대처했다고 생각했기 때문에 면접을 잘봤다고 생각했던건데, 사실 가장 좋은건 모르는 질문이 없는 것이고, 그런 사람이 뽑힌게 아닐까. 안일하고 건방졌다. 반성한다…ㅜ   2021년의 나도 꽤 잘하는 사람이라고 생각했는데, 2022년의 내가 보기에는 형편없는 사람이었듯이, 2022년의 나도 괜찮은 사람이라고 생각하지만 2023년의 내가 보면 또 형편없는 사람일 수 있다는 생각이 들었다. 올해의 나는 유독 뭣도 없으면서 너무 자신감이 찼던것 같다.   사실 돌아보면 이번년도에 면접 한번만 가보는게 목표였는데, 어느새 욕심이 무럭무럭 자라나 준비가 덜됐음에도 최종 합격이 목표가 되었다. 채용프로세스 기간이 길기도 해서, 면접을 준비하는동안 이 곳에 합격해서 일하는 상상도 많이했기도 하고… 그래서 더 힘들고 멘탈이 깨지는 것 같다.   솔직히 정말 냉정하게 말해서 준비가 아직 덜 된 것도 사실이고, 내 부족함을 면접으로 포장해보려 해도, 결국 내 성과가 적다면 면접을 아무리 잘봐도 떨어질 수 밖에 없다는 생각이 들었다. 오히려 내 성과를 끌어올리지 않고 면접만 보러다니면, 이유없이 계속 떨어져서 더 괴로울 수도 있을 것이다.   어차피 이미 지나간일이고, 더 괴로워하고 힘들어한다고 달라질건 아무것도 없다. 굳이 달라질게 있다면 부정적인 방향으로만 달라질거다. 그래서 실패가 주는 괴로움과 아픔은 걷어내고, 실패가 주는 배울점만 가져가기로 했다. 채용과정에 과몰입하지 않고 기계적으로 대하기, 항상 모든 프로젝트와 공부를 면접에서 물어본다면 어떻게 대답할지 생각하고 공부하기, 코딩테스트는 하루에 한문제씩 무조건 풀기…   사실 지금까지 취준 비스무리한걸 경험하면서 힘들다거나 마음 고생한적이 없었는데, 그럼 아직 취업할 자격이 없다고 생각한다. 옆에 친구들은 다 취준을 하며 힘들어하고 괴로워하며 간절해 하는데, 그렇지 않은 사람이 먼저 붙는건 너무 불공평하다.   그래도 면접을 준비하며 그동안 몰랐던 것도 많이 알게되고, 절대 알아서 공부 안하고 미루던 CS도 열심히 했으니까 얻은걸 바탕으로 또 열심히 해야지. 그래도 일기를 이렇게 쓰면서 마음을 좀 정리하니까 많이 괜찮아지는 기분인 것 같기도 하고… 생각을 속으로만 하는 것과 글로 실체화 시키는 것은 큰 차이라서, 이렇게 글로 남겨야만 내가 내 자신에게 피드백을 줄 수 있는 것 같다.   1차면접 합격으로 면접 가보기 목표를 초과 달성했으니까, 이번에는 최종 면접 가보기를 목표로 한번 열심히 해보자…  ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EB%A9%B4%EC%A0%91%EA%B3%BC-%ED%83%88%EB%9D%BD/",
        "teaser": null
      },{
        "title": "Blocking과 Non-Blocking, 동기와 비동기",
        "excerpt":"Block과 동기의 차이는?  동기와 비동기, Blocking과 Non-Blocking은 언뜻보면 비슷한 개념으로 보여 헷갈릴 수 있는 개념입니다. 아예 같은 개념으로 알고있는 사람들도 있을 정도죠. 오늘은 이  두 개념의 차이에 대해서 적어보려 합니다.   먼저 간단하게 이 두 차이점을 먼저 설명하자면, 동기와 비동기는 프로세스의 수행 순서 보장에 대한 개념이고, 블로킹과 논블로킹은 프로세스의 제어권에 대한 개념입니다.   무슨 말인지 직관적으로 감이 안온다면 한번 자세히 이 개념에 대해서 알아보도록 합시다.   동기와 비동기  먼저, 동기와 비동기의 개념에 대해서 알아봅시다.   동기는 현재 작업의 응답과 다음 작업의 요청을 맞추는 것을 말합니다.   예를 들어서, 어떠한 함수안에 다른 함수가 있으면, 해당 함수에게 요청을 보내고, 그 응답을 기다렸다가 해당 함수의 응답을 받아야 다음 작업을 실행 함으로써, 우리가 사용해야할 리턴값을 받을때 다음 작업을 실행하는 것이죠.   코드로 보도록 합시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function boss () {   console.log('사장: 출근');   console.log('직원에게 작업 지시');   employee();   console.log('사장: 퇴근'); }  function employee () {    for (let i = 1; i &lt; 101; i++) {     console.log(`직원: 지시받은 작업 ${i}번 수행`);   } }  boss();  위에서 설명한 것처럼 boss() 함수안에 employee()라는 함수가 있습니다. boss()가 employee() 함수에게 작업을 지시하면, 직원이 지시받은 작업을 처리하는 것이죠.   그럼 동기에서는 이 작업이 어떻게 이루어질까요?   1 2 3 4 5 6 7 8 9 사장: 출근 직원에게 작업 지시 직원: 지시받은 작업 1번 수행 직원: 지시받은 작업 2번 수행 \t        . \t\t    . \t        . 직원: 지시받은 작업 100번 수행 사장: 퇴근  이렇게 순차적으로 직원이 모든 작업을 다 해야만 employee() 함수가 종료되므로 그동안 사장은 기다렸다가 퇴근 할 것입니다.   그렇다면 비동기는 어떨까요?   비동기는 현재 작업의 응답과 다음 작업의 요청을 맞추지 않는 것입니다.   위의 예제로 말하면, 사장은 지시를 내리고 바로 퇴근하고, 직원은 해당 작업을 사장이 퇴근하고 마무리하고 종료하는 것이죠.   마찬가지로 코드로 보도록 합시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function employee (maxWorkCount = 1, callback) {   let workCount = 0;   const interval = setInterval(() =&gt; {     if (workCount &gt; maxWorkCount) {       callback();       clearInterval(interval);     }     workCount ++;     console.log(`직원: 직원: 지시받은 작업 ${workCount}번 수행`);   }, 10); }  function boss () {   console.log('사장: 출근');   console.log(`직원에게 작업지시`);   employee(100, () =&gt; console.log('직원: 작업이 마무리 되었습니다.'));   console.log('사장: 퇴근'); }  boss();   이 경우에는 결과가 어떻게 나오게 될까요?   1 2 3 4 5 6 7 8 9 10 사장: 출근 직원에게 작업 지시 사장: 퇴근 직원: 지시받은 작업 1번 수행 직원: 지시받은 작업 2번 수행 \t        . \t\t    . \t        . 직원: 지시받은 작업 100번 수행 직원: 작업이 마무리 되었습니다.  차이를 아시겠나요? 비동기의 경우 boss() 함수안에 employee() 함수가 있음에도, employee() 함수가 끝나지도 않았는데 boss() 함수가 종료됩니다.   따라서 employee()의 응답을 다음작업인 boss()의 퇴근과 맞추지 않은 것이죠.   블락과 논블락  자 그럼 이제 블락과 논블락에 대해서 알아봅시다.   블락과 논 블락은  제어권과 관련이 있다고 했습니다.   만약 Blocking의 경우에서 Boss()가 employee()를 호출한다면, boss가 employee()에게 제어권을 넘기는 것입니다. 한마디로 함수실행이 멈추는 것이죠.  따라서, 일을 시킨 사장이 퇴근하지 않고 직원이 일을 끝마칠때까지 기다린다는 것이죠.   이렇게 말로만 보면, 첫번째 예제였던 동기에서의 예제와 똑같다는 생각이 들겁니다. 다시 한번 아까의 예제를 보도록 할까요?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function boss () {   console.log('사장: 출근');   console.log('직원에게 작업 지시');   employee();   console.log('사장: 퇴근'); }  function employee () {    for (let i = 1; i &lt; 101; i++) {     console.log(`직원: 지시받은 작업 ${i}번 수행`);   } }  boss();  1 2 3 4 5 6 7 8 9 사장: 출근 직원에게 작업 지시 직원: 지시받은 작업 1번 수행 직원: 지시받은 작업 2번 수행 \t        . \t\t    . \t        . 직원: 지시받은 작업 100번 수행 사장: 퇴근   사장이 출근을 하고, 직원에게 작업을 지시한다음, 작업이 끝날때까지 제어권을 넘겨주고 기다립니다. Blocking이죠. 왜 아까는 동기와 Blocking은 다르다고 해놓고, 이제는 왜 결과가 똑같다고 할까요?   사실 위의 코드는 Blocking + 동기 방식입니다. 보통 Blocking과 동기를 같이 사용하죠. 위 코드는 제어권을 하위 함수에게 넘기는 Blocking인 동시에, 해당 함수의 응답과 다음 작업을 맞추기 위해 기다리는 동기방식입니다.   자 그렇다면 동기 + Non-Blocking은 어떨까요?   다음 코드를 보도록 합시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function* employee () {   for (let i = 1; i &lt; 101; i++) {     console.log(`직원: 지시받은 작업 ${i}번 수행`);     yield;   }   return; }  function boss () {   console.log('사장: 출근');    const generator = employee();   let result = {};    while (!result.done) {     result = generator.next();     console.log(`사장:  사장 업무 처리...`);   }    console.log('사장: 퇴근'); }  boss();   이 코드는 동기 + Non-Blocking 코드입니다.   어떤 결과가 나올까요?   1 2 3 4 5 6 7 8 9 10 11 사장: 출근 직원: 지시받은 작업 1번 수행 사장:  사장 업무 처리... 직원: 지시받은 작업 2번 수행 사장:  사장 업무 처리...             . \t\t    . \t        . 직원: 지시받은 작업 100번 수행 사장: 사장 업무 처리... 사장: 퇴근  어떤가요?   위 코드는 동기이므로, boss() 함수는 employee()의 응답과 다음 작업을 맞추려하지만, Non-Blocking이기 떄문에 제어권은 넘기지 않습니다. 따라서 자신의 작업을 진행합니다. 자신의 작업을 진행하면서, 직원이 일을 마쳤는지 계속 확인하다가 직원의 작업이 끝나면 타이밍을 맞추어 다음 작업, 퇴근을 진행하는 것이죠.   차이가 이해가 좀 되시나요?   그럼 이제 동기 + Blocking, 동기 + Non-Blocking, 비동기 + Non-Blocking을 모두 알아봤습니다.   그럼 비동기 + Blocking은 무엇일까요?   비동기 + Blocking  이 방식은 위에서 배운내용을 토대로 생각해봤을때, 이상한 느낌이 들 것 입니다. 비동기이므로, 응답과 다음 작업의 타이밍을 맞출 필요가 없는데, 어차피 Blocking이면 타이밍을 맞추지 않는데도 제어권을 넘겨버려, 결국 하위 함수가 끝날때까지 상위 함수가 자신의 일을 처리할 수 없기 때문이죠.   이 방식은 일반적인 어플리케이션 레이어에서는 자주 사용되지 않고 Linux와 Unix 운영체제의 I/O 다중화 모델 정도의 저레벨에서 사용되고 있습니다. 그래서 지금까지 예제로 사용하던 사장님과 직원의 예제로 설명하기는 어려운 개념이므로, 따로 다뤄보도록 하겠습니다.   이 개념이 사용되는 이유는 다음과 같습니다.      동기 &amp; 블록킹 I/O의 경우 직관적이나, 여러 개의 I/O를 동시에 처리할 수 없습니다.   논블록킹 I/O는 프로세스들의 작업을 컨트롤하는 것이 까다롭습니다.   그렇다고 동기 &amp; 블록킹 I/O와 멀티 프로세싱이나 쓰레딩을 결합해서 쓰자니 자원 문제도 있고 프로세스/쓰레드 간 통신이나 동기화가 어렵습니다.   그래서 이를 해결하기 위해서 “프로세스를 블록킹 해놓은 상태로 (제어권을 넘겨 작업을 할 수 없는 상태로 만들고) 비동기로 여러개의 I/O를 다중화해서 받자”는 비동기 + Blocking의 개념이 등장한것입니다.   이 부분은 자세히 다루면 너무 로우한 개념이기도 하고, 특수한 상황에만 쓰이는 개념이므로 여기까지만 간단하게 설명하도록 하겠습니다.   마무리  이제 동기와 비동기, Block과 Non-Block의 차이에 대해서 조금 이해가 가셨나요?   마지막으로 정리하자면, 동기와 비동기는 응답과 다음 작업의 타이밍을 맞출래 말래? 인 것이고, Block과 Non-Block은 하위 함수한테 제어권을 넘길래 말래?의 개념인 것입니다.   어려운 개념이지만 위의 코드를 예제로 직접 작동해보면 이해가 더 쉽게 될 것 같습니다.   이상으로 동기와 비동기, Block과 Non-Block의 차이에 대한 글을 마칩니다.  ","categories": ["CS"],
        "tags": [],
        "url": "/cs/Blocking%EA%B3%BC-Non-Blocking,-%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[Effective Java] 생성자 대신 팩토리 메서드 사용하기",
        "excerpt":"정적 팩토리 메서드란?  우리가 새로운 인스턴스를 생성할 때, 어떤 방식을 사용하나요?   보통 new를 통해 생성자를 사용하여 새 인스턴스를 만듭니다. 하지만 이러한 방식은 여러 단점들을 포함하고 있는데요. 이러한 단점들을 극복하고 더 가독성 있는 코드를 위해 정적 팩토리 메서드를 사용하는 것이 더 좋습니다.   정적 팩토리 메서드는 말그대로 Static Factory Method를 말합니다. 이 함수는 어떠한 비지니스 로직을 포함하지 않고 오직 클래스의 인스턴스만을 반환하는 함수입니다.   먼저 예로, String 객체를 생성한다고 해봅시다.   1 2 3 4 5 6 public static void main(String[] args) {     String str1 = new String(\"test\");     String str2 = String.valueOf(\"test\");      System.out.println(str1 + \" \" + str2); }   위 코드를 보면, 똑같은 test라는 값을 가진 String  객체를 만들었음에도, 다른 방식을 사용했습니다. str1의 경우가 우리에게 익숙한 생성자를 이용하여 인스턴스를 만든 방식이고, str2의 경우가 바로 이번 게시물에서 공부하게 될 정적 패토리 메서드를 이용해서 만든 인스턴스 입니다.   이 두가지는 어떤 차이가 있을까요?   valuOf 라는 메서드를 타고들어가서 한번 어떻게 선언 되어 있는지 확인 해봅시다.   1 2 3 public static String valueOf(char data[]) {     return new String(data); }   위 코드를 보면, 해당 메서드는 static으로 선언되어 있으며 new String() 을 통해 우리가 넣어준 값을 매개변수로 String 객체를 생성해주고 있습니다.   사실상 생성자 방식과 크게 다른점이 없는 것이죠.   이렇게 하면 어떤 장점들이 생기길래, 생성자보다 정적 팩터리 메서드를 사용하는 것을 권장하는 걸까요?   1. 이름을 가질 수 있다  프로그래밍에서 변수명과 함수명을 잘 짓는 것은 매우 중요합니다.   함수 이름만으로도 이 함수가 어떤일을 하는 함수인지 알 수 있다면, 그 코드가 본인이 작성한 코드가 아니더라도 알아보기가 쉬울 것 입니다.   그래서 정적 팩토리 메서드를 사용해 생성자에 이름을 붙여줄 수 있는 것은 별것 아닌 것 처럼 보이지만 가독성에 있어 큰 장점이 됩니다.   예를 들어 봅시다.   카드라는 클래스를 만들어 본다고 가정해봅시다.   카드에는 신용카드와 체크카드가 있고, 신용카드의 경우 계좌에 있는 돈을 다써도 limit 만큼의 돈을 신용으로 더 쓸 수 있으며, 체크카드는 limit이 자동으로 0이되어 신용을 사용할 수 없게 한다고 해보겠습니다.   1 2 3 4 5 6 7 8 9 class Card {     int money;     int limit;      public Card(int money, int limit) {         this.money = money;         this.limit = limit;     } }   대략 이렇게 코드를 작성해볼 수 있겠죠?   그럼 한번 신용카드와 체크카드 객체를 만들어 봅시다.   각각 5000원씩의 돈이 들어있고, 신용카드의 경우는 5000의 limit이 더 있어 현금외에도 5000의 돈을 신용으로 더 쓸 수 있다고 해봅시다.   1 2 Card creditCard = new Card(5000, 5000); Card checkCard = new Card(5000, 0);   이렇게 코딩하면 우리가 원하는 기능을 구현해볼 수 있겠네요. 하지만 이렇게 하면, 체크카드의 경우는 무조건 limit이 0이 되어야 하는데, 누군가는 실수로 체크카드임에도 limit을 0으로 설정해놓지 않을 수 있습니다.   또, 이름이 현재는 creditCard와 checkCard로 되어있지만, 만약 카드의 이름이 minjaeCard라면, 생성자만 보고서는 이 카드가 체크카드인지, 신용카드인지 판별하기 어려울 것 입니다.      (물론 이 경우에는 Card를 상속받는 ChcekCard와 CreditCard라는 클래스를 만들어주는게 더 효율적인 방법일 것 같지만, 예시를 들기 위해서 이렇게 한다고 가정해보겠습니다.)    그럼 정적 팩터리 메서드를 사용하면 어떻게 될까요?   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Card {     int money;     int limit;      public static Card createCheckCard(int money) {         return new Card(money, 0);     }      public static Card createCreditCard(int money, int limit) {         return new Card(money, limit);     }      public Card(int money, int limit) {         this.money = money;         this.limit = limit;     } }   1 2 Card creditCard = Card.createCreditCard(5000, 5000); Card checkCard = Card.createCheckCard(5000);   이렇게 이번에는 정적 패터리 메서드를 사용해서 객체를 생성하게 해보았습니다.   어떤가요? 장점이 느껴지시나요?   우선 createCreditCard라는 메서드를 사용해서, 우리가 만들 객체가 “신용카드”임을 헷갈리지 않게 되었으며, 체크카드의 경우는 매개변수에 0이라고 해줄 필요없이 createCheckCard를 사용하면 알아서 매개변수를 money만 받고 limit은 0으로 설정하도록 도와줍니다.   이름이 생기니 한결 가독성이 나아지고, 어떤 객체가 반환되는지를 더 직관적으로 알 수 있게 되어 실수를 더 줄일 수 있게 되었습니다.   2. 호출될 때마다 인스턴스를 생성하지 않아도 된다  객체를 생성하는 것은 꽤나 비용이 드는 일입니다.   객체가 많아질 수록 힙영역에 공간이 빠르게 차고, 이 공간이 빠르게 차면 찰수록 GC도 자주 일어나 성능이 저하될 우려가 큽니다. 그렇기 때문에 같은 객체라면 굳이 여러개 생성하지 말고, 이미 생성되었던 객체를 반환해주는게 더 효과적일 것입니다.   이것을 디자인패턴에서는 싱글톤 (Singleton) 패턴이라고도 합니다.   대표적인 예로 Boolean.valueOf 메서드가 있습니다.   1 2 3 4 5 6 7 8 public final class Boolean implements java.io.Serializable, Comparable&lt;Boolean&gt; {     public static final Boolean TRUE = new Boolean(true);     public static final Boolean FALSE = new Boolean(false);          public static Boolean valueOf(boolean b) {         return (b ? TRUE : FALSE);     } }  위의 코드를 보면 마찬가지로 valueOf로 값을 받아 객체를 생성해주는 정적 팩토리 메서드인데요, 위에서 본 String.valueOf와는 다른 점이 있습니다.   미리 final로 상수 객체인 TRUE와 FALSE를 만들어 놓은 뒤, 메서드를 실행할때마다 새로운 객체를 생성해주는 것이 아니라, static으로 선언하여 애플리케이션 실행 시에 미리 만들어진 객체를 반환해줍니다.   이렇게 하면 기존 방식보다 객체를 훨씬 적게 만들 수 있을것 입니다.   이 방식의 예제를 하나 더 보도록 하겠습니다. 이런 방식으로도 사용 가능합니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 public class Day {     private static final Map&lt;String, Day&gt; days = new HashMap&lt;&gt;();      static {         days.put(\"mon\", new Day(\"Monday\"));         days.put(\"tue\", new Day(\"Tuesday\"));         days.put(\"wen\", new Day(\"Wednesday\"));         days.put(\"thu\", new Day(\"Thursday\"));         days.put(\"fri\", new Day(\"Friday\"));         days.put(\"sat\", new Day(\"Saturday\"));         days.put(\"sun\", new Day(\"Sunday\"));     }      public static Day from(String day) {         return days.get(day);     }      private final String day;      private Day(String day) {         this.day = day;     }      public String getDay() {         return day;     } }   위의 예제를 보면 어차피 요일은 월요일부터 일요일까지 밖에 없음으로, 미리 월요일부터 일요일까지의 Day 객체를 생성해둔 뒤, 이를 해쉬맵에 넣어 놨다가 해당 정적 팩토리 메서드를 호출하면 새로운 객체를 생성하는 것이 아니라, 해당 요일의 값을 String으로 받아 해당 객체를 반환해주는 방식입니다.   이렇게 하면 객체를 재사용해서 효율적일 뿐만아니라, 실수로 이 7가지 요일 외의 다른 값이 들어오면 컴파일전에 미리 잡아 주어서 더 안전할 것입니다.   3. 하위 자료형객체를 반환할 수 있다  정적 팩토리 메서드를 사용하면, 하위 자료형 객체를 반환할 수 있습니다.   아래 코드를 보도록 합시다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public class Card {     public static Card from(int expenditure) {         if (0 &lt; expenditure &amp;&amp; expenditure &lt;= 1000) {             return new Silver();         }         if (1000 &lt; expenditure &amp;&amp; expenditure &lt;= 2000) {             return new Gold();         }         if (2000 &lt; expenditure &amp;&amp; expenditure &lt;= 3000) {             return new Platinum();         }         if (3000 &lt; expenditure &amp;&amp; expenditure &lt;= 4000){             return new Diamond();         }         throw new IllegalArgumentException();     } } class Silver extends Card { }  class Gold extends Card { }  class Platinum extends Card { }  class Diamond extends Card { }   위 코드는 아까 들었던 예시인 카드의 클래스 인데요, 이번에는 Card가 등급이 있다고 가정해 봅시다.   지출액에 따라, 1000 이하면 실버등급, 1000에서 2000사이면 골드 등급, 2000에서 3000사이면 플래티넘, 3000에서 4000사이면 다이아몬드라고 해보도록 하죠. 혹여나 이상한 음수나 조건에 맞지않는 값이 들어오면 예외를 출력하도록 하겠습니다.   정적 팩토리 메서드를 사용하면, Card하나에서 이렇게 하위 객체를 반환하게 할 수 있습니다.   1 Card creditCard = Card.from(2500);  이렇게 하면, 코드를 작성하는 사람이 카드가 어떤 하위 객체가 있는지, 금액에 따라 어떤 하위 객체로 만들어야 할 지 알 필요없이, 지출액만 입력하면 알아서 등급에 맞는 하위 객체 자료형으로 객체가 생성됩니다.   4. 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.  아까 체크카드와 신용카드의 예시를 다시 가져와 설명하도록 하겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Card {     int money;     int limit;      public static Card createCheckCard(int money) {         return new Card(money, 0);     }      public static Card createCreditCard(int money, int limit) {         return new Card(money, limit);     }      public Card(int money, int limit) {         this.money = money;         this.limit = limit;     } }  아까 코드에서는 createCheckCard와 createCreditCard를 사용해서 객체를 생성했습니다.   이 두개의 정적 팩토리 메서드를, 입력 매개변수에 따라 다른 클래스의 객체를 반환할 수 있다는 정적 팩토리 메서드의 장점을 살려서 하나의 메서드로 통합해주도록 하겠습니다.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Card {     int money;     int limit;      public static Card of(int money) {         return new CheckCard(money, 0);     }      public static Card of(int money, int limit) {         return new CreditCard(money, limit);     }      public Card(int money, int limit) {         this.money = money;         this.limit = limit;     }   }  class CreditCard extends Card {     public CreditCard(int money, int limit) {         super(money, limit);     } }  class CheckCard extends Card {     public CheckCard(int money, int limit) {         super(money, limit);     } }   이렇게 하면 어떤 결과가 나올거라고 예상되시나요?   전에는 createCheckCard로 체크카드를 발급하고, createCreditCard로 신용카드를 발급했다면, 이제는 of 메서드 하나만으로  money와 limit을 모두 기입해주면 신용카드, money만 입력해주면 체크카드, 이런식으로 매개변수의 개수에 따라 다른 객체를 반환하도록 합니다.   이렇게 정적 팩토리 메서드를 사용하면, 매개변수 갯수에 따라 다른 객체를 반환하게 할 수 있습니다.   정적 팩토리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.  아마 이 부분이 가장 이해하기 어려운 부분이라고 생각합니다.   인터페이스만 존재하는 객체의 구현체가 없어도 정적 팩토리 메소드를 사용하면 그 구현체를 사용할 수 있다는 뜻인데요.   이 부분은 글로 설명하는 것보다 아래 영상을 보시는 것이 빠를 것 같아서 링크 첨부합니다.      백기선 유튜브 - 자바, 생성자 대신 정적팩토리의 장점 마무리    아마 스프링과 같은 프레임워크의 구조에 대해 공부를 해보신 분들은 이 기능이 왜 프레임워크의 근간이 되는 기능인지 이해가 되실 것 같습니다.   간단하게 설명하자면 결국은 구현체에 대한 의존성없이 인턴페이스 기반으로 코딩할 수 있도록 도와주는 역할을 한다는 것입니다.   정적 팩토리 메서드의 단점  모든 것이 그렇듯 장점만 있는 방식은 없을 것입니다.   정적 팩토리 메서드도 마찬가지로 단점들을 갖고 있는데요. 다음과 같습니다.      상속에는 pulic 혹은 protected 생성자가 필요하므로 정적 팩토리 메서드만 제공할 경우, 상속이 불가능하다   정적 팩토리 메서드를 다른 개발자들이 찾기 어렵다.  개발자가 임의로 만든 정적 팩토리 메서드 특성 상, 다른 개발자들이 사용시에 정퍽 팩토리 메서드를 찾기가 어렵다고 생각 할 수 있다.   따라서 이러한 단점을 해결하기 위해서 보편적으로 사용하는 네이밍 컨벤션을 지켜주어 다른 개발자가 편하게 사용할 수 있도록 해주어야 합니다.   정적 팩토리 메서드의 네이밍 컨벤션은 다음과 같습니다.      from : 하나의 매개변수를 받아 해당 타입의 인스턴스를 반환하는 형변환 메서드   of : 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드   valueOf : from과 Of의 더 자세한 버전   instance 혹은 getInstance : 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴스임을 보장 하지 않음   create 혹은 newInstance :instance 혹은 getInstance 와 같으나 매번 새로운 인스턴스를 생성해 반환 함을 보장.   위에서도 from, of, valueOf, create등을 제가 이미 사용하고 있었습니다.   getInstance()와 newInstance()의 차이  여기서 getInstance와 newInstance의 설명이 조금 헷갈리신다면, 간단하게 getInstance()의 경우는 아까 배웠던 요일의 예시처럼 이름만 같다면 동일한 객체를 반환해주는 싱글톤객체를 반환하는 메서드일때는 getInstance()로 네이밍을 해주는 것이 좋고, 매번 새로운 객체를 반환하는 메서드일때는 newInstance()으로 이름을 지어주는것이 바람직하다는 것을 뜻합니다.   이렇게 이펙티브 자바의 첫번째 아이템인 정적 팩토리 메서드를   ","categories": ["EffectiveJava"],
        "tags": [],
        "url": "/effectivejava/%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%ED%8C%A9%ED%86%A0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "스포츠에 대하여",
        "excerpt":"2022.12.03  어제 새벽 두시, 대한민국이 16강에 진출했다.   기적같은 추가시간 골을 넣으며 어려운 상황에서 강력한 팀인 포르투갈을 잡고 16강을 갔다.   올해는 정말 언더독의 해가 아닐까…   나는 스포츠가 주는 감동에 대해서 인색한 편이었다.   결국 그들의 성공이지 나의 성공이 아니라고 생각했고, 그렇기에 우리나라가 지거나 이길때 재밌게 보기는 했지만 그래도 그들의 성공은 내 성공이 아니었고 그들의 패배는 나의 패배가 아니었다.   하지만 어제만큼은 대한민국의 승리가 나의 승리였고, 대한민국의 패배가 나의 패배였다. 그만큼 진짜 너무 감동적인 승리였다.   어떻게 보면 스포츠라는건 남의 성공을 진심으로 응원하고 남의 패배를 진심으로 아파해야 즐길 수 있는 거라서 공감력이 좀 떨어지는 나한테는 그렇게 재밌지는 않았는데, 뭔가 올해를 거치며 스포츠가 주는 의미에 대해서 깨닫게 되었다.   사실은 그 사람들은 남의 성공을 응원하는 것이 아니라 남에게 투영한 자신을 응원하고 그렇기 때문에 간절하게 원하는 것이었다. 왜냐면 나도 어제 뭔가 우리나라가 이기면 나도 이길 것 같은 그런 기분이 들었다. ㅜ   DRX가 언더독의 언더독을 넘어 월즈를 우승하고, 우리나라가 언더독의 언더독을 넘어 16강에 진출하고…   그들의 꺾이지 않는 마음, 강한 적들 앞에서도 자신감있게 물러서지 않는 마음이 나도 그렇게 될 수 있다는, 그렇게 되어야겠다는 생각이 들었다. 결국 꺾이지 않는마음 뒤에는 하루하루를 지독하게 열심히 고통스럽게 보낸 그들의 노력이 있었을테니까…   2022년은 어떻게 보면 나라는 사람에 있어서는 실패하고 무너지는 한해였는데, 스포츠는 그렇지 않아서 그들의 성공이 나에게 있어 너무나 큰 응원이 되고 치유가 되었다. 어떻게 보면 당연하고 예상된 성공이 아니라, 실패하고 무너짐을 여러번 반복 후 얻어낸 성공이라 더 감동적이고 와닿았다. 이게 인간과 스포츠가 오랜 역사동안 공존 했던 이유인것 같다.   나도 실패하고 고통스러운 결과가 결국 값진 목표를 이뤄내기 위한 과정임을 알고, 다가오는 미래를 두려워하지 않고 해내겠다는 마음으로 또 책상에 앉아서 열심히 뭔가를 조금씩 이뤄나가야겠다.   부정적인 밈과 언어들로 가득했던 2022년이었다고 생각하는데, 그 마지막을 장식하는 밈이 너무 감동적이라서 오글거려도 마지막에다 적어본다.   중요한것은 꺾이지 않는 마음!   ","categories": ["diary-univ"],
        "tags": ["일기장"],
        "url": "/diary-univ/%EC%8A%A4%ED%8F%AC%EC%B8%A0%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC/",
        "teaser": null
      }]
